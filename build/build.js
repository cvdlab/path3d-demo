
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module._resolving && !module.exports) {
    var mod = {};
    mod.exports = {};
    mod.client = mod.component = true;
    module._resolving = true;
    module.call(this, mod.exports, require.relative(resolved), mod);
    delete module._resolving;
    module.exports = mod.exports;
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("cvdlab-f/index.js", Function("exports, require, module",
"/* !\n\
 * ƒ\n\
 * JavaScript functional library\n\
 * Copyright (c) 2012 Enrico Marino and Federico Spini\n\
 * MIT License\n\
 */\n\
\n\
/**\n\
 * Library namespace.\n\
 */\n\
\n\
var ƒ = exports;\n\
\n\
/**\n\
 * Utils\n\
 */\n\
\n\
var array = [];\n\
var slice = array.slice;\n\
\n\
/**\n\
 * choose \n\
 * binomial coefficients\n\
 * \n\
 * @example \n\
 *   choose([7,5]); //21\n\
 *\n\
 * @param {Array} pair\n\
 * @return {Function} binomial coefficient\n\
 * @api public\n\
 */\n\
\n\
ƒ.choose = function (pair) {\n\
  var n = pair[0];\n\
  var k = pair[1];\n\
  var coeff = 1;\n\
  var i;\n\
\n\
  for (i = n-k+1; i <= n; i++) {\n\
    coeff *= i;\n\
  }\n\
\n\
  for (i = 1; i <= k; i++) {\n\
    coeff /= i;\n\
  }\n\
\n\
  return coeff;\n\
};\n\
\n\
/**\n\
 * sel \n\
 * select n-th element from array\n\
 * \n\
 * @example \n\
 *   sel(2)([0,1,2,3]); //2\n\
 *\n\
 * @param {Number} index of selection\n\
 * @return {Function}\n\
 *   @param {Array} array\n\
 *   @return {*} array[index]\n\
 * @api public\n\
 */\n\
\n\
ƒ.sel = function (index) {\n\
  return function (array) {\n\
    return array[index];\n\
  };\n\
};\n\
\n\
ƒ.s0 = ƒ.sel(0);\n\
ƒ.s1 = ƒ.sel(1);\n\
ƒ.s2 = ƒ.sel(2);\n\
ƒ.s3 = ƒ.sel(3);\n\
ƒ.s4 = ƒ.sel(4);\n\
ƒ.s5 = ƒ.sel(5);\n\
ƒ.s6 = ƒ.sel(6);\n\
ƒ.s7 = ƒ.sel(7);\n\
ƒ.s8 = ƒ.sel(8);\n\
ƒ.s9 = ƒ.sel(9);\n\
\n\
/**\n\
 * apply \n\
 * apply([f,x]) \n\
 * apply `f` to `x`.\n\
 * \n\
 * @example \n\
 *   apply([Math.cos, Math.PI/3]); //0.5\n\
 *\n\
 * @param {Function} [f = pair[0]] the function to apply\n\
 * @param {*} [x = pair[1]] the value to apply `f` to.\n\
 * @return {*} the result of `f(x)`.\n\
 * @api public\n\
 */\n\
\n\
ƒ.apply = function (pair) {\n\
  var f = pair[0];\n\
  var x = pair[1];\n\
  return f(x);\n\
};\n\
\n\
/**\n\
 * aa\n\
 * aa(f)(array)\n\
 * apply `f` to each element of `array`.\n\
 * \n\
 * @example aa(function (x) {return x * 2;})([1,3,5,7,9]); //[2,6,10,14,18]\n\
 *\n\
 * @param {Function} function f\n\
 * @return {Function}\n\
 *    @param {Array} array [a0,a1,...,an]\n\
 *    @return {Array} [f(a0),f(a1),...,f(an)]\n\
 * @api public\n\
 */\n\
\n\
ƒ.aa = function (f) {\n\
  return function (array) {\n\
    return array.map(function (element) {\n\
      return f(element);\n\
    });\n\
  };\n\
};\n\
\n\
/**\n\
 * comp2\n\
 * returns the composition of the given functions\n\
 * \n\
 * @example\n\
 *   comp2([\n\
 *     function (x) {return x * 2;}, \n\
 *     function (y) {return y - 1;}\n\
 *   ])(5); //8\n\
 * \n\
 * @param {Array} functions array of functions to compose\n\
 * @param {Function} [functions[0]] f\n\
 * @param {Function} [functions[1]] g\n\
 * @return {Function} the composition of the given functions\n\
 * @api public\n\
 */\n\
\n\
ƒ.comp2 = function (functions) {\n\
  var f = functions[0];\n\
  var g = functions[1];\n\
  return function (x) {\n\
    return f(g(x));\n\
  };\n\
};\n\
\n\
/**\n\
 * comp\n\
 * returns the composition of the given functions\n\
 * \n\
 * @example\n\
 *   comp([\n\
 *     function (x) {return x + 1;}, \n\
 *     function (y) {return y * 2;},\n\
 *     function (z) {return z - 1;}\n\
 *   ])(5); //3\n\
 *\n\
 * @param {Array} functions array of functions to compose\n\
 * @return {Function} the composition of the given functions\n\
 * @api public\n\
 */\n\
\n\
ƒ.comp = function (functions) {\n\
  return functions.reduce(function (f, g) {\n\
    return function (x) {\n\
      return f(g(x));\n\
    };\n\
  });\n\
};\n\
\n\
/**\n\
 * cons\n\
 * Apply each function of the given array `functions` to the given value `x`,\n\
 * and return the array of application values\n\
 *\n\
 * @example\n\
 *   cons([\n\
 *     function (x) {return x - 1;}, \n\
 *     function (y) {return y * 2;},\n\
 *     function (z) {return z % 3}\n\
 *   ])(5); //[4,10,2]\n\
 *\n\
 * @param {Array} functions\n\
 * @return {Array} the array of application values\n\
 * @api public\n\
 */\n\
\n\
ƒ.cons = function (functions) {\n\
  return function (x) {\n\
    return functions.map(function (f) {\n\
      return f(x);\n\
    });\n\
  };\n\
};\n\
\n\
/**\n\
 * curry\n\
 * currify `fn`\n\
 * \n\
 * @param {Function} fn function to currify\n\
 * @return {Function} currified function\n\
 * @api public\n\
 */\n\
 \n\
ƒ.curry = function (fn) {\n\
  if (arguments.length == 1) return fn;\n\
  var args = slice.call(arguments, 1);\n\
  return function () {\n\
    return fn.apply(null, args.concat(slice.call(arguments)));\n\
  };\n\
};\n\
\n\
/**\n\
 * id\n\
 * return the given `value`\n\
 * \n\
 * @param value\n\
 * @return the given `value`\n\
 * @api public\n\
 */\n\
\n\
ƒ.id = function (value) {\n\
  return value;\n\
};\n\
\n\
/**\n\
 * k\n\
 * return a function that return the given `value`\n\
 * \n\
 * @param value\n\
 * @return {Function} a function that return `value`\n\
 * @api public\n\
 */\n\
\n\
ƒ.k = function (value) {\n\
  return function () {\n\
    return value;\n\
  };\n\
};\n\
\n\
/**\n\
 * cat\n\
 * catenates `args`, an array of arrays, by eliminating a level of nesting\n\
 *\n\
 * @example\n\
 *   cat([\n\
 *     [0,1,2],\n\
 *     [3,4,5,6],\n\
 *     [7,8,9,10,11]\n\
 *   ]); //[0, 1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10, 11]\n\
 *\n\
 * @param {Array} arrays array of arrays\n\
 * @return {Array} array created eliminating a level of nesting\n\
 * @api public \n\
 */\n\
\n\
ƒ.cat = function (arrays) {\n\
  var result = [];\n\
  arrays.forEach(function (array) {\n\
    result = result.concat(array);\n\
  });\n\
  return result;\n\
};\n\
\n\
/**\n\
 * distl\n\
 * distribute left: \n\
 * returns the `pair` sequence with `value` and the elements of `array` \n\
 * \n\
 * @example\n\
 *   distl(['a',[0,1,2,3,4]]); //[['a',0],['a',1],['a',2],['a',3],['a',4]]\n\
 *\n\
 * @param {Array} pair\n\
 * @param {Array} [pair[0]] array\n\
 * @param {Any}   [pair[1]] value\n\
 * @return the `pair` sequence with `value` and the elements of `array`\n\
 * @api public\n\
 */\n\
\n\
ƒ.distl = function (pair) {\n\
  var value = pair[0];\n\
  var array = pair[1];\n\
  return array.map(function (item) {\n\
    return [value, item];\n\
  });\n\
};\n\
\n\
/**\n\
 * distr\n\
 * distribute right: \n\
 * returns the `pair` sequence with the elements of `array` and `value`\n\
 * \n\
 * @example\n\
 *   distr([[0,1,2,3,4],'a']); //[[0,'a'],[1,'a'],[2,'a'],[3,'a'],[4,'a']]\n\
 *\n\
 * @param {Array} pair\n\
 * @param {Array} [pair[0]] array\n\
 * @param {Any}   [pair[1]] value\n\
 * @return the `pair` sequence with the elements of `array` and `value`\n\
 * @api public\n\
 */\n\
\n\
ƒ.distr = function (pair) {\n\
  var array = pair[0];\n\
  var value = pair[1];\n\
  return array.map(function (item) {\n\
    return [item, value];\n\
  });\n\
};\n\
\n\
/**\n\
 * insl\n\
 * insert left operator  \n\
 * given a binary associative `operator` \n\
 * returns a function that given an array \n\
 * returns the riduction of the array by the operator.\n\
 * \n\
 * @param {Function} operator binary operator\n\
 * @return {Function} function that apply `operator` to the given `array`\n\
 * @api public\n\
 */\n\
\n\
ƒ.insl = function (operator) {\n\
  return function (array) {\n\
    return array.reduce(operator);\n\
  };\n\
};\n\
\n\
/**\n\
 * insr\n\
 * insert right operator  \n\
 * given a binary associative `operator` \n\
 * returns a function that given an array \n\
 * returns the right riduction of the array by the operator.\n\
 * \n\
 * @param {Function} operator binary operator\n\
 * @return {Function} function that apply `operator` to the given `array`\n\
 * @api public\n\
 */\n\
\n\
ƒ.insr = function (operator) {\n\
  return function (array) {\n\
    return array.reduceRight(operator);\n\
  };\n\
};\n\
\n\
/**\n\
 * al\n\
 * append left\n\
 * append `item` on the left of `array`\n\
 * \n\
 * @param {Array} pair\n\
 * @param {Array} [pair[0]] item\n\
 * @param {Any}   [pair[1]] array\n\
 * @return {Array} `array` concatenated with `item`\n\
 * @api public\n\
 */\n\
\n\
ƒ.al = function (pair) {\n\
  var item = pair[0];\n\
  var array = pair[1];\n\
  return [item].concat(array);\n\
};\n\
\n\
/**\n\
 * ar\n\
 * append right\n\
 * append `item` on the right of `array`\n\
 * \n\
 * @param {Array} pair\n\
 * @param {Any}   [pair[0]] array\n\
 * @param {Array} [pair[1]] item\n\
 * @return {Array} `array` concatenated with `item`\n\
 * @api public\n\
 */\n\
\n\
ƒ.ar = function (pair) {\n\
  var array = pair[0];\n\
  var item = pair[1];\n\
  return array.concat([item]);\n\
};\n\
\n\
/**\n\
 * last\n\
 * returns the last element of the given `array`\n\
 *\n\
 * @example\n\
 *   last([0,1,2,3,4,5]); //5\n\
 *\n\
 * @param {Array} array array\n\
 * @return {Any} the last element of `array`\n\
 * @api public\n\
 */\n\
\n\
ƒ.last = function (array) {\n\
  return array[array.length - 1];\n\
};\n\
\n\
/** \n\
 * list\n\
 * returns an array containing `arg`. \n\
 *\n\
 * @param {Array} arg\n\
 * @return {Array} array containing `arg`\n\
 * @api public\n\
 */\n\
\n\
ƒ.list = function (arg) {\n\
  return [arg];\n\
};\n\
\n\
/**\n\
 * len\n\
 * returns the length of the given `array`\n\
 * \n\
 * @param {Array} array array\n\
 * @return {Number} the length of the given `array`\n\
 * @api public\n\
 */\n\
\n\
ƒ.len = function (array) {\n\
  return array.length;\n\
};\n\
\n\
/**\n\
 * first\n\
 * returns the first element of the given `array`.\n\
 * \n\
 * @param {Array} array array\n\
 * @return the first element of the given `array`.\n\
 * @api public\n\
 */ \n\
\n\
ƒ.first = function (array) {\n\
  return array[0];\n\
};\n\
\n\
/** \n\
 * reverse\n\
 * returns the given `array` in reverse order\n\
 *\n\
 * @example\n\
 *   reverse([0,1,2,3,4,5]); //[5,4,3,2,1,0]\n\
 *\n\
 * @param {Array} array array\n\
 * @return {Array} the given `array` in reverse order\n\
 * @api public\n\
 */\n\
\n\
ƒ.reverse = function (array) {\n\
  var result = [];\n\
  var i;\n\
  for (i = array.length - 1; i >= 0; i--) {\n\
    result.push(array[i]);\n\
  }\n\
  return result;\n\
};\n\
\n\
/**\n\
 * tail\n\
 * returns the non-empty `array` but its `first` element\n\
 * \n\
 * @example\n\
 *   tail([0,1,2,3,4,5]); //[1,2,3,4,5]\n\
 *\n\
 * @param {Array} array array\n\
 * @return {Array} the tail of the given `array`\n\
 * @api public\n\
 */\n\
\n\
ƒ.tail = function (array) {\n\
  return array.slice(1);\n\
};\n\
\n\
/**\n\
 * butlast\n\
 * returns the non-empty `array` but its `last` element\n\
 * \n\
 * @example\n\
 *   butlast([0,1,2,3,4,5]); //[0,1,2,3,4]\n\
 * @example\n\
*    butlast([]); //[]\n\
 *\n\
 * @return {Array} the non-empty `array` but its `last` element\n\
 * @api public\n\
 */\n\
\n\
ƒ.butlast = function (array) {\n\
  return array.slice(0,-1);\n\
};\n\
\n\
/**\n\
 * repeat\n\
 * returns an array with `n` repetitions of `value`\n\
 * \n\
 * @example\n\
 *   repeat(3)(12); //[12,12,12]\n\
 *\n\
 * @param {Number} n number of repetitions\n\
 * @return {Function} a function that given `value` \n\
 *   returns an array with `n` repetitions of `value`\n\
 * @api public\n\
 */\n\
\n\
ƒ.repeat = function (n) {\n\
  return function (value) {\n\
    var result = [];\n\
    var i;\n\
    for (i = 0; i < n; i++) {\n\
      result.push(value);\n\
    }\n\
    return result;\n\
  };\n\
};\n\
\n\
/**\n\
 * replica\n\
 * repeat list and catenate.\n\
 * \n\
 * @example\n\
 *   replica(3)(['A',1]); //[\"A\", 1, \"A\", 1, \"A\", 1]\n\
 *\n\
 * @param {Number} n number of repetitions\n\
 * @return {Function} a function that given `value` \n\
 *   returns an array with `n` repetitions of `value` concatenated\n\
 * @api public\n\
 */\n\
\n\
ƒ.replica = function (n) {\n\
  return function (value) { \n\
    var result = [];\n\
    var i;\n\
    for (i = 0; i < n; i++) {\n\
      result = result.concat(value);\n\
    }\n\
    return result;\n\
  };\n\
};\n\
\n\
/**\n\
 * bigger\n\
 * binary operator that returns the greater of the given pair\n\
 * \n\
 * @example\n\
 *   bigger([4,9]); //9\n\
 *\n\
 * @param {Array} pair\n\
 * @return {Number} return the greater of the `pair`\n\
 * @api public\n\
 */\n\
\n\
ƒ.bigger = function (pair) {\n\
  var a = pair[0];\n\
  var b = pair[1];\n\
  return a > b ? a : b;\n\
};\n\
\n\
/**\n\
 * smaller\n\
 * binary operator that returns the smaller of the given pair\n\
 * \n\
 * @example\n\
 *   bigger([4,9]); //9\n\
 *\n\
 * @param {Array} pair\n\
 * @return {Number} return the smaller of the `pair`\n\
 * @api public\n\
 */\n\
\n\
ƒ.smaller = function (pair) {\n\
  var a = pair[0];\n\
  var b = pair[1];\n\
  return a < b ? a : b;\n\
};\n\
\n\
/**\n\
 * biggest\n\
 * returns the greatest of the given `values`\n\
 * \n\
 * @example\n\
 *   biggest([4,9,2,8,1,7]); //9\n\
 *\n\
 * @param {Array} values values\n\
 * @return {Number} return the greatest of the given `values`\n\
 * @api public\n\
 */\n\
\n\
ƒ.biggest = function (values) {\n\
  return Math.max.apply(null, values);\n\
};\n\
\n\
/**\n\
 * smallest\n\
 * returns the smallest of the given `values`\n\
 *\n\
 * @example\n\
 *   smallest([4,9,2,8,1,7]); //1\n\
 *\n\
 * @param {Array} values values\n\
 * @return {Number} return the smallest of the given `values`\n\
 * @api public\n\
 */\n\
\n\
ƒ.smallest = function (values) {\n\
  return Math.min.apply(null, values);\n\
};\n\
\n\
/**\n\
 * sum\n\
 * returns the sum of the given `values` (numbers or arrays)\n\
 * \n\
 * @example\n\
 *   sum([[1,2,3],[2,3,4],[3,4,5]]); //[6,9,12]\n\
 * @example\n\
 *   sum([1,2,3,4]); //10\n\
 *\n\
 * @param {Array} values values\n\
 * @return {Number} return the sum of the given `values`\n\
 * @api public\n\
 */\n\
\n\
ƒ.sum = function (values) {\n\
  if (values[0] instanceof Array) {\n\
    return values.reduce(function (prev, curr) {\n\
      return prev.map(function (value, i) {\n\
        return value + curr[i];\n\
      });\n\
    });\n\
  }\n\
    \n\
  return values.reduce(function (prev, curr) {\n\
    return prev + curr;\n\
  });\n\
};\n\
\n\
/**\n\
 * sub\n\
 * returns the difference of the given `values` (numbers or arrays)\n\
 * \n\
 * @param {Array} values values\n\
 * @return {Number} return the difference of the given `values`\n\
 * @api public\n\
 */\n\
\n\
ƒ.sub = function (values) {\n\
  if (values[0] instanceof Array) {\n\
    return values.reduce(function (prev, curr) {\n\
      return prev.map(function (value, i) {\n\
        return value - curr[i];\n\
      });\n\
    });\n\
  }\n\
    \n\
  return values.reduce(function (prev, curr) {\n\
    return prev - curr;\n\
  });\n\
};\n\
\n\
/**\n\
 * mul\n\
 * multiplicate the given `values`\n\
 *\n\
 * @example\n\
 *   mul([[1,2,3],[2,3,4],[3,4,5]]); //[6,24,60]\n\
 * @example\n\
 *   mul([1,2,3,4]); //24\n\
 *\n\
 * @param {Array} values values\n\
 * @return {Number} return the product of the given `values`\n\
 * @api public\n\
 */\n\
\n\
ƒ.mul = function (values) {\n\
  if (values[0] instanceof Array) {\n\
    return values.reduce(function (prev, curr) {\n\
      return prev.map(function (value, i) {\n\
        return value * curr[i];\n\
      });\n\
    });\n\
  }\n\
    \n\
  return values.reduce(function (prev, curr) {\n\
    return prev * curr;\n\
  });\n\
};\n\
\n\
/**\n\
 * div\n\
 * divide the given `values`\n\
 *    \n\
 * @param {Array} values values\n\
 * @return {Number} return the division of the given `values`\n\
 * @api public\n\
 */\n\
\n\
ƒ.div = function (values) {\n\
  if (values[0] instanceof Array) {\n\
    return values.reduce(function (prev, curr) {\n\
      return prev.map(function (value, i) {\n\
        return value / curr[i];\n\
      });\n\
    });\n\
  }\n\
    \n\
  return values.reduce(function (prev, curr) {\n\
    return prev / curr;\n\
  });\n\
};\n\
\n\
/** \n\
 * cart\n\
 * cartesian product\n\
 * \n\
 * @example\n\
 *  cart([[1,2],['a','b']]); //[[1,\"a\"],[1,\"b\"],[2,\"a\"],[2,\"b\"]]\n\
 *\n\
 * @param {Array} args\n\
 * @return {Array} the cartesian product of `args`\n\
 * @api public\n\
 */\n\
\n\
ƒ.cart = function (args) {\n\
  return args.reduce(function (a, b) {\n\
    var ret = [];\n\
    a.forEach(function (a) {\n\
      b.forEach(function (b) {\n\
        ret.push(a.concat([b]));\n\
      });\n\
    });\n\
    return ret;\n\
  }, [[]]);\n\
};\n\
\n\
/**\n\
 * Math constant\n\
 */\n\
\n\
/**\n\
 * E\n\
 *\n\
 * @constant\n\
 */\n\
\n\
ƒ.E = Math.E;\n\
\n\
/**\n\
 * LN2\n\
 *\n\
 * @constant\n\
 */\n\
\n\
ƒ.LN2 = Math.LN2;\n\
\n\
/**\n\
 * LN10\n\
 *\n\
 * @constant\n\
 */\n\
\n\
ƒ.LN10 = Math.LN10;\n\
\n\
/**\n\
 * LOG2E\n\
 *\n\
 * @constant\n\
 */\n\
\n\
ƒ.LOG2E = Math.LOG2E;\n\
\n\
/**\n\
 * LOG10E\n\
 *\n\
 * @constant\n\
 */\n\
\n\
ƒ.LOG10E = Math.LOG10E;\n\
\n\
/**\n\
 * PI\n\
 *\n\
 * @constant\n\
 */\n\
\n\
ƒ.PI = Math.PI;\n\
\n\
/**\n\
 * SQRT1_2\n\
 *\n\
 * @constant\n\
 */\n\
\n\
ƒ.SQRT1_2 = Math.SQRT1_2;\n\
\n\
/**\n\
 * SQRT2\n\
 *\n\
 * @constant\n\
 */\n\
\n\
ƒ.SQRT2 = Math.SQRT2;\n\
\n\
/**\n\
 * abs\n\
 * returns the absolute value of the given number\n\
 *\n\
 * @param {Number} number\n\
 * @return {Number} the absolute value of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.abs = Math.abs;\n\
\n\
/**\n\
 * acos\n\
 * returns the arc-cosine of the given number\n\
 *\n\
 * @param {Number} number\n\
 * @return {Number} the arc-cosine of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.acos = Math.acos;\n\
\n\
/**\n\
 * asin\n\
 * returns the arc-sine of the given number\n\
 *\n\
 * @param {Number} number\n\
 * @return {Number} the arc-sine of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.asin = Math.asin;\n\
\n\
/**\n\
 * atan\n\
 * returns the arc-tangent of the given number\n\
 *\n\
 * @param {Number} number\n\
 * @return {Number} the arc-tangent of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.atan = Math.atan;\n\
\n\
/**\n\
 * atan2\n\
 * returns the squared arc-tangent of the given number\n\
 *\n\
 * @param {Number} number\n\
 * @return {Number} the squred arc-tangent of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.atan2 = Math.atan2; \n\
\n\
/**\n\
 * ceil\n\
 * returns the ceil of the given number\n\
 *\n\
 * @param {Number} number\n\
 * @return {Number} the ceil of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.ceil = Math.ceil; \n\
\n\
/**\n\
 * cos\n\
 * returns the cosine of the given number\n\
 *\n\
 * @param {Number} number\n\
 * @return {Number} the cosine of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.cos = Math.cos; \n\
\n\
/**\n\
 * exp\n\
 * returns the exponential of the given value (e^value)\n\
 *\n\
 * @param {Array} pair\n\
 * @param {Number} [pair[0]] value\n\
 * @param {Number} [pari[1]] n\n\
 * @return {Number} the `n`-th power of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.exp = Math.exp;\n\
\n\
/**\n\
 * floor\n\
 * returns the floor of the given number\n\
 *\n\
 * @param {Number} value\n\
 * @return {Number} the floor of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.floor = Math.floor;\n\
\n\
/**\n\
 * log\n\
 * returns the log of the given number\n\
 *\n\
 * @param {Number} value\n\
 * @return {Number} the log of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.log = Math.log;\n\
\n\
/**\n\
 * floor\n\
 * returns the floor of the given number\n\
 *\n\
 * @param {Number} value\n\
 * @return {Number} the floor of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.floor = Math.floor;\n\
\n\
/**\n\
 * power\n\
 * returns the n-th power of the given value (value^n)\n\
 *\n\
 * @param {Array} pair\n\
 * @param {Number} [pair[0]] value\n\
 * @param {Number} [pari[1]] n\n\
 * @return {Number} the `n`-th power of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.pow = function (pair) {\n\
  return Math.pow.apply(null, pair);\n\
}; \n\
\n\
/**\n\
 * random\n\
 * returns a random number in [0, 1) interval\n\
 *\n\
 * @return {Number} a random number in [0, 1) interval\n\
 * @api public\n\
 */\n\
\n\
ƒ.random = Math.random;  \n\
\n\
/**\n\
 * round\n\
 * returns the given number rounded \n\
 *\n\
 * @return {Number} the given number rounded\n\
 * @api public\n\
 */\n\
\n\
ƒ.round = Math.round;  \n\
\n\
/**\n\
 * sin\n\
 * returns the sine of the given number\n\
 *\n\
 * @return {Number} the sin of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.sin = Math.sin;  \n\
\n\
/**\n\
 * sqrt\n\
 * returns the squared root of the given number\n\
 *\n\
 * @return {Number} the squared root of the given number\n\
 * @api public\n\
 */\n\
\n\
var sqrt = \n\
ƒ.sqrt = Math.sqrt; \n\
\n\
/**\n\
 * tan\n\
 * returns the tan of the given number\n\
 *\n\
 * @return {Number} the tan of the given number\n\
 * @api public\n\
 */\n\
\n\
ƒ.tan = Math.tan;\n\
\n\
/**\n\
 * trans\n\
 * transpose the given matrix\n\
 *\n\
 * @example\n\
 *   trans([[0,1,2],[3,4,5],[6,7,8]]); //[[0,3,6],[1,4,7],[2,5,8]\n\
 *\n\
 * @param {Array} matrix matrix\n\
 * @return {Array} the transpose of the given matrix\n\
 * @api public\n\
 */\n\
\n\
ƒ.trans = function (matrix) {\n\
  var result = [];\n\
\n\
  matrix.forEach(function (row, i) {\n\
    row.forEach(function (value, j) {\n\
      (result[j] = result[j] || [])[i] = value;\n\
    });\n\
  });\n\
\n\
  return result;\n\
};\n\
\n\
/**\n\
 * prod\n\
 * product scalar by vector\n\
 *\n\
 * @example\n\
 *   prod([2, [0,1,1]]); //[0,2,2]\n\
 *\n\
 * @param {Array} pair\n\
 * @param {Number} [pair[0]] scalar\n\
 * @param {Array} [pair[1]] vector\n\
 * @return {Array} the given `vector` scaled by the given `scalar`\n\
 * @api public\n\
 */\n\
\n\
ƒ.prod = function (pair) {\n\
  var scalar = pair[0];\n\
  var vector = pair[1];\n\
  var result = vector.map(function (value) {\n\
    return scalar * value;\n\
  });\n\
  return result;\n\
};\n\
\n\
/**\n\
 * innerprod\n\
 * inner (or scalar) product\n\
 *\n\
 * @example\n\
 *   innerprod([[0,1,1],[2,3,1]]); //4\n\
 *\n\
 * @param {Array} pair\n\
 * @param {Array} [pair[0]] v1\n\
 * @param {Array} [pair[1]] v2\n\
 * @return {Number} the inner producto of the given vectors\n\
 * @api public\n\
 */\n\
\n\
ƒ.innerprod = function (pair) {\n\
  var v1 = pair[0];\n\
  var v2 = pair[1];\n\
  var result = 0;\n\
  v1.forEach(function (value, i) {\n\
    result += value * v2[i];\n\
  });\n\
  return result;\n\
};\n\
\n\
/**\n\
 * vectnorm\n\
 * returns the norm of the given `vector`\n\
 *\n\
 * @example\n\
 *   vectrnorm([0,3,4]); //5\n\
 *\n\
 * @param {Array} vector\n\
 * @return {Array} the the norm of the given `vector`\n\
 * @api public\n\
 */\n\
\n\
var vectnorm = \n\
ƒ.vectnorm = function (vector) {\n\
  return sqrt(vector.reduce(function (prev, current) {\n\
    return prev + current * current;\n\
  }, 0));\n\
};\n\
\n\
/**\n\
 * unitvect\n\
 * returns the unit vector of the given `vector`\n\
 *\n\
 * @example\n\
 *   univect([0,3,4]); //[0, 0.6, 0.8]\n\
 *\n\
 * @param {Array} vector\n\
 * @return {Array} the the unit vector of the given `vector`\n\
 * @api public\n\
 */\n\
\n\
var unitvect = \n\
ƒ.unitvect = function (vector) {\n\
  var norm = vectnorm(vector);\n\
  var result = vector.map(function (value) {\n\
    return value / norm;\n\
  });\n\
  return result;\n\
};\n\
\n\
/**\n\
 * matsum\n\
 * matrix sum\n\
 *\n\
 * @example\n\
 *   matsum([[[1,0],[0,1]],[[1,0],[[1,0]]]); //[[2,0],[1,1]]\n\
 *\n\
 * @param {Array} pair\n\
 * @param {Array} [pair[0]] m1\n\
 * @param {Array} [pair[1]] m2\n\
 * @return {Array} the sum of the given matrices\n\
 * @api public\n\
 */\n\
\n\
var matsum = \n\
ƒ.matsum = function (pair) {\n\
  var m1 = pair[0];\n\
  var m2 = pair[1];\n\
  var result = [];\n\
  m1.forEach(function (row, i) {\n\
    result[i] = [];\n\
    row.forEach(function (value, j) {\n\
      result[i][j] = value + m2[i][j];\n\
    });\n\
  })\n\
  return result;\n\
};\n\
\n\
/**\n\
 * matprod\n\
 * matrix product\n\
 *\n\
 * @param {Array} pair\n\
 * @param {Array} [pair[0]] m1\n\
 * @param {Array} [pair[1]] m2\n\
 * @return {Array} the matrix product of of the given matrices\n\
 * @api public\n\
 */\n\
\n\
var matprod = \n\
ƒ.matprod = function (pair) {\n\
  var m1 = pair[0];\n\
  var m2 = pair[1];\n\
  var n = m1.length;\n\
  var m = m1[0].length;\n\
  var i;\n\
  var j;\n\
  var k;\n\
  var result = [];\n\
\n\
  for (i = 0; i < n; i += 1) {\n\
    result[i] = [];\n\
    for (j = 0; j < m; j += 1) {\n\
      result[i][j] = 0;\n\
    }\n\
  }\n\
\n\
  for (i = 0; i < n; i += 1) {\n\
    for (j = 0; j < m; j += 1) {\n\
      for (k = 0; k < m; k += 1) {\n\
        result[i][j] += m1[i][k] * m2[k][j];\n\
      }\n\
    }\n\
  }\n\
\n\
  return result;\n\
};\n\
\n\
/**\n\
 * identity\n\
 * matrix identity\n\
 *\n\
 * @example\n\
 *   identity(4); //[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]\n\
 *\n\
 * @param {Number} n dim of the identity matrix\n\
 * @return {Array} an identity n x n matrix\n\
 * @api public\n\
 */\n\
\n\
var identity = \n\
ƒ.identity = function (n) {\n\
  var result = [];\n\
  var i;\n\
\n\
  for (i = 0; i < n; i += 1) {\n\
    result[i] = [];\n\
    for (j = 0; j < n; j += 1) {\n\
      result[i][j] = (i === j) ? 1 : 0;\n\
    }\n\
  }\n\
\n\
  return result;\n\
};\n\
\n\
/**\n\
 * vectprod\n\
 * vector product\n\
 *\n\
 * @param {Array} pair\n\
 * @param {Array} [pair[0]] u\n\
 * @param {Array} [pair[1]] v\n\
 * @return {Array} the vector product of of the given vectors\n\
 * @api public\n\
 */\n\
\n\
var vectprod = \n\
ƒ.vectprod = function (pair) {\n\
  var u = pair[0];\n\
  var v = pair[1];\n\
  var result = [];\n\
\n\
  result[0] = u[1]*v[2] - u[2]*v[1];\n\
  result[1] = u[2]*v[0] - u[0]*v[2];\n\
  result[2] = u[0]*v[1] - u[1]*v[0];\n\
\n\
  return result;\n\
};\n\
\n\
/**\n\
 * mat\n\
 * create a nxm matrix from the given vector\n\
 *\n\
 * @example\n\
 *   mat([3,2])([0,1,2,3,4,5]); //[[0,1],[2,3],[4,5]]\n\
 *\n\
 * @param {Array} dims\n\
 * @param {Array} [dims[0]] n number of rows\n\
 * @param {Array} [pair[1]] m number of cols\n\
 * @return {Function} \n\
 *   @param {Array} vector\n\
 *   @return {Array} matrix nxm from `vector` values\n\
 * @api public\n\
 */\n\
\n\
var mat = \n\
ƒ.mat = function (dims) {\n\
  var n = dims[0];\n\
  var m = dims[1];\n\
\n\
  return function (vector) {\n\
    var result = [];\n\
    var i;\n\
\n\
    for (i = 0; i < n; i += 1) {\n\
      result[i] = vector.slice(i*m, i*m+m);\n\
    }\n\
    \n\
    return result;\n\
  };\n\
};\n\
//@ sourceURL=cvdlab-f/index.js"
));
require.register("cvdlab-simplexn/index.js", Function("exports, require, module",
"/* !\n\
 * simplexn\n\
 * dimension-independent geometric kernel based on simplicial complex\n\
 * Copyright (c) 2012 Enrico Marino and Federico Spini\n\
 * MIT License\n\
 */\n\
\n\
/**\n\
 * Variables.\n\
 */\n\
\n\
var cos = Math.cos;\n\
var sin = Math.sin;\n\
var round = Math.round;\n\
var min = Math.min;\n\
var abs = Math.abs;\n\
var pi = Math.PI;\n\
var random = Math.random;\n\
var floor = Math.floor;\n\
\n\
/**\n\
 * Library namespace.\n\
 */\n\
\n\
var simplexn = exports;\n\
\n\
/**\n\
 * Library version.\n\
 */\n\
\n\
simplexn.version = '0.2.0';\n\
\n\
/**\n\
 * utils namespace\n\
 * @api private\n\
 */\n\
\n\
simplexn._utils = {};\n\
\n\
/**\n\
 * _flat\n\
 * Return a flat version of the given array of arrays.\n\
 * \n\
 * @param {Array} arrays\n\
 * @return {Array} array\n\
 * @api private\n\
 */\n\
\n\
var _flat =\n\
simplexn._utils._flat = function (arrays) {\n\
  var res = [];\n\
\n\
  arrays.forEach(function (item) {\n\
    res = res.concat(item);\n\
  });\n\
\n\
  return res;\n\
};\n\
\n\
/**\n\
 * _repeat\n\
 * Return an array made by n times value item.\n\
 * \n\
 * @param {Number|Boolean|String} value\n\
 * @param {Number} n\n\
 * @return {Array} array\n\
 * @api private\n\
 */\n\
\n\
var _repeat = \n\
simplexn._utils._repeat = function (value, n) {\n\
  var res = [];\n\
\n\
  while (n--) res.push(value);\n\
\n\
  return res;\n\
};\n\
\n\
/**\n\
 * _swap\n\
 * Swap i1 to i2 indexed items in array.\n\
 * \n\
 * @param {Array|BufferArray} array\n\
 * @param {Number} i1\n\
 * @param {Number} i2\n\
 * @api private\n\
 */\n\
\n\
var _swap = \n\
simplexn._utils._swap = function (array, i1, i2) {\n\
  var tmp = array[i1];\n\
  array[i1] = array[i2];\n\
  array[i2] = tmp;\n\
};\n\
\n\
/**\n\
 * _quickSort\n\
 * Quick sort algorithm.\n\
 *\n\
 * @param {Array|BufferArray} array to sort\n\
 * @api private\n\
 */\n\
\n\
var _partition = \n\
simplexn._utils._partition = function (array, begin, end, pivot) {\n\
  var piv = array[pivot];\n\
  var store = begin;\n\
  var ix;\n\
\n\
  _swap(array, pivot, end - 1);\n\
  for (ix = begin; ix < end - 1; ++ix) {\n\
    if (array[ix] <= piv) {\n\
      _swap(array, store, ix);\n\
      ++store;\n\
    }\n\
  }\n\
  _swap(array, end - 1, store);\n\
\n\
  return store;\n\
};\n\
\n\
var _qsort = \n\
simplexn._utils._qsort = function (array, begin, end) {\n\
  if (end - 1 > begin) {\n\
    var pivot = begin + floor(random() * (end - begin));\n\
\n\
    pivot = _partition(array, begin, end, pivot);\n\
\n\
    _qsort(array, begin, pivot);\n\
    _qsort(array, pivot + 1, end);\n\
  }\n\
};\n\
\n\
var _quickSort = \n\
simplexn._utils._quickSort = function (array) {\n\
  _qsort(array, 0, array.length);\n\
};\n\
\n\
/**\n\
 * _areEqual\n\
 * \n\
 * @param {Array|Float32Array|Uint32Array} a1\n\
 * @param {Array|Float32Array|Uint32Array} a2\n\
 * @return {Boolean} true if each item of a1 is === to correspond element of a2\n\
 * @api private\n\
 */\n\
\n\
var _areEqual = \n\
simplexn._utils._areEqual = function (a1, a2) {\n\
  var a1Len = a1.length;\n\
  var a2Len = a2.length;\n\
  var i;\n\
\n\
  if (a1Len !== a2Len) {\n\
    return false;\n\
  }\n\
\n\
  for (i = 0; i < a1Len; i++) {\n\
    if (a1[i] !== a2[i]) {\n\
      return false;\n\
    }\n\
  }\n\
\n\
  return true;\n\
};\n\
\n\
/**\n\
 * _toArray\n\
 * \n\
 * @param {Array|Float32Array|Uint32Array} inArray\n\
 * @return {Array} Array object containing all of the element in inArray\n\
 * @api private\n\
 */\n\
\n\
var _toArray = \n\
simplexn._utils._toArray = function (inArray) {\n\
  var i;\n\
  var length = inArray.length;\n\
  var outArray = new Array(length);\n\
\n\
  for (i = 0; i < length; i += 1) {\n\
    outArray[i] = (inArray[i]);\n\
  }\n\
\n\
  return outArray;\n\
};\n\
\n\
/**\n\
 * vector operations namespace\n\
 * @api public\n\
 */\n\
\n\
simplexn.vector = {};\n\
\n\
/**\n\
 * add\n\
 * \n\
 * @param {Array|Float32Array|Uint32Array} v1\n\
 * @param {Array|Float32Array|Uint32Array} v2\n\
 * @return {Array|Float32Array|Uint32Array}\n\
 * @api public\n\
 */\n\
\n\
var vectorAdd =\n\
simplexn.vector.add = function (v1, v2) {\n\
  var rn = v1.length;\n\
  var res = new v1.constructor(rn);\n\
  var i;\n\
\n\
  for (var i = 0; i < rn; i += 1) {\n\
    res[i] = v1[i] + v2[i];\n\
  };\n\
\n\
  return res;\n\
};\n\
\n\
/**\n\
 * sub\n\
 * \n\
 * @param {Array|Float32Array|Uint32Array} v1\n\
 * @param {Array|Float32Array|Uint32Array} v2\n\
 * @return {Array|Float32Array|Uint32Array}\n\
 * @api public\n\
 */\n\
\n\
var vectorSub =\n\
simplexn.vector.sub = function (v1, v2) {\n\
  var rn = v1.length;\n\
  var res = new v1.constructor(rn);\n\
  var i;\n\
\n\
  for (var i = 0; i < rn; i += 1) {\n\
    res[i] = v1[i] - v2[i];\n\
  };\n\
\n\
  return res;\n\
};\n\
\n\
/**\n\
 * mul\n\
 * \n\
 * @param {Array|Float32Array|Uint32Array} v1\n\
 * @param {Array|Float32Array|Uint32Array} v2\n\
 * @return {Array|Float32Array|Uint32Array}\n\
 * @api public\n\
 */\n\
\n\
var vectorMul =\n\
simplexn.vector.mul = function (v1, v2) {\n\
  var rn = v1.length;\n\
  var res = new v1.constructor(rn);\n\
  var i;\n\
\n\
  for (var i = 0; i < rn; i += 1) {\n\
    res[i] = v1[i] * (v2[i] || 1);\n\
  };\n\
\n\
  return res;\n\
};\n\
\n\
/**\n\
 * scalarMul\n\
 * \n\
 * @param {Number} scalar\n\
 * @param {Array|Float32Array|Uint32Array} v\n\
 * @return {Array|Float32Array|Uint32Array}\n\
 * @api public\n\
 */\n\
\n\
var vectorScalarMul =\n\
simplexn.vector.scalarMul = function (scalar, v) {\n\
  var rn = v.length;\n\
  var res = new v.constructor(rn);\n\
  var i;\n\
\n\
  for (var i = 0; i < rn; i += 1) {\n\
    res[i] = scalar * v[i];\n\
  };\n\
\n\
  return res;\n\
};\n\
\n\
/**\n\
 * scalarDiv\n\
 * \n\
 * @param {Number} scalar\n\
 * @param {Array|Float32Array|Uint32Array} v\n\
 * @return {Array|Float32Array|Uint32Array}\n\
 * @api public\n\
 */\n\
\n\
var vectorScalarDiv =\n\
simplexn.vector.scalarDiv = function (scalar, v) {\n\
  var rn = v.length;\n\
  var res = new v.constructor(rn);\n\
  var i;\n\
\n\
  for (var i = 0; i < rn; i += 1) {\n\
    res[i] = v[i] / scalar;\n\
  };\n\
\n\
  return res;\n\
};\n\
\n\
/**\n\
 * average\n\
 * \n\
 * @param {Array} vectors\n\
 * @return {Array|Float32Array|Uint32Array}\n\
 * @api public\n\
 */\n\
\n\
var vectorAvg =\n\
simplexn.vector.avg = function (vectors) {\n\
  var vectors = vectors || [[]];\n\
  var length = vectors.length;\n\
  var rn = vectors[0].length;\n\
  var res = new vectors[0].constructor(rn);\n\
  var i;\n\
\n\
  for (i = 0; i < rn; i += 1) {\n\
    res[i] = 0;\n\
  }\n\
\n\
  res = vectors.reduce(vectorAdd, res);\n\
  res = vectorScalarDiv(length, res);\n\
\n\
  return res;\n\
};\n\
\n\
/**\n\
 * matrix operations namespace\n\
 * @api public\n\
 */\n\
\n\
simplexn.matrix = {};\n\
\n\
/**\n\
 * identity\n\
 * \n\
 * @param {Number} dim\n\
 * @api public\n\
 */\n\
\n\
var matrixIdentity =\n\
simplexn.matrix.identity = function (dim) {\n\
  var matrix = new Array(dim);\n\
  var i, j;\n\
\n\
  for (i = 0; i < dim; i += 1) {\n\
    matrix[i] = new Array(dim);\n\
    for(j = 0; j < dim; j += 1) {\n\
      matrix[i][j] = (j === i) ? 1 : 0;\n\
    }\n\
  }\n\
\n\
  return matrix;\n\
};\n\
\n\
/**\n\
 * PointSet\n\
 * \n\
 * @constructor\n\
 * @param {Array|Number} points or number of point to initialize;\n\
 * @rn {Number} [rn=points[0].length] points dimension;\n\
 * @api public\n\
 */\n\
\n\
var PointSet = \n\
simplexn.PointSet = function (points, rn) {\n\
  points = points || [[]];\n\
  if (typeof points === 'number') {\n\
    this.rn = rn;\n\
    points = points * rn;\n\
  } else {\n\
    this.rn  = points[0].length;\n\
    points = _flat(points);\n\
  }\n\
  this.points = new Float32Array(points);\n\
};\n\
\n\
/**\n\
 * size\n\
 * \n\
 * @property\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.__defineGetter__('size', function () {\n\
  return this.points.length / this.rn;\n\
});\n\
\n\
/** \n\
 * clone\n\
 * \n\
 * @return {PointSet} clone\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.clone = function () {\n\
  var clone = new PointSet();\n\
  clone.size = this.size;\n\
  clone.rn = this.rn;\n\
  clone.points = new Float32Array(this.points);\n\
  return clone;\n\
};\n\
\n\
/**\n\
 * toJSON\n\
 * return a JSON of Pointset data\n\
 * \n\
 * @return {Ojbect} model\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.toJSON = function () {\n\
  var json = {};\n\
  \n\
  json.points = _toArray(this.points);\n\
  json.rn = this.rn;\n\
\n\
  return json;\n\
};\n\
\n\
/**\n\
 * fromJSON\n\
 * instantiate a PointSet from a JSON\n\
 * @param {Object|String} json\n\
 *\n\
 * @return {simplexn.PointSet} struct\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.fromJSON = function (json) {\n\
  var json = typeof json === \"string\" ? JSON.parse(json) : json;\n\
  var rn = json.rn;\n\
  var pointset = new PointSet(json.points.length/rn, rn);\n\
\n\
  pointset.points = new Float32Array(json.points);\n\
\n\
  return pointset;\n\
};\n\
\n\
/**\n\
 * equals \n\
 * \n\
 * @param {simplexn.PointSet} pointSet\n\
 * @return {Boolean} true if this is equals to the given point set, false otherwise.\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.equals = function (other) {\n\
  if (this.rn !== other.rn || this.size !== other.size) return false;\n\
  for (var i = 0, l = this.points.length; i < l; i += 1) {\n\
    if (this.points[i] !== other.points[i]) {\n\
      return false;\n\
    }\n\
  }\n\
  return true;\n\
};\n\
\n\
/**\n\
 * get\n\
 * \n\
 * @param {Number} index\n\
 * @return {Float32Array} the indexed point\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.get = function (index) {\n\
  var rn = this.rn;\n\
  var begin = index * rn;\n\
  var end = begin + rn;\n\
\n\
  return this.points.subarray(begin, end);\n\
};\n\
\n\
/**\n\
 * set\n\
 * \n\
 * @param {Array|Float32Array} points\n\
 * @param {Number} [index=0]\n\
 * @return {simplexn.PointSet} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.set = function (point, index) {\n\
  point = point || 0;\n\
  this.points.set(point, index * this.rn);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * forEach\n\
 * \n\
 * @param {Function} iterator\n\
 * @return {simplexn.PointSet} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.forEach = function (iterator) {\n\
  var points = this.points;\n\
  var length = points.length;\n\
  var rn = this.rn;\n\
  var i, j;\n\
\n\
  for (i = j = 0; i < length; i += rn, j += 1) {\n\
    iterator(points.subarray(i, i + rn), j);\n\
  }\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * map\n\
 * \n\
 * @param {Function} mapping\n\
 * @return {simplexn.PointSet} a new point set\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.map = function (mapping) {\n\
  var points = this.points;\n\
  var oldRn = this.rn;\n\
  var size = this.size;\n\
  var mappedPoints0 = mapping(points.subarray(0,oldRn));\n\
  var newRn = mappedPoints0.length;\n\
  var newPoints = new Float32Array(size * newRn);\n\
  var i, j;\n\
\n\
  newPoints.set(mappedPoints0);\n\
\n\
  for (i = oldRn, j = 1; j < size; i += oldRn, j += 1) {\n\
    newPoints.set(mapping(points.subarray(i, i + oldRn), j), j * newRn);\n\
  }\n\
\n\
  this.points = newPoints;\n\
  this.rn = newRn;\n\
  return this;\n\
};\n\
\n\
/**\n\
 * filter\n\
 * \n\
 * @param {Function} iterator\n\
 *   \n\
 * @return {Float32Array} new filtered PointSet\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.filter = function (iterator) {\n\
  var points = this.points;\n\
  var length = points.length;\n\
  var filtered = new Float32Array(length);\n\
  var rn = this.rn;\n\
  var i, j, k;\n\
  var point;\n\
  var pointset;\n\
\n\
  for (i = j = k = 0; i < length; i += rn, j += 1) {\n\
    point = points.subarray(i, i + rn);\n\
    if (iterator(point, j)) {\n\
      filtered.set(point, k);\n\
      k += rn;\n\
    }\n\
  }\n\
\n\
  filtered = filtered.subarray(0, k);\n\
  pointset = new PointSet();\n\
  pointset.points = filtered;\n\
  pointset.rn = rn;\n\
  pointset.size = k / rn;\n\
  \n\
  return pointset;\n\
};\n\
\n\
/**\n\
 * merge\n\
 * Filter duplicated and overlapped vertices \n\
 * according to precision parameter (10e-4 by default).\n\
 * \n\
 * @param {Number} [precision = 10e-4] \n\
 * @return {Float32Array} inidices mapping changes\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.merge = function (precision) {\n\
  var precision = precision || 1e-4;\n\
  var points = this.points;\n\
  var length = points.length;\n\
  var rn = this.rn;\n\
  var size = this.size;\n\
  var indices = new Uint32Array(size);\n\
  var merged = new Float32Array(length);\n\
  var usedIndices = 0;\n\
  var usedCoords = 0;\n\
  var vertexAdded;\n\
  var equals;\n\
  var i, j, k;\n\
\n\
  for (i = 0; i < length; i += rn) {\n\
    vertexAdded = false;\n\
    for (j = 0; j < usedCoords && !vertexAdded; j += rn) {\n\
      equals = true;\n\
      for (k = 0; k < rn; k += 1) {\n\
        points[i+k] = round(points[i+k] / precision) * precision;\n\
        equals &= points[i+k] === merged[j+k];\n\
      }\n\
      vertexAdded |= equals; \n\
    }\n\
    indices[i/rn] = !vertexAdded ? usedIndices : j/rn-1;\n\
    if (!vertexAdded) {\n\
      for (k = 0; k < rn; k += 1) {\n\
        merged[usedCoords+k] = points[i+k];\n\
      }\n\
      usedIndices += 1;\n\
      usedCoords = usedIndices*rn;\n\
    }\n\
  }\n\
\n\
  this.points = merged.subarray(0, usedCoords);\n\
\n\
  return indices;\n\
};\n\
\n\
/**\n\
 * rotate\n\
 * a 3d rotation\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Number} angle\n\
 * @return {simplexn.PointSet} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.rotate = function (dims, angle) {\n\
  var dims = dims[0] > dims[1] ? [dims[1], dims[0]] : dims;\n\
  var points = this.points;\n\
  var length = points.length;\n\
  var rn = this.rn;\n\
  var cos_a = cos(angle);\n\
  var sin_a = sin(angle);\n\
  var r_ii = cos_a;\n\
  var r_ij = -sin_a;\n\
  var r_ji = sin_a;\n\
  var r_jj = cos_a;\n\
  var d_i = dims[0];\n\
  var d_j = dims[1];\n\
  var v_i;\n\
  var v_j;\n\
  var i, j, k;\n\
\n\
  if ((dims[0] + dims[1]) % 2 == 0) {\n\
    r_ij *= -1;\n\
    r_ji *= -1;\n\
  }\n\
\n\
  for (k = 0, i = d_i, j = d_j; k < length; k += rn, i = k + d_i, j = k + d_j) {\n\
    v_i = points[i];\n\
    v_j = points[j];\n\
    points[i] = v_i * r_ii + v_j * r_ij;\n\
    points[j] = v_i * r_ji + v_j * r_jj;\n\
  }\n\
  \n\
  return this;\n\
};\n\
\n\
/**\n\
 * scale\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Array|Float32Array} values\n\
 * @return {simplexn.PointSet} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.scale = function (dims, values) {\n\
  var points = this.points \n\
  var length = points.length;\n\
  var dimsLength = dims.length;\n\
  var rn = this.rn;\n\
  var i, j;\n\
\n\
  for (i = 0; i < length; i += rn) {\n\
    for (j = 0; j < dimsLength; j += 1) {\n\
      points[i+dims[j]] *= values[j]; \n\
    }\n\
  }\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * translate\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Array|Float32Array} values\n\
 * @return {simplexn.PointSet} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.translate = function (dims, values) {\n\
  var rn = this.rn;\n\
  var maxDim = Math.max.apply(null, dims.concat(rn - 1));\n\
  this.embed(maxDim + 1);\n\
\n\
  var points = this.points \n\
  var length = points.length;\n\
  var dimsLength = dims.length;\n\
  var i, j;\n\
\n\
  for (i = 0; i < length; i += rn) {\n\
    for (j = 0; j < dimsLength; j += 1) {\n\
      points[i+dims[j]] += values[j]; \n\
    }\n\
  }\n\
  return this;\n\
};\n\
\n\
/**\n\
 * transform\n\
 * \n\
 * @param {Array|Float32Array} matrix\n\
 * @return {simplexn.PointSet} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.transform = function (matrix) {\n\
  // body...\n\
  \n\
  return this;\n\
};\n\
\n\
/**\n\
 * embed\n\
 * \n\
 * @param {Number} dim\n\
 * @return {simplexn.PointSet} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.embed = function (dim) {\n\
  var dim = dim || this.rn + 1\n\
  var rn = this.rn;\n\
  var minDim = Math.min(rn, dim);\n\
  var oldPoints = this.points;\n\
  var oldLength = oldPoints.length;\n\
  var length = oldLength / rn * dim;\n\
  var points = new Float32Array(length);\n\
  var i, j, k;\n\
\n\
  for (i = 0, j = 0; i < oldLength; i += rn, j += dim) {\n\
    for (k = 0; k < minDim; k += 1) {\n\
      points[j + k] = oldPoints[i + k];\n\
    }\n\
  }\n\
\n\
  this.points = points;\n\
  this.rn = dim;\n\
  \n\
  return this;\n\
};\n\
\n\
/**\n\
 * prod\n\
 * Execute product of this pointset pointset.\n\
 *\n\
 * @param {simplexn.PointSet} pointset\n\
 * @return {simplexn.PointSet} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.prod = function(pointset) {\n\
  var size = this.size;\n\
  var rn = this.rn\n\
  var pointsetSize = pointset.size;\n\
  var pointsetRn = pointset.rn;\n\
  var newSize = size * pointsetSize;\n\
  var newRn = rn + pointsetRn;\n\
  var newLength = newSize * newRn;\n\
  var newPoints = new Float32Array(newLength);\n\
  var newPoint, point1, point2;\n\
  var i, j;\n\
  var n = 0;\n\
\n\
  for (j = 0; j < pointsetSize; j += 1) {\n\
    point2 = pointset.get(j);\n\
    for (i = 0; i < size; i += 1) {\n\
      newPoint = new Float32Array(newRn);\n\
      point1 = this.get(i);\n\
      newPoint.set(point1);\n\
      newPoint.set(point2, rn);\n\
      newPoints.set(newPoint, newRn*n++);\n\
    }\n\
  }\n\
\n\
  this.points = newPoints;\n\
  this.rn = newRn;\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Topology\n\
 * \n\
 * @constructor\n\
 * @param {Array|Uint32Array} complex\n\
 * @param {Number} [dim=complex[0].length - 1]\n\
 * @param {Boolean} [computeTopology=true]\n\
 * @api public\n\
 */\n\
\n\
var Topology = \n\
simplexn.Topology = function (complex, dim) {\n\
  this._computeTopology(complex, dim);\n\
}\n\
\n\
/**\n\
 * _computeTopologyogy\n\
 * \n\
 * @param {Array|Uint32Array} complex\n\
 * @param {Number} [dim=complex[0].length - 1]\n\
 * @api private\n\
 */\n\
\n\
simplexn.Topology.prototype._computeTopology = function (complex, dim) {\n\
  var complex = complex || [[]];\n\
  var dim;\n\
  var complexes = new Array();\n\
  var complexTemp, complexNext;\n\
  var complexNextLength;\n\
  var complexLength;\n\
  var cellDim;\n\
  var d, c, i, j, k;\n\
  var exchange1, exchange2;\n\
\n\
  complex = complex.length > 0 ? complex : [[]];\n\
  dim = dim || complex[0].length - 1;\n\
  complex = complex instanceof Array ? _flat(complex) : complex;\n\
  if (dim >= 0) { complexes[0] = new Uint32Array(); }\n\
  if (dim === 0 || dim >= 1) { complexes[dim] = new Uint32Array(complex); }\n\
\n\
  for (d = dim; d > 1; d -= 1) {\n\
    complexNext = complexes[d];\n\
    complexNextLength = complexNext.length;\n\
    cellDim = d + 1;\n\
    complexLength = complexNextLength / cellDim;\n\
    complexTemp = new Uint32Array(cellDim * complexLength * d);\n\
    complexes[d-1] = complexTemp;\n\
    k = 0;\n\
    for (c = 0; c < complexNextLength; c += cellDim) {\n\
      for (i = 0; i < cellDim; i++) {\n\
        for (j = 0; j < cellDim; j++) {\n\
          if (i != j) {\n\
            complexTemp[k] = complexNext[c+j];\n\
            k++;\n\
          }\n\
        }\n\
        if (i & 1) { // is odd\n\
          // exchange1 = k - cellDim + 1;\n\
          exchange1 = k - 2;\n\
          exchange2 = k - 1;\n\
          complexTemp[exchange1] ^= complexTemp[exchange2];\n\
          complexTemp[exchange2] ^= complexTemp[exchange1];\n\
          complexTemp[exchange1] ^= complexTemp[exchange2];\n\
        }\n\
      }\n\
    }\n\
  }\n\
\n\
  this.complexes = complexes;\n\
};\n\
\n\
/**\n\
 * dim\n\
 * \n\
 * @property\n\
 * @api public\n\
 */\n\
\n\
simplexn.Topology.prototype.__defineGetter__('dim', function () {\n\
  return this.complexes.length - 1;\n\
});\n\
\n\
/**\n\
 * maxCells\n\
 * \n\
 * @property\n\
 * @api public\n\
 */\n\
\n\
simplexn.Topology.prototype.__defineGetter__('maxCells', function () {\n\
  return this.complexes[this.dim];\n\
});\n\
\n\
/**\n\
 * equals \n\
 * \n\
 * @param {simplexn.Topology} topology\n\
 * @return {Boolean} true if this is equals to the given topology, false otherwise.\n\
 * @api public\n\
 */\n\
\n\
simplexn.Topology.prototype.equals = function (other) {\n\
  var complexes1 = this.complexes;\n\
  var complexes2 = other.complexes;\n\
  var dim1 = this.dim;\n\
  var dim2 = other.dim;\n\
  var i;\n\
\n\
  if (dim1 !== dim2) return false;\n\
  for (i = 0; i < dim1; i += 1) {\n\
    if (!_areEqual(complexes1[i], complexes2[i])) return false;\n\
  }\n\
  return true;\n\
};\n\
\n\
/**\n\
 * remap\n\
 *\n\
 * Remap topology by given mapping array.\n\
 *\n\
 * @param {Array} mapping\n\
 * @return {simplexn.Topology} cloned topology\n\
 * @api public\n\
 */\n\
\n\
simplexn.Topology.prototype.remap = function (mapping) {\n\
  var length;\n\
  var i;\n\
\n\
  this.complexes.forEach(function (complex) {\n\
    length = complex.length;\n\
    for (var i = 0; i < length; i += 1) {\n\
      complex[i] = mapping[complex[i]];\n\
    }\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * invert\n\
 * Invert orientation of all of the cells in topology\n\
 * \n\
 * @return {simplexn.Topology} this for chaining \n\
 * @api public\n\
 */\n\
\n\
simplexn.Topology.prototype.invert = function () {\n\
  var dim = this.dim;\n\
  var complex = this.complexes[dim];\n\
  var length = complex.length;\n\
  var cellSize = dim + 1;\n\
  var cells = [];\n\
  var cell;\n\
  var swap;\n\
  var i, j;\n\
\n\
  for (i = 0; i < length; i += cellSize) {\n\
    cell = [];\n\
    for (j = 0; j < cellSize; j += 1) {\n\
      cell.push(complex[i+j]);\n\
    }\n\
    swap = cell[0];\n\
    cell[0] = cell[dim];\n\
    cell[dim] = swap; \n\
    cells.push(cell);\n\
  }\n\
\n\
  this._computeTopology(cells);\n\
};\n\
\n\
/**\n\
 * clone\n\
 * \n\
 * @return {simplexn.Topology} cloned topology\n\
 * @api public\n\
 */\n\
\n\
simplexn.Topology.prototype.clone = function () {\n\
  var clone = new Topology();\n\
  var dim = this.dim;\n\
  var complexes = new Array();\n\
  var i;\n\
\n\
  this.complexes.forEach(function (complex, i) {\n\
    complexes[i] = new Uint32Array(complex);\n\
  });\n\
\n\
  clone.complexes = complexes;\n\
\n\
  return clone;\n\
};\n\
\n\
/**\n\
 * toJSON\n\
 * return a JSON of Topology data\n\
 * \n\
 * @return {Object} model\n\
 * @api public\n\
 */\n\
\n\
simplexn.Topology.prototype.toJSON = function () {\n\
  var json = {};\n\
  var complexes = [];\n\
  \n\
  this.complexes.forEach(function (complex) {\n\
    complexes.push(_toArray(complex));\n\
  });\n\
\n\
  json.complexes = complexes;\n\
  json.dim = this.dim;\n\
\n\
  return json;\n\
};\n\
\n\
/**\n\
 * fromJSON\n\
 * instantiate a Topology from a JSON\n\
 * @param {Object|String} json\n\
 *\n\
 * @return {simplexn.Topology} struct\n\
 * @api public\n\
 */\n\
\n\
simplexn.Topology.fromJSON = function (json) {\n\
  var json = typeof json === \"string\" ? JSON.parse(json) : json;\n\
  var complexes = new Array();\n\
  var topology = new Topology();\n\
\n\
  json.complexes.forEach(function (complex) {\n\
    complexes.push(new Uint32Array(complex));\n\
  });\n\
\n\
  topology.complexes = complexes;\n\
\n\
  return topology;\n\
};\n\
\n\
/**\n\
 * equals \n\
 * \n\
 * @param {simplexn.PointSet} pointSet\n\
 * @return {Boolean} true if this is equals to the given point set, false otherwise.\n\
 * @api public\n\
 */\n\
\n\
simplexn.PointSet.prototype.equals = function (other) {\n\
  if (this.rn !== other.rn || this.size !== other.size) return false;\n\
  for (var i = 0, l = this.points.length; i < l; i += 1) {\n\
    if (this.points[i] !== other.points[i]) {\n\
      return false;\n\
    }\n\
  }\n\
  return true;\n\
};\n\
\n\
/**\n\
 * cells0d\n\
 * \n\
 * @return {Uint32Array} 0-dimension cells\n\
 * @api private\n\
 */\n\
 \n\
simplexn.Topology.prototype.cells0d = function () {\n\
  if (this.dim === 0) { return this.complexes[0]; }\n\
\n\
  var complexes = this.complexes || [[]];\n\
  var cells1d = complexes[1] || [];\n\
  var length = cells1d.length;\n\
  var cells0d = new Uint32Array(length);\n\
  var i, j;\n\
  var k = 0;\n\
  var found;\n\
\n\
  for (i = 0; i < length; i += 1) {\n\
    found = false;\n\
    for (j = 0; j < k && !found; j += 1) {\n\
      found |= cells1d[i] === cells0d[j];\n\
    }\n\
    if (!found) {\n\
      cells0d[k++] = [cells1d[i]];\n\
    }\n\
  }\n\
\n\
  return cells0d.subarray(0,k);\n\
}\n\
\n\
/**\n\
 * skeleton\n\
 * \n\
 * @param {Number} ord skeleton order\n\
 * @return {simplexn.Topology} topology of the skeleton\n\
 * @api public\n\
 */\n\
\n\
simplexn.Topology.prototype.skeleton = function (ord) {\n\
  var dim = this.dim\n\
  var ord = ord === undefined ? dim - 1 : ord;\n\
  var out = dim - ord;\n\
\n\
  if (ord === 0) {\n\
    this.complexes = [this.cells0d()];\n\
  } else {\n\
    while (out--) this.complexes.pop();\n\
  }\n\
\n\
  return this;\n\
};\n\
\n\
\n\
/**\n\
 * boundary\n\
 * \n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.Topology.prototype.boundary = function () {\n\
  var dim = this.dim - 1;\n\
\n\
  this.skeleton(dim);\n\
  \n\
  var complexes = this.complexes;\n\
  var cellLength = dim + 1;\n\
  var cells = complexes[dim];\n\
  var cellsLength = cells.length;\n\
  var cellsSize = cellsLength / cellLength;\n\
  var sortedCells = new Uint32Array(cells);\n\
  var notBoundaryCells = new Uint8Array(cellsSize);\n\
  var boundary;\n\
  var boundarySize = cellsSize;\n\
  var cell;\n\
  var equal;\n\
  var i, j, b, c;\n\
\n\
  for (i = 0; i < cellsLength; i += cellLength) {\n\
    _quickSort(sortedCells.subarray(i, i + cellLength));\n\
  }\n\
  for (c = 0; c < cellsSize; c += 1) {\n\
    cell = sortedCells.subarray(c * cellLength, c * cellLength + cellLength);\n\
    if (!notBoundaryCells[c]) {\n\
      for (i = c + 1; i < cellsSize; i += 1) {\n\
        equal = true;\n\
        for (j = 0; j < cellLength && equal; j += 1) {\n\
          equal &= sortedCells[i*cellLength+j] === cell[j]; \n\
        }\n\
        notBoundaryCells[c] |= equal;\n\
        notBoundaryCells[i] |= equal;\n\
      }\n\
    }\n\
  }\n\
  for (c = 0; c < cellsSize; c += 1) {\n\
    boundarySize -= notBoundaryCells[c];\n\
  }\n\
  boundary = new Uint32Array(boundarySize * cellLength);\n\
  for (c = 0, b = 0; c < cellsSize; c += 1) {\n\
    if (!notBoundaryCells[c]) {\n\
      for (i = 0; i < cellLength; i += 1) {\n\
        boundary[b++] = cells[c*cellLength+i];\n\
      }\n\
    }\n\
  }\n\
\n\
  this._computeTopology(boundary, dim);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * SimplicialComplex\n\
 * \n\
 * @constructor\n\
 * @param {Array|Float32Array} points\n\
 * @faces {Array|Uint32Array} complex\n\
 * @api public\n\
 */\n\
\n\
var SimplicialComplex =\n\
simplexn.SimplicialComplex = function (points, complex) {\n\
  var points = points || [[]];\n\
  var complex = complex || [[]];\n\
\n\
  this.pointset = new PointSet(points);\n\
  this.topology = new Topology(complex);\n\
};\n\
\n\
/**\n\
 * rn\n\
 * \n\
 * @property\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.__defineGetter__('rn', function () {\n\
  return this.pointset.rn;\n\
});\n\
\n\
/**\n\
 * size\n\
 * \n\
 * @property\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.__defineGetter__('size', function () {\n\
  return this.pointset.size;\n\
});\n\
\n\
/**\n\
 * dim\n\
 * \n\
 * @property\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.__defineGetter__('dim', function () {\n\
  return this.topology.dim;\n\
});\n\
\n\
/**\n\
 * rotate\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Number} angle\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.rotate = function (dims, angle) {\n\
  this.pointset.rotate(dims, angle);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * scale\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Array|Float32Array} values\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.scale = function (dims, values) {\n\
  var invert;\n\
\n\
  this.pointset.scale(dims, values);\n\
\n\
  invert = values.reduce(function (v1, v2) {\n\
    return v1 * v2;\n\
  });\n\
\n\
  if (invert < 0) {\n\
    this.topology.invert();\n\
  };\n\
  \n\
  return this;\n\
};\n\
\n\
/**\n\
 * translate\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Array|Float32Array} values\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.translate = function (dims, values) {\n\
  this.pointset.translate(dims, values);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * transform\n\
 * \n\
 * @param {Array|Float32Array} matrix\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.transform = function (matrix) {\n\
  this.pointset.transform(matrix);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * embed\n\
 * \n\
 * @param {Number} dim\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.embed = function (dim) {\n\
  this.pointset.embed(dim);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * merge\n\
 * \n\
 * @precision {Number} [precision=1e-4]\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.merge = function (precision) {\n\
  var precision = precision || 1e-4;\n\
  var mapping = this.pointset.merge(precision);\n\
  this.topology.remap(mapping);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * clone\n\
 * \n\
 * @return {simplexn.SimplicialComplex} cloned SimplicialComplex\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.clone = function () {\n\
  var clone = new SimplicialComplex();\n\
  clone.pointset = this.pointset.clone();\n\
  clone.topology = this.topology.clone();\n\
  return clone;\n\
};\n\
\n\
/**\n\
 * toJSON\n\
 * return a JSON of SimplicialComplex data\n\
 * \n\
 * @return {Object} model\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.toJSON = function () {\n\
  var json = {};\n\
  \n\
  json.pointset = this.pointset.toJSON();\n\
  json.topology = this.topology.toJSON();\n\
\n\
  return json;\n\
};\n\
\n\
/**\n\
 * fromJSON\n\
 * instantiate a SimplicialComplex from a JSON\n\
 * @param {Object|String} json\n\
 *\n\
 * @return {simplexn.SimplicialComplex} struct\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.fromJSON = function (json) {\n\
  var json = typeof json === \"string\" ? JSON.parse(json) : json;\n\
  var simplicialComplex = new SimplicialComplex();\n\
\n\
  simplicialComplex.pointset = PointSet.fromJSON(json.pointset);\n\
  simplicialComplex.topology = Topology.fromJSON(json.topology);\n\
\n\
  return simplicialComplex;\n\
};\n\
\n\
/**\n\
 * map\n\
 * \n\
 * @param {Function} mapping\n\
 * @param {Boolean|Number} merge\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.map = function (mapping, merge) {\n\
  var precision = typeof merge === 'boolean' ? undefined : merge;\n\
  this.pointset.map(mapping);\n\
  if (merge) this.merge(precision);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * equals \n\
 * \n\
 * @param {simplexn.SimplicialComplex} simpcomp\n\
 * @return {Boolean} true if this is equals to the given mplicial complex, false otherwise.\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.equals = function (simpcomp) {\n\
  var pointset1 = this.pointset;\n\
  var pointset2 = simpcomp.pointset;\n\
  var topology1 = this.topology;\n\
  var topology2 = simpcomp.topology;\n\
\n\
  if (! pointset1.equals(pointset2)) return false;\n\
  if (! topology1.equals(topology2)) return false;\n\
\n\
  return true;\n\
};\n\
\n\
/**\n\
 * extrude\n\
 * \n\
 * @param {Array|Float32Array} hlist which must be made by positive numbers \n\
 *   or by an alternation of positive and negative numbers\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api private\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.extrude = function (hlist) {\n\
  var hlist = hlist || [1];\n\
  var hlistLength = hlist.length;\n\
  var hlist0 = hlist[0];\n\
  var hlist0isNegative = hlist0 < 0;\n\
  var positiveQuotes = hlist.filter(function (h) {return h >= 0}).length;\n\
  \n\
  var oldRn = this.rn;\n\
  var newRn = oldRn + 1;\n\
  var pointset = this.pointset;\n\
  var pointsetSize = pointset.size;\n\
  var oldEmbeddedPoints;\n\
  var oldPointsLength = pointsetSize * oldRn;\n\
  var newPointsLength = pointsetSize * newRn;\n\
  var newPoints = new Float32Array(newPointsLength);\n\
\n\
  var newPointsetSize = (hlistLength + 1 - (hlist0isNegative)) * pointsetSize;\n\
  var newPointset = new PointSet(newPointsetSize, newRn);\n\
\n\
  var oldDim = this.dim;\n\
  var newDim = oldDim + 1; \n\
  var topology = this.topology;\n\
  var cellLength = oldDim + 1;\n\
  var complex = topology.complexes[oldDim];\n\
  var complexLength = complex.length;\n\
  var complexSize = complexLength / cellLength;\n\
\n\
  var newCellLength = newDim + 1;\n\
  var newComplexLength = positiveQuotes * complexSize * newDim * newCellLength;\n\
  var newComplex = new Uint32Array(newComplexLength);\n\
\n\
  var tempLength = 2 * cellLength;\n\
  var temp = new Uint32Array(tempLength);\n\
  var tempIndx;\n\
  var cIndx = 0 ;\n\
  var exchange1, exchange2;\n\
  var end;\n\
  var quote = 0;\n\
  var h, v, c, i, j;\n\
\n\
  for (i = 0; i < complexLength; i += cellLength) {\n\
    _quickSort(complex.subarray(i, i + cellLength));\n\
  }\n\
\n\
  this.embed();\n\
  oldEmbeddedPoints = this.pointset.points;\n\
  newPoints.set(oldEmbeddedPoints);\n\
  if (!hlist0isNegative) newPointset.set(oldEmbeddedPoints);\n\
\n\
  for (h = 0; h < hlistLength; h += 1) {\n\
    quote += abs(hlist[h]);\n\
\n\
    // add new points\n\
    for (v = newRn - 1; v < newPointsLength; v += newRn) {\n\
      newPoints[v] = quote;\n\
    }\n\
    newPointset.set(newPoints, (h + 1 - (hlist0isNegative)) * pointsetSize);\n\
\n\
    // create new cells\n\
    if (hlist[h] >= 0) {\n\
      for (c = 0; c < complexSize; c += 1) {\n\
        // fill temp with selected indexes\n\
        for (i = 0; i < cellLength; i++) {\n\
          tempIndx = complex[c*cellLength+i] + (h - (hlist0isNegative)) * pointsetSize;\n\
          temp[i] = tempIndx;\n\
          temp[i+cellLength] = tempIndx + pointsetSize;\n\
        }\n\
        \n\
        // pick cells from temp, cellLength by cellLength\n\
        for (i = 0; i < cellLength; i += 1) {\n\
          end = i + cellLength + 1;\n\
          for (j = i; j < end; j++) {\n\
            newComplex[cIndx++] = temp[j];\n\
          }\n\
          // take care of orientation\n\
          if (((newDim & 1) * (c) + (oldDim & 1) * i) & 1) {\n\
            exchange1 = cIndx - 1;\n\
            exchange2 = exchange1 - 1;\n\
            _swap(newComplex, exchange1, exchange2);\n\
          }\n\
        }\n\
      }\n\
    }\n\
  }\n\
\n\
  this.pointset = newPointset;\n\
  this.topology = new Topology(newComplex, newDim);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * getFacet\n\
 * Return the `dim` and `index` facet\n\
 *\n\
 * @param {Number} dim\n\
 * @param {Number} index\n\
 * @return {Array} the facet represented by a `dim+1` length array\n\
 * @api private\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.getFacet = function (dim, index) {\n\
  var topology = this.topology;\n\
  var pointset = this.pointset;\n\
  var cells = this.topology.complexes[dim];\n\
  var size = dim + 1;\n\
  var start = size*index;\n\
  var cell = cells.subarray(start, start + size);\n\
  var facet = [];\n\
  var i;\n\
\n\
  for (i = 0; i < size; i += 1) {\n\
    facet.push(pointset.get(cell[i]));\n\
  }\n\
\n\
  return facet;\n\
};\n\
\n\
/**\n\
 * centroids\n\
 * Return a PointsSet of centroids of dim-cells.\n\
 * \n\
 * @param {Number} [dim=this.dim]\n\
 * @return {simplexn.PointSet}\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.centroids = function (dim) {\n\
  var dim = dim || this.dim;\n\
  var cellSize = dim + 1;\n\
  var cellsSize = this.topology.complexes[dim].length / cellSize;\n\
  var centroids = new PointSet(cellsSize, this.rn);\n\
  var i;\n\
  var centroid;\n\
\n\
  for (i = 0; i < cellsSize; i += 1) {\n\
    centroid = vectorAvg(this.getFacet(dim, i));\n\
    centroids.set(centroid, i);\n\
  }\n\
\n\
  return centroids;\n\
\n\
};\n\
\n\
/**\n\
 * explode\n\
 *\n\
 * @param {Array|Float32Array} values\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.explode = function (values) {\n\
  var dim = this.dim;\n\
  var values = values || [];\n\
  var cell;\n\
  var cellSize = dim + 1;\n\
  var cells = this.topology.complexes[dim];\n\
  var cellsSize = cells.length / cellSize;\n\
  var newCell, newCells = [];\n\
  var pointset = this.pointset;\n\
  var newPointset = new PointSet(cellsSize*cellSize, this.rn);\n\
  var centroids = this.centroids();\n\
  var centroid;\n\
  var translatedCentroid;\n\
  var translationVect;\n\
  var c, i;\n\
  var indx = 0;\n\
\n\
  for (c = 0; c < cellsSize; c += 1) {\n\
    cell = cells.subarray(c*cellSize, c*cellSize + cellSize);\n\
    newCell = [];\n\
    centroid = centroids.get(c);\n\
    translatedCentroid = vectorMul(centroid, values);\n\
    translationVect = vectorSub(translatedCentroid, centroid);\n\
    for (i = 0; i < cellSize; i += 1) {\n\
      newCell.push(indx);\n\
      newPointset.set(vectorAdd(pointset.get(cell[i]), translationVect), indx);\n\
      indx++;\n\
    }\n\
    newCells.push(newCell);\n\
  }\n\
\n\
  this.pointset = newPointset;\n\
  this.topology = new Topology(newCells);\n\
  return this.merge();\n\
};\n\
\n\
/**\n\
 * skeleton\n\
 * \n\
 * @param {Number} dim\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.skeleton = function (dim) {\n\
  this.topology.skeleton(dim);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * boundary\n\
 * \n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.boundary = function () {\n\
  this.topology.boundary();\n\
  return this;\n\
};\n\
\n\
/**\n\
 * prod\n\
 * Execute product of this simplicial complex \n\
 * by a given simplicial complex.\n\
 * At the moment it's customed and tested only for following cases:\n\
 * - 1-rn x 1-rn\n\
 * - 1-rn x 2-rn\n\
 * - 2-rn x 1-rn\n\
 * \n\
 * @param {simplexn.SimplicialComplex} simpcomp\n\
 * @return {simplexn.SimplicialComplex} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.SimplicialComplex.prototype.prod = function(simpcomp) {\n\
  if (this.rn > 1 && simpcomp.rn > 2) return;\n\
  if (this.rn > 2 && simpcomp.rn > 1) return;\n\
\n\
  var n = simpcomp.size - 1;\n\
  var pointset = this.pointset.clone().prod(simpcomp.pointset);\n\
  var quotes = [];\n\
\n\
  while (n--) quotes.push(1);\n\
\n\
  this.extrude(quotes);\n\
\n\
  this.pointset = pointset;\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Struct\n\
 * A simplexn.Struct is a collection of simplexn.SimplicialComplex\n\
 *\n\
 * @constructor\n\
 * @param {Array} items simplexn.SimplicialComplex or simplexn.Struct instaces;\n\
 * @api public\n\
 */\n\
\n\
var Struct = \n\
simplexn.Struct = function (items) {\n\
  var items = items || [];\n\
  var complexes = [];\n\
  var structs = [];\n\
\n\
  items.forEach(function (item) {\n\
    if (item instanceof SimplicialComplex) {\n\
      complexes.push(item);\n\
    } else if (item instanceof Struct) {\n\
      structs.push(item);\n\
    }\n\
  });\n\
\n\
  this.complexes = complexes;\n\
  this.structs = structs;\n\
};\n\
\n\
/**\n\
 * rotate\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Number} angle\n\
 * @return {simplexn.Struct} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.Struct.prototype.rotate = function (dims, angle) {\n\
  this.complexes.forEach(function (complex) {\n\
    complex.rotate(dims, angle);\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.rotate(dims, angle);\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * scale\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Array|Float32Array} values\n\
 * @return {simplexn.Struct} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.Struct.prototype.scale = function (dims, values) {\n\
  this.complexes.forEach(function (complex) {\n\
    complex.scale(dims, values);\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.scale(dims, values);\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * translate\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Array|Float32Array} values\n\
 * @return {simplexn.Struct} this for chaining\n\
 * @api public\n\
 */\n\
\n\
simplexn.Struct.prototype.translate = function(dims, values) {\n\
  this.complexes.forEach(function (complex) {\n\
    complex.translate(dims, values);\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.translate(dims, values);\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * clone\n\
 * \n\
 * @return {simplexn.Struct} cloned Struct\n\
 * @api public\n\
 */\n\
\n\
simplexn.Struct.prototype.clone = function () {\n\
  //...\n\
};\n\
\n\
/**\n\
 * geometries\n\
 */\n\
\n\
simplexn.geometries = {};\n\
\n\
/**\n\
 * simplex\n\
 * \n\
 * @param {number} d\n\
 * @return {simplexn.SimplicialComplex} a simplex\n\
 * @api public\n\
 */\n\
\n\
var simplex =\n\
simplexn.geometries.simplex = function (d) {\n\
  var d = d !== undefined ? d + 1 : 1;\n\
  var dim = d;\n\
  var points0 = [];\n\
  var points = [];\n\
  var cells = [];\n\
\n\
  while (d--) {\n\
    points0.push(0);\n\
    cells.unshift(d);\n\
  }\n\
\n\
  points =  matrixIdentity(dim);\n\
  points.unshift(points0);\n\
\n\
  return new SimplicialComplex(points, [cells]);\n\
}\n\
\n\
/**\n\
 * polyline\n\
 * \n\
 * @param {Array} points\n\
 * @return {simplexn.SimplicialComplex} a simplex\n\
 * @api public\n\
 */\n\
\n\
var polyline =\n\
simplexn.geometries.polyline = function (points) {\n\
  var points = points || [[]];\n\
  var n = points.length - 1;\n\
  var cells = [];\n\
  var i;\n\
\n\
  for (i = 0; i < n; i += 1) {\n\
    cells.push([i, i+1]);\n\
  }\n\
\n\
  return (new SimplicialComplex(points, cells)).merge();\n\
};\n\
\n\
/**\n\
 * polypoint\n\
 * \n\
 * @param {Array} points\n\
 * @return {simplexn.SimplicialComplex} a simplex\n\
 * @api public\n\
 */\n\
\n\
var polypoint =\n\
simplexn.geometries.polypoint = function (points) {\n\
  var points = points || [[]];\n\
  var cells = points.map(function (p,i) { \n\
    return [i];\n\
  });\n\
\n\
  return (new SimplicialComplex(points, cells));\n\
};\n\
\n\
/**\n\
 * simplexGrid\n\
 * \n\
 * @param {Array} quotesList is a list of hlist which must be made by positive numbers \n\
*                 or by an alternation of positive and negative numbers\n\
 * @return {simplexn.SimplicialComplex} a grid of simplexes\n\
 * @api public\n\
 */\n\
\n\
var simplexGrid = \n\
simplexn.geometries.simplexGrid = function (quotesList) {\n\
  var quotesList = quotesList ? quotesList.slice(0) : [[]];\n\
  var quotesListHead = quotesList.shift();\n\
  var quotesListHead0 = quotesListHead[0];\n\
  var quotesListHead0isNeg = quotesListHead0 <= 0;\n\
  var points = quotesListHead0isNeg ? [] : [[0]];\n\
  var length = quotesList.length;\n\
  var complex = [];\n\
  var simpcomp;\n\
  var quote = 0;\n\
  var indx;\n\
\n\
  quotesListHead.forEach(function (height, i) {\n\
    quote += abs(height);\n\
    points.push([quote]);\n\
    if (height > 0) {\n\
      indx = i - (quotesListHead0isNeg);\n\
      complex.push([indx,indx+1]);\n\
    }\n\
  });\n\
\n\
  simpcomp = new SimplicialComplex(points, complex);\n\
\n\
  quotesList.forEach(function (quotes) {\n\
    simpcomp.extrude(quotes);\n\
  });\n\
\n\
  return simpcomp;\n\
};\n\
\n\
/**\n\
 * cuboid\n\
 * \n\
 * @param {Array} sideds\n\
 * @return {simplexn.SimplicialComplex} a cuboidal simplicial complex\n\
 * @api public\n\
 */\n\
\n\
simplexn.geometries.cuboid = function (sides) {\n\
  sides = sides.map(function (s) { return [s]; });\n\
  return simplexGrid(sides);\n\
};\n\
\n\
/**\n\
 * intervals\n\
 *\n\
 * @param {Array} values\n\
 * @return {simplexn.SimplicialComplex} intervals\n\
 * @api public\n\
 */\n\
\n\
var intervals = \n\
simplexn.geometries.intervals = function (tip, n) {\n\
  var values = [];\n\
  var value = tip/n;\n\
  \n\
  while (n--) values.push(value);\n\
\n\
  return simplexGrid([values]);\n\
};\n\
\n\
/**\n\
 * domain\n\
 *\n\
 * @param {Array} ends\n\
 * @param {Array} ns\n\
 * @return {simplexn.SimplicialComplex} domain\n\
 * @api public\n\
 */\n\
\n\
var domain = \n\
simplexn.geometries.domain = function (ends, ns) {\n\
  var ends = ends || [0, 2*Math.PI];\n\
  var ns = ns || [36];\n\
  var length = ends.length;\n\
  var endsn = ends[0];\n\
  var begin = endsn[0];\n\
  var end = endsn[1];\n\
  var domain = intervals(end - begin, ns[0]).translate([0], [begin]);\n\
  var values;\n\
  var value;\n\
  var i;\n\
  var n;\n\
\n\
  for (i = 1; i < length; i += 1) {\n\
    endsn = ends[i];\n\
    begin = endsn[0];\n\
    end = endsn[1];\n\
    n = ns[i];\n\
    values = [];\n\
    value = (end - begin)/n;\n\
\n\
    while (n--) values.push(value);\n\
\n\
    domain = domain.extrude(values).translate([i], [begin]);\n\
  }\n\
\n\
  return domain;\n\
};\n\
\n\
/**\n\
 * cube\n\
 * \n\
 * @param {Number} d\n\
 * @return {simplexn.SimplicialComplex} a dim-dimendional cube\n\
 * @api public\n\
 */\n\
\n\
simplexn.geometries.cube = function (d) {\n\
  var d = d || 1;\n\
  var quotes = [];\n\
  while (d--) quotes.push([1]);\n\
  return simplexGrid(quotes);\n\
};\n\
\n\
/**\n\
 * circle\n\
 * \n\
 * @param {Number} [radius=1]\n\
 * @param {Number} [n=32] \n\
 * @return {simplexn.SimplicialComplex} a circle\n\
 * @api public\n\
 */\n\
\n\
simplexn.geometries.circle = function (radius, n) {\n\
  var r = radius || 1;\n\
  var n = n || 32;\n\
  var domain = intervals(2 * pi, n);\n\
  \n\
  domain.map(function (v) { \n\
    return [r * sin(v[0]), r * cos(v[0])]; \n\
  }, true);\n\
\n\
  return domain;\n\
};\n\
\n\
/**\n\
 * disk\n\
 * \n\
 * @param {Number} [radius=1]\n\
 * @param {Number} [n=32]\n\
 * @param {Number} [m=1] \n\
 * @return {simplexn.SimplicialComplex} a disk\n\
 * @api public\n\
 */\n\
\n\
simplexn.geometries.disk = function (radius, n, m) {\n\
  var radius = radius || 1;\n\
  var n = n || 32;\n\
  var m = m || 1;\n\
  var nQuote = 2 * pi / n;\n\
  var mQuote = radius / m;\n\
  var nQuotes = [];\n\
  var mQuotes = [];\n\
  var domain;\n\
\n\
  while (n--) nQuotes.push(nQuote);\n\
  while (m--) mQuotes.push(mQuote);\n\
  domain = simplexGrid([nQuotes,mQuotes]);\n\
  domain.map(function (coords) {\n\
    var u = coords[0];\n\
    var v = coords[1];\n\
    return [v*sin(u), v*cos(u)];\n\
  }, true);\n\
\n\
  return domain;\n\
};\n\
\n\
/**\n\
 * cylinderSurface\n\
 * Produces a cylindrical surface of radius r and heigth h.\n\
 * \n\
 * @param {Number} [r=1]\n\
 * @param {Number} [h=1]\n\
 * @param {Number} [n=16]\n\
 * @param {Number} [m=2] \n\
 * @return {simplexn.SimplicialComplex} a cylindrical surface\n\
 * @api public\n\
 */\n\
simplexn.geometries.cylinderSurface = function (r, h, n, m) {\n\
  var r = r || 1;\n\
  var h = h || 1;\n\
  var n = n || 16;\n\
  var m = m || 2;\n\
  var domain = simplexGrid([_repeat(2*pi/n, n), _repeat(1./m, m)]);\n\
\n\
  domain.map(function(v) {\n\
    return [\n\
      r * cos(v[0])\n\
    , r * sin(v[0])\n\
    , h * v[1]\n\
    ];\n\
  }, true);\n\
\n\
  return domain;\n\
};\n\
\n\
/**\n\
 * cylinderSolid\n\
 * Produces a solid cylindrer with radius r and heigth h.\n\
 *\n\
 * @param {Number} [R=1] \n\
 * @param {Number} [r=0]\n\
 * @param {Number} [h=1]\n\
 * @param {Number} [n=16]\n\
 * @param {Number} [m=1]\n\
 * @param {Number} [p=1] \n\
 * @return {simplexn.SimplicialComplex} a cylinder\n\
 * @api public\n\
 */\n\
\n\
var cilinderSolid =\n\
simplexn.geometries.cylinderSolid = function (R, r, h, n, m, p) {\n\
  var R = R || 1.; \n\
  var r = r || 0.; \n\
  var h = h || 1.;\n\
  var n = n || 16;\n\
  var m = m || 1;\n\
  var p = p || 1; \n\
  var domain = simplexGrid([_repeat(2*pi/n, n), _repeat((R-r)/m, m), _repeat(h/p, p)]);\n\
  \n\
  domain.translate([1],[r]).map(function(v) {\n\
    return [\n\
      v[1] * sin(v[0])\n\
    , v[1] * cos(v[0])\n\
    , v[2]\n\
    ];\n\
  }, true);\n\
\n\
  return domain;\n\
};\n\
\n\
/**\n\
 * torusSurface\n\
 *\n\
 * produces a toroidal surface of radiuses r,R \n\
 * approximated with n x m x 2 triangles\n\
 *\n\
 * @param {Number} [r=1] r\n\
 * @param {Number} [R=3] R\n\
 * @param {Number} [n=12] n\n\
 * @param {Number} [m=8] m\n\
 * @return {simplexn.SimplicialComplex} torus surface\n\
 * @api public\n\
 */\n\
\n\
var torusSurface =\n\
simplexn.geometries.torusSurface = function (r, R, n, m) {\n\
  var r = r || 0.5;\n\
  var R = R || 1.5;\n\
  var n = n || 12;\n\
  var m = m || 8;\n\
  var domain = simplexGrid([ _repeat(2*pi/n, n), _repeat(2*pi/m, m)]);\n\
\n\
  domain.map(function (v) {\n\
    return [\n\
        (R + r * cos(v[1])) * cos(v[0])\n\
      , (R + r * cos(v[1])) * sin(v[0])\n\
      , r * sin(v[1])\n\
    ];\n\
  }, true);\n\
\n\
  return domain;\n\
};\n\
\n\
/**\n\
* torusSolid\n\
*\n\
* produces a toroidal surface of radiuses r,R \n\
* approximated with n x m x 2 triangles\n\
*\n\
* @param {Number} [r=1] r\n\
* @param {Number} [R=3] r\n\
* @param {Number} [n=12] n\n\
* @param {Number} [m=8] m\n\
* @param {Number} [p=8] p\n\
* @return {simplexn.SimplicialComplex} torus solid\n\
* @api public\n\
*/\n\
\n\
var torusSolid = \n\
simplexn.geometries.torusSolid = function (r, R, n, m, p) {\n\
  var r = r || 1;\n\
  var R = R || 3;\n\
  var n = n || 12;\n\
  var m = m || 8;\n\
  var p = p || 2;\n\
  var domain = simplexGrid([ _repeat(2*pi/n, n), _repeat(2*pi/m, m), _repeat(1/pi, p)]);\n\
\n\
  domain.map(function (v) {\n\
    return [\n\
        (R + r * v[2] * cos(v[0])) * cos(v[1])\n\
      , (R + r * v[2] * cos(v[0])) * -sin(v[1])\n\
      , r * v[2] * sin(v[0])\n\
    ];\n\
  }, true);\n\
\n\
  return domain;\n\
};\n\
\n\
/**\n\
 * triangleStrip\n\
 * \n\
 * @param {Array} points\n\
 * @return {simplexn.SimplicialComplex} triangle strip\n\
 * @api public\n\
 */\n\
\n\
var triangleStrip = \n\
simplexn.geometries.triangleStrip = function (points) {\n\
  var n = points.length;\n\
  var cells = [];\n\
  var i;\n\
  \n\
  for (i = 2; i < n; i += 1) {\n\
    if (cells.length & 1) {\n\
      cells.push([i-1, i-2, i-0]);\n\
    }\n\
    else {\n\
      cells.push([i-2, i-1, i-0]);\n\
    }\n\
  }\n\
\n\
  return new SimplicialComplex(points, cells);\n\
};\n\
\n\
\n\
/**\n\
 * triangleFan\n\
 * \n\
 * @param {Array} points\n\
 * @return {simplexn.SimplicialComplex} triangle strip\n\
 * @api public\n\
 */\n\
\n\
var triangleFan = \n\
simplexn.geometries.triangleFan = function (points) {\n\
  var n = points.length;\n\
  var cells = [];\n\
  var i;\n\
  \n\
  for (i = 2; i < n; i += 1) {\n\
    cells.push([0, i-1, i]);\n\
  }\n\
\n\
  return new SimplicialComplex(points, cells);\n\
};\n\
\n\
/**\n\
 * helix\n\
 *\n\
 * @param {Number} [r=1] r\n\
 * @param {Number} [pitch=1] pitch\n\
 * @param {Number} [n=24] n\n\
 * @param {Number} [turns=1] turns\n\
 * @return {simplexn.SimplicialComplex} helix\n\
 * @api public\n\
 */\n\
\n\
var helix = \n\
simplexn.geometries.helix = function (r, pitch, n, turns) {\n\
  var r = r || 1;\n\
  var pitch = pitch || 1;\n\
  var n = n || 24;\n\
  var turns = turns || 8;\n\
  var domain = intervals(2*pi*turns, n*turns);\n\
\n\
  domain.map(function (v) {\n\
    return [\n\
        r * sin(v[0])\n\
      , r * cos(v[0])\n\
      , pitch / (2*pi) * v[0]\n\
    ];\n\
  }, true);\n\
\n\
  return domain;\n\
};\n\
\n\
/**\n\
 * triangleDomain\n\
 * \n\
 * @param {n} subdivisions\n\
 * @param {Array} points\n\
 * @return {simplexn.SimplicialComplex} triangleDomain\n\
 * @api public\n\
 */\n\
\n\
var triangleDomain = \n\
simplexn.geometries.triangleDomain = function (n, points) {\n\
  \n\
  var pa = points[0];\n\
  var pb = points[1];\n\
  var pc = points[2];\n\
\n\
  var net = [];\n\
  var cells = [];\n\
\n\
  var x;\n\
  var y;\n\
\n\
  for (i = 0; i <= n; i += 1) {net.push([pa[0] + i * (pb[0] - pa[0]) / n, pa[1] + i * (pb[1] - pa[1]) / n, pa[2] + i * (pb[2] - pa[2]) / n]);};\n\
\n\
  for  (y = 1; y <= n; y += 1) {\n\
    var r0 = (y - 1) * (n + 2) - (y - 1) * y / 2;\n\
    var r1 = y * (n + 2) - y * (y + 1) / 2; \n\
    for (x = 0; x <= n - y; x += 1) {\n\
      var c0 = r0 + x;\n\
      var c1 = r1 + x;\n\
      net.push([pa[0] + x * (pb[0] - pa[0]) / n + y * (pc[0] - pa[0]) / n, pa[1] + x * (pb[1] - pa[1]) / n + y * (pc[1] - pa[1]) / n, pa[2] + x * (pb[2] - pa[2]) / n + y * (pc[2] - pa[2]) / n]);\n\
      if (x > 0) {cells.push([c1, c0, c1 - 1]);};\n\
      cells.push([c1, c0 + 1, c0]);\n\
    };\n\
  };\n\
\n\
  return new SimplicialComplex(net, cells);\n\
};//@ sourceURL=cvdlab-simplexn/index.js"
));
require.register("cvdlab-three/index.js", Function("exports, require, module",
"/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author Larry Battle / http://bateru.com/news\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
var THREE = exports; \n\
\n\
THREE.REVISION = '60';\n\
\n\
self.console = self.console || {\n\
\n\
\tinfo: function () {},\n\
\tlog: function () {},\n\
\tdebug: function () {},\n\
\twarn: function () {},\n\
\terror: function () {}\n\
\n\
};\n\
\n\
String.prototype.trim = String.prototype.trim || function () {\n\
\n\
\treturn this.replace( /^\\s+|\\s+$/g, '' );\n\
\n\
};\n\
\n\
// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767\n\
THREE.extend = function ( obj, source ) {\n\
\n\
\t// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/\n\
\tif ( Object.keys ) {\n\
\n\
\t\tvar keys = Object.keys( source );\n\
\n\
\t\tfor (var i = 0, il = keys.length; i < il; i++) {\n\
\n\
\t\t\tvar prop = keys[i];\n\
\t\t\tObject.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );\n\
\n\
\t\t}\n\
\n\
\t} else {\n\
\n\
\t\tvar safeHasOwnProperty = {}.hasOwnProperty;\n\
\n\
\t\tfor ( var prop in source ) {\n\
\n\
\t\t\tif ( safeHasOwnProperty.call( source, prop ) ) {\n\
\n\
\t\t\t\tobj[prop] = source[prop];\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\treturn obj;\n\
\n\
};\n\
\n\
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n\
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\
\n\
// requestAnimationFrame polyfill by Erik Möller\n\
// fixes from Paul Irish and Tino Zijdel\n\
// using 'self' instead of 'window' for compatibility with both NodeJS and IE10.\n\
( function () {\n\
\n\
\tvar lastTime = 0;\n\
\tvar vendors = [ 'ms', 'moz', 'webkit', 'o' ];\n\
\n\
\tfor ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++ x ) {\n\
\n\
\t\tself.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];\n\
\t\tself.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];\n\
\n\
\t}\n\
\n\
\tif ( self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined ) {\n\
\n\
\t\tself.requestAnimationFrame = function ( callback ) {\n\
\n\
\t\t\tvar currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\n\
\t\t\tvar id = self.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );\n\
\t\t\tlastTime = currTime + timeToCall;\n\
\t\t\treturn id;\n\
\n\
\t\t};\n\
\n\
\t}\n\
\n\
\tif( self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined ) {\n\
\n\
\t\tself.cancelAnimationFrame = function ( id ) { self.clearTimeout( id ) };\n\
\n\
\t}\n\
\n\
}() );\n\
\n\
// GL STATE CONSTANTS\n\
\n\
THREE.CullFaceNone = 0;\n\
THREE.CullFaceBack = 1;\n\
THREE.CullFaceFront = 2;\n\
THREE.CullFaceFrontBack = 3;\n\
\n\
THREE.FrontFaceDirectionCW = 0;\n\
THREE.FrontFaceDirectionCCW = 1;\n\
\n\
// SHADOWING TYPES\n\
\n\
THREE.BasicShadowMap = 0;\n\
THREE.PCFShadowMap = 1;\n\
THREE.PCFSoftShadowMap = 2;\n\
\n\
// MATERIAL CONSTANTS\n\
\n\
// side\n\
\n\
THREE.FrontSide = 0;\n\
THREE.BackSide = 1;\n\
THREE.DoubleSide = 2;\n\
\n\
// shading\n\
\n\
THREE.NoShading = 0;\n\
THREE.FlatShading = 1;\n\
THREE.SmoothShading = 2;\n\
\n\
// colors\n\
\n\
THREE.NoColors = 0;\n\
THREE.FaceColors = 1;\n\
THREE.VertexColors = 2;\n\
\n\
// blending modes\n\
\n\
THREE.NoBlending = 0;\n\
THREE.NormalBlending = 1;\n\
THREE.AdditiveBlending = 2;\n\
THREE.SubtractiveBlending = 3;\n\
THREE.MultiplyBlending = 4;\n\
THREE.CustomBlending = 5;\n\
\n\
// custom blending equations\n\
// (numbers start from 100 not to clash with other\n\
//  mappings to OpenGL constants defined in Texture.js)\n\
\n\
THREE.AddEquation = 100;\n\
THREE.SubtractEquation = 101;\n\
THREE.ReverseSubtractEquation = 102;\n\
\n\
// custom blending destination factors\n\
\n\
THREE.ZeroFactor = 200;\n\
THREE.OneFactor = 201;\n\
THREE.SrcColorFactor = 202;\n\
THREE.OneMinusSrcColorFactor = 203;\n\
THREE.SrcAlphaFactor = 204;\n\
THREE.OneMinusSrcAlphaFactor = 205;\n\
THREE.DstAlphaFactor = 206;\n\
THREE.OneMinusDstAlphaFactor = 207;\n\
\n\
// custom blending source factors\n\
\n\
//THREE.ZeroFactor = 200;\n\
//THREE.OneFactor = 201;\n\
//THREE.SrcAlphaFactor = 204;\n\
//THREE.OneMinusSrcAlphaFactor = 205;\n\
//THREE.DstAlphaFactor = 206;\n\
//THREE.OneMinusDstAlphaFactor = 207;\n\
THREE.DstColorFactor = 208;\n\
THREE.OneMinusDstColorFactor = 209;\n\
THREE.SrcAlphaSaturateFactor = 210;\n\
\n\
\n\
// TEXTURE CONSTANTS\n\
\n\
THREE.MultiplyOperation = 0;\n\
THREE.MixOperation = 1;\n\
THREE.AddOperation = 2;\n\
\n\
// Mapping modes\n\
\n\
THREE.UVMapping = function () {};\n\
\n\
THREE.CubeReflectionMapping = function () {};\n\
THREE.CubeRefractionMapping = function () {};\n\
\n\
THREE.SphericalReflectionMapping = function () {};\n\
THREE.SphericalRefractionMapping = function () {};\n\
\n\
// Wrapping modes\n\
\n\
THREE.RepeatWrapping = 1000;\n\
THREE.ClampToEdgeWrapping = 1001;\n\
THREE.MirroredRepeatWrapping = 1002;\n\
\n\
// Filters\n\
\n\
THREE.NearestFilter = 1003;\n\
THREE.NearestMipMapNearestFilter = 1004;\n\
THREE.NearestMipMapLinearFilter = 1005;\n\
THREE.LinearFilter = 1006;\n\
THREE.LinearMipMapNearestFilter = 1007;\n\
THREE.LinearMipMapLinearFilter = 1008;\n\
\n\
// Data types\n\
\n\
THREE.UnsignedByteType = 1009;\n\
THREE.ByteType = 1010;\n\
THREE.ShortType = 1011;\n\
THREE.UnsignedShortType = 1012;\n\
THREE.IntType = 1013;\n\
THREE.UnsignedIntType = 1014;\n\
THREE.FloatType = 1015;\n\
\n\
// Pixel types\n\
\n\
//THREE.UnsignedByteType = 1009;\n\
THREE.UnsignedShort4444Type = 1016;\n\
THREE.UnsignedShort5551Type = 1017;\n\
THREE.UnsignedShort565Type = 1018;\n\
\n\
// Pixel formats\n\
\n\
THREE.AlphaFormat = 1019;\n\
THREE.RGBFormat = 1020;\n\
THREE.RGBAFormat = 1021;\n\
THREE.LuminanceFormat = 1022;\n\
THREE.LuminanceAlphaFormat = 1023;\n\
\n\
// Compressed texture formats\n\
\n\
THREE.RGB_S3TC_DXT1_Format = 2001;\n\
THREE.RGBA_S3TC_DXT1_Format = 2002;\n\
THREE.RGBA_S3TC_DXT3_Format = 2003;\n\
THREE.RGBA_S3TC_DXT5_Format = 2004;\n\
\n\
/*\n\
// Potential future PVRTC compressed texture formats\n\
THREE.RGB_PVRTC_4BPPV1_Format = 2100;\n\
THREE.RGB_PVRTC_2BPPV1_Format = 2101;\n\
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;\n\
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;\n\
*/\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.Color = function ( value ) {\n\
\n\
\tif ( value !== undefined ) this.set( value );\n\
\n\
\treturn this;\n\
\n\
};\n\
\n\
THREE.Color.prototype = {\n\
\n\
\tconstructor: THREE.Color,\n\
\n\
\tr: 1, g: 1, b: 1,\n\
\n\
\tset: function ( value ) {\n\
\n\
\t\tif ( value instanceof THREE.Color ) {\n\
\n\
\t\t\tthis.copy( value );\n\
\n\
\t\t} else if ( typeof value === 'number' ) {\n\
\n\
\t\t\tthis.setHex( value );\n\
\n\
\t\t} else if ( typeof value === 'string' ) {\n\
\n\
\t\t\tthis.setStyle( value );\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetHex: function ( hex ) {\n\
\n\
\t\thex = Math.floor( hex );\n\
\n\
\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\
\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\
\t\tthis.b = ( hex & 255 ) / 255;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetRGB: function ( r, g, b ) {\n\
\n\
\t\tthis.r = r;\n\
\t\tthis.g = g;\n\
\t\tthis.b = b;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetHSL: function ( h, s, l ) {\n\
\n\
\t\t// h,s,l ranges are in 0.0 - 1.0\n\
\n\
\t\tif ( s === 0 ) {\n\
\n\
\t\t\tthis.r = this.g = this.b = l;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tvar hue2rgb = function ( p, q, t ) {\n\
\n\
\t\t\t\tif ( t < 0 ) t += 1;\n\
\t\t\t\tif ( t > 1 ) t -= 1;\n\
\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\
\t\t\t\tif ( t < 1 / 2 ) return q;\n\
\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\
\t\t\t\treturn p;\n\
\n\
\t\t\t};\n\
\n\
\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\
\t\t\tvar q = ( 2 * l ) - p;\n\
\n\
\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\
\t\t\tthis.g = hue2rgb( q, p, h );\n\
\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetStyle: function ( style ) {\n\
\n\
\t\t// rgb(255,0,0)\n\
\n\
\t\tif ( /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.test( style ) ) {\n\
\n\
\t\t\tvar color = /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.exec( style );\n\
\n\
\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\
\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\
\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t}\n\
\n\
\t\t// rgb(100%,0%,0%)\n\
\n\
\t\tif ( /^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.test( style ) ) {\n\
\n\
\t\t\tvar color = /^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.exec( style );\n\
\n\
\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\
\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\
\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t}\n\
\n\
\t\t// #ff0000\n\
\n\
\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\n\
\n\
\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\n\
\n\
\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t}\n\
\n\
\t\t// #f00\n\
\n\
\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\n\
\n\
\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\n\
\n\
\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t}\n\
\n\
\t\t// red\n\
\n\
\t\tif ( /^(\\w+)$/i.test( style ) ) {\n\
\n\
\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t}\n\
\n\
\n\
\t},\n\
\n\
\tcopy: function ( color ) {\n\
\n\
\t\tthis.r = color.r;\n\
\t\tthis.g = color.g;\n\
\t\tthis.b = color.b;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcopyGammaToLinear: function ( color ) {\n\
\n\
\t\tthis.r = color.r * color.r;\n\
\t\tthis.g = color.g * color.g;\n\
\t\tthis.b = color.b * color.b;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcopyLinearToGamma: function ( color ) {\n\
\n\
\t\tthis.r = Math.sqrt( color.r );\n\
\t\tthis.g = Math.sqrt( color.g );\n\
\t\tthis.b = Math.sqrt( color.b );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tconvertGammaToLinear: function () {\n\
\n\
\t\tvar r = this.r, g = this.g, b = this.b;\n\
\n\
\t\tthis.r = r * r;\n\
\t\tthis.g = g * g;\n\
\t\tthis.b = b * b;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tconvertLinearToGamma: function () {\n\
\n\
\t\tthis.r = Math.sqrt( this.r );\n\
\t\tthis.g = Math.sqrt( this.g );\n\
\t\tthis.b = Math.sqrt( this.b );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tgetHex: function () {\n\
\n\
\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\
\n\
\t},\n\
\n\
\tgetHexString: function () {\n\
\n\
\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\
\n\
\t},\n\
\n\
\tgetHSL: function () {\n\
\n\
\t\tvar hsl = { h: 0, s: 0, l: 0 };\n\
\n\
\t\treturn function () {\n\
\n\
\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\
\n\
\t\t\tvar r = this.r, g = this.g, b = this.b;\n\
\n\
\t\t\tvar max = Math.max( r, g, b );\n\
\t\t\tvar min = Math.min( r, g, b );\n\
\n\
\t\t\tvar hue, saturation;\n\
\t\t\tvar lightness = ( min + max ) / 2.0;\n\
\n\
\t\t\tif ( min === max ) {\n\
\n\
\t\t\t\thue = 0;\n\
\t\t\t\tsaturation = 0;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tvar delta = max - min;\n\
\n\
\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\
\n\
\t\t\t\tswitch ( max ) {\n\
\n\
\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\
\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\
\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\thue /= 6;\n\
\n\
\t\t\t}\n\
\n\
\t\t\thsl.h = hue;\n\
\t\t\thsl.s = saturation;\n\
\t\t\thsl.l = lightness;\n\
\n\
\t\t\treturn hsl;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tgetStyle: function () {\n\
\n\
\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\
\n\
\t},\n\
\n\
\toffsetHSL: function ( h, s, l ) {\n\
\n\
\t\tvar hsl = this.getHSL();\n\
\n\
\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\
\n\
\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tadd: function ( color ) {\n\
\n\
\t\tthis.r += color.r;\n\
\t\tthis.g += color.g;\n\
\t\tthis.b += color.b;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\taddColors: function ( color1, color2 ) {\n\
\n\
\t\tthis.r = color1.r + color2.r;\n\
\t\tthis.g = color1.g + color2.g;\n\
\t\tthis.b = color1.b + color2.b;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\taddScalar: function ( s ) {\n\
\n\
\t\tthis.r += s;\n\
\t\tthis.g += s;\n\
\t\tthis.b += s;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiply: function ( color ) {\n\
\n\
\t\tthis.r *= color.r;\n\
\t\tthis.g *= color.g;\n\
\t\tthis.b *= color.b;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiplyScalar: function ( s ) {\n\
\n\
\t\tthis.r *= s;\n\
\t\tthis.g *= s;\n\
\t\tthis.b *= s;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tlerp: function ( color, alpha ) {\n\
\n\
\t\tthis.r += ( color.r - this.r ) * alpha;\n\
\t\tthis.g += ( color.g - this.g ) * alpha;\n\
\t\tthis.b += ( color.b - this.b ) * alpha;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tequals: function ( c ) {\n\
\n\
\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\
\n\
\t},\n\
\n\
\tfromArray: function ( array ) {\n\
\n\
\t\tthis.r = array[ 0 ];\n\
\t\tthis.g = array[ 1 ];\n\
\t\tthis.b = array[ 2 ];\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttoArray: function () {\n\
\n\
\t\treturn [ this.r, this.g, this.b ];\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.ColorKeywords = { \"aliceblue\": 0xF0F8FF, \"antiquewhite\": 0xFAEBD7, \"aqua\": 0x00FFFF, \"aquamarine\": 0x7FFFD4, \"azure\": 0xF0FFFF,\n\
\"beige\": 0xF5F5DC, \"bisque\": 0xFFE4C4, \"black\": 0x000000, \"blanchedalmond\": 0xFFEBCD, \"blue\": 0x0000FF, \"blueviolet\": 0x8A2BE2,\n\
\"brown\": 0xA52A2A, \"burlywood\": 0xDEB887, \"cadetblue\": 0x5F9EA0, \"chartreuse\": 0x7FFF00, \"chocolate\": 0xD2691E, \"coral\": 0xFF7F50,\n\
\"cornflowerblue\": 0x6495ED, \"cornsilk\": 0xFFF8DC, \"crimson\": 0xDC143C, \"cyan\": 0x00FFFF, \"darkblue\": 0x00008B, \"darkcyan\": 0x008B8B,\n\
\"darkgoldenrod\": 0xB8860B, \"darkgray\": 0xA9A9A9, \"darkgreen\": 0x006400, \"darkgrey\": 0xA9A9A9, \"darkkhaki\": 0xBDB76B, \"darkmagenta\": 0x8B008B,\n\
\"darkolivegreen\": 0x556B2F, \"darkorange\": 0xFF8C00, \"darkorchid\": 0x9932CC, \"darkred\": 0x8B0000, \"darksalmon\": 0xE9967A, \"darkseagreen\": 0x8FBC8F,\n\
\"darkslateblue\": 0x483D8B, \"darkslategray\": 0x2F4F4F, \"darkslategrey\": 0x2F4F4F, \"darkturquoise\": 0x00CED1, \"darkviolet\": 0x9400D3,\n\
\"deeppink\": 0xFF1493, \"deepskyblue\": 0x00BFFF, \"dimgray\": 0x696969, \"dimgrey\": 0x696969, \"dodgerblue\": 0x1E90FF, \"firebrick\": 0xB22222,\n\
\"floralwhite\": 0xFFFAF0, \"forestgreen\": 0x228B22, \"fuchsia\": 0xFF00FF, \"gainsboro\": 0xDCDCDC, \"ghostwhite\": 0xF8F8FF, \"gold\": 0xFFD700,\n\
\"goldenrod\": 0xDAA520, \"gray\": 0x808080, \"green\": 0x008000, \"greenyellow\": 0xADFF2F, \"grey\": 0x808080, \"honeydew\": 0xF0FFF0, \"hotpink\": 0xFF69B4,\n\
\"indianred\": 0xCD5C5C, \"indigo\": 0x4B0082, \"ivory\": 0xFFFFF0, \"khaki\": 0xF0E68C, \"lavender\": 0xE6E6FA, \"lavenderblush\": 0xFFF0F5, \"lawngreen\": 0x7CFC00,\n\
\"lemonchiffon\": 0xFFFACD, \"lightblue\": 0xADD8E6, \"lightcoral\": 0xF08080, \"lightcyan\": 0xE0FFFF, \"lightgoldenrodyellow\": 0xFAFAD2, \"lightgray\": 0xD3D3D3,\n\
\"lightgreen\": 0x90EE90, \"lightgrey\": 0xD3D3D3, \"lightpink\": 0xFFB6C1, \"lightsalmon\": 0xFFA07A, \"lightseagreen\": 0x20B2AA, \"lightskyblue\": 0x87CEFA,\n\
\"lightslategray\": 0x778899, \"lightslategrey\": 0x778899, \"lightsteelblue\": 0xB0C4DE, \"lightyellow\": 0xFFFFE0, \"lime\": 0x00FF00, \"limegreen\": 0x32CD32,\n\
\"linen\": 0xFAF0E6, \"magenta\": 0xFF00FF, \"maroon\": 0x800000, \"mediumaquamarine\": 0x66CDAA, \"mediumblue\": 0x0000CD, \"mediumorchid\": 0xBA55D3,\n\
\"mediumpurple\": 0x9370DB, \"mediumseagreen\": 0x3CB371, \"mediumslateblue\": 0x7B68EE, \"mediumspringgreen\": 0x00FA9A, \"mediumturquoise\": 0x48D1CC,\n\
\"mediumvioletred\": 0xC71585, \"midnightblue\": 0x191970, \"mintcream\": 0xF5FFFA, \"mistyrose\": 0xFFE4E1, \"moccasin\": 0xFFE4B5, \"navajowhite\": 0xFFDEAD,\n\
\"navy\": 0x000080, \"oldlace\": 0xFDF5E6, \"olive\": 0x808000, \"olivedrab\": 0x6B8E23, \"orange\": 0xFFA500, \"orangered\": 0xFF4500, \"orchid\": 0xDA70D6,\n\
\"palegoldenrod\": 0xEEE8AA, \"palegreen\": 0x98FB98, \"paleturquoise\": 0xAFEEEE, \"palevioletred\": 0xDB7093, \"papayawhip\": 0xFFEFD5, \"peachpuff\": 0xFFDAB9,\n\
\"peru\": 0xCD853F, \"pink\": 0xFFC0CB, \"plum\": 0xDDA0DD, \"powderblue\": 0xB0E0E6, \"purple\": 0x800080, \"red\": 0xFF0000, \"rosybrown\": 0xBC8F8F,\n\
\"royalblue\": 0x4169E1, \"saddlebrown\": 0x8B4513, \"salmon\": 0xFA8072, \"sandybrown\": 0xF4A460, \"seagreen\": 0x2E8B57, \"seashell\": 0xFFF5EE,\n\
\"sienna\": 0xA0522D, \"silver\": 0xC0C0C0, \"skyblue\": 0x87CEEB, \"slateblue\": 0x6A5ACD, \"slategray\": 0x708090, \"slategrey\": 0x708090, \"snow\": 0xFFFAFA,\n\
\"springgreen\": 0x00FF7F, \"steelblue\": 0x4682B4, \"tan\": 0xD2B48C, \"teal\": 0x008080, \"thistle\": 0xD8BFD8, \"tomato\": 0xFF6347, \"turquoise\": 0x40E0D0,\n\
\"violet\": 0xEE82EE, \"wheat\": 0xF5DEB3, \"white\": 0xFFFFFF, \"whitesmoke\": 0xF5F5F5, \"yellow\": 0xFFFF00, \"yellowgreen\": 0x9ACD32 };\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
THREE.Quaternion = function ( x, y, z, w ) {\n\
\n\
\tthis._x = x || 0;\n\
\tthis._y = y || 0;\n\
\tthis._z = z || 0;\n\
\tthis._w = ( w !== undefined ) ? w : 1;\n\
\n\
};\n\
\n\
THREE.Quaternion.prototype = {\n\
\n\
\tconstructor: THREE.Quaternion,\n\
\n\
\t_x: 0,_y: 0, _z: 0, _w: 0,\n\
\n\
\t_euler: undefined,\n\
\n\
\t_updateEuler: function ( callback ) {\n\
\n\
\t\tif ( this._euler !== undefined ) {\n\
\n\
\t\t\tthis._euler.setFromQuaternion( this, undefined, false );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tget x () {\n\
\n\
\t\treturn this._x;\n\
\n\
\t},\n\
\n\
\tset x ( value ) {\n\
\n\
\t\tthis._x = value;\n\
\t\tthis._updateEuler();\n\
\n\
\t},\n\
\n\
\tget y () {\n\
\n\
\t\treturn this._y;\n\
\n\
\t},\n\
\n\
\tset y ( value ) {\n\
\n\
\t\tthis._y = value;\n\
\t\tthis._updateEuler();\n\
\n\
\t},\n\
\n\
\tget z () {\n\
\n\
\t\treturn this._z;\n\
\n\
\t},\n\
\n\
\tset z ( value ) {\n\
\n\
\t\tthis._z = value;\n\
\t\tthis._updateEuler();\n\
\n\
\t},\n\
\n\
\tget w () {\n\
\n\
\t\treturn this._w;\n\
\n\
\t},\n\
\n\
\tset w ( value ) {\n\
\n\
\t\tthis._w = value;\n\
\t\tthis._updateEuler();\n\
\n\
\t},\n\
\n\
\tset: function ( x, y, z, w ) {\n\
\n\
\t\tthis._x = x;\n\
\t\tthis._y = y;\n\
\t\tthis._z = z;\n\
\t\tthis._w = w;\n\
\n\
\t\tthis._updateEuler();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcopy: function ( quaternion ) {\n\
\n\
\t\tthis._x = quaternion._x;\n\
\t\tthis._y = quaternion._y;\n\
\t\tthis._z = quaternion._z;\n\
\t\tthis._w = quaternion._w;\n\
\n\
\t\tthis._updateEuler();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromEuler: function ( euler, update ) {\n\
\n\
\t\tif ( euler instanceof THREE.Euler === false ) {\n\
\n\
\t\t\tthrow new Error( 'ERROR: Quaternion\\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );\n\
\t\t}\n\
\n\
\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\
\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\
\t\t//\tcontent/SpinCalc.m\n\
\n\
\t\tvar c1 = Math.cos( euler._x / 2 );\n\
\t\tvar c2 = Math.cos( euler._y / 2 );\n\
\t\tvar c3 = Math.cos( euler._z / 2 );\n\
\t\tvar s1 = Math.sin( euler._x / 2 );\n\
\t\tvar s2 = Math.sin( euler._y / 2 );\n\
\t\tvar s3 = Math.sin( euler._z / 2 );\n\
\n\
\t\tif ( euler.order === 'XYZ' ) {\n\
\n\
\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\
\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\
\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\
\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\
\n\
\t\t} else if ( euler.order === 'YXZ' ) {\n\
\n\
\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\
\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\
\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\
\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\
\n\
\t\t} else if ( euler.order === 'ZXY' ) {\n\
\n\
\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\
\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\
\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\
\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\
\n\
\t\t} else if ( euler.order === 'ZYX' ) {\n\
\n\
\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\
\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\
\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\
\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\
\n\
\t\t} else if ( euler.order === 'YZX' ) {\n\
\n\
\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\
\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\
\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\
\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\
\n\
\t\t} else if ( euler.order === 'XZY' ) {\n\
\n\
\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\
\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\
\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\
\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\
\n\
\t\t}\n\
\n\
\t\tif ( update !== false ) this._updateEuler();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromAxisAngle: function ( axis, angle ) {\n\
\n\
\t\t// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\
\t\t// axis have to be normalized\n\
\n\
\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\
\n\
\t\tthis._x = axis.x * s;\n\
\t\tthis._y = axis.y * s;\n\
\t\tthis._z = axis.z * s;\n\
\t\tthis._w = Math.cos( halfAngle );\n\
\n\
\t\tthis._updateEuler();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromRotationMatrix: function ( m ) {\n\
\n\
\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\
\n\
\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\
\n\
\t\tvar te = m.elements,\n\
\n\
\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\n\
\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\n\
\t\t\tm31 = te[2], m32 = te[6], m33 = te[10],\n\
\n\
\t\t\ttrace = m11 + m22 + m33,\n\
\t\t\ts;\n\
\n\
\t\tif ( trace > 0 ) {\n\
\n\
\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\
\n\
\t\t\tthis._w = 0.25 / s;\n\
\t\t\tthis._x = ( m32 - m23 ) * s;\n\
\t\t\tthis._y = ( m13 - m31 ) * s;\n\
\t\t\tthis._z = ( m21 - m12 ) * s;\n\
\n\
\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\
\n\
\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\
\n\
\t\t\tthis._w = (m32 - m23 ) / s;\n\
\t\t\tthis._x = 0.25 * s;\n\
\t\t\tthis._y = (m12 + m21 ) / s;\n\
\t\t\tthis._z = (m13 + m31 ) / s;\n\
\n\
\t\t} else if ( m22 > m33 ) {\n\
\n\
\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\
\n\
\t\t\tthis._w = (m13 - m31 ) / s;\n\
\t\t\tthis._x = (m12 + m21 ) / s;\n\
\t\t\tthis._y = 0.25 * s;\n\
\t\t\tthis._z = (m23 + m32 ) / s;\n\
\n\
\t\t} else {\n\
\n\
\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\
\n\
\t\t\tthis._w = ( m21 - m12 ) / s;\n\
\t\t\tthis._x = ( m13 + m31 ) / s;\n\
\t\t\tthis._y = ( m23 + m32 ) / s;\n\
\t\t\tthis._z = 0.25 * s;\n\
\n\
\t\t}\n\
\n\
\t\tthis._updateEuler();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tinverse: function () {\n\
\n\
\t\tthis.conjugate().normalize();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tconjugate: function () {\n\
\n\
\t\tthis._x *= -1;\n\
\t\tthis._y *= -1;\n\
\t\tthis._z *= -1;\n\
\n\
\t\tthis._updateEuler();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tlengthSq: function () {\n\
\n\
\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\
\n\
\t},\n\
\n\
\tlength: function () {\n\
\n\
\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\
\n\
\t},\n\
\n\
\tnormalize: function () {\n\
\n\
\t\tvar l = this.length();\n\
\n\
\t\tif ( l === 0 ) {\n\
\n\
\t\t\tthis._x = 0;\n\
\t\t\tthis._y = 0;\n\
\t\t\tthis._z = 0;\n\
\t\t\tthis._w = 1;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tl = 1 / l;\n\
\n\
\t\t\tthis._x = this._x * l;\n\
\t\t\tthis._y = this._y * l;\n\
\t\t\tthis._z = this._z * l;\n\
\t\t\tthis._w = this._w * l;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiply: function ( q, p ) {\n\
\n\
\t\tif ( p !== undefined ) {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\
\t\t\treturn this.multiplyQuaternions( q, p );\n\
\n\
\t\t}\n\
\n\
\t\treturn this.multiplyQuaternions( this, q );\n\
\n\
\t},\n\
\n\
\tmultiplyQuaternions: function ( a, b ) {\n\
\n\
\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\
\n\
\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\
\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\
\n\
\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\
\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\
\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\
\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\
\n\
\t\tthis._updateEuler();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiplyVector3: function ( vector ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\
\t\treturn vector.applyQuaternion( this );\n\
\n\
\t},\n\
\n\
\tslerp: function ( qb, t ) {\n\
\n\
\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\
\n\
\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\
\n\
\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\
\n\
\t\tif ( cosHalfTheta < 0 ) {\n\
\n\
\t\t\tthis._w = -qb._w;\n\
\t\t\tthis._x = -qb._x;\n\
\t\t\tthis._y = -qb._y;\n\
\t\t\tthis._z = -qb._z;\n\
\n\
\t\t\tcosHalfTheta = -cosHalfTheta;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tthis.copy( qb );\n\
\n\
\t\t}\n\
\n\
\t\tif ( cosHalfTheta >= 1.0 ) {\n\
\n\
\t\t\tthis._w = w;\n\
\t\t\tthis._x = x;\n\
\t\t\tthis._y = y;\n\
\t\t\tthis._z = z;\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t}\n\
\n\
\t\tvar halfTheta = Math.acos( cosHalfTheta );\n\
\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\
\n\
\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\
\n\
\t\t\tthis._w = 0.5 * ( w + this._w );\n\
\t\t\tthis._x = 0.5 * ( x + this._x );\n\
\t\t\tthis._y = 0.5 * ( y + this._y );\n\
\t\t\tthis._z = 0.5 * ( z + this._z );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t}\n\
\n\
\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\
\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\
\n\
\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\
\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\
\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\
\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\
\n\
\t\tthis._updateEuler();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tequals: function ( quaternion ) {\n\
\n\
\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\
\n\
\t},\n\
\n\
\tfromArray: function ( array ) {\n\
\n\
\t\tthis._x = array[ 0 ];\n\
\t\tthis._y = array[ 1 ];\n\
\t\tthis._z = array[ 2 ];\n\
\t\tthis._w = array[ 3 ];\n\
\n\
\t\tthis._updateEuler();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttoArray: function () {\n\
\n\
\t\treturn [ this._x, this._y, this._z, this._w ];\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Quaternion( this._x, this._y, this._z, this._w );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\n\
\n\
\treturn qm.copy( qa ).slerp( qb, t );\n\
\n\
}\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author philogb / http://blog.thejit.org/\n\
 * @author egraether / http://egraether.com/\n\
 * @author zz85 / http://www.lab4games.net/zz85/blog\n\
 */\n\
\n\
THREE.Vector2 = function ( x, y ) {\n\
\n\
\tthis.x = x || 0;\n\
\tthis.y = y || 0;\n\
\n\
};\n\
\n\
THREE.Vector2.prototype = {\n\
\n\
\tconstructor: THREE.Vector2,\n\
\n\
\tset: function ( x, y ) {\n\
\n\
\t\tthis.x = x;\n\
\t\tthis.y = y;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetX: function ( x ) {\n\
\n\
\t\tthis.x = x;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetY: function ( y ) {\n\
\n\
\t\tthis.y = y;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\n\
\tsetComponent: function ( index, value ) {\n\
\n\
\t\tswitch ( index ) {\n\
\n\
\t\t\tcase 0: this.x = value; break;\n\
\t\t\tcase 1: this.y = value; break;\n\
\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tgetComponent: function ( index ) {\n\
\n\
\t\tswitch ( index ) {\n\
\n\
\t\t\tcase 0: return this.x;\n\
\t\t\tcase 1: return this.y;\n\
\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcopy: function ( v ) {\n\
\n\
\t\tthis.x = v.x;\n\
\t\tthis.y = v.y;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tadd: function ( v, w ) {\n\
\n\
\t\tif ( w !== undefined ) {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\
\t\t\treturn this.addVectors( v, w );\n\
\n\
\t\t}\n\
\n\
\t\tthis.x += v.x;\n\
\t\tthis.y += v.y;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\taddVectors: function ( a, b ) {\n\
\n\
\t\tthis.x = a.x + b.x;\n\
\t\tthis.y = a.y + b.y;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\taddScalar: function ( s ) {\n\
\n\
\t\tthis.x += s;\n\
\t\tthis.y += s;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsub: function ( v, w ) {\n\
\n\
\t\tif ( w !== undefined ) {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\
\t\t\treturn this.subVectors( v, w );\n\
\n\
\t\t}\n\
\n\
\t\tthis.x -= v.x;\n\
\t\tthis.y -= v.y;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsubVectors: function ( a, b ) {\n\
\n\
\t\tthis.x = a.x - b.x;\n\
\t\tthis.y = a.y - b.y;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiplyScalar: function ( s ) {\n\
\n\
\t\tthis.x *= s;\n\
\t\tthis.y *= s;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tdivideScalar: function ( scalar ) {\n\
\n\
\t\tif ( scalar !== 0 ) {\n\
\n\
\t\t\tvar invScalar = 1 / scalar;\n\
\n\
\t\t\tthis.x *= invScalar;\n\
\t\t\tthis.y *= invScalar;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tthis.x = 0;\n\
\t\t\tthis.y = 0;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmin: function ( v ) {\n\
\n\
\t\tif ( this.x > v.x ) {\n\
\n\
\t\t\tthis.x = v.x;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.y > v.y ) {\n\
\n\
\t\t\tthis.y = v.y;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmax: function ( v ) {\n\
\n\
\t\tif ( this.x < v.x ) {\n\
\n\
\t\t\tthis.x = v.x;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.y < v.y ) {\n\
\n\
\t\t\tthis.y = v.y;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tclamp: function ( min, max ) {\n\
\n\
\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\
\n\
\t\tif ( this.x < min.x ) {\n\
\n\
\t\t\tthis.x = min.x;\n\
\n\
\t\t} else if ( this.x > max.x ) {\n\
\n\
\t\t\tthis.x = max.x;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.y < min.y ) {\n\
\n\
\t\t\tthis.y = min.y;\n\
\n\
\t\t} else if ( this.y > max.y ) {\n\
\n\
\t\t\tthis.y = max.y;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tnegate: function() {\n\
\n\
\t\treturn this.multiplyScalar( - 1 );\n\
\n\
\t},\n\
\n\
\tdot: function ( v ) {\n\
\n\
\t\treturn this.x * v.x + this.y * v.y;\n\
\n\
\t},\n\
\n\
\tlengthSq: function () {\n\
\n\
\t\treturn this.x * this.x + this.y * this.y;\n\
\n\
\t},\n\
\n\
\tlength: function () {\n\
\n\
\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\
\n\
\t},\n\
\n\
\tnormalize: function () {\n\
\n\
\t\treturn this.divideScalar( this.length() );\n\
\n\
\t},\n\
\n\
\tdistanceTo: function ( v ) {\n\
\n\
\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\
\n\
\t},\n\
\n\
\tdistanceToSquared: function ( v ) {\n\
\n\
\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\
\t\treturn dx * dx + dy * dy;\n\
\n\
\t},\n\
\n\
\tsetLength: function ( l ) {\n\
\n\
\t\tvar oldLength = this.length();\n\
\n\
\t\tif ( oldLength !== 0 && l !== oldLength ) {\n\
\n\
\t\t\tthis.multiplyScalar( l / oldLength );\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tlerp: function ( v, alpha ) {\n\
\n\
\t\tthis.x += ( v.x - this.x ) * alpha;\n\
\t\tthis.y += ( v.y - this.y ) * alpha;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tequals: function( v ) {\n\
\n\
\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\
\n\
\t},\n\
\n\
\tfromArray: function ( array ) {\n\
\n\
\t\tthis.x = array[ 0 ];\n\
\t\tthis.y = array[ 1 ];\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttoArray: function () {\n\
\n\
\t\treturn [ this.x, this.y ];\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Vector2( this.x, this.y );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author *kile / http://kile.stravaganza.org/\n\
 * @author philogb / http://blog.thejit.org/\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author egraether / http://egraether.com/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
 */\n\
\n\
THREE.Vector3 = function ( x, y, z ) {\n\
\n\
\tthis.x = x || 0;\n\
\tthis.y = y || 0;\n\
\tthis.z = z || 0;\n\
\n\
};\n\
\n\
THREE.Vector3.prototype = {\n\
\n\
\tconstructor: THREE.Vector3,\n\
\n\
\tset: function ( x, y, z ) {\n\
\n\
\t\tthis.x = x;\n\
\t\tthis.y = y;\n\
\t\tthis.z = z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetX: function ( x ) {\n\
\n\
\t\tthis.x = x;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetY: function ( y ) {\n\
\n\
\t\tthis.y = y;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetZ: function ( z ) {\n\
\n\
\t\tthis.z = z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetComponent: function ( index, value ) {\n\
\n\
\t\tswitch ( index ) {\n\
\n\
\t\t\tcase 0: this.x = value; break;\n\
\t\t\tcase 1: this.y = value; break;\n\
\t\t\tcase 2: this.z = value; break;\n\
\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tgetComponent: function ( index ) {\n\
\n\
\t\tswitch ( index ) {\n\
\n\
\t\t\tcase 0: return this.x;\n\
\t\t\tcase 1: return this.y;\n\
\t\t\tcase 2: return this.z;\n\
\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcopy: function ( v ) {\n\
\n\
\t\tthis.x = v.x;\n\
\t\tthis.y = v.y;\n\
\t\tthis.z = v.z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tadd: function ( v, w ) {\n\
\n\
\t\tif ( w !== undefined ) {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\
\t\t\treturn this.addVectors( v, w );\n\
\n\
\t\t}\n\
\n\
\t\tthis.x += v.x;\n\
\t\tthis.y += v.y;\n\
\t\tthis.z += v.z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\taddScalar: function ( s ) {\n\
\n\
\t\tthis.x += s;\n\
\t\tthis.y += s;\n\
\t\tthis.z += s;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\taddVectors: function ( a, b ) {\n\
\n\
\t\tthis.x = a.x + b.x;\n\
\t\tthis.y = a.y + b.y;\n\
\t\tthis.z = a.z + b.z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsub: function ( v, w ) {\n\
\n\
\t\tif ( w !== undefined ) {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\
\t\t\treturn this.subVectors( v, w );\n\
\n\
\t\t}\n\
\n\
\t\tthis.x -= v.x;\n\
\t\tthis.y -= v.y;\n\
\t\tthis.z -= v.z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsubVectors: function ( a, b ) {\n\
\n\
\t\tthis.x = a.x - b.x;\n\
\t\tthis.y = a.y - b.y;\n\
\t\tthis.z = a.z - b.z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiply: function ( v, w ) {\n\
\n\
\t\tif ( w !== undefined ) {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\
\t\t\treturn this.multiplyVectors( v, w );\n\
\n\
\t\t}\n\
\n\
\t\tthis.x *= v.x;\n\
\t\tthis.y *= v.y;\n\
\t\tthis.z *= v.z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiplyScalar: function ( scalar ) {\n\
\n\
\t\tthis.x *= scalar;\n\
\t\tthis.y *= scalar;\n\
\t\tthis.z *= scalar;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiplyVectors: function ( a, b ) {\n\
\n\
\t\tthis.x = a.x * b.x;\n\
\t\tthis.y = a.y * b.y;\n\
\t\tthis.z = a.z * b.z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tapplyMatrix3: function ( m ) {\n\
\n\
\t\tvar x = this.x;\n\
\t\tvar y = this.y;\n\
\t\tvar z = this.z;\n\
\n\
\t\tvar e = m.elements;\n\
\n\
\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\n\
\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\n\
\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tapplyMatrix4: function ( m ) {\n\
\n\
\t\t// input: THREE.Matrix4 affine matrix\n\
\n\
\t\tvar x = this.x, y = this.y, z = this.z;\n\
\n\
\t\tvar e = m.elements;\n\
\n\
\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z + e[12];\n\
\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z + e[13];\n\
\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tapplyProjection: function ( m ) {\n\
\n\
\t\t// input: THREE.Matrix4 projection matrix\n\
\n\
\t\tvar x = this.x, y = this.y, z = this.z;\n\
\n\
\t\tvar e = m.elements;\n\
\t\tvar d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide\n\
\n\
\t\tthis.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;\n\
\t\tthis.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;\n\
\t\tthis.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tapplyQuaternion: function ( q ) {\n\
\n\
\t\tvar x = this.x;\n\
\t\tvar y = this.y;\n\
\t\tvar z = this.z;\n\
\n\
\t\tvar qx = q.x;\n\
\t\tvar qy = q.y;\n\
\t\tvar qz = q.z;\n\
\t\tvar qw = q.w;\n\
\n\
\t\t// calculate quat * vector\n\
\n\
\t\tvar ix =  qw * x + qy * z - qz * y;\n\
\t\tvar iy =  qw * y + qz * x - qx * z;\n\
\t\tvar iz =  qw * z + qx * y - qy * x;\n\
\t\tvar iw = -qx * x - qy * y - qz * z;\n\
\n\
\t\t// calculate result * inverse quat\n\
\n\
\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\
\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\
\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttransformDirection: function ( m ) {\n\
\n\
\t\t// input: THREE.Matrix4 affine matrix\n\
\t\t// vector interpreted as a direction\n\
\n\
\t\tvar x = this.x, y = this.y, z = this.z;\n\
\n\
\t\tvar e = m.elements;\n\
\n\
\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z;\n\
\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z;\n\
\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\n\
\n\
\t\tthis.normalize();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tdivide: function ( v ) {\n\
\n\
\t\tthis.x /= v.x;\n\
\t\tthis.y /= v.y;\n\
\t\tthis.z /= v.z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tdivideScalar: function ( scalar ) {\n\
\n\
\t\tif ( scalar !== 0 ) {\n\
\n\
\t\t\tvar invScalar = 1 / scalar;\n\
\n\
\t\t\tthis.x *= invScalar;\n\
\t\t\tthis.y *= invScalar;\n\
\t\t\tthis.z *= invScalar;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tthis.x = 0;\n\
\t\t\tthis.y = 0;\n\
\t\t\tthis.z = 0;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmin: function ( v ) {\n\
\n\
\t\tif ( this.x > v.x ) {\n\
\n\
\t\t\tthis.x = v.x;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.y > v.y ) {\n\
\n\
\t\t\tthis.y = v.y;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.z > v.z ) {\n\
\n\
\t\t\tthis.z = v.z;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmax: function ( v ) {\n\
\n\
\t\tif ( this.x < v.x ) {\n\
\n\
\t\t\tthis.x = v.x;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.y < v.y ) {\n\
\n\
\t\t\tthis.y = v.y;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.z < v.z ) {\n\
\n\
\t\t\tthis.z = v.z;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tclamp: function ( min, max ) {\n\
\n\
\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\
\n\
\t\tif ( this.x < min.x ) {\n\
\n\
\t\t\tthis.x = min.x;\n\
\n\
\t\t} else if ( this.x > max.x ) {\n\
\n\
\t\t\tthis.x = max.x;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.y < min.y ) {\n\
\n\
\t\t\tthis.y = min.y;\n\
\n\
\t\t} else if ( this.y > max.y ) {\n\
\n\
\t\t\tthis.y = max.y;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.z < min.z ) {\n\
\n\
\t\t\tthis.z = min.z;\n\
\n\
\t\t} else if ( this.z > max.z ) {\n\
\n\
\t\t\tthis.z = max.z;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tnegate: function () {\n\
\n\
\t\treturn this.multiplyScalar( - 1 );\n\
\n\
\t},\n\
\n\
\tdot: function ( v ) {\n\
\n\
\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\
\n\
\t},\n\
\n\
\tlengthSq: function () {\n\
\n\
\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\
\n\
\t},\n\
\n\
\tlength: function () {\n\
\n\
\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\
\n\
\t},\n\
\n\
\tlengthManhattan: function () {\n\
\n\
\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\
\n\
\t},\n\
\n\
\tnormalize: function () {\n\
\n\
\t\treturn this.divideScalar( this.length() );\n\
\n\
\t},\n\
\n\
\tsetLength: function ( l ) {\n\
\n\
\t\tvar oldLength = this.length();\n\
\n\
\t\tif ( oldLength !== 0 && l !== oldLength  ) {\n\
\n\
\t\t\tthis.multiplyScalar( l / oldLength );\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tlerp: function ( v, alpha ) {\n\
\n\
\t\tthis.x += ( v.x - this.x ) * alpha;\n\
\t\tthis.y += ( v.y - this.y ) * alpha;\n\
\t\tthis.z += ( v.z - this.z ) * alpha;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcross: function ( v, w ) {\n\
\n\
\t\tif ( w !== undefined ) {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\
\t\t\treturn this.crossVectors( v, w );\n\
\n\
\t\t}\n\
\n\
\t\tvar x = this.x, y = this.y, z = this.z;\n\
\n\
\t\tthis.x = y * v.z - z * v.y;\n\
\t\tthis.y = z * v.x - x * v.z;\n\
\t\tthis.z = x * v.y - y * v.x;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcrossVectors: function ( a, b ) {\n\
\n\
\t\tvar ax = a.x, ay = a.y, az = a.z;\n\
\t\tvar bx = b.x, by = b.y, bz = b.z;\n\
\n\
\t\tthis.x = ay * bz - az * by;\n\
\t\tthis.y = az * bx - ax * bz;\n\
\t\tthis.z = ax * by - ay * bx;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tangleTo: function ( v ) {\n\
\n\
\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\n\
\n\
\t\t// clamp, to handle numerical problems\n\
\n\
\t\treturn Math.acos( THREE.Math.clamp( theta, -1, 1 ) );\n\
\n\
\t},\n\
\n\
\tdistanceTo: function ( v ) {\n\
\n\
\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\
\n\
\t},\n\
\n\
\tdistanceToSquared: function ( v ) {\n\
\n\
\t\tvar dx = this.x - v.x;\n\
\t\tvar dy = this.y - v.y;\n\
\t\tvar dz = this.z - v.z;\n\
\n\
\t\treturn dx * dx + dy * dy + dz * dz;\n\
\n\
\t},\n\
\n\
\tsetEulerFromRotationMatrix: function ( m, order ) {\n\
\n\
\t\tconsole.error( \"REMOVED: Vector3\\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.\");\n\
\n\
\t},\n\
\n\
\tsetEulerFromQuaternion: function ( q, order ) {\n\
\n\
\t\tconsole.error( \"REMOVED: Vector3\\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.\");\n\
\n\
\t},\n\
\n\
\tgetPositionFromMatrix: function ( m ) {\n\
\n\
\t\tthis.x = m.elements[12];\n\
\t\tthis.y = m.elements[13];\n\
\t\tthis.z = m.elements[14];\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tgetScaleFromMatrix: function ( m ) {\n\
\n\
\t\tvar sx = this.set( m.elements[0], m.elements[1], m.elements[2] ).length();\n\
\t\tvar sy = this.set( m.elements[4], m.elements[5], m.elements[6] ).length();\n\
\t\tvar sz = this.set( m.elements[8], m.elements[9], m.elements[10] ).length();\n\
\n\
\t\tthis.x = sx;\n\
\t\tthis.y = sy;\n\
\t\tthis.z = sz;\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\tgetColumnFromMatrix: function ( index, matrix ) {\n\
\n\
\t\tvar offset = index * 4;\n\
\n\
\t\tvar me = matrix.elements;\n\
\n\
\t\tthis.x = me[ offset ];\n\
\t\tthis.y = me[ offset + 1 ];\n\
\t\tthis.z = me[ offset + 2 ];\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tequals: function ( v ) {\n\
\n\
\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\
\n\
\t},\n\
\n\
\tfromArray: function ( array ) {\n\
\n\
\t\tthis.x = array[ 0 ];\n\
\t\tthis.y = array[ 1 ];\n\
\t\tthis.z = array[ 2 ];\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttoArray: function () {\n\
\n\
\t\treturn [ this.x, this.y, this.z ];\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Vector3( this.x, this.y, this.z );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.extend( THREE.Vector3.prototype, {\n\
\n\
\tapplyEuler: function () {\n\
\n\
\t\tvar quaternion = new THREE.Quaternion();\n\
\n\
\t\treturn function ( euler ) {\n\
\n\
\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\
\n\
\t\t\t\tconsole.error( 'ERROR: Vector3\\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tapplyAxisAngle: function () {\n\
\n\
\t\tvar quaternion = new THREE.Quaternion();\n\
\n\
\t\treturn function ( axis, angle ) {\n\
\n\
\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tprojectOnVector: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( vector ) {\n\
\n\
\t\t\tv1.copy( vector ).normalize();\n\
\t\t\tvar d = this.dot( v1 );\n\
\t\t\treturn this.copy( v1 ).multiplyScalar( d );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tprojectOnPlane: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( planeNormal ) {\n\
\n\
\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\
\n\
\t\t\treturn this.sub( v1 );\n\
\n\
\t\t}\n\
\n\
\t}(),\n\
\n\
\treflect: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( vector ) {\n\
\n\
\t\t    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );\n\
\n\
\t\t    return this.subVectors( v1, this );\n\
\n\
\t\t}\n\
\n\
\t}()\n\
\n\
} );\n\
\n\
/**\n\
 * @author supereggbert / http://www.paulbrunt.co.uk/\n\
 * @author philogb / http://blog.thejit.org/\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author egraether / http://egraether.com/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
 */\n\
\n\
THREE.Vector4 = function ( x, y, z, w ) {\n\
\n\
\tthis.x = x || 0;\n\
\tthis.y = y || 0;\n\
\tthis.z = z || 0;\n\
\tthis.w = ( w !== undefined ) ? w : 1;\n\
\n\
};\n\
\n\
THREE.Vector4.prototype = {\n\
\n\
\tconstructor: THREE.Vector4,\n\
\n\
\tset: function ( x, y, z, w ) {\n\
\n\
\t\tthis.x = x;\n\
\t\tthis.y = y;\n\
\t\tthis.z = z;\n\
\t\tthis.w = w;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetX: function ( x ) {\n\
\n\
\t\tthis.x = x;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetY: function ( y ) {\n\
\n\
\t\tthis.y = y;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetZ: function ( z ) {\n\
\n\
\t\tthis.z = z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetW: function ( w ) {\n\
\n\
\t\tthis.w = w;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetComponent: function ( index, value ) {\n\
\n\
\t\tswitch ( index ) {\n\
\n\
\t\t\tcase 0: this.x = value; break;\n\
\t\t\tcase 1: this.y = value; break;\n\
\t\t\tcase 2: this.z = value; break;\n\
\t\t\tcase 3: this.w = value; break;\n\
\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tgetComponent: function ( index ) {\n\
\n\
\t\tswitch ( index ) {\n\
\n\
\t\t\tcase 0: return this.x;\n\
\t\t\tcase 1: return this.y;\n\
\t\t\tcase 2: return this.z;\n\
\t\t\tcase 3: return this.w;\n\
\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcopy: function ( v ) {\n\
\n\
\t\tthis.x = v.x;\n\
\t\tthis.y = v.y;\n\
\t\tthis.z = v.z;\n\
\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tadd: function ( v, w ) {\n\
\n\
\t\tif ( w !== undefined ) {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\
\t\t\treturn this.addVectors( v, w );\n\
\n\
\t\t}\n\
\n\
\t\tthis.x += v.x;\n\
\t\tthis.y += v.y;\n\
\t\tthis.z += v.z;\n\
\t\tthis.w += v.w;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\taddScalar: function ( s ) {\n\
\n\
\t\tthis.x += s;\n\
\t\tthis.y += s;\n\
\t\tthis.z += s;\n\
\t\tthis.w += s;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\taddVectors: function ( a, b ) {\n\
\n\
\t\tthis.x = a.x + b.x;\n\
\t\tthis.y = a.y + b.y;\n\
\t\tthis.z = a.z + b.z;\n\
\t\tthis.w = a.w + b.w;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsub: function ( v, w ) {\n\
\n\
\t\tif ( w !== undefined ) {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\
\t\t\treturn this.subVectors( v, w );\n\
\n\
\t\t}\n\
\n\
\t\tthis.x -= v.x;\n\
\t\tthis.y -= v.y;\n\
\t\tthis.z -= v.z;\n\
\t\tthis.w -= v.w;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsubVectors: function ( a, b ) {\n\
\n\
\t\tthis.x = a.x - b.x;\n\
\t\tthis.y = a.y - b.y;\n\
\t\tthis.z = a.z - b.z;\n\
\t\tthis.w = a.w - b.w;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiplyScalar: function ( scalar ) {\n\
\n\
\t\tthis.x *= scalar;\n\
\t\tthis.y *= scalar;\n\
\t\tthis.z *= scalar;\n\
\t\tthis.w *= scalar;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tapplyMatrix4: function ( m ) {\n\
\n\
\t\tvar x = this.x;\n\
\t\tvar y = this.y;\n\
\t\tvar z = this.z;\n\
\t\tvar w = this.w;\n\
\n\
\t\tvar e = m.elements;\n\
\n\
\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n\
\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n\
\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n\
\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tdivideScalar: function ( scalar ) {\n\
\n\
\t\tif ( scalar !== 0 ) {\n\
\n\
\t\t\tvar invScalar = 1 / scalar;\n\
\n\
\t\t\tthis.x *= invScalar;\n\
\t\t\tthis.y *= invScalar;\n\
\t\t\tthis.z *= invScalar;\n\
\t\t\tthis.w *= invScalar;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tthis.x = 0;\n\
\t\t\tthis.y = 0;\n\
\t\t\tthis.z = 0;\n\
\t\t\tthis.w = 1;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetAxisAngleFromQuaternion: function ( q ) {\n\
\n\
\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\
\n\
\t\t// q is assumed to be normalized\n\
\n\
\t\tthis.w = 2 * Math.acos( q.w );\n\
\n\
\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\
\n\
\t\tif ( s < 0.0001 ) {\n\
\n\
\t\t\t this.x = 1;\n\
\t\t\t this.y = 0;\n\
\t\t\t this.z = 0;\n\
\n\
\t\t} else {\n\
\n\
\t\t\t this.x = q.x / s;\n\
\t\t\t this.y = q.y / s;\n\
\t\t\t this.z = q.z / s;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\
\n\
\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\
\n\
\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\
\n\
\t\tvar angle, x, y, z,\t\t// variables for result\n\
\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\
\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\
\n\
\t\t\tte = m.elements,\n\
\n\
\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\n\
\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\n\
\t\t\tm31 = te[2], m32 = te[6], m33 = te[10];\n\
\n\
\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\n\
\t\t  && ( Math.abs( m13 - m31 ) < epsilon )\n\
\t\t  && ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\
\n\
\t\t\t// singularity found\n\
\t\t\t// first check for identity matrix which must have +1 for all terms\n\
\t\t\t// in leading diagonal and zero in other terms\n\
\n\
\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\n\
\t\t\t  && ( Math.abs( m13 + m31 ) < epsilon2 )\n\
\t\t\t  && ( Math.abs( m23 + m32 ) < epsilon2 )\n\
\t\t\t  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\
\n\
\t\t\t\t// this singularity is identity matrix so angle = 0\n\
\n\
\t\t\t\tthis.set( 1, 0, 0, 0 );\n\
\n\
\t\t\t\treturn this; // zero angle, arbitrary axis\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// otherwise this singularity is angle = 180\n\
\n\
\t\t\tangle = Math.PI;\n\
\n\
\t\t\tvar xx = ( m11 + 1 ) / 2;\n\
\t\t\tvar yy = ( m22 + 1 ) / 2;\n\
\t\t\tvar zz = ( m33 + 1 ) / 2;\n\
\t\t\tvar xy = ( m12 + m21 ) / 4;\n\
\t\t\tvar xz = ( m13 + m31 ) / 4;\n\
\t\t\tvar yz = ( m23 + m32 ) / 4;\n\
\n\
\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\n\
\n\
\t\t\t\tif ( xx < epsilon ) {\n\
\n\
\t\t\t\t\tx = 0;\n\
\t\t\t\t\ty = 0.707106781;\n\
\t\t\t\t\tz = 0.707106781;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tx = Math.sqrt( xx );\n\
\t\t\t\t\ty = xy / x;\n\
\t\t\t\t\tz = xz / x;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\n\
\n\
\t\t\t\tif ( yy < epsilon ) {\n\
\n\
\t\t\t\t\tx = 0.707106781;\n\
\t\t\t\t\ty = 0;\n\
\t\t\t\t\tz = 0.707106781;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\ty = Math.sqrt( yy );\n\
\t\t\t\t\tx = xy / y;\n\
\t\t\t\t\tz = yz / y;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else { // m33 is the largest diagonal term so base result on this\n\
\n\
\t\t\t\tif ( zz < epsilon ) {\n\
\n\
\t\t\t\t\tx = 0.707106781;\n\
\t\t\t\t\ty = 0.707106781;\n\
\t\t\t\t\tz = 0;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tz = Math.sqrt( zz );\n\
\t\t\t\t\tx = xz / z;\n\
\t\t\t\t\ty = yz / z;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tthis.set( x, y, z, angle );\n\
\n\
\t\t\treturn this; // return 180 deg rotation\n\
\n\
\t\t}\n\
\n\
\t\t// as we have reached here there are no singularities so we can handle normally\n\
\n\
\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\n\
\t\t\t\t\t\t + ( m13 - m31 ) * ( m13 - m31 )\n\
\t\t\t\t\t\t + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\
\n\
\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\
\n\
\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\
\t\t// caught by singularity test above, but I've left it in just in case\n\
\n\
\t\tthis.x = ( m32 - m23 ) / s;\n\
\t\tthis.y = ( m13 - m31 ) / s;\n\
\t\tthis.z = ( m21 - m12 ) / s;\n\
\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmin: function ( v ) {\n\
\n\
\t\tif ( this.x > v.x ) {\n\
\n\
\t\t\tthis.x = v.x;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.y > v.y ) {\n\
\n\
\t\t\tthis.y = v.y;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.z > v.z ) {\n\
\n\
\t\t\tthis.z = v.z;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.w > v.w ) {\n\
\n\
\t\t\tthis.w = v.w;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmax: function ( v ) {\n\
\n\
\t\tif ( this.x < v.x ) {\n\
\n\
\t\t\tthis.x = v.x;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.y < v.y ) {\n\
\n\
\t\t\tthis.y = v.y;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.z < v.z ) {\n\
\n\
\t\t\tthis.z = v.z;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.w < v.w ) {\n\
\n\
\t\t\tthis.w = v.w;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tclamp: function ( min, max ) {\n\
\n\
\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\
\n\
\t\tif ( this.x < min.x ) {\n\
\n\
\t\t\tthis.x = min.x;\n\
\n\
\t\t} else if ( this.x > max.x ) {\n\
\n\
\t\t\tthis.x = max.x;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.y < min.y ) {\n\
\n\
\t\t\tthis.y = min.y;\n\
\n\
\t\t} else if ( this.y > max.y ) {\n\
\n\
\t\t\tthis.y = max.y;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.z < min.z ) {\n\
\n\
\t\t\tthis.z = min.z;\n\
\n\
\t\t} else if ( this.z > max.z ) {\n\
\n\
\t\t\tthis.z = max.z;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.w < min.w ) {\n\
\n\
\t\t\tthis.w = min.w;\n\
\n\
\t\t} else if ( this.w > max.w ) {\n\
\n\
\t\t\tthis.w = max.w;\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tnegate: function() {\n\
\n\
\t\treturn this.multiplyScalar( -1 );\n\
\n\
\t},\n\
\n\
\tdot: function ( v ) {\n\
\n\
\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\
\n\
\t},\n\
\n\
\tlengthSq: function () {\n\
\n\
\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\
\n\
\t},\n\
\n\
\tlength: function () {\n\
\n\
\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\
\n\
\t},\n\
\n\
\tlengthManhattan: function () {\n\
\n\
\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\
\n\
\t},\n\
\n\
\tnormalize: function () {\n\
\n\
\t\treturn this.divideScalar( this.length() );\n\
\n\
\t},\n\
\n\
\tsetLength: function ( l ) {\n\
\n\
\t\tvar oldLength = this.length();\n\
\n\
\t\tif ( oldLength !== 0 && l !== oldLength ) {\n\
\n\
\t\t\tthis.multiplyScalar( l / oldLength );\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tlerp: function ( v, alpha ) {\n\
\n\
\t\tthis.x += ( v.x - this.x ) * alpha;\n\
\t\tthis.y += ( v.y - this.y ) * alpha;\n\
\t\tthis.z += ( v.z - this.z ) * alpha;\n\
\t\tthis.w += ( v.w - this.w ) * alpha;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tequals: function ( v ) {\n\
\n\
\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\
\n\
\t},\n\
\n\
\tfromArray: function ( array ) {\n\
\n\
\t\tthis.x = array[ 0 ];\n\
\t\tthis.y = array[ 1 ];\n\
\t\tthis.z = array[ 2 ];\n\
\t\tthis.w = array[ 3 ];\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttoArray: function () {\n\
\n\
\t\treturn [ this.x, this.y, this.z, this.w ];\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
THREE.Euler = function ( x, y, z, order ) {\n\
\n\
\tthis._x = x || 0;\n\
\tthis._y = y || 0;\n\
\tthis._z = z || 0;\n\
\tthis._order = order || THREE.Euler.DefaultOrder;\n\
\n\
};\n\
\n\
THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\
\n\
THREE.Euler.DefaultOrder = 'XYZ';\n\
\n\
THREE.Euler.prototype = {\n\
\n\
\tconstructor: THREE.Euler,\n\
\n\
\t_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,\n\
\n\
\t_quaternion: undefined,\n\
\n\
\t_updateQuaternion: function () {\n\
\n\
\t\tif ( this._quaternion !== undefined ) {\n\
\n\
\t\t\tthis._quaternion.setFromEuler( this, false );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tget x () {\n\
\n\
\t\treturn this._x;\n\
\n\
\t},\n\
\n\
\tset x ( value ) {\n\
\n\
\t\tthis._x = value;\n\
\t\tthis._updateQuaternion();\n\
\n\
\t},\n\
\n\
\tget y () {\n\
\n\
\t\treturn this._y;\n\
\n\
\t},\n\
\n\
\tset y ( value ) {\n\
\n\
\t\tthis._y = value;\n\
\t\tthis._updateQuaternion();\n\
\n\
\t},\n\
\n\
\tget z () {\n\
\n\
\t\treturn this._z;\n\
\n\
\t},\n\
\n\
\tset z ( value ) {\n\
\n\
\t\tthis._z = value;\n\
\t\tthis._updateQuaternion();\n\
\n\
\t},\n\
\n\
\tget order () {\n\
\n\
\t\treturn this._order;\n\
\n\
\t},\n\
\n\
\tset order ( value ) {\n\
\n\
\t\tthis._order = value;\n\
\t\tthis._updateQuaternion();\n\
\n\
\t},\n\
\n\
\tset: function ( x, y, z, order ) {\n\
\n\
\t\tthis._x = x;\n\
\t\tthis._y = y;\n\
\t\tthis._z = z;\n\
\t\tthis._order = order || this._order;\n\
\n\
\t\tthis._updateQuaternion();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcopy: function ( euler ) {\n\
\n\
\t\tthis._x = euler._x;\n\
\t\tthis._y = euler._y;\n\
\t\tthis._z = euler._z;\n\
\t\tthis._order = euler._order;\n\
\n\
\t\tthis._updateQuaternion();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromRotationMatrix: function ( m, order ) {\n\
\n\
\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\
\n\
\t\t// clamp, to handle numerical problems\n\
\n\
\t\tfunction clamp( x ) {\n\
\n\
\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\n\
\n\
\t\t}\n\
\n\
\t\tvar te = m.elements;\n\
\t\tvar m11 = te[0], m12 = te[4], m13 = te[8];\n\
\t\tvar m21 = te[1], m22 = te[5], m23 = te[9];\n\
\t\tvar m31 = te[2], m32 = te[6], m33 = te[10];\n\
\n\
\t\torder = order || this._order;\n\
\n\
\t\tif ( order === 'XYZ' ) {\n\
\n\
\t\t\tthis._y = Math.asin( clamp( m13 ) );\n\
\n\
\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\
\n\
\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\
\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\
\t\t\t\tthis._z = 0;\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( order === 'YXZ' ) {\n\
\n\
\t\t\tthis._x = Math.asin( - clamp( m23 ) );\n\
\n\
\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\
\n\
\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\
\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\
\t\t\t\tthis._z = 0;\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( order === 'ZXY' ) {\n\
\n\
\t\t\tthis._x = Math.asin( clamp( m32 ) );\n\
\n\
\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\
\n\
\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\
\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tthis._y = 0;\n\
\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( order === 'ZYX' ) {\n\
\n\
\t\t\tthis._y = Math.asin( - clamp( m31 ) );\n\
\n\
\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\
\n\
\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\
\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tthis._x = 0;\n\
\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( order === 'YZX' ) {\n\
\n\
\t\t\tthis._z = Math.asin( clamp( m21 ) );\n\
\n\
\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\
\n\
\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\
\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tthis._x = 0;\n\
\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( order === 'XZY' ) {\n\
\n\
\t\t\tthis._z = Math.asin( - clamp( m12 ) );\n\
\n\
\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\
\n\
\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\
\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\
\t\t\t\tthis._y = 0;\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tconsole.warn( 'WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order )\n\
\n\
\t\t}\n\
\n\
\t\tthis._order = order;\n\
\n\
\t\tthis._updateQuaternion();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromQuaternion: function ( q, order, update ) {\n\
\n\
\t\t// q is assumed to be normalized\n\
\n\
\t\t// clamp, to handle numerical problems\n\
\n\
\t\tfunction clamp( x ) {\n\
\n\
\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\n\
\n\
\t\t}\n\
\n\
\t\t// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n\
\n\
\t\tvar sqx = q.x * q.x;\n\
\t\tvar sqy = q.y * q.y;\n\
\t\tvar sqz = q.z * q.z;\n\
\t\tvar sqw = q.w * q.w;\n\
\n\
\t\torder = order || this._order;\n\
\n\
\t\tif ( order === 'XYZ' ) {\n\
\n\
\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );\n\
\t\t\tthis._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );\n\
\t\t\tthis._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );\n\
\n\
\t\t} else if ( order ===  'YXZ' ) {\n\
\n\
\t\t\tthis._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );\n\
\t\t\tthis._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );\n\
\t\t\tthis._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );\n\
\n\
\t\t} else if ( order === 'ZXY' ) {\n\
\n\
\t\t\tthis._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );\n\
\t\t\tthis._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );\n\
\t\t\tthis._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );\n\
\n\
\t\t} else if ( order === 'ZYX' ) {\n\
\n\
\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );\n\
\t\t\tthis._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );\n\
\t\t\tthis._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );\n\
\n\
\t\t} else if ( order === 'YZX' ) {\n\
\n\
\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );\n\
\t\t\tthis._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );\n\
\t\t\tthis._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );\n\
\n\
\t\t} else if ( order === 'XZY' ) {\n\
\n\
\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );\n\
\t\t\tthis._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );\n\
\t\t\tthis._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );\n\
\n\
\t\t} else {\n\
\n\
\t\t\tconsole.warn( 'WARNING: Euler.setFromQuaternion() given unsupported order: ' + order )\n\
\n\
\t\t}\n\
\n\
\t\tthis._order = order;\n\
\n\
\t\tif ( update !== false ) this._updateQuaternion();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\treorder: function () {\n\
\n\
\t\t// WARNING: this discards revolution information -bhouston\n\
\n\
\t\tvar q = new THREE.Quaternion();\n\
\n\
\t\treturn function ( newOrder ) {\n\
\n\
\t\t\tq.setFromEuler( this );\n\
\t\t\tthis.setFromQuaternion( q, newOrder );\n\
\n\
\t\t};\n\
\n\
\n\
\t}(),\n\
\n\
\tfromArray: function ( array ) {\n\
\n\
\t\tthis._x = array[ 0 ];\n\
\t\tthis._y = array[ 1 ];\n\
\t\tthis._z = array[ 2 ];\n\
\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\
\n\
\t\tthis._updateQuaternion();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttoArray: function () {\n\
\n\
\t\treturn [ this._x, this._y, this._z, this._order ];\n\
\n\
\t},\n\
\n\
\tequals: function ( euler ) {\n\
\n\
\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Euler( this._x, this._y, this._z, this._order );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
THREE.Line3 = function ( start, end ) {\n\
\n\
\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\
\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\
\n\
};\n\
\n\
THREE.Line3.prototype = {\n\
\n\
\tconstructor: THREE.Line3,\n\
\n\
\tset: function ( start, end ) {\n\
\n\
\t\tthis.start.copy( start );\n\
\t\tthis.end.copy( end );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcopy: function ( line ) {\n\
\n\
\t\tthis.start.copy( line.start );\n\
\t\tthis.end.copy( line.end );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcenter: function ( optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\
\n\
\t},\n\
\n\
\tdelta: function ( optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\t\treturn result.subVectors( this.end, this.start );\n\
\n\
\t},\n\
\n\
\tdistanceSq: function () {\n\
\n\
\t\treturn this.start.distanceToSquared( this.end );\n\
\n\
\t},\n\
\n\
\tdistance: function () {\n\
\n\
\t\treturn this.start.distanceTo( this.end );\n\
\n\
\t},\n\
\n\
\tat: function ( t, optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\n\
\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\
\n\
\t},\n\
\n\
\tclosestPointToPointParameter: function() {\n\
\n\
\t\tvar startP = new THREE.Vector3();\n\
\t\tvar startEnd = new THREE.Vector3();\n\
\n\
\t\treturn function ( point, clampToLine ) {\n\
\n\
\t\t\tstartP.subVectors( point, this.start );\n\
\t\t\tstartEnd.subVectors( this.end, this.start );\n\
\n\
\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\
\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\
\n\
\t\t\tvar t = startEnd_startP / startEnd2;\n\
\n\
\t\t\tif ( clampToLine ) {\n\
\n\
\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\
\n\
\t\t\t}\n\
\n\
\t\t\treturn t;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\
\n\
\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\n\
\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\
\n\
\t},\n\
\n\
\tapplyMatrix4: function ( matrix ) {\n\
\n\
\t\tthis.start.applyMatrix4( matrix );\n\
\t\tthis.end.applyMatrix4( matrix );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tequals: function ( line ) {\n\
\n\
\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Line3().copy( this );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
THREE.Box2 = function ( min, max ) {\n\
\n\
\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\n\
\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );\n\
\n\
};\n\
\n\
THREE.Box2.prototype = {\n\
\n\
\tconstructor: THREE.Box2,\n\
\n\
\tset: function ( min, max ) {\n\
\n\
\t\tthis.min.copy( min );\n\
\t\tthis.max.copy( max );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromPoints: function ( points ) {\n\
\n\
\t\tif ( points.length > 0 ) {\n\
\n\
\t\t\tvar point = points[ 0 ];\n\
\n\
\t\t\tthis.min.copy( point );\n\
\t\t\tthis.max.copy( point );\n\
\n\
\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tpoint = points[ i ];\n\
\n\
\t\t\t\tif ( point.x < this.min.x ) {\n\
\n\
\t\t\t\t\tthis.min.x = point.x;\n\
\n\
\t\t\t\t} else if ( point.x > this.max.x ) {\n\
\n\
\t\t\t\t\tthis.max.x = point.x;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( point.y < this.min.y ) {\n\
\n\
\t\t\t\t\tthis.min.y = point.y;\n\
\n\
\t\t\t\t} else if ( point.y > this.max.y ) {\n\
\n\
\t\t\t\t\tthis.max.y = point.y;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tthis.makeEmpty();\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromCenterAndSize: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector2();\n\
\n\
\t\treturn function ( center, size ) {\n\
\n\
\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\
\t\t\tthis.min.copy( center ).sub( halfSize );\n\
\t\t\tthis.max.copy( center ).add( halfSize );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tcopy: function ( box ) {\n\
\n\
\t\tthis.min.copy( box.min );\n\
\t\tthis.max.copy( box.max );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmakeEmpty: function () {\n\
\n\
\t\tthis.min.x = this.min.y = Infinity;\n\
\t\tthis.max.x = this.max.y = -Infinity;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tempty: function () {\n\
\n\
\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\
\n\
\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\
\n\
\t},\n\
\n\
\tcenter: function ( optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector2();\n\
\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\
\n\
\t},\n\
\n\
\tsize: function ( optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector2();\n\
\t\treturn result.subVectors( this.max, this.min );\n\
\n\
\t},\n\
\n\
\texpandByPoint: function ( point ) {\n\
\n\
\t\tthis.min.min( point );\n\
\t\tthis.max.max( point );\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\texpandByVector: function ( vector ) {\n\
\n\
\t\tthis.min.sub( vector );\n\
\t\tthis.max.add( vector );\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\texpandByScalar: function ( scalar ) {\n\
\n\
\t\tthis.min.addScalar( -scalar );\n\
\t\tthis.max.addScalar( scalar );\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\tcontainsPoint: function ( point ) {\n\
\n\
\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\
\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\
\n\
\t\t\treturn false;\n\
\n\
\t\t}\n\
\n\
\t\treturn true;\n\
\n\
\t},\n\
\n\
\tcontainsBox: function ( box ) {\n\
\n\
\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\
\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\
\n\
\t\t\treturn true;\n\
\n\
\t\t}\n\
\n\
\t\treturn false;\n\
\n\
\t},\n\
\n\
\tgetParameter: function ( point ) {\n\
\n\
\t\t// This can potentially have a divide by zero if the box\n\
\t\t// has a size dimension of 0.\n\
\n\
\t\treturn new THREE.Vector2(\n\
\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\
\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\
\t\t);\n\
\n\
\t},\n\
\n\
\tisIntersectionBox: function ( box ) {\n\
\n\
\t\t// using 6 splitting planes to rule out intersections.\n\
\n\
\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\
\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\
\n\
\t\t\treturn false;\n\
\n\
\t\t}\n\
\n\
\t\treturn true;\n\
\n\
\t},\n\
\n\
\tclampPoint: function ( point, optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector2();\n\
\t\treturn result.copy( point ).clamp( this.min, this.max );\n\
\n\
\t},\n\
\n\
\tdistanceToPoint: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector2();\n\
\n\
\t\treturn function ( point ) {\n\
\n\
\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\
\t\t\treturn clampedPoint.sub( point ).length();\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tintersect: function ( box ) {\n\
\n\
\t\tthis.min.max( box.min );\n\
\t\tthis.max.min( box.max );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tunion: function ( box ) {\n\
\n\
\t\tthis.min.min( box.min );\n\
\t\tthis.max.max( box.max );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttranslate: function ( offset ) {\n\
\n\
\t\tthis.min.add( offset );\n\
\t\tthis.max.add( offset );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tequals: function ( box ) {\n\
\n\
\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Box2().copy( this );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author bhouston / http://exocortex.com\n\
 * @author WestLangley / http://github.com/WestLangley\n\
 */\n\
\n\
THREE.Box3 = function ( min, max ) {\n\
\n\
\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\n\
\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );\n\
\n\
};\n\
\n\
THREE.Box3.prototype = {\n\
\n\
\tconstructor: THREE.Box3,\n\
\n\
\tset: function ( min, max ) {\n\
\n\
\t\tthis.min.copy( min );\n\
\t\tthis.max.copy( max );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\taddPoint: function ( point ) {\n\
\n\
\t\tif ( point.x < this.min.x ) {\n\
\n\
\t\t\tthis.min.x = point.x;\n\
\n\
\t\t} else if ( point.x > this.max.x ) {\n\
\n\
\t\t\tthis.max.x = point.x;\n\
\n\
\t\t}\n\
\n\
\t\tif ( point.y < this.min.y ) {\n\
\n\
\t\t\tthis.min.y = point.y;\n\
\n\
\t\t} else if ( point.y > this.max.y ) {\n\
\n\
\t\t\tthis.max.y = point.y;\n\
\n\
\t\t}\n\
\n\
\t\tif ( point.z < this.min.z ) {\n\
\n\
\t\t\tthis.min.z = point.z;\n\
\n\
\t\t} else if ( point.z > this.max.z ) {\n\
\n\
\t\t\tthis.max.z = point.z;\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tsetFromPoints: function ( points ) {\n\
\n\
\t\tif ( points.length > 0 ) {\n\
\n\
\t\t\tvar point = points[ 0 ];\n\
\n\
\t\t\tthis.min.copy( point );\n\
\t\t\tthis.max.copy( point );\n\
\n\
\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tthis.addPoint( points[ i ] )\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tthis.makeEmpty();\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromCenterAndSize: function() {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( center, size ) {\n\
\n\
\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\
\n\
\t\t\tthis.min.copy( center ).sub( halfSize );\n\
\t\t\tthis.max.copy( center ).add( halfSize );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tsetFromObject: function() {\n\
\n\
\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\
\t\t// accounting for both the object's, and childrens', world transforms\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function( object ) {\n\
\n\
\t\t\tvar scope = this;\n\
\n\
\t\t\tobject.updateMatrixWorld( true );\n\
\n\
\t\t\tthis.makeEmpty();\n\
\n\
\t\t\tobject.traverse( function ( node ) {\n\
\n\
\t\t\t\tif ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {\n\
\n\
\t\t\t\t\tvar vertices = node.geometry.vertices;\n\
\n\
\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i++ ) {\n\
\n\
\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\
\n\
\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\
\n\
\t\t\t\t\t\tscope.expandByPoint( v1 );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tcopy: function ( box ) {\n\
\n\
\t\tthis.min.copy( box.min );\n\
\t\tthis.max.copy( box.max );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmakeEmpty: function () {\n\
\n\
\t\tthis.min.x = this.min.y = this.min.z = Infinity;\n\
\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tempty: function () {\n\
\n\
\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\
\n\
\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\
\n\
\t},\n\
\n\
\tcenter: function ( optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\
\n\
\t},\n\
\n\
\tsize: function ( optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\t\treturn result.subVectors( this.max, this.min );\n\
\n\
\t},\n\
\n\
\texpandByPoint: function ( point ) {\n\
\n\
\t\tthis.min.min( point );\n\
\t\tthis.max.max( point );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\texpandByVector: function ( vector ) {\n\
\n\
\t\tthis.min.sub( vector );\n\
\t\tthis.max.add( vector );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\texpandByScalar: function ( scalar ) {\n\
\n\
\t\tthis.min.addScalar( -scalar );\n\
\t\tthis.max.addScalar( scalar );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcontainsPoint: function ( point ) {\n\
\n\
\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\
\t\t     point.y < this.min.y || point.y > this.max.y ||\n\
\t\t     point.z < this.min.z || point.z > this.max.z ) {\n\
\n\
\t\t\treturn false;\n\
\n\
\t\t}\n\
\n\
\t\treturn true;\n\
\n\
\t},\n\
\n\
\tcontainsBox: function ( box ) {\n\
\n\
\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\
\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\
\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\
\n\
\t\t\treturn true;\n\
\n\
\t\t}\n\
\n\
\t\treturn false;\n\
\n\
\t},\n\
\n\
\tgetParameter: function ( point ) {\n\
\n\
\t\t// This can potentially have a divide by zero if the box\n\
\t\t// has a size dimension of 0.\n\
\n\
\t\treturn new THREE.Vector3(\n\
\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\
\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\
\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\
\t\t);\n\
\n\
\t},\n\
\n\
\tisIntersectionBox: function ( box ) {\n\
\n\
\t\t// using 6 splitting planes to rule out intersections.\n\
\n\
\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\
\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\n\
\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\n\
\n\
\t\t\treturn false;\n\
\n\
\t\t}\n\
\n\
\t\treturn true;\n\
\n\
\t},\n\
\n\
\tclampPoint: function ( point, optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\t\treturn result.copy( point ).clamp( this.min, this.max );\n\
\n\
\t},\n\
\n\
\tdistanceToPoint: function() {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( point ) {\n\
\n\
\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\
\t\t\treturn clampedPoint.sub( point ).length();\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tgetBoundingSphere: function() {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( optionalTarget ) {\n\
\n\
\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\
\n\
\t\t\tresult.center = this.center();\n\
\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\
\n\
\t\t\treturn result;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tintersect: function ( box ) {\n\
\n\
\t\tthis.min.max( box.min );\n\
\t\tthis.max.min( box.max );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tunion: function ( box ) {\n\
\n\
\t\tthis.min.min( box.min );\n\
\t\tthis.max.max( box.max );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tapplyMatrix4: function() {\n\
\n\
\t\tvar points = [\n\
\t\t\tnew THREE.Vector3(),\n\
\t\t\tnew THREE.Vector3(),\n\
\t\t\tnew THREE.Vector3(),\n\
\t\t\tnew THREE.Vector3(),\n\
\t\t\tnew THREE.Vector3(),\n\
\t\t\tnew THREE.Vector3(),\n\
\t\t\tnew THREE.Vector3(),\n\
\t\t\tnew THREE.Vector3()\n\
\t\t];\n\
\n\
\t\treturn function ( matrix ) {\n\
\n\
\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\
\t\t\tpoints[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\
\t\t\tpoints[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\
\t\t\tpoints[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\
\t\t\tpoints[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\
\t\t\tpoints[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\
\t\t\tpoints[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\
\t\t\tpoints[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\
\t\t\tpoints[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\n\
\n\
\t\t\tthis.makeEmpty();\n\
\t\t\tthis.setFromPoints( points );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\ttranslate: function ( offset ) {\n\
\n\
\t\tthis.min.add( offset );\n\
\t\tthis.max.add( offset );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tequals: function ( box ) {\n\
\n\
\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Box3().copy( this );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
THREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\
\n\
\tthis.elements = new Float32Array(9);\n\
\n\
\tthis.set(\n\
\n\
\t\t( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,\n\
\t\tn21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,\n\
\t\tn31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1\n\
\n\
\t);\n\
};\n\
\n\
THREE.Matrix3.prototype = {\n\
\n\
\tconstructor: THREE.Matrix3,\n\
\n\
\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tte[0] = n11; te[3] = n12; te[6] = n13;\n\
\t\tte[1] = n21; te[4] = n22; te[7] = n23;\n\
\t\tte[2] = n31; te[5] = n32; te[8] = n33;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tidentity: function () {\n\
\n\
\t\tthis.set(\n\
\n\
\t\t\t1, 0, 0,\n\
\t\t\t0, 1, 0,\n\
\t\t\t0, 0, 1\n\
\n\
\t\t);\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcopy: function ( m ) {\n\
\n\
\t\tvar me = m.elements;\n\
\n\
\t\tthis.set(\n\
\n\
\t\t\tme[0], me[3], me[6],\n\
\t\t\tme[1], me[4], me[7],\n\
\t\t\tme[2], me[5], me[8]\n\
\n\
\t\t);\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiplyVector3: function ( vector ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix3\\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\
\t\treturn vector.applyMatrix3( this );\n\
\n\
\t},\n\
\n\
\tmultiplyVector3Array: function() {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( a ) {\n\
\n\
\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\n\
\n\
\t\t\t\tv1.x = a[ i ];\n\
\t\t\t\tv1.y = a[ i + 1 ];\n\
\t\t\t\tv1.z = a[ i + 2 ];\n\
\n\
\t\t\t\tv1.applyMatrix3(this);\n\
\n\
\t\t\t\ta[ i ]     = v1.x;\n\
\t\t\t\ta[ i + 1 ] = v1.y;\n\
\t\t\t\ta[ i + 2 ] = v1.z;\n\
\n\
\t\t\t}\n\
\n\
\t\t\treturn a;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tmultiplyScalar: function ( s ) {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tte[0] *= s; te[3] *= s; te[6] *= s;\n\
\t\tte[1] *= s; te[4] *= s; te[7] *= s;\n\
\t\tte[2] *= s; te[5] *= s; te[8] *= s;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tdeterminant: function () {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tvar a = te[0], b = te[1], c = te[2],\n\
\t\t\td = te[3], e = te[4], f = te[5],\n\
\t\t\tg = te[6], h = te[7], i = te[8];\n\
\n\
\t\treturn a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;\n\
\n\
\t},\n\
\n\
\tgetInverse: function ( matrix, throwOnInvertible ) {\n\
\n\
\t\t// input: THREE.Matrix4\n\
\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\n\
\n\
\t\tvar me = matrix.elements;\n\
\t\tvar te = this.elements;\n\
\n\
\t\tte[ 0 ] =   me[10] * me[5] - me[6] * me[9];\n\
\t\tte[ 1 ] = - me[10] * me[1] + me[2] * me[9];\n\
\t\tte[ 2 ] =   me[6] * me[1] - me[2] * me[5];\n\
\t\tte[ 3 ] = - me[10] * me[4] + me[6] * me[8];\n\
\t\tte[ 4 ] =   me[10] * me[0] - me[2] * me[8];\n\
\t\tte[ 5 ] = - me[6] * me[0] + me[2] * me[4];\n\
\t\tte[ 6 ] =   me[9] * me[4] - me[5] * me[8];\n\
\t\tte[ 7 ] = - me[9] * me[0] + me[1] * me[8];\n\
\t\tte[ 8 ] =   me[5] * me[0] - me[1] * me[4];\n\
\n\
\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\n\
\n\
\t\t// no inverse\n\
\n\
\t\tif ( det === 0 ) {\n\
\n\
\t\t\tvar msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\
\n\
\t\t\tif ( throwOnInvertible || false ) {\n\
\n\
\t\t\t\tthrow new Error( msg ); \n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tconsole.warn( msg );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tthis.identity();\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t}\n\
\n\
\t\tthis.multiplyScalar( 1.0 / det );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttranspose: function () {\n\
\n\
\t\tvar tmp, m = this.elements;\n\
\n\
\t\ttmp = m[1]; m[1] = m[3]; m[3] = tmp;\n\
\t\ttmp = m[2]; m[2] = m[6]; m[6] = tmp;\n\
\t\ttmp = m[5]; m[5] = m[7]; m[7] = tmp;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tgetNormalMatrix: function ( m ) {\n\
\n\
\t\t// input: THREE.Matrix4\n\
\n\
\t\tthis.getInverse( m ).transpose();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttransposeIntoArray: function ( r ) {\n\
\n\
\t\tvar m = this.elements;\n\
\n\
\t\tr[ 0 ] = m[ 0 ];\n\
\t\tr[ 1 ] = m[ 3 ];\n\
\t\tr[ 2 ] = m[ 6 ];\n\
\t\tr[ 3 ] = m[ 1 ];\n\
\t\tr[ 4 ] = m[ 4 ];\n\
\t\tr[ 5 ] = m[ 7 ];\n\
\t\tr[ 6 ] = m[ 2 ];\n\
\t\tr[ 7 ] = m[ 5 ];\n\
\t\tr[ 8 ] = m[ 8 ];\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\treturn new THREE.Matrix3(\n\
\n\
\t\t\tte[0], te[3], te[6],\n\
\t\t\tte[1], te[4], te[7],\n\
\t\t\tte[2], te[5], te[8]\n\
\n\
\t\t);\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author supereggbert / http://www.paulbrunt.co.uk/\n\
 * @author philogb / http://blog.thejit.org/\n\
 * @author jordi_ros / http://plattsoft.com\n\
 * @author D1plo1d / http://github.com/D1plo1d\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author timknip / http://www.floorplanner.com/\n\
 * @author bhouston / http://exocortex.com\n\
 * @author WestLangley / http://github.com/WestLangley\n\
 */\n\
\n\
\n\
THREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\
\n\
\tthis.elements = new Float32Array( 16 );\n\
\n\
\t// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix\n\
\t//   we should not support semi specification of Matrix4, it is just weird.\n\
\n\
\tvar te = this.elements;\n\
\n\
\tte[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;\n\
\tte[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;\n\
\tte[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;\n\
\tte[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;\n\
\n\
};\n\
\n\
THREE.Matrix4.prototype = {\n\
\n\
\tconstructor: THREE.Matrix4,\n\
\n\
\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tte[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;\n\
\t\tte[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;\n\
\t\tte[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;\n\
\t\tte[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tidentity: function () {\n\
\n\
\t\tthis.set(\n\
\n\
\t\t\t1, 0, 0, 0,\n\
\t\t\t0, 1, 0, 0,\n\
\t\t\t0, 0, 1, 0,\n\
\t\t\t0, 0, 0, 1\n\
\n\
\t\t);\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcopy: function ( m ) {\n\
\n\
\t\tthis.elements.set( m.elements );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\textractPosition: function ( m ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .extractPosition() has been renamed to .copyPosition().' );\n\
\t\treturn this.copyPosition( m );\n\
\n\
\t},\n\
\n\
\tcopyPosition: function ( m ) {\n\
\n\
\t\tvar te = this.elements;\n\
\t\tvar me = m.elements;\n\
\n\
\t\tte[12] = me[12];\n\
\t\tte[13] = me[13];\n\
\t\tte[14] = me[14];\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\textractRotation: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( m ) {\n\
\n\
\t\t\tvar te = this.elements;\n\
\t\t\tvar me = m.elements;\n\
\n\
\t\t\tvar scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();\n\
\t\t\tvar scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();\n\
\t\t\tvar scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();\n\
\n\
\t\t\tte[0] = me[0] * scaleX;\n\
\t\t\tte[1] = me[1] * scaleX;\n\
\t\t\tte[2] = me[2] * scaleX;\n\
\n\
\t\t\tte[4] = me[4] * scaleY;\n\
\t\t\tte[5] = me[5] * scaleY;\n\
\t\t\tte[6] = me[6] * scaleY;\n\
\n\
\t\t\tte[8] = me[8] * scaleZ;\n\
\t\t\tte[9] = me[9] * scaleZ;\n\
\t\t\tte[10] = me[10] * scaleZ;\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tmakeRotationFromEuler: function ( euler ) {\n\
\n\
\t\tif ( euler instanceof THREE.Euler === false ) {\n\
\n\
\t\t\tconsole.error( 'ERROR: Matrix\\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );\n\
\n\
\t\t}\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\
\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\
\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\
\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\
\n\
\t\tif ( euler.order === 'XYZ' ) {\n\
\n\
\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\
\n\
\t\t\tte[0] = c * e;\n\
\t\t\tte[4] = - c * f;\n\
\t\t\tte[8] = d;\n\
\n\
\t\t\tte[1] = af + be * d;\n\
\t\t\tte[5] = ae - bf * d;\n\
\t\t\tte[9] = - b * c;\n\
\n\
\t\t\tte[2] = bf - ae * d;\n\
\t\t\tte[6] = be + af * d;\n\
\t\t\tte[10] = a * c;\n\
\n\
\t\t} else if ( euler.order === 'YXZ' ) {\n\
\n\
\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\
\n\
\t\t\tte[0] = ce + df * b;\n\
\t\t\tte[4] = de * b - cf;\n\
\t\t\tte[8] = a * d;\n\
\n\
\t\t\tte[1] = a * f;\n\
\t\t\tte[5] = a * e;\n\
\t\t\tte[9] = - b;\n\
\n\
\t\t\tte[2] = cf * b - de;\n\
\t\t\tte[6] = df + ce * b;\n\
\t\t\tte[10] = a * c;\n\
\n\
\t\t} else if ( euler.order === 'ZXY' ) {\n\
\n\
\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\
\n\
\t\t\tte[0] = ce - df * b;\n\
\t\t\tte[4] = - a * f;\n\
\t\t\tte[8] = de + cf * b;\n\
\n\
\t\t\tte[1] = cf + de * b;\n\
\t\t\tte[5] = a * e;\n\
\t\t\tte[9] = df - ce * b;\n\
\n\
\t\t\tte[2] = - a * d;\n\
\t\t\tte[6] = b;\n\
\t\t\tte[10] = a * c;\n\
\n\
\t\t} else if ( euler.order === 'ZYX' ) {\n\
\n\
\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\
\n\
\t\t\tte[0] = c * e;\n\
\t\t\tte[4] = be * d - af;\n\
\t\t\tte[8] = ae * d + bf;\n\
\n\
\t\t\tte[1] = c * f;\n\
\t\t\tte[5] = bf * d + ae;\n\
\t\t\tte[9] = af * d - be;\n\
\n\
\t\t\tte[2] = - d;\n\
\t\t\tte[6] = b * c;\n\
\t\t\tte[10] = a * c;\n\
\n\
\t\t} else if ( euler.order === 'YZX' ) {\n\
\n\
\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\
\n\
\t\t\tte[0] = c * e;\n\
\t\t\tte[4] = bd - ac * f;\n\
\t\t\tte[8] = bc * f + ad;\n\
\n\
\t\t\tte[1] = f;\n\
\t\t\tte[5] = a * e;\n\
\t\t\tte[9] = - b * e;\n\
\n\
\t\t\tte[2] = - d * e;\n\
\t\t\tte[6] = ad * f + bc;\n\
\t\t\tte[10] = ac - bd * f;\n\
\n\
\t\t} else if ( euler.order === 'XZY' ) {\n\
\n\
\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\
\n\
\t\t\tte[0] = c * e;\n\
\t\t\tte[4] = - f;\n\
\t\t\tte[8] = d * e;\n\
\n\
\t\t\tte[1] = ac * f + bd;\n\
\t\t\tte[5] = a * e;\n\
\t\t\tte[9] = ad * f - bc;\n\
\n\
\t\t\tte[2] = bc * f - ad;\n\
\t\t\tte[6] = b * e;\n\
\t\t\tte[10] = bd * f + ac;\n\
\n\
\t\t}\n\
\n\
\t\t// last column\n\
\t\tte[3] = 0;\n\
\t\tte[7] = 0;\n\
\t\tte[11] = 0;\n\
\n\
\t\t// bottom row\n\
\t\tte[12] = 0;\n\
\t\tte[13] = 0;\n\
\t\tte[14] = 0;\n\
\t\tte[15] = 1;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetRotationFromQuaternion: function ( q ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.' );\n\
\n\
\t\treturn this.makeRotationFromQuaternion( q );\n\
\n\
\t},\n\
\n\
\tmakeRotationFromQuaternion: function ( q ) {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\
\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\
\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\
\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\
\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\
\n\
\t\tte[0] = 1 - ( yy + zz );\n\
\t\tte[4] = xy - wz;\n\
\t\tte[8] = xz + wy;\n\
\n\
\t\tte[1] = xy + wz;\n\
\t\tte[5] = 1 - ( xx + zz );\n\
\t\tte[9] = yz - wx;\n\
\n\
\t\tte[2] = xz - wy;\n\
\t\tte[6] = yz + wx;\n\
\t\tte[10] = 1 - ( xx + yy );\n\
\n\
\t\t// last column\n\
\t\tte[3] = 0;\n\
\t\tte[7] = 0;\n\
\t\tte[11] = 0;\n\
\n\
\t\t// bottom row\n\
\t\tte[12] = 0;\n\
\t\tte[13] = 0;\n\
\t\tte[14] = 0;\n\
\t\tte[15] = 1;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tlookAt: function() {\n\
\n\
\t\tvar x = new THREE.Vector3();\n\
\t\tvar y = new THREE.Vector3();\n\
\t\tvar z = new THREE.Vector3();\n\
\n\
\t\treturn function ( eye, target, up ) {\n\
\n\
\t\t\tvar te = this.elements;\n\
\n\
\t\t\tz.subVectors( eye, target ).normalize();\n\
\n\
\t\t\tif ( z.length() === 0 ) {\n\
\n\
\t\t\t\tz.z = 1;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tx.crossVectors( up, z ).normalize();\n\
\n\
\t\t\tif ( x.length() === 0 ) {\n\
\n\
\t\t\t\tz.x += 0.0001;\n\
\t\t\t\tx.crossVectors( up, z ).normalize();\n\
\n\
\t\t\t}\n\
\n\
\t\t\ty.crossVectors( z, x );\n\
\n\
\n\
\t\t\tte[0] = x.x; te[4] = y.x; te[8] = z.x;\n\
\t\t\tte[1] = x.y; te[5] = y.y; te[9] = z.y;\n\
\t\t\tte[2] = x.z; te[6] = y.z; te[10] = z.z;\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tmultiply: function ( m, n ) {\n\
\n\
\t\tif ( n !== undefined ) {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\
\t\t\treturn this.multiplyMatrices( m, n );\n\
\n\
\t\t}\n\
\n\
\t\treturn this.multiplyMatrices( this, m );\n\
\n\
\t},\n\
\n\
\tmultiplyMatrices: function ( a, b ) {\n\
\n\
\t\tvar ae = a.elements;\n\
\t\tvar be = b.elements;\n\
\t\tvar te = this.elements;\n\
\n\
\t\tvar a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n\
\t\tvar a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n\
\t\tvar a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n\
\t\tvar a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n\
\n\
\t\tvar b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n\
\t\tvar b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n\
\t\tvar b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n\
\t\tvar b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n\
\n\
\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\
\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\
\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\
\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\
\n\
\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\
\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\
\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\
\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\
\n\
\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\
\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\
\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\
\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\
\n\
\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\
\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\
\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\
\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiplyToArray: function ( a, b, r ) {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tthis.multiplyMatrices( a, b );\n\
\n\
\t\tr[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];\n\
\t\tr[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];\n\
\t\tr[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];\n\
\t\tr[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiplyScalar: function ( s ) {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tte[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;\n\
\t\tte[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;\n\
\t\tte[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;\n\
\t\tte[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmultiplyVector3: function ( vector ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\
\t\treturn vector.applyProjection( this );\n\
\n\
\t},\n\
\n\
\tmultiplyVector4: function ( vector ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\
\t\treturn vector.applyMatrix4( this );\n\
\n\
\t},\n\
\n\
\tmultiplyVector3Array: function() {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( a ) {\n\
\n\
\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\n\
\n\
\t\t\t\tv1.x = a[ i ];\n\
\t\t\t\tv1.y = a[ i + 1 ];\n\
\t\t\t\tv1.z = a[ i + 2 ];\n\
\n\
\t\t\t\tv1.applyProjection( this );\n\
\n\
\t\t\t\ta[ i ]     = v1.x;\n\
\t\t\t\ta[ i + 1 ] = v1.y;\n\
\t\t\t\ta[ i + 2 ] = v1.z;\n\
\n\
\t\t\t}\n\
\n\
\t\t\treturn a;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\trotateAxis: function ( v ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\
\n\
\t\tv.transformDirection( this );\n\
\n\
\t},\n\
\n\
\tcrossVector: function ( vector ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\
\t\treturn vector.applyMatrix4( this );\n\
\n\
\t},\n\
\n\
\tdeterminant: function () {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tvar n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n\
\t\tvar n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n\
\t\tvar n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n\
\t\tvar n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n\
\n\
\t\t//TODO: make this more efficient\n\
\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\
\n\
\t\treturn (\n\
\t\t\tn41 * (\n\
\t\t\t\t+n14 * n23 * n32\n\
\t\t\t\t-n13 * n24 * n32\n\
\t\t\t\t-n14 * n22 * n33\n\
\t\t\t\t+n12 * n24 * n33\n\
\t\t\t\t+n13 * n22 * n34\n\
\t\t\t\t-n12 * n23 * n34\n\
\t\t\t) +\n\
\t\t\tn42 * (\n\
\t\t\t\t+n11 * n23 * n34\n\
\t\t\t\t-n11 * n24 * n33\n\
\t\t\t\t+n14 * n21 * n33\n\
\t\t\t\t-n13 * n21 * n34\n\
\t\t\t\t+n13 * n24 * n31\n\
\t\t\t\t-n14 * n23 * n31\n\
\t\t\t) +\n\
\t\t\tn43 * (\n\
\t\t\t\t+n11 * n24 * n32\n\
\t\t\t\t-n11 * n22 * n34\n\
\t\t\t\t-n14 * n21 * n32\n\
\t\t\t\t+n12 * n21 * n34\n\
\t\t\t\t+n14 * n22 * n31\n\
\t\t\t\t-n12 * n24 * n31\n\
\t\t\t) +\n\
\t\t\tn44 * (\n\
\t\t\t\t-n13 * n22 * n31\n\
\t\t\t\t-n11 * n23 * n32\n\
\t\t\t\t+n11 * n22 * n33\n\
\t\t\t\t+n13 * n21 * n32\n\
\t\t\t\t-n12 * n21 * n33\n\
\t\t\t\t+n12 * n23 * n31\n\
\t\t\t)\n\
\n\
\t\t);\n\
\n\
\t},\n\
\n\
\ttranspose: function () {\n\
\n\
\t\tvar te = this.elements;\n\
\t\tvar tmp;\n\
\n\
\t\ttmp = te[1]; te[1] = te[4]; te[4] = tmp;\n\
\t\ttmp = te[2]; te[2] = te[8]; te[8] = tmp;\n\
\t\ttmp = te[6]; te[6] = te[9]; te[9] = tmp;\n\
\n\
\t\ttmp = te[3]; te[3] = te[12]; te[12] = tmp;\n\
\t\ttmp = te[7]; te[7] = te[13]; te[13] = tmp;\n\
\t\ttmp = te[11]; te[11] = te[14]; te[14] = tmp;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tflattenToArray: function ( flat ) {\n\
\n\
\t\tvar te = this.elements;\n\
\t\tflat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];\n\
\t\tflat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];\n\
\t\tflat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];\n\
\t\tflat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];\n\
\n\
\t\treturn flat;\n\
\n\
\t},\n\
\n\
\tflattenToArrayOffset: function( flat, offset ) {\n\
\n\
\t\tvar te = this.elements;\n\
\t\tflat[ offset ] = te[0];\n\
\t\tflat[ offset + 1 ] = te[1];\n\
\t\tflat[ offset + 2 ] = te[2];\n\
\t\tflat[ offset + 3 ] = te[3];\n\
\n\
\t\tflat[ offset + 4 ] = te[4];\n\
\t\tflat[ offset + 5 ] = te[5];\n\
\t\tflat[ offset + 6 ] = te[6];\n\
\t\tflat[ offset + 7 ] = te[7];\n\
\n\
\t\tflat[ offset + 8 ]  = te[8];\n\
\t\tflat[ offset + 9 ]  = te[9];\n\
\t\tflat[ offset + 10 ] = te[10];\n\
\t\tflat[ offset + 11 ] = te[11];\n\
\n\
\t\tflat[ offset + 12 ] = te[12];\n\
\t\tflat[ offset + 13 ] = te[13];\n\
\t\tflat[ offset + 14 ] = te[14];\n\
\t\tflat[ offset + 15 ] = te[15];\n\
\n\
\t\treturn flat;\n\
\n\
\t},\n\
\n\
\tgetPosition: function() {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function () {\n\
\n\
\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.' );\n\
\n\
\t\t\tvar te = this.elements;\n\
\t\t\treturn v1.set( te[12], te[13], te[14] );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tsetPosition: function ( v ) {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tte[12] = v.x;\n\
\t\tte[13] = v.y;\n\
\t\tte[14] = v.z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tgetInverse: function ( m, throwOnInvertible ) {\n\
\n\
\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\
\t\tvar te = this.elements;\n\
\t\tvar me = m.elements;\n\
\n\
\t\tvar n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];\n\
\t\tvar n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];\n\
\t\tvar n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];\n\
\t\tvar n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];\n\
\n\
\t\tte[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;\n\
\t\tte[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;\n\
\t\tte[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;\n\
\t\tte[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;\n\
\t\tte[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;\n\
\t\tte[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;\n\
\t\tte[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;\n\
\t\tte[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;\n\
\t\tte[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;\n\
\t\tte[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;\n\
\t\tte[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;\n\
\t\tte[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;\n\
\t\tte[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;\n\
\t\tte[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;\n\
\t\tte[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;\n\
\t\tte[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;\n\
\n\
\t\tvar det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\n\
\n\
\t\tif ( det == 0 ) {\n\
\n\
\t\t\tvar msg = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\
\n\
\t\t\tif ( throwOnInvertible || false ) {\n\
\n\
\t\t\t\tthrow new Error( msg ); \n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tconsole.warn( msg );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tthis.identity();\n\
\n\
\t\t\treturn this;\n\
\t\t}\n\
\n\
\t\tthis.multiplyScalar( 1 / det );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttranslate: function ( v ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .translate() has been removed.');\n\
\n\
\t},\n\
\n\
\trotateX: function ( angle ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateX() has been removed.');\n\
\n\
\t},\n\
\n\
\trotateY: function ( angle ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateY() has been removed.');\n\
\n\
\t},\n\
\n\
\trotateZ: function ( angle ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateZ() has been removed.');\n\
\n\
\t},\n\
\n\
\trotateByAxis: function ( axis, angle ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateByAxis() has been removed.');\n\
\n\
\t},\n\
\n\
\tscale: function ( v ) {\n\
\n\
\t\tvar te = this.elements;\n\
\t\tvar x = v.x, y = v.y, z = v.z;\n\
\n\
\t\tte[0] *= x; te[4] *= y; te[8] *= z;\n\
\t\tte[1] *= x; te[5] *= y; te[9] *= z;\n\
\t\tte[2] *= x; te[6] *= y; te[10] *= z;\n\
\t\tte[3] *= x; te[7] *= y; te[11] *= z;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tgetMaxScaleOnAxis: function () {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n\
\t\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n\
\t\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\
\n\
\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\n\
\n\
\t},\n\
\n\
\tmakeTranslation: function ( x, y, z ) {\n\
\n\
\t\tthis.set(\n\
\n\
\t\t\t1, 0, 0, x,\n\
\t\t\t0, 1, 0, y,\n\
\t\t\t0, 0, 1, z,\n\
\t\t\t0, 0, 0, 1\n\
\n\
\t\t);\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmakeRotationX: function ( theta ) {\n\
\n\
\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\
\n\
\t\tthis.set(\n\
\n\
\t\t\t1, 0,  0, 0,\n\
\t\t\t0, c, -s, 0,\n\
\t\t\t0, s,  c, 0,\n\
\t\t\t0, 0,  0, 1\n\
\n\
\t\t);\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmakeRotationY: function ( theta ) {\n\
\n\
\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\
\n\
\t\tthis.set(\n\
\n\
\t\t\t c, 0, s, 0,\n\
\t\t\t 0, 1, 0, 0,\n\
\t\t\t-s, 0, c, 0,\n\
\t\t\t 0, 0, 0, 1\n\
\n\
\t\t);\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmakeRotationZ: function ( theta ) {\n\
\n\
\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\
\n\
\t\tthis.set(\n\
\n\
\t\t\tc, -s, 0, 0,\n\
\t\t\ts,  c, 0, 0,\n\
\t\t\t0,  0, 1, 0,\n\
\t\t\t0,  0, 0, 1\n\
\n\
\t\t);\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmakeRotationAxis: function ( axis, angle ) {\n\
\n\
\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\
\n\
\t\tvar c = Math.cos( angle );\n\
\t\tvar s = Math.sin( angle );\n\
\t\tvar t = 1 - c;\n\
\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\
\t\tvar tx = t * x, ty = t * y;\n\
\n\
\t\tthis.set(\n\
\n\
\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\
\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\
\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\
\t\t\t0, 0, 0, 1\n\
\n\
\t\t);\n\
\n\
\t\t return this;\n\
\n\
\t},\n\
\n\
\tmakeScale: function ( x, y, z ) {\n\
\n\
\t\tthis.set(\n\
\n\
\t\t\tx, 0, 0, 0,\n\
\t\t\t0, y, 0, 0,\n\
\t\t\t0, 0, z, 0,\n\
\t\t\t0, 0, 0, 1\n\
\n\
\t\t);\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcompose: function ( position, quaternion, scale ) {\n\
\n\
\t\tthis.makeRotationFromQuaternion( quaternion );\n\
\t\tthis.scale( scale );\n\
\t\tthis.setPosition( position );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tdecompose: function () {\n\
\n\
\t\tvar vector = new THREE.Vector3();\n\
\t\tvar matrix = new THREE.Matrix4();\n\
\n\
\t\treturn function ( position, quaternion, scale ) {\n\
\n\
\t\t\tvar te = this.elements;\n\
\n\
\t\t\tvar sx = vector.set( te[0], te[1], te[2] ).length();\n\
\t\t\tvar sy = vector.set( te[4], te[5], te[6] ).length();\n\
\t\t\tvar sz = vector.set( te[8], te[9], te[10] ).length();\n\
\n\
\t\t\tposition.x = te[12];\n\
\t\t\tposition.y = te[13];\n\
\t\t\tposition.z = te[14];\n\
\n\
\t\t\t// scale the rotation part\n\
\n\
\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\
\n\
\t\t\tvar invSX = 1 / sx;\n\
\t\t\tvar invSY = 1 / sy;\n\
\t\t\tvar invSZ = 1 / sz;\n\
\n\
\t\t\tmatrix.elements[0] *= invSX;\n\
\t\t\tmatrix.elements[1] *= invSX;\n\
\t\t\tmatrix.elements[2] *= invSX;\n\
\n\
\t\t\tmatrix.elements[4] *= invSY;\n\
\t\t\tmatrix.elements[5] *= invSY;\n\
\t\t\tmatrix.elements[6] *= invSY;\n\
\n\
\t\t\tmatrix.elements[8] *= invSZ;\n\
\t\t\tmatrix.elements[9] *= invSZ;\n\
\t\t\tmatrix.elements[10] *= invSZ;\n\
\n\
\t\t\tquaternion.setFromRotationMatrix( matrix );\n\
\n\
\t\t\tscale.x = sx;\n\
\t\t\tscale.y = sy;\n\
\t\t\tscale.z = sz;\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\
\n\
\t\tvar te = this.elements;\n\
\t\tvar x = 2 * near / ( right - left );\n\
\t\tvar y = 2 * near / ( top - bottom );\n\
\n\
\t\tvar a = ( right + left ) / ( right - left );\n\
\t\tvar b = ( top + bottom ) / ( top - bottom );\n\
\t\tvar c = - ( far + near ) / ( far - near );\n\
\t\tvar d = - 2 * far * near / ( far - near );\n\
\n\
\t\tte[0] = x;\tte[4] = 0;\tte[8] = a;\tte[12] = 0;\n\
\t\tte[1] = 0;\tte[5] = y;\tte[9] = b;\tte[13] = 0;\n\
\t\tte[2] = 0;\tte[6] = 0;\tte[10] = c;\tte[14] = d;\n\
\t\tte[3] = 0;\tte[7] = 0;\tte[11] = - 1;\tte[15] = 0;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tmakePerspective: function ( fov, aspect, near, far ) {\n\
\n\
\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\n\
\t\tvar ymin = - ymax;\n\
\t\tvar xmin = ymin * aspect;\n\
\t\tvar xmax = ymax * aspect;\n\
\n\
\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\
\n\
\t},\n\
\n\
\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\
\n\
\t\tvar te = this.elements;\n\
\t\tvar w = right - left;\n\
\t\tvar h = top - bottom;\n\
\t\tvar p = far - near;\n\
\n\
\t\tvar x = ( right + left ) / w;\n\
\t\tvar y = ( top + bottom ) / h;\n\
\t\tvar z = ( far + near ) / p;\n\
\n\
\t\tte[0] = 2 / w;\tte[4] = 0;\tte[8] = 0;\tte[12] = -x;\n\
\t\tte[1] = 0;\tte[5] = 2 / h;\tte[9] = 0;\tte[13] = -y;\n\
\t\tte[2] = 0;\tte[6] = 0;\tte[10] = -2/p;\tte[14] = -z;\n\
\t\tte[3] = 0;\tte[7] = 0;\tte[11] = 0;\tte[15] = 1;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tfromArray: function ( array ) {\n\
\n\
\t\tthis.elements.set( array );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttoArray: function () {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\treturn [\n\
\t\t\tte[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\n\
\t\t\tte[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\n\
\t\t\tte[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\n\
\t\t\tte[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\n\
\t\t];\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\tvar te = this.elements;\n\
\n\
\t\treturn new THREE.Matrix4(\n\
\n\
\t\t\tte[0], te[4], te[8], te[12],\n\
\t\t\tte[1], te[5], te[9], te[13],\n\
\t\t\tte[2], te[6], te[10], te[14],\n\
\t\t\tte[3], te[7], te[11], te[15]\n\
\n\
\t\t);\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
THREE.Ray = function ( origin, direction ) {\n\
\n\
\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\
\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\
\n\
};\n\
\n\
THREE.Ray.prototype = {\n\
\n\
\tconstructor: THREE.Ray,\n\
\n\
\tset: function ( origin, direction ) {\n\
\n\
\t\tthis.origin.copy( origin );\n\
\t\tthis.direction.copy( direction );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcopy: function ( ray ) {\n\
\n\
\t\tthis.origin.copy( ray.origin );\n\
\t\tthis.direction.copy( ray.direction );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tat: function ( t, optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\n\
\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\
\n\
\t},\n\
\n\
\trecast: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( t ) {\n\
\n\
\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tclosestPointToPoint: function ( point, optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\t\tresult.subVectors( point, this.origin );\n\
\t\tvar directionDistance = result.dot( this.direction );\n\
\n\
\t\tif ( directionDistance < 0 ) {\n\
\n\
\t\t\treturn result.copy( this.origin );\n\
\n\
\t\t}\n\
\n\
\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\
\n\
\t},\n\
\n\
\tdistanceToPoint: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( point ) {\n\
\n\
\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\
\n\
\t\t\t// point behind the ray\n\
\n\
\t\t\tif ( directionDistance < 0 ) {\n\
\n\
\t\t\t\treturn this.origin.distanceTo( point );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\
\n\
\t\t\treturn v1.distanceTo( point );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tdistanceSqToSegment: function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\
\n\
\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\n\
\t\t// It returns the min distance between the ray and the segment\n\
\t\t// defined by v0 and v1\n\
\t\t// It can also set two optional targets :\n\
\t\t// - The closest point on the ray\n\
\t\t// - The closest point on the segment\n\
\n\
\t\tvar segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );\n\
\t\tvar segDir = v1.clone().sub( v0 ).normalize();\n\
\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\
\t\tvar diff = this.origin.clone().sub( segCenter );\n\
\t\tvar a01 = - this.direction.dot( segDir );\n\
\t\tvar b0 = diff.dot( this.direction );\n\
\t\tvar b1 = - diff.dot( segDir );\n\
\t\tvar c = diff.lengthSq();\n\
\t\tvar det = Math.abs( 1 - a01 * a01 );\n\
\t\tvar s0, s1, sqrDist, extDet;\n\
\n\
\t\tif ( det >= 0 ) {\n\
\n\
\t\t\t// The ray and segment are not parallel.\n\
\n\
\t\t\ts0 = a01 * b1 - b0;\n\
\t\t\ts1 = a01 * b0 - b1;\n\
\t\t\textDet = segExtent * det;\n\
\n\
\t\t\tif ( s0 >= 0 ) {\n\
\n\
\t\t\t\tif ( s1 >= - extDet ) {\n\
\n\
\t\t\t\t\tif ( s1 <= extDet ) {\n\
\n\
\t\t\t\t\t\t// region 0\n\
\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\
\n\
\t\t\t\t\t\tvar invDet = 1 / det;\n\
\t\t\t\t\t\ts0 *= invDet;\n\
\t\t\t\t\t\ts1 *= invDet;\n\
\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t// region 1\n\
\n\
\t\t\t\t\t\ts1 = segExtent;\n\
\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0) );\n\
\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t// region 5\n\
\n\
\t\t\t\t\ts1 = - segExtent;\n\
\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0) );\n\
\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tif ( s1 <= - extDet) {\n\
\n\
\t\t\t\t\t// region 4\n\
\n\
\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\
\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\
\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\
\n\
\t\t\t\t} else if ( s1 <= extDet ) {\n\
\n\
\t\t\t\t\t// region 3\n\
\n\
\t\t\t\t\ts0 = 0;\n\
\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\
\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t// region 2\n\
\n\
\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\
\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\
\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\t// Ray and segment are parallel.\n\
\n\
\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\
\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\
\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\
\n\
\t\t}\n\
\n\
\t\tif ( optionalPointOnRay ) {\n\
\n\
\t\t\toptionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );\n\
\n\
\t\t}\n\
\n\
\t\tif ( optionalPointOnSegment ) {\n\
\n\
\t\t\toptionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );\n\
\n\
\t\t}\n\
\n\
\t\treturn sqrDist;\n\
\n\
\t},\n\
\n\
\tisIntersectionSphere: function ( sphere ) {\n\
\n\
\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\
\n\
\t},\n\
\n\
\tisIntersectionPlane: function ( plane ) {\n\
\n\
\t\t// check if the ray lies on the plane first\n\
\n\
\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\
\n\
\t\tif ( distToPoint === 0 ) {\n\
\n\
\t\t\treturn true;\n\
\n\
\t\t}\n\
\n\
\t\tvar denominator = plane.normal.dot( this.direction );\n\
\n\
\t\tif ( denominator * distToPoint < 0 ) {\n\
\n\
\t\t\treturn true\n\
\n\
\t\t}\n\
\n\
\t\t// ray origin is behind the plane (and is pointing behind it)\n\
\n\
\t\treturn false;\n\
\n\
\t},\n\
\n\
\tdistanceToPlane: function ( plane ) {\n\
\n\
\t\tvar denominator = plane.normal.dot( this.direction );\n\
\t\tif ( denominator == 0 ) {\n\
\n\
\t\t\t// line is coplanar, return origin\n\
\t\t\tif( plane.distanceToPoint( this.origin ) == 0 ) {\n\
\n\
\t\t\t\treturn 0;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\
\n\
\t\t\treturn null;\n\
\n\
\t\t}\n\
\n\
\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\
\n\
\t\t// Return if the ray never intersects the plane\n\
\n\
\t\treturn t >= 0 ? t :  null;\n\
\n\
\t},\n\
\n\
\tintersectPlane: function ( plane, optionalTarget ) {\n\
\n\
\t\tvar t = this.distanceToPlane( plane );\n\
\n\
\t\tif ( t === null ) {\n\
\n\
\t\t\treturn null;\n\
\t\t}\n\
\n\
\t\treturn this.at( t, optionalTarget );\n\
\n\
\t},\n\
\n\
\tisIntersectionBox: function () {\n\
\t\t\n\
\t\tvar v = new THREE.Vector3();\n\
\n\
\t\treturn function ( box ) {\n\
\n\
\t\t\treturn this.intersectBox( box, v ) !== null;\n\
\n\
\t\t}\n\
\n\
\t}(),\n\
\n\
\tintersectBox: function ( box , optionalTarget ) {\n\
\n\
\t\t// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\n\
\n\
\t\tvar tmin,tmax,tymin,tymax,tzmin,tzmax;\n\
\n\
\t\tvar invdirx = 1/this.direction.x,\n\
\t\t\tinvdiry = 1/this.direction.y,\n\
\t\t\tinvdirz = 1/this.direction.z;\n\
\n\
\t\tvar origin = this.origin;\n\
\n\
\t\tif (invdirx >= 0) {\n\
\t\t\t\t\n\
\t\t\ttmin = (box.min.x - origin.x) * invdirx;\n\
\t\t\ttmax = (box.max.x - origin.x) * invdirx;\n\
\n\
\t\t} else { \n\
\n\
\t\t\ttmin = (box.max.x - origin.x) * invdirx;\n\
\t\t\ttmax = (box.min.x - origin.x) * invdirx;\n\
\t\t}\t\t\t\n\
\n\
\t\tif (invdiry >= 0) {\n\
\t\t\n\
\t\t\ttymin = (box.min.y - origin.y) * invdiry;\n\
\t\t\ttymax = (box.max.y - origin.y) * invdiry;\n\
\n\
\t\t} else {\n\
\n\
\t\t\ttymin = (box.max.y - origin.y) * invdiry;\n\
\t\t\ttymax = (box.min.y - origin.y) * invdiry;\n\
\t\t}\n\
\n\
\t\tif ((tmin > tymax) || (tymin > tmax)) return null;\n\
\n\
\t\t// These lines also handle the case where tmin or tmax is NaN\n\
\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\
\t\t\n\
\t\tif (tymin > tmin || tmin !== tmin ) tmin = tymin;\n\
\n\
\t\tif (tymax < tmax || tmax !== tmax ) tmax = tymax;\n\
\n\
\t\tif (invdirz >= 0) {\n\
\t\t\n\
\t\t\ttzmin = (box.min.z - origin.z) * invdirz;\n\
\t\t\ttzmax = (box.max.z - origin.z) * invdirz;\n\
\n\
\t\t} else {\n\
\n\
\t\t\ttzmin = (box.max.z - origin.z) * invdirz;\n\
\t\t\ttzmax = (box.min.z - origin.z) * invdirz;\n\
\t\t}\n\
\n\
\t\tif ((tmin > tzmax) || (tzmin > tmax)) return null;\n\
\n\
\t\tif (tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\
\n\
\t\tif (tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\
\n\
\t\t//return point closest to the ray (positive side)\n\
\n\
\t\tif ( tmax < 0 ) return null;\n\
\n\
\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\
\n\
\t},\n\
\n\
\tintersectTriangle: function() {\n\
\n\
\t\t// Compute the offset origin, edges, and normal.\n\
\t\tvar diff = new THREE.Vector3();\n\
\t\tvar edge1 = new THREE.Vector3();\n\
\t\tvar edge2 = new THREE.Vector3();\n\
\t\tvar normal = new THREE.Vector3();\n\
\n\
\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\n\
\n\
\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\n\
\n\
\t\t\tedge1.subVectors( b, a );\n\
\t\t\tedge2.subVectors( c, a );\n\
\t\t\tnormal.crossVectors( edge1, edge2 );\n\
\n\
\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\
\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\
\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\
\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\
\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\
\t\t\tvar DdN = this.direction.dot( normal );\n\
\t\t\tvar sign;\n\
\n\
\t\t\tif ( DdN > 0 ) {\n\
\n\
\t\t\t\tif ( backfaceCulling ) return null;\n\
\t\t\t\tsign = 1;\n\
\n\
\t\t\t} else if ( DdN < 0 ) {\n\
\n\
\t\t\t\tsign = - 1;\n\
\t\t\t\tDdN = - DdN;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\treturn null;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tdiff.subVectors( this.origin, a );\n\
\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\
\n\
\t\t\t// b1 < 0, no intersection\n\
\t\t\tif ( DdQxE2 < 0 ) {\n\
\n\
\t\t\t\treturn null;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\
\n\
\t\t\t// b2 < 0, no intersection\n\
\t\t\tif ( DdE1xQ < 0 ) {\n\
\n\
\t\t\t\treturn null;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// b1+b2 > 1, no intersection\n\
\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\
\n\
\t\t\t\treturn null;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// Line intersects triangle, check if ray does.\n\
\t\t\tvar QdN = - sign * diff.dot( normal );\n\
\n\
\t\t\t// t < 0, no intersection\n\
\t\t\tif ( QdN < 0 ) {\n\
\n\
\t\t\t\treturn null;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// Ray intersects triangle.\n\
\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\
\t\n\
\t\t}\n\
\t\n\
\t}(),\n\
\n\
\tapplyMatrix4: function ( matrix4 ) {\n\
\n\
\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\
\t\tthis.origin.applyMatrix4( matrix4 );\n\
\t\tthis.direction.sub( this.origin );\n\
\t\tthis.direction.normalize();\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\tequals: function ( ray ) {\n\
\n\
\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Ray().copy( this );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author bhouston / http://exocortex.com\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.Sphere = function ( center, radius ) {\n\
\n\
\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\
\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\
\n\
};\n\
\n\
THREE.Sphere.prototype = {\n\
\n\
\tconstructor: THREE.Sphere,\n\
\n\
\tset: function ( center, radius ) {\n\
\n\
\t\tthis.center.copy( center );\n\
\t\tthis.radius = radius;\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\n\
\tsetFromPoints: function () {\n\
\n\
\t\tvar box = new THREE.Box3();\n\
\n\
\t\treturn function ( points, optionalCenter )  {\n\
\n\
\t\t\tvar center = this.center;\n\
\n\
\t\t\tif ( optionalCenter !== undefined ) {\n\
\n\
\t\t\t\tcenter.copy( optionalCenter );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tbox.setFromPoints( points ).center( center );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar maxRadiusSq = 0;\n\
\n\
\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\
\n\
\t\t\treturn this;\t\t\t\n\
 \t\t\n\
 \t\t};\n\
\n\
\t}(),\n\
\n\
\tcopy: function ( sphere ) {\n\
\n\
\t\tthis.center.copy( sphere.center );\n\
\t\tthis.radius = sphere.radius;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tempty: function () {\n\
\n\
\t\treturn ( this.radius <= 0 );\n\
\n\
\t},\n\
\n\
\tcontainsPoint: function ( point ) {\n\
\n\
\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\
\n\
\t},\n\
\n\
\tdistanceToPoint: function ( point ) {\n\
\n\
\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\
\n\
\t},\n\
\n\
\tintersectsSphere: function ( sphere ) {\n\
\n\
\t\tvar radiusSum = this.radius + sphere.radius;\n\
\n\
\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\
\n\
\t},\n\
\n\
\tclampPoint: function ( point, optionalTarget ) {\n\
\n\
\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\t\tresult.copy( point );\n\
\n\
\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\
\n\
\t\t\tresult.sub( this.center ).normalize();\n\
\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\
\n\
\t\t}\n\
\n\
\t\treturn result;\n\
\n\
\t},\n\
\n\
\tgetBoundingBox: function ( optionalTarget ) {\n\
\n\
\t\tvar box = optionalTarget || new THREE.Box3();\n\
\n\
\t\tbox.set( this.center, this.center );\n\
\t\tbox.expandByScalar( this.radius );\n\
\n\
\t\treturn box;\n\
\n\
\t},\n\
\n\
\tapplyMatrix4: function ( matrix ) {\n\
\n\
\t\tthis.center.applyMatrix4( matrix );\n\
\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\ttranslate: function ( offset ) {\n\
\n\
\t\tthis.center.add( offset );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tequals: function ( sphere ) {\n\
\n\
\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Sphere().copy( this );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\
\n\
\tthis.planes = [\n\
\n\
\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\
\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\
\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\
\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\
\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\
\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\
\n\
\t];\n\
\n\
};\n\
\n\
THREE.Frustum.prototype = {\n\
\n\
\tconstructor: THREE.Frustum,\n\
\n\
\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\
\n\
\t\tvar planes = this.planes;\n\
\n\
\t\tplanes[0].copy( p0 );\n\
\t\tplanes[1].copy( p1 );\n\
\t\tplanes[2].copy( p2 );\n\
\t\tplanes[3].copy( p3 );\n\
\t\tplanes[4].copy( p4 );\n\
\t\tplanes[5].copy( p5 );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcopy: function ( frustum ) {\n\
\n\
\t\tvar planes = this.planes;\n\
\n\
\t\tfor( var i = 0; i < 6; i ++ ) {\n\
\n\
\t\t\tplanes[i].copy( frustum.planes[i] );\n\
\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromMatrix: function ( m ) {\n\
\n\
\t\tvar planes = this.planes;\n\
\t\tvar me = m.elements;\n\
\t\tvar me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n\
\t\tvar me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n\
\t\tvar me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n\
\t\tvar me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\n\
\n\
\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\
\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\
\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\
\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\
\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\
\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tintersectsObject: function () {\n\
\n\
\t\tvar sphere = new THREE.Sphere();\n\
\n\
\t\treturn function ( object ) {\n\
\n\
\t\t\tvar geometry = object.geometry;\n\
\n\
\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\
\n\
\t\t\tsphere.copy( geometry.boundingSphere );\n\
\t\t\tsphere.applyMatrix4( object.matrixWorld );\n\
\n\
\t\t\treturn this.intersectsSphere( sphere );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tintersectsSphere: function ( sphere ) {\n\
\n\
\t\tvar planes = this.planes;\n\
\t\tvar center = sphere.center;\n\
\t\tvar negRadius = -sphere.radius;\n\
\n\
\t\tfor ( var i = 0; i < 6; i ++ ) {\n\
\n\
\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\
\n\
\t\t\tif ( distance < negRadius ) {\n\
\n\
\t\t\t\treturn false;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn true;\n\
\n\
\t},\n\
\n\
\tintersectsBox : function() {\n\
\n\
\t\tvar p1 = new THREE.Vector3(),\n\
\t\t\tp2 = new THREE.Vector3();\n\
\n\
\t\treturn function( box ) {\n\
\n\
\t\t\tvar planes = this.planes;\n\
\t\t\t\n\
\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\
\t\t\t\n\
\t\t\t\tvar plane = planes[i];\n\
\t\t\t\t\n\
\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\
\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\
\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\
\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\
\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\
\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\
\n\
\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\
\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\
\t\t\t\t\n\
\t\t\t\t// if both outside plane, no intersection\n\
\n\
\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\
\t\t\t\t\t\n\
\t\t\t\t\treturn false;\n\
\t\t\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\treturn true;\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\n\
\tcontainsPoint: function ( point ) {\n\
\n\
\t\tvar planes = this.planes;\n\
\n\
\t\tfor ( var i = 0; i < 6; i ++ ) {\n\
\n\
\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\
\n\
\t\t\t\treturn false;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn true;\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Frustum().copy( this );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
THREE.Plane = function ( normal, constant ) {\n\
\n\
\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\
\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\
\n\
};\n\
\n\
THREE.Plane.prototype = {\n\
\n\
\tconstructor: THREE.Plane,\n\
\n\
\tset: function ( normal, constant ) {\n\
\n\
\t\tthis.normal.copy( normal );\n\
\t\tthis.constant = constant;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetComponents: function ( x, y, z, w ) {\n\
\n\
\t\tthis.normal.set( x, y, z );\n\
\t\tthis.constant = w;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\
\n\
\t\tthis.normal.copy( normal );\n\
\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromCoplanarPoints: function() {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\t\tvar v2 = new THREE.Vector3();\n\
\n\
\t\treturn function ( a, b, c ) {\n\
\n\
\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\
\n\
\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\
\n\
\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\n\
\tcopy: function ( plane ) {\n\
\n\
\t\tthis.normal.copy( plane.normal );\n\
\t\tthis.constant = plane.constant;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tnormalize: function () {\n\
\n\
\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\
\n\
\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\
\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\
\t\tthis.constant *= inverseNormalLength;\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tnegate: function () {\n\
\n\
\t\tthis.constant *= -1;\n\
\t\tthis.normal.negate();\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tdistanceToPoint: function ( point ) {\n\
\n\
\t\treturn this.normal.dot( point ) + this.constant;\n\
\n\
\t},\n\
\n\
\tdistanceToSphere: function ( sphere ) {\n\
\n\
\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\
\n\
\t},\n\
\n\
\tprojectPoint: function ( point, optionalTarget ) {\n\
\n\
\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\
\n\
\t},\n\
\n\
\torthoPoint: function ( point, optionalTarget ) {\n\
\n\
\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\
\n\
\t},\n\
\n\
\tisIntersectionLine: function ( line ) {\n\
\n\
\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\
\n\
\t\tvar startSign = this.distanceToPoint( line.start );\n\
\t\tvar endSign = this.distanceToPoint( line.end );\n\
\n\
\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\
\n\
\t},\n\
\n\
\tintersectLine: function() {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( line, optionalTarget ) {\n\
\n\
\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\n\
\t\t\tvar direction = line.delta( v1 );\n\
\n\
\t\t\tvar denominator = this.normal.dot( direction );\n\
\n\
\t\t\tif ( denominator == 0 ) {\n\
\n\
\t\t\t\t// line is coplanar, return origin\n\
\t\t\t\tif( this.distanceToPoint( line.start ) == 0 ) {\n\
\n\
\t\t\t\t\treturn result.copy( line.start );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// Unsure if this is the correct method to handle this case.\n\
\t\t\t\treturn undefined;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\
\n\
\t\t\tif( t < 0 || t > 1 ) {\n\
\n\
\t\t\t\treturn undefined;\n\
\n\
\t\t\t}\n\
\n\
\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\n\
\tcoplanarPoint: function ( optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\
\n\
\t},\n\
\n\
\tapplyMatrix4: function() {\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\t\tvar v2 = new THREE.Vector3();\n\
\n\
\t\treturn function ( matrix, optionalNormalMatrix ) {\n\
\n\
\t\t\t// compute new normal based on theory here:\n\
\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\
\t\t\toptionalNormalMatrix = optionalNormalMatrix || new THREE.Matrix3().getNormalMatrix( matrix );\n\
\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( optionalNormalMatrix );\n\
\n\
\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\n\
\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\n\
\n\
\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\ttranslate: function ( offset ) {\n\
\n\
\t\tthis.constant = this.constant - offset.dot( this.normal );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tequals: function ( plane ) {\n\
\n\
\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Plane().copy( this );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.Math = {\n\
\n\
\tPI2: Math.PI * 2,\n\
\n\
\tgenerateUUID: function () {\n\
\n\
\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\
\t\t\n\
\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\
\t\tvar uuid = new Array(36);\n\
\t\tvar rnd = 0, r;\n\
\n\
\t\treturn function () {\n\
\n\
\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\
\n\
\t\t\t\tif ( i == 8 || i == 13 || i == 18 || i == 23 ) {\n\
\t\t\t\n\
\t\t\t\t\tuuid[ i ] = '-';\n\
\t\t\t\n\
\t\t\t\t} else if ( i == 14 ) {\n\
\t\t\t\n\
\t\t\t\t\tuuid[ i ] = '4';\n\
\t\t\t\n\
\t\t\t\t} else {\n\
\t\t\t\n\
\t\t\t\t\tif (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\n\
\t\t\t\t\tr = rnd & 0xf;\n\
\t\t\t\t\trnd = rnd >> 4;\n\
\t\t\t\t\tuuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n\
\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t\t\n\
\t\t\treturn uuid.join('');\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\t// Clamp value to range <a, b>\n\
\n\
\tclamp: function ( x, a, b ) {\n\
\n\
\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\n\
\n\
\t},\n\
\n\
\t// Clamp value to range <a, inf)\n\
\n\
\tclampBottom: function ( x, a ) {\n\
\n\
\t\treturn x < a ? a : x;\n\
\n\
\t},\n\
\n\
\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\
\n\
\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\
\n\
\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\
\n\
\t},\n\
\n\
\t// http://en.wikipedia.org/wiki/Smoothstep\n\
\n\
\tsmoothstep: function ( x, min, max ) {\n\
\n\
\t\tif ( x <= min ) return 0;\n\
\t\tif ( x >= max ) return 1;\n\
\n\
\t\tx = ( x - min )/( max - min );\n\
\n\
\t\treturn x*x*(3 - 2*x);\n\
\n\
\t},\n\
\n\
\tsmootherstep: function ( x, min, max ) {\n\
\n\
\t\tif ( x <= min ) return 0;\n\
\t\tif ( x >= max ) return 1;\n\
\n\
\t\tx = ( x - min )/( max - min );\n\
\n\
\t\treturn x*x*x*(x*(x*6 - 15) + 10);\n\
\n\
\t},\n\
\n\
\t// Random float from <0, 1> with 16 bits of randomness\n\
\t// (standard Math.random() creates repetitive patterns when applied over larger space)\n\
\n\
\trandom16: function () {\n\
\n\
\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\n\
\n\
\t},\n\
\n\
\t// Random integer from <low, high> interval\n\
\n\
\trandInt: function ( low, high ) {\n\
\n\
\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\
\n\
\t},\n\
\n\
\t// Random float from <low, high> interval\n\
\n\
\trandFloat: function ( low, high ) {\n\
\n\
\t\treturn low + Math.random() * ( high - low );\n\
\n\
\t},\n\
\n\
\t// Random float from <-range/2, range/2> interval\n\
\n\
\trandFloatSpread: function ( range ) {\n\
\n\
\t\treturn range * ( 0.5 - Math.random() );\n\
\n\
\t},\n\
\n\
\tsign: function ( x ) {\n\
\n\
\t\treturn ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );\n\
\n\
\t},\n\
\n\
\tdegToRad: function() {\n\
\n\
\t\tvar degreeToRadiansFactor = Math.PI / 180;\n\
\n\
\t\treturn function ( degrees ) {\n\
\n\
\t\t\treturn degrees * degreeToRadiansFactor;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tradToDeg: function() {\n\
\n\
\t\tvar radianToDegreesFactor = 180 / Math.PI;\n\
\n\
\t\treturn function ( radians ) {\n\
\n\
\t\t\treturn radians * radianToDegreesFactor;\n\
\n\
\t\t};\n\
\n\
\t}()\n\
\n\
};\n\
\n\
/**\n\
 * Spline from Tween.js, slightly optimized (and trashed)\n\
 * http://sole.github.com/tween.js/examples/05_spline.html\n\
 *\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Spline = function ( points ) {\n\
\n\
\tthis.points = points;\n\
\n\
\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\
\tpoint, intPoint, weight, w2, w3,\n\
\tpa, pb, pc, pd;\n\
\n\
\tthis.initFromArray = function( a ) {\n\
\n\
\t\tthis.points = [];\n\
\n\
\t\tfor ( var i = 0; i < a.length; i++ ) {\n\
\n\
\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tthis.getPoint = function ( k ) {\n\
\n\
\t\tpoint = ( this.points.length - 1 ) * k;\n\
\t\tintPoint = Math.floor( point );\n\
\t\tweight = point - intPoint;\n\
\n\
\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\
\t\tc[ 1 ] = intPoint;\n\
\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\
\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\
\n\
\t\tpa = this.points[ c[ 0 ] ];\n\
\t\tpb = this.points[ c[ 1 ] ];\n\
\t\tpc = this.points[ c[ 2 ] ];\n\
\t\tpd = this.points[ c[ 3 ] ];\n\
\n\
\t\tw2 = weight * weight;\n\
\t\tw3 = weight * w2;\n\
\n\
\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\
\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\
\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\
\n\
\t\treturn v3;\n\
\n\
\t};\n\
\n\
\tthis.getControlPointsArray = function () {\n\
\n\
\t\tvar i, p, l = this.points.length,\n\
\t\t\tcoords = [];\n\
\n\
\t\tfor ( i = 0; i < l; i ++ ) {\n\
\n\
\t\t\tp = this.points[ i ];\n\
\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\
\n\
\t\t}\n\
\n\
\t\treturn coords;\n\
\n\
\t};\n\
\n\
\t// approximate length by summing linear segments\n\
\n\
\tthis.getLength = function ( nSubDivisions ) {\n\
\n\
\t\tvar i, index, nSamples, position,\n\
\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\
\t\t\toldPosition = new THREE.Vector3(),\n\
\t\t\ttmpVec = new THREE.Vector3(),\n\
\t\t\tchunkLengths = [],\n\
\t\t\ttotalLength = 0;\n\
\n\
\t\t// first point has 0 length\n\
\n\
\t\tchunkLengths[ 0 ] = 0;\n\
\n\
\t\tif ( !nSubDivisions ) nSubDivisions = 100;\n\
\n\
\t\tnSamples = this.points.length * nSubDivisions;\n\
\n\
\t\toldPosition.copy( this.points[ 0 ] );\n\
\n\
\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\
\n\
\t\t\tindex = i / nSamples;\n\
\n\
\t\t\tposition = this.getPoint( index );\n\
\t\t\ttmpVec.copy( position );\n\
\n\
\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\
\n\
\t\t\toldPosition.copy( position );\n\
\n\
\t\t\tpoint = ( this.points.length - 1 ) * index;\n\
\t\t\tintPoint = Math.floor( point );\n\
\n\
\t\t\tif ( intPoint != oldIntPoint ) {\n\
\n\
\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\
\t\t\t\toldIntPoint = intPoint;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// last point ends with total length\n\
\n\
\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\
\n\
\t\treturn { chunks: chunkLengths, total: totalLength };\n\
\n\
\t};\n\
\n\
\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\
\n\
\t\tvar i, j,\n\
\t\t\tindex, indexCurrent, indexNext,\n\
\t\t\tlinearDistance, realDistance,\n\
\t\t\tsampling, position,\n\
\t\t\tnewpoints = [],\n\
\t\t\ttmpVec = new THREE.Vector3(),\n\
\t\t\tsl = this.getLength();\n\
\n\
\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\
\n\
\t\tfor ( i = 1; i < this.points.length; i++ ) {\n\
\n\
\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\
\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\
\n\
\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\
\n\
\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\
\n\
\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\
\t\t\tindexNext = i / ( this.points.length - 1 );\n\
\n\
\t\t\tfor ( j = 1; j < sampling - 1; j++ ) {\n\
\n\
\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\
\n\
\t\t\t\tposition = this.getPoint( index );\n\
\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\
\n\
\t\t}\n\
\n\
\t\tthis.points = newpoints;\n\
\n\
\t};\n\
\n\
\t// Catmull-Rom\n\
\n\
\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\
\n\
\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\
\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\
\n\
\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\
\n\
\t};\n\
\n\
};\n\
\n\
/**\n\
 * @author bhouston / http://exocortex.com\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.Triangle = function ( a, b, c ) {\n\
\n\
\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\
\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\
\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\
\n\
};\n\
\n\
THREE.Triangle.normal = function() {\n\
\n\
\tvar v0 = new THREE.Vector3();\n\
\n\
\treturn function ( a, b, c, optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\n\
\t\tresult.subVectors( c, b );\n\
\t\tv0.subVectors( a, b );\n\
\t\tresult.cross( v0 );\n\
\n\
\t\tvar resultLengthSq = result.lengthSq();\n\
\t\tif( resultLengthSq > 0 ) {\n\
\n\
\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\
\n\
\t\t}\n\
\n\
\t\treturn result.set( 0, 0, 0 );\n\
\n\
\t};\n\
\n\
}();\n\
\n\
// static/instance method to calculate barycoordinates\n\
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\
THREE.Triangle.barycoordFromPoint = function() {\n\
\n\
\tvar v0 = new THREE.Vector3();\n\
\tvar v1 = new THREE.Vector3();\n\
\tvar v2 = new THREE.Vector3();\n\
\n\
\treturn function ( point, a, b, c, optionalTarget ) {\n\
\n\
\t\tv0.subVectors( c, a );\n\
\t\tv1.subVectors( b, a );\n\
\t\tv2.subVectors( point, a );\n\
\n\
\t\tvar dot00 = v0.dot( v0 );\n\
\t\tvar dot01 = v0.dot( v1 );\n\
\t\tvar dot02 = v0.dot( v2 );\n\
\t\tvar dot11 = v1.dot( v1 );\n\
\t\tvar dot12 = v1.dot( v2 );\n\
\n\
\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\n\
\t\t// colinear or singular triangle\n\
\t\tif( denom == 0 ) {\n\
\t\t\t// arbitrary location outside of triangle?\n\
\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\
\t\t\treturn result.set( -2, -1, -1 );\n\
\t\t}\n\
\n\
\t\tvar invDenom = 1 / denom;\n\
\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\
\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\
\n\
\t\t// barycoordinates must always sum to 1\n\
\t\treturn result.set( 1 - u - v, v, u );\n\
\n\
\t};\n\
\n\
}();\n\
\n\
THREE.Triangle.containsPoint = function() {\n\
\n\
\tvar v1 = new THREE.Vector3();\n\
\n\
\treturn function ( point, a, b, c ) {\n\
\n\
\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\
\n\
\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\
\n\
\t};\n\
\n\
}();\n\
\n\
THREE.Triangle.prototype = {\n\
\n\
\tconstructor: THREE.Triangle,\n\
\n\
\tset: function ( a, b, c ) {\n\
\n\
\t\tthis.a.copy( a );\n\
\t\tthis.b.copy( b );\n\
\t\tthis.c.copy( c );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\
\n\
\t\tthis.a.copy( points[i0] );\n\
\t\tthis.b.copy( points[i1] );\n\
\t\tthis.c.copy( points[i2] );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tcopy: function ( triangle ) {\n\
\n\
\t\tthis.a.copy( triangle.a );\n\
\t\tthis.b.copy( triangle.b );\n\
\t\tthis.c.copy( triangle.c );\n\
\n\
\t\treturn this;\n\
\n\
\t},\n\
\n\
\tarea: function() {\n\
\n\
\t\tvar v0 = new THREE.Vector3();\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function () {\n\
\n\
\t\t\tv0.subVectors( this.c, this.b );\n\
\t\t\tv1.subVectors( this.a, this.b );\n\
\n\
\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tmidpoint: function ( optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Vector3();\n\
\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\
\n\
\t},\n\
\n\
\tnormal: function ( optionalTarget ) {\n\
\n\
\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\
\n\
\t},\n\
\n\
\tplane: function ( optionalTarget ) {\n\
\n\
\t\tvar result = optionalTarget || new THREE.Plane();\n\
\n\
\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\
\n\
\t},\n\
\n\
\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\
\n\
\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\
\n\
\t},\n\
\n\
\tcontainsPoint: function ( point ) {\n\
\n\
\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\
\n\
\t},\n\
\n\
\tequals: function ( triangle ) {\n\
\n\
\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\treturn new THREE.Triangle().copy( this );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.Vertex = function ( v ) {\n\
\n\
\tconsole.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')\n\
\treturn v;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.UV = function ( u, v ) {\n\
\n\
\tconsole.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')\n\
\treturn new THREE.Vector2( u, v );\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Clock = function ( autoStart ) {\n\
\n\
\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\
\n\
\tthis.startTime = 0;\n\
\tthis.oldTime = 0;\n\
\tthis.elapsedTime = 0;\n\
\n\
\tthis.running = false;\n\
\n\
};\n\
\n\
THREE.Clock.prototype = {\n\
\n\
\tconstructor: THREE.Clock,\n\
\n\
\tstart: function () {\n\
\n\
\t\tthis.startTime = self.performance !== undefined && self.performance.now !== undefined\n\
\t\t\t\t\t? self.performance.now()\n\
\t\t\t\t\t: Date.now();\n\
\n\
\t\tthis.oldTime = this.startTime;\n\
\t\tthis.running = true;\n\
\t},\n\
\n\
\tstop: function () {\n\
\n\
\t\tthis.getElapsedTime();\n\
\t\tthis.running = false;\n\
\n\
\t},\n\
\n\
\tgetElapsedTime: function () {\n\
\n\
\t\tthis.getDelta();\n\
\t\treturn this.elapsedTime;\n\
\n\
\t},\n\
\n\
\tgetDelta: function () {\n\
\n\
\t\tvar diff = 0;\n\
\n\
\t\tif ( this.autoStart && ! this.running ) {\n\
\n\
\t\t\tthis.start();\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.running ) {\n\
\n\
\t\t\tvar newTime = self.performance !== undefined && self.performance.now !== undefined\n\
\t\t\t\t\t? self.performance.now()\n\
\t\t\t\t\t: Date.now();\n\
\n\
\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\n\
\t\t\tthis.oldTime = newTime;\n\
\n\
\t\t\tthis.elapsedTime += diff;\n\
\n\
\t\t}\n\
\n\
\t\treturn diff;\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * https://github.com/mrdoob/eventdispatcher.js/\n\
 */\n\
\n\
THREE.EventDispatcher = function () {}\n\
\n\
THREE.EventDispatcher.prototype = {\n\
\n\
\tconstructor: THREE.EventDispatcher,\n\
\n\
\tapply: function ( object ) {\n\
\n\
\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\n\
\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\n\
\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\n\
\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\n\
\n\
\t},\n\
\n\
\taddEventListener: function ( type, listener ) {\n\
\n\
\t\tif ( this._listeners === undefined ) this._listeners = {};\n\
\n\
\t\tvar listeners = this._listeners;\n\
\n\
\t\tif ( listeners[ type ] === undefined ) {\n\
\n\
\t\t\tlisteners[ type ] = [];\n\
\n\
\t\t}\n\
\n\
\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\
\n\
\t\t\tlisteners[ type ].push( listener );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\thasEventListener: function ( type, listener ) {\n\
\n\
\t\tif ( this._listeners === undefined ) return false;\n\
\n\
\t\tvar listeners = this._listeners;\n\
\n\
\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\
\n\
\t\t\treturn true;\n\
\n\
\t\t}\n\
\n\
\t\treturn false;\n\
\n\
\t},\n\
\n\
\tremoveEventListener: function ( type, listener ) {\n\
\n\
\t\tif ( this._listeners === undefined ) return;\n\
\n\
\t\tvar listeners = this._listeners;\n\
\t\tvar index = listeners[ type ].indexOf( listener );\n\
\n\
\t\tif ( index !== - 1 ) {\n\
\n\
\t\t\tlisteners[ type ].splice( index, 1 );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tdispatchEvent: function ( event ) {\n\
\n\
\t\tif ( this._listeners === undefined ) return;\n\
\n\
\t\tvar listeners = this._listeners;\n\
\t\tvar listenerArray = listeners[ event.type ];\n\
\n\
\t\tif ( listenerArray !== undefined ) {\n\
\n\
\t\t\tevent.target = this;\n\
\n\
\t\t\tfor ( var i = 0, l = listenerArray.length; i < l; i ++ ) {\n\
\n\
\t\t\t\tlistenerArray[ i ].call( this, event );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author bhouston / http://exocortex.com/\n\
 * @author stephomi / http://stephaneginier.com/\n\
 */\n\
\n\
( function ( THREE ) {\n\
\n\
\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\
\n\
\t\tthis.ray = new THREE.Ray( origin, direction );\n\
\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\
\n\
\t\tthis.near = near || 0;\n\
\t\tthis.far = far || Infinity;\n\
\n\
\t};\n\
\n\
\tvar sphere = new THREE.Sphere();\n\
\tvar localRay = new THREE.Ray();\n\
\tvar facePlane = new THREE.Plane();\n\
\tvar intersectPoint = new THREE.Vector3();\n\
\tvar matrixPosition = new THREE.Vector3();\n\
\n\
\tvar inverseMatrix = new THREE.Matrix4();\n\
\n\
\tvar descSort = function ( a, b ) {\n\
\n\
\t\treturn a.distance - b.distance;\n\
\n\
\t};\n\
\n\
\tvar vA = new THREE.Vector3();\n\
\tvar vB = new THREE.Vector3();\n\
\tvar vC = new THREE.Vector3();\n\
\n\
\tvar intersectObject = function ( object, raycaster, intersects ) {\n\
\n\
\t\tif ( object instanceof THREE.Particle ) {\n\
\n\
\t\t\tmatrixPosition.getPositionFromMatrix( object.matrixWorld );\n\
\t\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\n\
\n\
\t\t\tif ( distance > object.scale.x ) {\n\
\n\
\t\t\t\treturn intersects;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tintersects.push( {\n\
\n\
\t\t\t\tdistance: distance,\n\
\t\t\t\tpoint: object.position,\n\
\t\t\t\tface: null,\n\
\t\t\t\tobject: object\n\
\n\
\t\t\t} );\n\
\n\
\t\t} else if ( object instanceof THREE.LOD ) {\n\
\n\
\t\t\tmatrixPosition.getPositionFromMatrix( object.matrixWorld );\n\
\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\
\n\
\t\t\tintersectObject( object.getObjectForDistance( distance ), raycaster, intersects );\n\
\n\
\t\t} else if ( object instanceof THREE.Mesh ) {\n\
\n\
\t\t\tvar geometry = object.geometry;\n\
\n\
\t\t\t// Checking boundingSphere distance to ray\n\
\n\
\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\
\n\
\t\t\tsphere.copy( geometry.boundingSphere );\n\
\t\t\tsphere.applyMatrix4( object.matrixWorld );\n\
\n\
\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\n\
\n\
\t\t\t\treturn intersects;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// Check boundingBox before continuing\n\
\t\t\t\n\
\t\t\tinverseMatrix.getInverse( object.matrixWorld );  \n\
\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\
\n\
\t\t\tif ( geometry.boundingBox !== null ) {\n\
\n\
\t\t\t\tif ( localRay.isIntersectionBox( geometry.boundingBox ) === false )  {\n\
\n\
\t\t\t\t\treturn intersects;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} \n\
\n\
\t\t\tvar vertices = geometry.vertices;\n\
\n\
\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\
\n\
\t\t\t\tvar material = object.material;\n\
\n\
\t\t\t\tif ( material === undefined ) return intersects;\n\
\t\t\t\tif ( geometry.dynamic === false ) return intersects;\n\
\n\
\t\t\t\tvar a, b, c;\n\
\t\t\t\tvar precision = raycaster.precision;\n\
\n\
\t\t\t\tif ( geometry.attributes.index !== undefined ) {\n\
\n\
\t\t\t\t\tvar offsets = geometry.offsets;\n\
\t\t\t\t\tvar indices = geometry.attributes.index.array;\n\
\t\t\t\t\tvar positions = geometry.attributes.position.array;\n\
\t\t\t\t\tvar offLength = geometry.offsets.length;\n\
\n\
\t\t\t\t\tvar fl = geometry.attributes.index.array.length / 3;\n\
\n\
\t\t\t\t\tfor ( var oi = 0; oi < offLength; ++oi ) {\n\
\n\
\t\t\t\t\t\tvar start = offsets[ oi ].start;\n\
\t\t\t\t\t\tvar count = offsets[ oi ].count;\n\
\t\t\t\t\t\tvar index = offsets[ oi ].index;\n\
\n\
\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\
\n\
\t\t\t\t\t\t\ta = index + indices[ i ];\n\
\t\t\t\t\t\t\tb = index + indices[ i + 1 ]; \n\
\t\t\t\t\t\t\tc = index + indices[ i + 2 ];\n\
\n\
\t\t\t\t\t\t\tvA.set(\n\
\t\t\t\t\t\t\t\tpositions[ a * 3 ],\n\
\t\t\t\t\t\t\t\tpositions[ a * 3 + 1 ],\n\
\t\t\t\t\t\t\t\tpositions[ a * 3 + 2 ]\n\
\t\t\t\t\t\t\t);\n\
\t\t\t\t\t\t\tvB.set(\n\
\t\t\t\t\t\t\t\tpositions[ b * 3 ],\n\
\t\t\t\t\t\t\t\tpositions[ b * 3 + 1 ],\n\
\t\t\t\t\t\t\t\tpositions[ b * 3 + 2 ]\n\
\t\t\t\t\t\t\t);\n\
\t\t\t\t\t\t\tvC.set(\n\
\t\t\t\t\t\t\t\tpositions[ c * 3 ],\n\
\t\t\t\t\t\t\t\tpositions[ c * 3 + 1 ],\n\
\t\t\t\t\t\t\t\tpositions[ c * 3 + 2 ]\n\
\t\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\n\
\n\
\t\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\n\
\n\
\t\t\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\n\
\n\
\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\n\
\n\
\t\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\n\
\n\
\t\t\t\t\t\t\tintersects.push( {\n\
\n\
\t\t\t\t\t\t\t\tdistance: distance,\n\
\t\t\t\t\t\t\t\tpoint: intersectionPoint,\n\
\t\t\t\t\t\t\t\tface: null,\n\
\t\t\t\t\t\t\t\tfaceIndex: null,\n\
\t\t\t\t\t\t\t\tobject: object\n\
\n\
\t\t\t\t\t\t\t} );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tvar offsets = geometry.offsets;\n\
\t\t\t\t\tvar positions = geometry.attributes.position.array;\n\
\t\t\t\t\tvar offLength = geometry.offsets.length;\n\
\n\
\t\t\t\t\tvar fl = geometry.attributes.position.array.length;\n\
\n\
\t\t\t\t\tfor ( var i = 0; i < fl; i += 3 ) {\n\
\n\
\t\t\t\t\t\ta = i;\n\
\t\t\t\t\t\tb = i + 1;\n\
\t\t\t\t\t\tc = i + 2;\n\
\n\
\t\t\t\t\t\tvA.set(\n\
\t\t\t\t\t\t\tpositions[ a * 3 ],\n\
\t\t\t\t\t\t\tpositions[ a * 3 + 1 ],\n\
\t\t\t\t\t\t\tpositions[ a * 3 + 2 ]\n\
\t\t\t\t\t\t);\n\
\t\t\t\t\t\tvB.set(\n\
\t\t\t\t\t\t\tpositions[ b * 3 ],\n\
\t\t\t\t\t\t\tpositions[ b * 3 + 1 ],\n\
\t\t\t\t\t\t\tpositions[ b * 3 + 2 ]\n\
\t\t\t\t\t\t);\n\
\t\t\t\t\t\tvC.set(\n\
\t\t\t\t\t\t\tpositions[ c * 3 ],\n\
\t\t\t\t\t\t\tpositions[ c * 3 + 1 ],\n\
\t\t\t\t\t\t\tpositions[ c * 3 + 2 ]\n\
\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\n\
\n\
\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\n\
\n\
\t\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\n\
\n\
\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\n\
\n\
\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\n\
\n\
\t\t\t\t\t\tintersects.push( {\n\
\n\
\t\t\t\t\t\t\tdistance: distance,\n\
\t\t\t\t\t\t\tpoint: intersectionPoint,\n\
\t\t\t\t\t\t\tface: null,\n\
\t\t\t\t\t\t\tfaceIndex: null,\n\
\t\t\t\t\t\t\tobject: object\n\
\n\
\t\t\t\t\t\t} );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\
\n\
\t\t\t\tvar isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n\
\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material.materials : null;\n\
\n\
\t\t\t\tvar a, b, c, d;\n\
\t\t\t\tvar precision = raycaster.precision;\n\
\n\
\t\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\tvar face = geometry.faces[ f ];\n\
\n\
\t\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;\n\
\n\
\t\t\t\t\tif ( material === undefined ) continue;\n\
\n\
\t\t\t\t\ta = vertices[ face.a ];\n\
\t\t\t\t\tb = vertices[ face.b ];\n\
\t\t\t\t\tc = vertices[ face.c ];\n\
\t\t\t\t\t\n\
\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );\n\
\n\
\t\t\t\t\tif ( intersectionPoint === null ) continue;\n\
\n\
\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\n\
\n\
\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\n\
\n\
\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\n\
\n\
\t\t\t\t\tintersects.push( {\n\
\n\
\t\t\t\t\t\tdistance: distance,\n\
\t\t\t\t\t\tpoint: intersectionPoint,\n\
\t\t\t\t\t\tface: face,\n\
\t\t\t\t\t\tfaceIndex: f,\n\
\t\t\t\t\t\tobject: object\n\
\n\
\t\t\t\t\t} );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( object instanceof THREE.Line ) {\n\
\n\
\t\t\tvar precision = raycaster.linePrecision;\n\
\t\t\tvar precisionSq = precision * precision;\n\
\n\
\t\t\tvar geometry = object.geometry;\n\
\n\
\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\
\n\
\t\t\t// Checking boundingSphere distance to ray\n\
\n\
\t\t\tsphere.copy( geometry.boundingSphere );\n\
\t\t\tsphere.applyMatrix4( object.matrixWorld );\n\
\t\t\t\n\
\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\n\
\n\
\t\t\t\treturn intersects;\n\
\n\
\t\t\t}\n\
\t\t\t\n\
\t\t\tinverseMatrix.getInverse( object.matrixWorld );\n\
\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\
\n\
\t\t\tvar vertices = geometry.vertices;\n\
\t\t\tvar nbVertices = vertices.length;\n\
\t\t\tvar interSegment = new THREE.Vector3();\n\
\t\t\tvar interRay = new THREE.Vector3();\n\
\t\t\tvar step = object.type === THREE.LineStrip ? 1 : 2;\n\
\n\
\t\t\tfor ( var i = 0; i < nbVertices - 1; i = i + step ) {\n\
\n\
\t\t\t\tvar distSq = localRay.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\
\n\
\t\t\t\tif ( distSq > precisionSq ) continue;\n\
\n\
\t\t\t\tvar distance = localRay.origin.distanceTo( interRay );\n\
\n\
\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\
\n\
\t\t\t\tintersects.push( {\n\
\n\
\t\t\t\t\tdistance: distance,\n\
\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\
\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\
\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( object.matrixWorld ),\n\
\t\t\t\t\tface: null,\n\
\t\t\t\t\tfaceIndex: null,\n\
\t\t\t\t\tobject: object\n\
\n\
\t\t\t\t} );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tvar intersectDescendants = function ( object, raycaster, intersects ) {\n\
\n\
\t\tvar descendants = object.getDescendants();\n\
\n\
\t\tfor ( var i = 0, l = descendants.length; i < l; i ++ ) {\n\
\n\
\t\t\tintersectObject( descendants[ i ], raycaster, intersects );\n\
\n\
\t\t}\n\
\t};\n\
\n\
\t//\n\
\n\
\tTHREE.Raycaster.prototype.precision = 0.0001;\n\
\tTHREE.Raycaster.prototype.linePrecision = 1;\n\
\n\
\tTHREE.Raycaster.prototype.set = function ( origin, direction ) {\n\
\n\
\t\tthis.ray.set( origin, direction );\n\
\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\
\n\
\t};\n\
\n\
\tTHREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {\n\
\n\
\t\tvar intersects = [];\n\
\n\
\t\tif ( recursive === true ) {\n\
\n\
\t\t\tintersectDescendants( object, this, intersects );\n\
\n\
\t\t}\n\
\n\
\t\tintersectObject( object, this, intersects );\n\
\n\
\t\tintersects.sort( descSort );\n\
\n\
\t\treturn intersects;\n\
\n\
\t};\n\
\n\
\tTHREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {\n\
\n\
\t\tvar intersects = [];\n\
\n\
\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\
\n\
\t\t\tintersectObject( objects[ i ], this, intersects );\n\
\n\
\t\t\tif ( recursive === true ) {\n\
\n\
\t\t\t\tintersectDescendants( objects[ i ], this, intersects );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tintersects.sort( descSort );\n\
\n\
\t\treturn intersects;\n\
\n\
\t};\n\
\n\
}( THREE ) );\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
 */\n\
\n\
THREE.Object3D = function () {\n\
\n\
\tthis.id = THREE.Object3DIdCount ++;\n\
\tthis.uuid = THREE.Math.generateUUID();\n\
\n\
\tthis.name = '';\n\
\n\
\tthis.parent = undefined;\n\
\tthis.children = [];\n\
\n\
\tthis.up = new THREE.Vector3( 0, 1, 0 );\n\
\n\
\tthis.position = new THREE.Vector3();\n\
\tthis.rotation = new THREE.Euler();\n\
\tthis.quaternion = new THREE.Quaternion();\n\
\tthis.scale = new THREE.Vector3( 1, 1, 1 );\n\
\n\
\t// keep rotation and quaternion in sync\n\
\n\
\tthis.rotation._quaternion = this.quaternion;\n\
\tthis.quaternion._euler = this.rotation;\n\
\n\
\tthis.renderDepth = null;\n\
\n\
\tthis.rotationAutoUpdate = true;\n\
\n\
\tthis.matrix = new THREE.Matrix4();\n\
\tthis.matrixWorld = new THREE.Matrix4();\n\
\n\
\tthis.matrixAutoUpdate = true;\n\
\tthis.matrixWorldNeedsUpdate = true;\n\
\n\
\tthis.visible = true;\n\
\n\
\tthis.castShadow = false;\n\
\tthis.receiveShadow = false;\n\
\n\
\tthis.frustumCulled = true;\n\
\n\
\tthis.userData = {};\n\
\n\
};\n\
\n\
\n\
THREE.Object3D.prototype = {\n\
\n\
\tconstructor: THREE.Object3D,\n\
\n\
\tget eulerOrder () {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .eulerOrder has been moved to Object3D\\'s .rotation.order.' );\n\
\n\
\t\treturn this.rotation.order;\n\
\n\
\t},\n\
\n\
\tset eulerOrder ( value ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .eulerOrder has been moved to Object3D\\'s .rotation.order.' );\n\
\n\
\t\tthis.rotation.order = value;\n\
\n\
\t},\n\
\n\
\tget useQuaternion () {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .useQuaternion has been removed. The library now uses quaternions by default.' );\n\
\n\
\t},\n\
\n\
\tset useQuaternion ( value ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .useQuaternion has been removed. The library now uses quaternions by default.' );\n\
\n\
\t},\n\
\n\
\tapplyMatrix: function () {\n\
\n\
\t\tvar m1 = new THREE.Matrix4();\n\
\n\
\t\treturn function ( matrix ) {\n\
\n\
\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\
\n\
\t\t\tthis.position.getPositionFromMatrix( this.matrix );\n\
\n\
\t\t\tthis.scale.getScaleFromMatrix( this.matrix );\n\
\n\
\t\t\tm1.extractRotation( this.matrix );\n\
\n\
\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\
\n\
\t\t}\n\
\n\
\t}(),\n\
\n\
\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\
\n\
\t\t// assumes axis is normalized\n\
\n\
\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\
\n\
\t},\n\
\n\
\tsetRotationFromEuler: function ( euler ) {\n\
\n\
\t\tthis.quaternion.setFromEuler( euler, true );\n\
\n\
\t},\n\
\n\
\tsetRotationFromMatrix: function ( m ) {\n\
\n\
\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\
\n\
\t\tthis.quaternion.setFromRotationMatrix( m );\n\
\n\
\t},\n\
\n\
\tsetRotationFromQuaternion: function ( q ) {\n\
\n\
\t\t// assumes q is normalized\n\
\n\
\t\tthis.quaternion.copy( q );\n\
\n\
\t},\n\
\n\
\trotateOnAxis: function() {\n\
\n\
\t\t// rotate object on axis in object space\n\
\t\t// axis is assumed to be normalized\n\
\n\
\t\tvar q1 = new THREE.Quaternion();\n\
\n\
\t\treturn function ( axis, angle ) {\n\
\n\
\t\t\tq1.setFromAxisAngle( axis, angle );\n\
\n\
\t\t\tthis.quaternion.multiply( q1 );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t}\n\
\n\
\t}(),\n\
\n\
\trotateX: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\
\n\
\t\treturn function ( angle ) {\n\
\n\
\t\t\treturn this.rotateOnAxis( v1, angle );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\trotateY: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\
\n\
\t\treturn function ( angle ) {\n\
\n\
\t\t\treturn this.rotateOnAxis( v1, angle );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\trotateZ: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\
\n\
\t\treturn function ( angle ) {\n\
\n\
\t\t\treturn this.rotateOnAxis( v1, angle );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\ttranslateOnAxis: function () {\n\
\n\
\t\t// translate object by distance along axis in object space\n\
\t\t// axis is assumed to be normalized\n\
\n\
\t\tvar v1 = new THREE.Vector3();\n\
\n\
\t\treturn function ( axis, distance ) {\n\
\n\
\t\t\tv1.copy( axis );\n\
\n\
\t\t\tv1.applyQuaternion( this.quaternion );\n\
\n\
\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\
\n\
\t\t\treturn this;\n\
\n\
\t\t}\n\
\n\
\t}(),\n\
\n\
\ttranslate: function ( distance, axis ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.' );\n\
\t\treturn this.translateOnAxis( axis, distance );\n\
\n\
\t},\n\
\n\
\ttranslateX: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\
\n\
\t\treturn function ( distance ) {\n\
\n\
\t\t\treturn this.translateOnAxis( v1, distance );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\ttranslateY: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\
\n\
\t\treturn function ( distance ) {\n\
\n\
\t\t\treturn this.translateOnAxis( v1, distance );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\ttranslateZ: function () {\n\
\n\
\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\
\n\
\t\treturn function ( distance ) {\n\
\n\
\t\t\treturn this.translateOnAxis( v1, distance );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tlocalToWorld: function ( vector ) {\n\
\n\
\t\treturn vector.applyMatrix4( this.matrixWorld );\n\
\n\
\t},\n\
\n\
\tworldToLocal: function () {\n\
\n\
\t\tvar m1 = new THREE.Matrix4();\n\
\n\
\t\treturn function ( vector ) {\n\
\n\
\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tlookAt: function () {\n\
\n\
\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\
\n\
\t\tvar m1 = new THREE.Matrix4();\n\
\n\
\t\treturn function ( vector ) {\n\
\n\
\t\t\tm1.lookAt( vector, this.position, this.up );\n\
\n\
\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\tadd: function ( object ) {\n\
\n\
\t\tif ( object === this ) {\n\
\n\
\t\t\tconsole.warn( 'THREE.Object3D.add: An object can\\'t be added as a child of itself.' );\n\
\t\t\treturn;\n\
\n\
\t\t}\n\
\n\
\t\tif ( object instanceof THREE.Object3D ) {\n\
\n\
\t\t\tif ( object.parent !== undefined ) {\n\
\n\
\t\t\t\tobject.parent.remove( object );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tobject.parent = this;\n\
\t\t\tobject.dispatchEvent( { type: 'added' } );\n\
\n\
\t\t\tthis.children.push( object );\n\
\n\
\t\t\t// add to scene\n\
\n\
\t\t\tvar scene = this;\n\
\n\
\t\t\twhile ( scene.parent !== undefined ) {\n\
\n\
\t\t\t\tscene = scene.parent;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene )  {\n\
\n\
\t\t\t\tscene.__addObject( object );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tremove: function ( object ) {\n\
\n\
\t\tvar index = this.children.indexOf( object );\n\
\n\
\t\tif ( index !== - 1 ) {\n\
\n\
\t\t\tobject.parent = undefined;\n\
\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\
\n\
\t\t\tthis.children.splice( index, 1 );\n\
\n\
\t\t\t// remove from scene\n\
\n\
\t\t\tvar scene = this;\n\
\n\
\t\t\twhile ( scene.parent !== undefined ) {\n\
\n\
\t\t\t\tscene = scene.parent;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\n\
\n\
\t\t\t\tscene.__removeObject( object );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\ttraverse: function ( callback ) {\n\
\n\
\t\tcallback( this );\n\
\n\
\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\
\n\
\t\t\tthis.children[ i ].traverse( callback );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tgetObjectById: function ( id, recursive ) {\n\
\n\
\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\
\n\
\t\t\tvar child = this.children[ i ];\n\
\n\
\t\t\tif ( child.id === id ) {\n\
\n\
\t\t\t\treturn child;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( recursive === true ) {\n\
\n\
\t\t\t\tchild = child.getObjectById( id, recursive );\n\
\n\
\t\t\t\tif ( child !== undefined ) {\n\
\n\
\t\t\t\t\treturn child;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn undefined;\n\
\n\
\t},\n\
\n\
\tgetObjectByName: function ( name, recursive ) {\n\
\n\
\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\
\n\
\t\t\tvar child = this.children[ i ];\n\
\n\
\t\t\tif ( child.name === name ) {\n\
\n\
\t\t\t\treturn child;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( recursive === true ) {\n\
\n\
\t\t\t\tchild = child.getObjectByName( name, recursive );\n\
\n\
\t\t\t\tif ( child !== undefined ) {\n\
\n\
\t\t\t\t\treturn child;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn undefined;\n\
\n\
\t},\n\
\n\
\tgetChildByName: function ( name, recursive ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .getChildByName() has been renamed to .getObjectByName().' );\n\
\t\treturn this.getObjectByName( name, recursive );\n\
\n\
\t},\n\
\n\
\tgetDescendants: function ( array ) {\n\
\n\
\t\tif ( array === undefined ) array = [];\n\
\n\
\t\tArray.prototype.push.apply( array, this.children );\n\
\n\
\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\
\n\
\t\t\tthis.children[ i ].getDescendants( array );\n\
\n\
\t\t}\n\
\n\
\t\treturn array;\n\
\n\
\t},\n\
\n\
\tupdateMatrix: function () {\n\
\n\
\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\
\n\
\t\tthis.matrixWorldNeedsUpdate = true;\n\
\n\
\t},\n\
\n\
\tupdateMatrixWorld: function ( force ) {\n\
\n\
\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\
\n\
\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\
\n\
\t\t\tif ( this.parent === undefined ) {\n\
\n\
\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tthis.matrixWorldNeedsUpdate = false;\n\
\n\
\t\t\tforce = true;\n\
\n\
\t\t}\n\
\n\
\t\t// update children\n\
\n\
\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\
\n\
\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tclone: function ( object, recursive ) {\n\
\n\
\t\tif ( object === undefined ) object = new THREE.Object3D();\n\
\t\tif ( recursive === undefined ) recursive = true;\n\
\n\
\t\tobject.name = this.name;\n\
\n\
\t\tobject.up.copy( this.up );\n\
\n\
\t\tobject.position.copy( this.position );\n\
\t\tobject.quaternion.copy( this.quaternion );\n\
\t\tobject.scale.copy( this.scale );\n\
\n\
\t\tobject.renderDepth = this.renderDepth;\n\
\n\
\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\n\
\n\
\t\tobject.matrix.copy( this.matrix );\n\
\t\tobject.matrixWorld.copy( this.matrixWorld );\n\
\n\
\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\n\
\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\n\
\n\
\t\tobject.visible = this.visible;\n\
\n\
\t\tobject.castShadow = this.castShadow;\n\
\t\tobject.receiveShadow = this.receiveShadow;\n\
\n\
\t\tobject.frustumCulled = this.frustumCulled;\n\
\n\
\t\tobject.userData = JSON.parse( JSON.stringify( this.userData ) );\n\
\n\
\t\tif ( recursive === true ) {\n\
\n\
\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\
\n\
\t\t\t\tvar child = this.children[ i ];\n\
\t\t\t\tobject.add( child.clone() );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn object;\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\n\
\n\
THREE.Object3DIdCount = 0;\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author supereggbert / http://www.paulbrunt.co.uk/\n\
 * @author julianwa / https://github.com/julianwa\n\
 */\n\
\n\
THREE.Projector = function () {\n\
\n\
\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\
\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\
\t_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,\n\
\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\
\t_particle, _particleCount, _particlePool = [], _particlePoolLength = 0,\n\
\n\
\t_renderData = { objects: [], sprites: [], lights: [], elements: [] },\n\
\n\
\t_vector3 = new THREE.Vector3(),\n\
\t_vector4 = new THREE.Vector4(),\n\
\n\
\t_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\
\t_boundingBox = new THREE.Box3(),\n\
\t_points3 = new Array( 3 ),\n\
\t_points4 = new Array( 4 ),\n\
\n\
\t_viewMatrix = new THREE.Matrix4(),\n\
\t_viewProjectionMatrix = new THREE.Matrix4(),\n\
\n\
\t_modelMatrix,\n\
\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\
\n\
\t_normalMatrix = new THREE.Matrix3(),\n\
\t_normalViewMatrix = new THREE.Matrix3(),\n\
\n\
\t_centroid = new THREE.Vector3(),\n\
\n\
\t_frustum = new THREE.Frustum(),\n\
\n\
\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\
\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\
\n\
\tthis.projectVector = function ( vector, camera ) {\n\
\n\
\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\
\n\
\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\
\n\
\t\treturn vector.applyProjection( _viewProjectionMatrix );\n\
\n\
\t};\n\
\n\
\tthis.unprojectVector = function ( vector, camera ) {\n\
\n\
\t\tcamera.projectionMatrixInverse.getInverse( camera.projectionMatrix );\n\
\n\
\t\t_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, camera.projectionMatrixInverse );\n\
\n\
\t\treturn vector.applyProjection( _viewProjectionMatrix );\n\
\n\
\t};\n\
\n\
\tthis.pickingRay = function ( vector, camera ) {\n\
\n\
\t\t// set two vectors with opposing z values\n\
\t\tvector.z = -1.0;\n\
\t\tvar end = new THREE.Vector3( vector.x, vector.y, 1.0 );\n\
\n\
\t\tthis.unprojectVector( vector, camera );\n\
\t\tthis.unprojectVector( end, camera );\n\
\n\
\t\t// find direction from vector to end\n\
\t\tend.sub( vector ).normalize();\n\
\n\
\t\treturn new THREE.Raycaster( vector, end );\n\
\n\
\t};\n\
\n\
\tvar getObject = function ( object ) {\n\
\n\
\t\t_object = getNextObjectInPool();\n\
\t\t_object.id = object.id;\n\
\t\t_object.object = object;\n\
\n\
\t\tif ( object.renderDepth !== null ) {\n\
\n\
\t\t\t_object.z = object.renderDepth;\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\n\
\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\
\t\t\t_object.z = _vector3.z;\n\
\n\
\t\t}\n\
\n\
\t\treturn _object;\n\
\n\
\t};\n\
\n\
\tvar projectObject = function ( object ) {\n\
\n\
\t\tif ( object.visible === false ) return;\n\
\n\
\t\tif ( object instanceof THREE.Light ) {\n\
\n\
\t\t\t_renderData.lights.push( object );\n\
\n\
\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\n\
\n\
\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\n\
\n\
\t\t\t\t_renderData.objects.push( getObject( object ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( object instanceof THREE.Sprite || object instanceof THREE.Particle ) {\n\
\n\
\t\t\t_renderData.sprites.push( getObject( object ) );\n\
\n\
\t\t}\n\
\n\
\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\n\
\n\
\t\t\tprojectObject( object.children[ i ] );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tvar projectGraph = function ( root, sortObjects ) {\n\
\n\
\t\t_objectCount = 0;\n\
\n\
\t\t_renderData.objects.length = 0;\n\
\t\t_renderData.sprites.length = 0;\n\
\t\t_renderData.lights.length = 0;\n\
\n\
\t\tprojectObject( root );\n\
\n\
\t\tif ( sortObjects === true ) {\n\
\n\
\t\t\t_renderData.objects.sort( painterSort );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\
\n\
\t\tvar visible = false,\n\
\t\to, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object,\n\
\t\tgeometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,\n\
\t\tv1, v2, v3, v4, isFaceMaterial, objectMaterials;\n\
\n\
\t\t_face3Count = 0;\n\
\t\t_lineCount = 0;\n\
\t\t_particleCount = 0;\n\
\n\
\t\t_renderData.elements.length = 0;\n\
\n\
\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\
\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\
\n\
\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\
\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\
\n\
\t\t_normalViewMatrix.getNormalMatrix( _viewMatrix );\n\
\n\
\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\
\n\
\t\tprojectGraph( scene, sortObjects );\n\
\n\
\t\tfor ( o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\
\n\
\t\t\tobject = _renderData.objects[ o ].object;\n\
\n\
\t\t\t_modelMatrix = object.matrixWorld;\n\
\n\
\t\t\t_vertexCount = 0;\n\
\n\
\t\t\tif ( object instanceof THREE.Mesh ) {\n\
\n\
\t\t\t\tgeometry = object.geometry;\n\
\n\
\t\t\t\tvertices = geometry.vertices;\n\
\t\t\t\tfaces = geometry.faces;\n\
\t\t\t\tfaceVertexUvs = geometry.faceVertexUvs;\n\
\n\
\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\n\
\n\
\t\t\t\tisFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n\
\t\t\t\tobjectMaterials = isFaceMaterial === true ? object.material : null;\n\
\n\
\t\t\t\tfor ( v = 0, vl = vertices.length; v < vl; v ++ ) {\n\
\n\
\t\t\t\t\t_vertex = getNextVertexInPool();\n\
\n\
\t\t\t\t\t_vertex.positionWorld.copy( vertices[ v ] ).applyMatrix4( _modelMatrix );\n\
\t\t\t\t\t_vertex.positionScreen.copy( _vertex.positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\
\n\
\t\t\t\t\tvar invW = 1 / _vertex.positionScreen.w;\n\
\n\
\t\t\t\t\t_vertex.positionScreen.x *= invW;\n\
\t\t\t\t\t_vertex.positionScreen.y *= invW;\n\
\t\t\t\t\t_vertex.positionScreen.z *= invW;\n\
\n\
\t\t\t\t\t_vertex.visible = ! ( _vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 ||\n\
\t\t\t\t\t\t\t      _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 ||\n\
\t\t\t\t\t\t\t      _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1 );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tfor ( f = 0, fl = faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\tface = faces[ f ];\n\
\n\
\t\t\t\t\tvar material = isFaceMaterial === true\n\
\t\t\t\t\t\t? objectMaterials.materials[ face.materialIndex ]\n\
\t\t\t\t\t\t: object.material;\n\
\n\
\t\t\t\t\tif ( material === undefined ) continue;\n\
\n\
\t\t\t\t\tvar side = material.side;\n\
\n\
\t\t\t\t\tv1 = _vertexPool[ face.a ];\n\
\t\t\t\t\tv2 = _vertexPool[ face.b ];\n\
\t\t\t\t\tv3 = _vertexPool[ face.c ];\n\
\n\
\t\t\t\t\t_points3[ 0 ] = v1.positionScreen;\n\
\t\t\t\t\t_points3[ 1 ] = v2.positionScreen;\n\
\t\t\t\t\t_points3[ 2 ] = v3.positionScreen;\n\
\n\
\t\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ||\n\
\t\t\t\t\t\t_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {\n\
\n\
\t\t\t\t\t\tvisible = ( ( v3.positionScreen.x - v1.positionScreen.x ) *\n\
\t\t\t\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\n\
\t\t\t\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\n\
\t\t\t\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\
\n\
\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\n\
\n\
\t\t\t\t\t\t\t_face = getNextFace3InPool();\n\
\n\
\t\t\t\t\t\t\t_face.id = object.id;\n\
\t\t\t\t\t\t\t_face.v1.copy( v1 );\n\
\t\t\t\t\t\t\t_face.v2.copy( v2 );\n\
\t\t\t\t\t\t\t_face.v3.copy( v3 );\n\
\n\
\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\tcontinue;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\tcontinue;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t_face.normalModel.copy( face.normal );\n\
\n\
\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\
\n\
\t\t\t\t\t\t_face.normalModel.negate();\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\
\n\
\t\t\t\t\t_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );\n\
\n\
\t\t\t\t\t_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );\n\
\n\
\t\t\t\t\tfaceVertexNormals = face.vertexNormals;\n\
\n\
\t\t\t\t\tfor ( n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\n\
\n\
\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\
\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\
\n\
\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\
\n\
\t\t\t\t\t\t\tnormalModel.negate();\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\
\n\
\t\t\t\t\t\tvar normalModelView = _face.vertexNormalsModelView[ n ];\n\
\t\t\t\t\t\tnormalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\
\n\
\t\t\t\t\tfor ( c = 0, cl = Math.min( faceVertexUvs.length, 3 ); c < cl; c ++ ) {\n\
\n\
\t\t\t\t\t\tuvs = faceVertexUvs[ c ][ f ];\n\
\n\
\t\t\t\t\t\tif ( uvs === undefined ) continue;\n\
\n\
\t\t\t\t\t\tfor ( u = 0, ul = uvs.length; u < ul; u ++ ) {\n\
\n\
\t\t\t\t\t\t\t_face.uvs[ c ][ u ] = uvs[ u ];\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t_face.color = face.color;\n\
\t\t\t\t\t_face.material = material;\n\
\n\
\t\t\t\t\t_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );\n\
\n\
\t\t\t\t\t_face.z = _centroid.z;\n\
\n\
\t\t\t\t\t_renderData.elements.push( _face );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( object instanceof THREE.Line ) {\n\
\n\
\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\
\n\
\t\t\t\tvertices = object.geometry.vertices;\n\
\n\
\t\t\t\tv1 = getNextVertexInPool();\n\
\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\
\n\
\t\t\t\t// Handle LineStrip and LinePieces\n\
\t\t\t\tvar step = object.type === THREE.LinePieces ? 2 : 1;\n\
\n\
\t\t\t\tfor ( v = 1, vl = vertices.length; v < vl; v ++ ) {\n\
\n\
\t\t\t\t\tv1 = getNextVertexInPool();\n\
\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\
\n\
\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\
\n\
\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\
\n\
\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\
\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\
\n\
\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\
\n\
\t\t\t\t\t\t// Perform the perspective divide\n\
\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\
\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\
\n\
\t\t\t\t\t\t_line = getNextLineInPool();\n\
\n\
\t\t\t\t\t\t_line.id = object.id;\n\
\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\
\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\
\n\
\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\
\n\
\t\t\t\t\t\t_line.material = object.material;\n\
\n\
\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\n\
\n\
\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\n\
\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t_renderData.elements.push( _line );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tfor ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {\n\
\n\
\t\t\tobject = _renderData.sprites[ o ].object;\n\
\n\
\t\t\t_modelMatrix = object.matrixWorld;\n\
\n\
\t\t\tif ( object instanceof THREE.Particle ) {\n\
\n\
\t\t\t\t_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );\n\
\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\
\n\
\t\t\t\tvar invW = 1 / _vector4.w;\n\
\n\
\t\t\t\t_vector4.z *= invW;\n\
\n\
\t\t\t\tif ( _vector4.z > 0 && _vector4.z < 1 ) {\n\
\n\
\t\t\t\t\t_particle = getNextParticleInPool();\n\
\t\t\t\t\t_particle.id = object.id;\n\
\t\t\t\t\t_particle.x = _vector4.x * invW;\n\
\t\t\t\t\t_particle.y = _vector4.y * invW;\n\
\t\t\t\t\t_particle.z = _vector4.z;\n\
\t\t\t\t\t_particle.object = object;\n\
\n\
\t\t\t\t\t_particle.rotation = object.rotation.z;\n\
\n\
\t\t\t\t\t_particle.scale.x = object.scale.x * Math.abs( _particle.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );\n\
\t\t\t\t\t_particle.scale.y = object.scale.y * Math.abs( _particle.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );\n\
\n\
\t\t\t\t\t_particle.material = object.material;\n\
\n\
\t\t\t\t\t_renderData.elements.push( _particle );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( sortElements === true ) _renderData.elements.sort( painterSort );\n\
\n\
\t\treturn _renderData;\n\
\n\
\t};\n\
\n\
\t// Pools\n\
\n\
\tfunction getNextObjectInPool() {\n\
\n\
\t\tif ( _objectCount === _objectPoolLength ) {\n\
\n\
\t\t\tvar object = new THREE.RenderableObject();\n\
\t\t\t_objectPool.push( object );\n\
\t\t\t_objectPoolLength ++;\n\
\t\t\t_objectCount ++;\n\
\t\t\treturn object;\n\
\n\
\t\t}\n\
\n\
\t\treturn _objectPool[ _objectCount ++ ];\n\
\n\
\t}\n\
\n\
\tfunction getNextVertexInPool() {\n\
\n\
\t\tif ( _vertexCount === _vertexPoolLength ) {\n\
\n\
\t\t\tvar vertex = new THREE.RenderableVertex();\n\
\t\t\t_vertexPool.push( vertex );\n\
\t\t\t_vertexPoolLength ++;\n\
\t\t\t_vertexCount ++;\n\
\t\t\treturn vertex;\n\
\n\
\t\t}\n\
\n\
\t\treturn _vertexPool[ _vertexCount ++ ];\n\
\n\
\t}\n\
\n\
\tfunction getNextFace3InPool() {\n\
\n\
\t\tif ( _face3Count === _face3PoolLength ) {\n\
\n\
\t\t\tvar face = new THREE.RenderableFace3();\n\
\t\t\t_face3Pool.push( face );\n\
\t\t\t_face3PoolLength ++;\n\
\t\t\t_face3Count ++;\n\
\t\t\treturn face;\n\
\n\
\t\t}\n\
\n\
\t\treturn _face3Pool[ _face3Count ++ ];\n\
\n\
\n\
\t}\n\
\n\
\tfunction getNextLineInPool() {\n\
\n\
\t\tif ( _lineCount === _linePoolLength ) {\n\
\n\
\t\t\tvar line = new THREE.RenderableLine();\n\
\t\t\t_linePool.push( line );\n\
\t\t\t_linePoolLength ++;\n\
\t\t\t_lineCount ++\n\
\t\t\treturn line;\n\
\n\
\t\t}\n\
\n\
\t\treturn _linePool[ _lineCount ++ ];\n\
\n\
\t}\n\
\n\
\tfunction getNextParticleInPool() {\n\
\n\
\t\tif ( _particleCount === _particlePoolLength ) {\n\
\n\
\t\t\tvar particle = new THREE.RenderableParticle();\n\
\t\t\t_particlePool.push( particle );\n\
\t\t\t_particlePoolLength ++;\n\
\t\t\t_particleCount ++\n\
\t\t\treturn particle;\n\
\n\
\t\t}\n\
\n\
\t\treturn _particlePool[ _particleCount ++ ];\n\
\n\
\t}\n\
\n\
\t//\n\
\n\
\tfunction painterSort( a, b ) {\n\
\n\
\t\tif ( a.z !== b.z ) {\n\
\n\
\t\t\treturn b.z - a.z;\n\
\n\
\t\t} else if ( a.id !== b.id ) {\n\
\n\
\t\t\treturn a.id - b.id;\n\
\n\
\t\t} else {\n\
\n\
\t\t\treturn 0;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction clipLine( s1, s2 ) {\n\
\n\
\t\tvar alpha1 = 0, alpha2 = 1,\n\
\n\
\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\
\t\t// Z = -1 and Z = +1, respectively.\n\
\t\tbc1near =  s1.z + s1.w,\n\
\t\tbc2near =  s2.z + s2.w,\n\
\t\tbc1far =  - s1.z + s1.w,\n\
\t\tbc2far =  - s2.z + s2.w;\n\
\n\
\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\
\n\
\t\t\t// Both vertices lie entirely within all clip planes.\n\
\t\t\treturn true;\n\
\n\
\t\t} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {\n\
\n\
\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\
\t\t\treturn false;\n\
\n\
\t\t} else {\n\
\n\
\t\t\t// The line segment spans at least one clip plane.\n\
\n\
\t\t\tif ( bc1near < 0 ) {\n\
\n\
\t\t\t\t// v1 lies outside the near plane, v2 inside\n\
\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\
\n\
\t\t\t} else if ( bc2near < 0 ) {\n\
\n\
\t\t\t\t// v2 lies outside the near plane, v1 inside\n\
\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( bc1far < 0 ) {\n\
\n\
\t\t\t\t// v1 lies outside the far plane, v2 inside\n\
\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\
\n\
\t\t\t} else if ( bc2far < 0 ) {\n\
\n\
\t\t\t\t// v2 lies outside the far plane, v2 inside\n\
\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( alpha2 < alpha1 ) {\n\
\n\
\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\
\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\
\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\
\t\t\t\treturn false;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\
\t\t\t\ts1.lerp( s2, alpha1 );\n\
\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\
\n\
\t\t\t\treturn true;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\
\n\
\tthis.a = a;\n\
\tthis.b = b;\n\
\tthis.c = c;\n\
\n\
\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\
\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\n\
\n\
\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\
\tthis.vertexColors = color instanceof Array ? color : [];\n\
\n\
\tthis.vertexTangents = [];\n\
\n\
\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\
\n\
\tthis.centroid = new THREE.Vector3();\n\
\n\
};\n\
\n\
THREE.Face3.prototype = {\n\
\n\
\tconstructor: THREE.Face3,\n\
\n\
\tclone: function () {\n\
\n\
\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\n\
\n\
\t\tface.normal.copy( this.normal );\n\
\t\tface.color.copy( this.color );\n\
\t\tface.centroid.copy( this.centroid );\n\
\n\
\t\tface.materialIndex = this.materialIndex;\n\
\n\
\t\tvar i, il;\n\
\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\n\
\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\n\
\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\n\
\n\
\t\treturn face;\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\n\
\n\
\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author kile / http://kile.stravaganza.org/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author zz85 / http://www.lab4games.net/zz85/blog\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
THREE.Geometry = function () {\n\
\n\
\tthis.id = THREE.GeometryIdCount ++;\n\
\tthis.uuid = THREE.Math.generateUUID();\n\
\n\
\tthis.name = '';\n\
\n\
\tthis.vertices = [];\n\
\tthis.colors = [];  // one-to-one vertex colors, used in ParticleSystem, Line and Ribbon\n\
\tthis.normals = []; // one-to-one vertex normals, used in Ribbon\n\
\n\
\tthis.faces = [];\n\
\n\
\tthis.faceVertexUvs = [[]];\n\
\n\
\tthis.morphTargets = [];\n\
\tthis.morphColors = [];\n\
\tthis.morphNormals = [];\n\
\n\
\tthis.skinWeights = [];\n\
\tthis.skinIndices = [];\n\
\n\
\tthis.lineDistances = [];\n\
\n\
\tthis.boundingBox = null;\n\
\tthis.boundingSphere = null;\n\
\n\
\tthis.hasTangents = false;\n\
\n\
\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\n\
\n\
\t// update flags\n\
\n\
\tthis.verticesNeedUpdate = false;\n\
\tthis.elementsNeedUpdate = false;\n\
\tthis.uvsNeedUpdate = false;\n\
\tthis.normalsNeedUpdate = false;\n\
\tthis.tangentsNeedUpdate = false;\n\
\tthis.colorsNeedUpdate = false;\n\
\tthis.lineDistancesNeedUpdate = false;\n\
\n\
\tthis.buffersNeedUpdate = false;\n\
\n\
};\n\
\n\
THREE.Geometry.prototype = {\n\
\n\
\tconstructor: THREE.Geometry,\n\
\n\
\tapplyMatrix: function ( matrix ) {\n\
\n\
\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\
\n\
\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\
\n\
\t\t\tvar vertex = this.vertices[ i ];\n\
\t\t\tvertex.applyMatrix4( matrix );\n\
\n\
\t\t}\n\
\n\
\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\
\n\
\t\t\tvar face = this.faces[ i ];\n\
\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\
\n\
\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\
\n\
\t\t\t}\n\
\n\
\t\t\tface.centroid.applyMatrix4( matrix );\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.boundingBox instanceof THREE.Box3 ) {\n\
\n\
\t\t\tthis.computeBoundingBox();\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.boundingSphere instanceof THREE.Sphere ) {\n\
\n\
\t\t\tthis.computeBoundingSphere();\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcomputeCentroids: function () {\n\
\n\
\t\tvar f, fl, face;\n\
\n\
\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\tface = this.faces[ f ];\n\
\t\t\tface.centroid.set( 0, 0, 0 );\n\
\n\
\t\t\tface.centroid.add( this.vertices[ face.a ] );\n\
\t\t\tface.centroid.add( this.vertices[ face.b ] );\n\
\t\t\tface.centroid.add( this.vertices[ face.c ] );\n\
\t\t\tface.centroid.divideScalar( 3 );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcomputeFaceNormals: function () {\n\
\n\
\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\
\n\
\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\tvar face = this.faces[ f ];\n\
\n\
\t\t\tvar vA = this.vertices[ face.a ];\n\
\t\t\tvar vB = this.vertices[ face.b ];\n\
\t\t\tvar vC = this.vertices[ face.c ];\n\
\n\
\t\t\tcb.subVectors( vC, vB );\n\
\t\t\tab.subVectors( vA, vB );\n\
\t\t\tcb.cross( ab );\n\
\n\
\t\t\tcb.normalize();\n\
\n\
\t\t\tface.normal.copy( cb );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcomputeVertexNormals: function ( areaWeighted ) {\n\
\n\
\t\tvar v, vl, f, fl, face, vertices;\n\
\n\
\t\t// create internal buffers for reuse when calling this method repeatedly\n\
\t\t// (otherwise memory allocation / deallocation every frame is big resource hog)\n\
\n\
\t\tif ( this.__tmpVertices === undefined ) {\n\
\n\
\t\t\tthis.__tmpVertices = new Array( this.vertices.length );\n\
\t\t\tvertices = this.__tmpVertices;\n\
\n\
\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\
\n\
\t\t\t\tvertices[ v ] = new THREE.Vector3();\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tface = this.faces[ f ];\n\
\t\t\t\tface.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tvertices = this.__tmpVertices;\n\
\n\
\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\
\n\
\t\t\t\tvertices[ v ].set( 0, 0, 0 );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( areaWeighted ) {\n\
\n\
\t\t\t// vertex normals weighted by triangle areas\n\
\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\
\n\
\t\t\tvar vA, vB, vC, vD;\n\
\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3(),\n\
\t\t\t\tdb = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();\n\
\n\
\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tface = this.faces[ f ];\n\
\n\
\t\t\t\tvA = this.vertices[ face.a ];\n\
\t\t\t\tvB = this.vertices[ face.b ];\n\
\t\t\t\tvC = this.vertices[ face.c ];\n\
\n\
\t\t\t\tcb.subVectors( vC, vB );\n\
\t\t\t\tab.subVectors( vA, vB );\n\
\t\t\t\tcb.cross( ab );\n\
\n\
\t\t\t\tvertices[ face.a ].add( cb );\n\
\t\t\t\tvertices[ face.b ].add( cb );\n\
\t\t\t\tvertices[ face.c ].add( cb );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tface = this.faces[ f ];\n\
\n\
\t\t\t\tvertices[ face.a ].add( face.normal );\n\
\t\t\t\tvertices[ face.b ].add( face.normal );\n\
\t\t\t\tvertices[ face.c ].add( face.normal );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\
\n\
\t\t\tvertices[ v ].normalize();\n\
\n\
\t\t}\n\
\n\
\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\tface = this.faces[ f ];\n\
\n\
\t\t\tface.vertexNormals[ 0 ].copy( vertices[ face.a ] );\n\
\t\t\tface.vertexNormals[ 1 ].copy( vertices[ face.b ] );\n\
\t\t\tface.vertexNormals[ 2 ].copy( vertices[ face.c ] );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcomputeMorphNormals: function () {\n\
\n\
\t\tvar i, il, f, fl, face;\n\
\n\
\t\t// save original normals\n\
\t\t// - create temp variables on first access\n\
\t\t//   otherwise just copy (for faster repeated calls)\n\
\n\
\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\tface = this.faces[ f ];\n\
\n\
\t\t\tif ( ! face.__originalFaceNormal ) {\n\
\n\
\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\
\n\
\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\
\n\
\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// use temp geometry to compute face and vertex normals for each morph\n\
\n\
\t\tvar tmpGeo = new THREE.Geometry();\n\
\t\ttmpGeo.faces = this.faces;\n\
\n\
\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\
\n\
\t\t\t// create on first access\n\
\n\
\t\t\tif ( ! this.morphNormals[ i ] ) {\n\
\n\
\t\t\t\tthis.morphNormals[ i ] = {};\n\
\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\
\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\
\n\
\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\
\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\
\n\
\t\t\t\tvar faceNormal, vertexNormals;\n\
\n\
\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\tface = this.faces[ f ];\n\
\n\
\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\
\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\
\n\
\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\
\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar morphNormals = this.morphNormals[ i ];\n\
\n\
\t\t\t// set vertices to morph target\n\
\n\
\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\
\n\
\t\t\t// compute morph normals\n\
\n\
\t\t\ttmpGeo.computeFaceNormals();\n\
\t\t\ttmpGeo.computeVertexNormals();\n\
\n\
\t\t\t// store morph normals\n\
\n\
\t\t\tvar faceNormal, vertexNormals;\n\
\n\
\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tface = this.faces[ f ];\n\
\n\
\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\
\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\
\n\
\t\t\t\tfaceNormal.copy( face.normal );\n\
\n\
\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\
\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\
\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// restore original normals\n\
\n\
\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\tface = this.faces[ f ];\n\
\n\
\t\t\tface.normal = face.__originalFaceNormal;\n\
\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcomputeTangents: function () {\n\
\n\
\t\t// based on http://www.terathon.com/code/tangent.html\n\
\t\t// tangents go to vertices\n\
\n\
\t\tvar f, fl, v, vl, i, il, vertexIndex,\n\
\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\n\
\t\t\tx1, x2, y1, y2, z1, z2,\n\
\t\t\ts1, s2, t1, t2, r, t, test,\n\
\t\t\ttan1 = [], tan2 = [],\n\
\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\n\
\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\n\
\t\t\tn = new THREE.Vector3(), w;\n\
\n\
\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\
\n\
\t\t\ttan1[ v ] = new THREE.Vector3();\n\
\t\t\ttan2[ v ] = new THREE.Vector3();\n\
\n\
\t\t}\n\
\n\
\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\n\
\n\
\t\t\tvA = context.vertices[ a ];\n\
\t\t\tvB = context.vertices[ b ];\n\
\t\t\tvC = context.vertices[ c ];\n\
\n\
\t\t\tuvA = uv[ ua ];\n\
\t\t\tuvB = uv[ ub ];\n\
\t\t\tuvC = uv[ uc ];\n\
\n\
\t\t\tx1 = vB.x - vA.x;\n\
\t\t\tx2 = vC.x - vA.x;\n\
\t\t\ty1 = vB.y - vA.y;\n\
\t\t\ty2 = vC.y - vA.y;\n\
\t\t\tz1 = vB.z - vA.z;\n\
\t\t\tz2 = vC.z - vA.z;\n\
\n\
\t\t\ts1 = uvB.x - uvA.x;\n\
\t\t\ts2 = uvC.x - uvA.x;\n\
\t\t\tt1 = uvB.y - uvA.y;\n\
\t\t\tt2 = uvC.y - uvA.y;\n\
\n\
\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\n\
\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\n\
\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\n\
\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\n\
\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\n\
\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\n\
\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\n\
\n\
\t\t\ttan1[ a ].add( sdir );\n\
\t\t\ttan1[ b ].add( sdir );\n\
\t\t\ttan1[ c ].add( sdir );\n\
\n\
\t\t\ttan2[ a ].add( tdir );\n\
\t\t\ttan2[ b ].add( tdir );\n\
\t\t\ttan2[ c ].add( tdir );\n\
\n\
\t\t}\n\
\n\
\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\tface = this.faces[ f ];\n\
\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\n\
\n\
\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\n\
\n\
\t\t}\n\
\n\
\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\n\
\n\
\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\tface = this.faces[ f ];\n\
\n\
\t\t\tfor ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i++ ) {\n\
\n\
\t\t\t\tn.copy( face.vertexNormals[ i ] );\n\
\n\
\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\n\
\n\
\t\t\t\tt = tan1[ vertexIndex ];\n\
\n\
\t\t\t\t// Gram-Schmidt orthogonalize\n\
\n\
\t\t\t\ttmp.copy( t );\n\
\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\
\n\
\t\t\t\t// Calculate handedness\n\
\n\
\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\n\
\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\n\
\t\t\t\tw = (test < 0.0) ? -1.0 : 1.0;\n\
\n\
\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tthis.hasTangents = true;\n\
\n\
\t},\n\
\n\
\tcomputeLineDistances: function ( ) {\n\
\n\
\t\tvar d = 0;\n\
\t\tvar vertices = this.vertices;\n\
\n\
\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\
\n\
\t\t\tif ( i > 0 ) {\n\
\n\
\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tthis.lineDistances[ i ] = d;\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcomputeBoundingBox: function () {\n\
\n\
\t\tif ( this.boundingBox === null ) {\n\
\n\
\t\t\tthis.boundingBox = new THREE.Box3();\n\
\n\
\t\t}\n\
\n\
\t\tthis.boundingBox.setFromPoints( this.vertices );\n\
\n\
\t},\n\
\n\
\tcomputeBoundingSphere: function () {\n\
\n\
\t\tif ( this.boundingSphere === null ) {\n\
\n\
\t\t\tthis.boundingSphere = new THREE.Sphere();\n\
\n\
\t\t}\n\
\n\
\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\
\n\
\t},\n\
\n\
\t/*\n\
\t * Checks for duplicate vertices with hashmap.\n\
\t * Duplicated vertices are removed\n\
\t * and faces' vertices are updated.\n\
\t */\n\
\n\
\tmergeVertices: function () {\n\
\n\
\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\n\
\t\tvar unique = [], changes = [];\n\
\n\
\t\tvar v, key;\n\
\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\n\
\t\tvar precision = Math.pow( 10, precisionPoints );\n\
\t\tvar i,il, face;\n\
\t\tvar indices, k, j, jl, u;\n\
\n\
\t\t// reset cache of vertices as it now will be changing.\n\
\t\tthis.__tmpVertices = undefined;\n\
\n\
\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\
\n\
\t\t\tv = this.vertices[ i ];\n\
\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\
\n\
\t\t\tif ( verticesMap[ key ] === undefined ) {\n\
\n\
\t\t\t\tverticesMap[ key ] = i;\n\
\t\t\t\tunique.push( this.vertices[ i ] );\n\
\t\t\t\tchanges[ i ] = unique.length - 1;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\
\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\
\n\
\t\t\t}\n\
\n\
\t\t};\n\
\n\
\n\
\t\t// if faces are completely degenerate after merging vertices, we\n\
\t\t// have to remove them from the geometry.\n\
\t\tvar faceIndicesToRemove = [];\n\
\n\
\t\tfor( i = 0, il = this.faces.length; i < il; i ++ ) {\n\
\n\
\t\t\tface = this.faces[ i ];\n\
\n\
\t\t\tface.a = changes[ face.a ];\n\
\t\t\tface.b = changes[ face.b ];\n\
\t\t\tface.c = changes[ face.c ];\n\
\n\
\t\t\tindices = [ face.a, face.b, face.c ];\n\
\n\
\t\t\tvar dupIndex = -1;\n\
\n\
\t\t\t// if any duplicate vertices are found in a Face3\n\
\t\t\t// we have to remove the face as nothing can be saved\n\
\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\
\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\n\
\n\
\t\t\t\t\tdupIndex = n;\n\
\t\t\t\t\tfaceIndicesToRemove.push( i );\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\
\n\
\t\t\tthis.faces.splice( i, 1 );\n\
\n\
\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\tthis.faceVertexUvs[ j ].splice( i, 1 );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// Use unique set of vertices\n\
\n\
\t\tvar diff = this.vertices.length - unique.length;\n\
\t\tthis.vertices = unique;\n\
\t\treturn diff;\n\
\n\
\t},\n\
\n\
\tclone: function () {\n\
\n\
\t\tvar geometry = new THREE.Geometry();\n\
\n\
\t\tvar vertices = this.vertices;\n\
\n\
\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\
\n\
\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\n\
\n\
\t\t}\n\
\n\
\t\tvar faces = this.faces;\n\
\n\
\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\
\n\
\t\t\tgeometry.faces.push( faces[ i ].clone() );\n\
\n\
\t\t}\n\
\n\
\t\tvar uvs = this.faceVertexUvs[ 0 ];\n\
\n\
\t\tfor ( var i = 0, il = uvs.length; i < il; i ++ ) {\n\
\n\
\t\t\tvar uv = uvs[ i ], uvCopy = [];\n\
\n\
\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tgeometry.faceVertexUvs[ 0 ].push( uvCopy );\n\
\n\
\t\t}\n\
\n\
\t\treturn geometry;\n\
\n\
\t},\n\
\n\
\tdispose: function () {\n\
\n\
\t\tthis.dispatchEvent( { type: 'dispose' } );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\n\
\n\
THREE.GeometryIdCount = 0;\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.BufferGeometry = function () {\n\
\n\
\tthis.id = THREE.GeometryIdCount ++;\n\
\tthis.uuid = THREE.Math.generateUUID();\n\
\n\
\tthis.name = '';\n\
\n\
\t// attributes\n\
\n\
\tthis.attributes = {};\n\
\n\
\t// attributes typed arrays are kept only if dynamic flag is set\n\
\n\
\tthis.dynamic = true;\n\
\n\
\t// offsets for chunks when using indexed elements\n\
\n\
\tthis.offsets = [];\n\
\n\
\t// boundings\n\
\n\
\tthis.boundingBox = null;\n\
\tthis.boundingSphere = null;\n\
\n\
\tthis.hasTangents = false;\n\
\n\
\t// for compatibility\n\
\n\
\tthis.morphTargets = [];\n\
\n\
};\n\
\n\
THREE.BufferGeometry.prototype = {\n\
\n\
\tconstructor: THREE.BufferGeometry,\n\
\n\
\tapplyMatrix: function ( matrix ) {\n\
\n\
\t\tvar positionArray;\n\
\t\tvar normalArray;\n\
\n\
\t\tif ( this.attributes[ \"position\" ] ) positionArray = this.attributes[ \"position\" ].array;\n\
\t\tif ( this.attributes[ \"normal\" ] ) normalArray = this.attributes[ \"normal\" ].array;\n\
\n\
\t\tif ( positionArray !== undefined ) {\n\
\n\
\t\t\tmatrix.multiplyVector3Array( positionArray );\n\
\t\t\tthis.verticesNeedUpdate = true;\n\
\n\
\t\t}\n\
\n\
\t\tif ( normalArray !== undefined ) {\n\
\n\
\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\
\n\
\t\t\tnormalMatrix.multiplyVector3Array( normalArray );\n\
\n\
\t\t\tthis.normalizeNormals();\n\
\n\
\t\t\tthis.normalsNeedUpdate = true;\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcomputeBoundingBox: function () {\n\
\n\
\t\tif ( this.boundingBox === null ) {\n\
\n\
\t\t\tthis.boundingBox = new THREE.Box3();\n\
\n\
\t\t}\n\
\n\
\t\tvar positions = this.attributes[ \"position\" ].array;\n\
\n\
\t\tif ( positions ) {\n\
\n\
\t\t\tvar bb = this.boundingBox;\n\
\t\t\tvar x, y, z;\n\
\n\
\t\t\tif( positions.length >= 3 ) {\n\
\t\t\t\tbb.min.x = bb.max.x = positions[ 0 ];\n\
\t\t\t\tbb.min.y = bb.max.y = positions[ 1 ];\n\
\t\t\t\tbb.min.z = bb.max.z = positions[ 2 ];\n\
\t\t\t}\n\
\n\
\t\t\tfor ( var i = 3, il = positions.length; i < il; i += 3 ) {\n\
\n\
\t\t\t\tx = positions[ i ];\n\
\t\t\t\ty = positions[ i + 1 ];\n\
\t\t\t\tz = positions[ i + 2 ];\n\
\n\
\t\t\t\t// bounding box\n\
\n\
\t\t\t\tif ( x < bb.min.x ) {\n\
\n\
\t\t\t\t\tbb.min.x = x;\n\
\n\
\t\t\t\t} else if ( x > bb.max.x ) {\n\
\n\
\t\t\t\t\tbb.max.x = x;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( y < bb.min.y ) {\n\
\n\
\t\t\t\t\tbb.min.y = y;\n\
\n\
\t\t\t\t} else if ( y > bb.max.y ) {\n\
\n\
\t\t\t\t\tbb.max.y = y;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( z < bb.min.z ) {\n\
\n\
\t\t\t\t\tbb.min.z = z;\n\
\n\
\t\t\t\t} else if ( z > bb.max.z ) {\n\
\n\
\t\t\t\t\tbb.max.z = z;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( positions === undefined || positions.length === 0 ) {\n\
\n\
\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\n\
\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcomputeBoundingSphere: function () {\n\
\n\
\t\tvar box = new THREE.Box3();\n\
\t\tvar vector = new THREE.Vector3();\n\
\n\
\t\treturn function () {\n\
\n\
\t\t\tif ( this.boundingSphere === null ) {\n\
\n\
\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar positions = this.attributes[ \"position\" ].array;\n\
\n\
\t\t\tif ( positions ) {\n\
\n\
\t\t\t\tvar center = this.boundingSphere.center;\n\
\n\
\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\
\n\
\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\
\t\t\t\t\tbox.addPoint( vector );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tbox.center( center );\n\
\n\
\t\t\t\tvar maxRadiusSq = 0;\n\
\n\
\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\
\n\
\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\
\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}(),\n\
\n\
\tcomputeVertexNormals: function () {\n\
\n\
\t\tif ( this.attributes[ \"position\" ] ) {\n\
\n\
\t\t\tvar i, il;\n\
\t\t\tvar j, jl;\n\
\n\
\t\t\tvar nVertexElements = this.attributes[ \"position\" ].array.length;\n\
\n\
\t\t\tif ( this.attributes[ \"normal\" ] === undefined ) {\n\
\n\
\t\t\t\tthis.attributes[ \"normal\" ] = {\n\
\n\
\t\t\t\t\titemSize: 3,\n\
\t\t\t\t\tarray: new Float32Array( nVertexElements )\n\
\n\
\t\t\t\t};\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t// reset existing normals to zero\n\
\n\
\t\t\t\tfor ( i = 0, il = this.attributes[ \"normal\" ].array.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\tthis.attributes[ \"normal\" ].array[ i ] = 0;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar positions = this.attributes[ \"position\" ].array;\n\
\t\t\tvar normals = this.attributes[ \"normal\" ].array;\n\
\n\
\t\t\tvar vA, vB, vC, x, y, z,\n\
\n\
\t\t\tpA = new THREE.Vector3(),\n\
\t\t\tpB = new THREE.Vector3(),\n\
\t\t\tpC = new THREE.Vector3(),\n\
\n\
\t\t\tcb = new THREE.Vector3(),\n\
\t\t\tab = new THREE.Vector3();\n\
\n\
\t\t\t// indexed elements\n\
\n\
\t\t\tif ( this.attributes[ \"index\" ] ) {\n\
\n\
\t\t\t\tvar indices = this.attributes[ \"index\" ].array;\n\
\n\
\t\t\t\tvar offsets = this.offsets;\n\
\n\
\t\t\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\
\n\
\t\t\t\t\tvar start = offsets[ j ].start;\n\
\t\t\t\t\tvar count = offsets[ j ].count;\n\
\t\t\t\t\tvar index = offsets[ j ].index;\n\
\n\
\t\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\
\n\
\t\t\t\t\t\tvA = index + indices[ i ];\n\
\t\t\t\t\t\tvB = index + indices[ i + 1 ];\n\
\t\t\t\t\t\tvC = index + indices[ i + 2 ];\n\
\n\
\t\t\t\t\t\tx = positions[ vA * 3 ];\n\
\t\t\t\t\t\ty = positions[ vA * 3 + 1 ];\n\
\t\t\t\t\t\tz = positions[ vA * 3 + 2 ];\n\
\t\t\t\t\t\tpA.set( x, y, z );\n\
\n\
\t\t\t\t\t\tx = positions[ vB * 3 ];\n\
\t\t\t\t\t\ty = positions[ vB * 3 + 1 ];\n\
\t\t\t\t\t\tz = positions[ vB * 3 + 2 ];\n\
\t\t\t\t\t\tpB.set( x, y, z );\n\
\n\
\t\t\t\t\t\tx = positions[ vC * 3 ];\n\
\t\t\t\t\t\ty = positions[ vC * 3 + 1 ];\n\
\t\t\t\t\t\tz = positions[ vC * 3 + 2 ];\n\
\t\t\t\t\t\tpC.set( x, y, z );\n\
\n\
\t\t\t\t\t\tcb.subVectors( pC, pB );\n\
\t\t\t\t\t\tab.subVectors( pA, pB );\n\
\t\t\t\t\t\tcb.cross( ab );\n\
\n\
\t\t\t\t\t\tnormals[ vA * 3 ]     += cb.x;\n\
\t\t\t\t\t\tnormals[ vA * 3 + 1 ] += cb.y;\n\
\t\t\t\t\t\tnormals[ vA * 3 + 2 ] += cb.z;\n\
\n\
\t\t\t\t\t\tnormals[ vB * 3 ]     += cb.x;\n\
\t\t\t\t\t\tnormals[ vB * 3 + 1 ] += cb.y;\n\
\t\t\t\t\t\tnormals[ vB * 3 + 2 ] += cb.z;\n\
\n\
\t\t\t\t\t\tnormals[ vC * 3 ]     += cb.x;\n\
\t\t\t\t\t\tnormals[ vC * 3 + 1 ] += cb.y;\n\
\t\t\t\t\t\tnormals[ vC * 3 + 2 ] += cb.z;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t// non-indexed elements (unconnected triangle soup)\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tfor ( i = 0, il = positions.length; i < il; i += 9 ) {\n\
\n\
\t\t\t\t\tx = positions[ i ];\n\
\t\t\t\t\ty = positions[ i + 1 ];\n\
\t\t\t\t\tz = positions[ i + 2 ];\n\
\t\t\t\t\tpA.set( x, y, z );\n\
\n\
\t\t\t\t\tx = positions[ i + 3 ];\n\
\t\t\t\t\ty = positions[ i + 4 ];\n\
\t\t\t\t\tz = positions[ i + 5 ];\n\
\t\t\t\t\tpB.set( x, y, z );\n\
\n\
\t\t\t\t\tx = positions[ i + 6 ];\n\
\t\t\t\t\ty = positions[ i + 7 ];\n\
\t\t\t\t\tz = positions[ i + 8 ];\n\
\t\t\t\t\tpC.set( x, y, z );\n\
\n\
\t\t\t\t\tcb.subVectors( pC, pB );\n\
\t\t\t\t\tab.subVectors( pA, pB );\n\
\t\t\t\t\tcb.cross( ab );\n\
\n\
\t\t\t\t\tnormals[ i ] \t = cb.x;\n\
\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\
\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\
\n\
\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\
\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\
\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\
\n\
\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\
\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\
\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tthis.normalizeNormals();\n\
\n\
\t\t\tthis.normalsNeedUpdate = true;\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tnormalizeNormals: function () {\n\
\n\
\t\tvar normals = this.attributes[ \"normal\" ].array;\n\
\n\
\t\tvar x, y, z, n;\n\
\n\
\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\
\n\
\t\t\tx = normals[ i ];\n\
\t\t\ty = normals[ i + 1 ];\n\
\t\t\tz = normals[ i + 2 ];\n\
\n\
\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\
\n\
\t\t\tnormals[ i ] \t *= n;\n\
\t\t\tnormals[ i + 1 ] *= n;\n\
\t\t\tnormals[ i + 2 ] *= n;\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tcomputeTangents: function () {\n\
\n\
\t\t// based on http://www.terathon.com/code/tangent.html\n\
\t\t// (per vertex tangents)\n\
\n\
\t\tif ( this.attributes[ \"index\" ] === undefined ||\n\
\t\t\t this.attributes[ \"position\" ] === undefined ||\n\
\t\t\t this.attributes[ \"normal\" ] === undefined ||\n\
\t\t\t this.attributes[ \"uv\" ] === undefined ) {\n\
\n\
\t\t\tconsole.warn( \"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\" );\n\
\t\t\treturn;\n\
\n\
\t\t}\n\
\n\
\t\tvar indices = this.attributes[ \"index\" ].array;\n\
\t\tvar positions = this.attributes[ \"position\" ].array;\n\
\t\tvar normals = this.attributes[ \"normal\" ].array;\n\
\t\tvar uvs = this.attributes[ \"uv\" ].array;\n\
\n\
\t\tvar nVertices = positions.length / 3;\n\
\n\
\t\tif ( this.attributes[ \"tangent\" ] === undefined ) {\n\
\n\
\t\t\tvar nTangentElements = 4 * nVertices;\n\
\n\
\t\t\tthis.attributes[ \"tangent\" ] = {\n\
\n\
\t\t\t\titemSize: 4,\n\
\t\t\t\tarray: new Float32Array( nTangentElements )\n\
\n\
\t\t\t};\n\
\n\
\t\t}\n\
\n\
\t\tvar tangents = this.attributes[ \"tangent\" ].array;\n\
\n\
\t\tvar tan1 = [], tan2 = [];\n\
\n\
\t\tfor ( var k = 0; k < nVertices; k ++ ) {\n\
\n\
\t\t\ttan1[ k ] = new THREE.Vector3();\n\
\t\t\ttan2[ k ] = new THREE.Vector3();\n\
\n\
\t\t}\n\
\n\
\t\tvar xA, yA, zA,\n\
\t\t\txB, yB, zB,\n\
\t\t\txC, yC, zC,\n\
\n\
\t\t\tuA, vA,\n\
\t\t\tuB, vB,\n\
\t\t\tuC, vC,\n\
\n\
\t\t\tx1, x2, y1, y2, z1, z2,\n\
\t\t\ts1, s2, t1, t2, r;\n\
\n\
\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\n\
\n\
\t\tfunction handleTriangle( a, b, c ) {\n\
\n\
\t\t\txA = positions[ a * 3 ];\n\
\t\t\tyA = positions[ a * 3 + 1 ];\n\
\t\t\tzA = positions[ a * 3 + 2 ];\n\
\n\
\t\t\txB = positions[ b * 3 ];\n\
\t\t\tyB = positions[ b * 3 + 1 ];\n\
\t\t\tzB = positions[ b * 3 + 2 ];\n\
\n\
\t\t\txC = positions[ c * 3 ];\n\
\t\t\tyC = positions[ c * 3 + 1 ];\n\
\t\t\tzC = positions[ c * 3 + 2 ];\n\
\n\
\t\t\tuA = uvs[ a * 2 ];\n\
\t\t\tvA = uvs[ a * 2 + 1 ];\n\
\n\
\t\t\tuB = uvs[ b * 2 ];\n\
\t\t\tvB = uvs[ b * 2 + 1 ];\n\
\n\
\t\t\tuC = uvs[ c * 2 ];\n\
\t\t\tvC = uvs[ c * 2 + 1 ];\n\
\n\
\t\t\tx1 = xB - xA;\n\
\t\t\tx2 = xC - xA;\n\
\n\
\t\t\ty1 = yB - yA;\n\
\t\t\ty2 = yC - yA;\n\
\n\
\t\t\tz1 = zB - zA;\n\
\t\t\tz2 = zC - zA;\n\
\n\
\t\t\ts1 = uB - uA;\n\
\t\t\ts2 = uC - uA;\n\
\n\
\t\t\tt1 = vB - vA;\n\
\t\t\tt2 = vC - vA;\n\
\n\
\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\n\
\n\
\t\t\tsdir.set(\n\
\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\n\
\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\n\
\t\t\t\t( t2 * z1 - t1 * z2 ) * r\n\
\t\t\t);\n\
\n\
\t\t\ttdir.set(\n\
\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\n\
\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\n\
\t\t\t\t( s1 * z2 - s2 * z1 ) * r\n\
\t\t\t);\n\
\n\
\t\t\ttan1[ a ].add( sdir );\n\
\t\t\ttan1[ b ].add( sdir );\n\
\t\t\ttan1[ c ].add( sdir );\n\
\n\
\t\t\ttan2[ a ].add( tdir );\n\
\t\t\ttan2[ b ].add( tdir );\n\
\t\t\ttan2[ c ].add( tdir );\n\
\n\
\t\t}\n\
\n\
\t\tvar i, il;\n\
\t\tvar j, jl;\n\
\t\tvar iA, iB, iC;\n\
\n\
\t\tvar offsets = this.offsets;\n\
\n\
\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\
\n\
\t\t\tvar start = offsets[ j ].start;\n\
\t\t\tvar count = offsets[ j ].count;\n\
\t\t\tvar index = offsets[ j ].index;\n\
\n\
\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\
\n\
\t\t\t\tiA = index + indices[ i ];\n\
\t\t\t\tiB = index + indices[ i + 1 ];\n\
\t\t\t\tiC = index + indices[ i + 2 ];\n\
\n\
\t\t\t\thandleTriangle( iA, iB, iC );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\n\
\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\n\
\t\tvar w, t, test;\n\
\n\
\t\tfunction handleVertex( v ) {\n\
\n\
\t\t\tn.x = normals[ v * 3 ];\n\
\t\t\tn.y = normals[ v * 3 + 1 ];\n\
\t\t\tn.z = normals[ v * 3 + 2 ];\n\
\n\
\t\t\tn2.copy( n );\n\
\n\
\t\t\tt = tan1[ v ];\n\
\n\
\t\t\t// Gram-Schmidt orthogonalize\n\
\n\
\t\t\ttmp.copy( t );\n\
\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\
\n\
\t\t\t// Calculate handedness\n\
\n\
\t\t\ttmp2.crossVectors( n2, t );\n\
\t\t\ttest = tmp2.dot( tan2[ v ] );\n\
\t\t\tw = ( test < 0.0 ) ? -1.0 : 1.0;\n\
\n\
\t\t\ttangents[ v * 4 ]     = tmp.x;\n\
\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\
\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\
\t\t\ttangents[ v * 4 + 3 ] = w;\n\
\n\
\t\t}\n\
\n\
\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\
\n\
\t\t\tvar start = offsets[ j ].start;\n\
\t\t\tvar count = offsets[ j ].count;\n\
\t\t\tvar index = offsets[ j ].index;\n\
\n\
\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\
\n\
\t\t\t\tiA = index + indices[ i ];\n\
\t\t\t\tiB = index + indices[ i + 1 ];\n\
\t\t\t\tiC = index + indices[ i + 2 ];\n\
\n\
\t\t\t\thandleVertex( iA );\n\
\t\t\t\thandleVertex( iB );\n\
\t\t\t\thandleVertex( iC );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tthis.hasTangents = true;\n\
\t\tthis.tangentsNeedUpdate = true;\n\
\n\
\t},\n\
\n\
\tdispose: function () {\n\
\n\
\t\tthis.dispatchEvent( { type: 'dispose' } );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
*/\n\
\n\
THREE.Camera = function () {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.matrixWorldInverse = new THREE.Matrix4();\n\
\n\
\tthis.projectionMatrix = new THREE.Matrix4();\n\
\tthis.projectionMatrixInverse = new THREE.Matrix4();\n\
\n\
};\n\
\n\
THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.Camera.prototype.lookAt = function () {\n\
\n\
\t// This routine does not support cameras with rotated and/or translated parent(s)\n\
\n\
\tvar m1 = new THREE.Matrix4();\n\
\n\
\treturn function ( vector ) {\n\
\n\
\t\tm1.lookAt( this.position, vector, this.up );\n\
\n\
\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\
\n\
\t};\n\
\n\
}();\n\
\n\
THREE.Camera.prototype.clone = function (camera) {\n\
\n\
\tif ( camera === undefined ) camera = new THREE.Camera();\n\
\n\
\tTHREE.Object3D.prototype.clone.call( this, camera );\n\
\n\
\tcamera.matrixWorldInverse.copy( this.matrixWorldInverse );\n\
\tcamera.projectionMatrix.copy( this.projectionMatrix );\n\
\tcamera.projectionMatrixInverse.copy( this.projectionMatrixInverse );\n\
\n\
\treturn camera;\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\
\n\
\tTHREE.Camera.call( this );\n\
\n\
\tthis.left = left;\n\
\tthis.right = right;\n\
\tthis.top = top;\n\
\tthis.bottom = bottom;\n\
\n\
\tthis.near = ( near !== undefined ) ? near : 0.1;\n\
\tthis.far = ( far !== undefined ) ? far : 2000;\n\
\n\
\tthis.updateProjectionMatrix();\n\
\n\
};\n\
\n\
THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\n\
\n\
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\n\
\n\
\tthis.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );\n\
\n\
};\n\
\n\
THREE.OrthographicCamera.prototype.clone = function () {\n\
\n\
\tvar camera = new THREE.OrthographicCamera();\n\
\n\
\tTHREE.Camera.prototype.clone.call( this, camera );\n\
\n\
\tcamera.left = this.left;\n\
\tcamera.right = this.right;\n\
\tcamera.top = this.top;\n\
\tcamera.bottom = this.bottom;\n\
\t\n\
\tcamera.near = this.near;\n\
\tcamera.far = this.far;\n\
\n\
\treturn camera;\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author greggman / http://games.greggman.com/\n\
 * @author zz85 / http://www.lab4games.net/zz85/blog\n\
 */\n\
\n\
THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\n\
\n\
\tTHREE.Camera.call( this );\n\
\n\
\tthis.fov = fov !== undefined ? fov : 50;\n\
\tthis.aspect = aspect !== undefined ? aspect : 1;\n\
\tthis.near = near !== undefined ? near : 0.1;\n\
\tthis.far = far !== undefined ? far : 2000;\n\
\n\
\tthis.updateProjectionMatrix();\n\
\n\
};\n\
\n\
THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\n\
\n\
\n\
/**\n\
 * Uses Focal Length (in mm) to estimate and set FOV\n\
 * 35mm (fullframe) camera is used if frame size is not specified;\n\
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n\
 */\n\
\n\
THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\n\
\n\
\tif ( frameHeight === undefined ) frameHeight = 24;\n\
\n\
\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\n\
\tthis.updateProjectionMatrix();\n\
\n\
}\n\
\n\
\n\
/**\n\
 * Sets an offset in a larger frustum. This is useful for multi-window or\n\
 * multi-monitor/multi-machine setups.\n\
 *\n\
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\
 * the monitors are in grid like this\n\
 *\n\
 *   +---+---+---+\n\
 *   | A | B | C |\n\
 *   +---+---+---+\n\
 *   | D | E | F |\n\
 *   +---+---+---+\n\
 *\n\
 * then for each monitor you would call it like this\n\
 *\n\
 *   var w = 1920;\n\
 *   var h = 1080;\n\
 *   var fullWidth = w * 3;\n\
 *   var fullHeight = h * 2;\n\
 *\n\
 *   --A--\n\
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\
 *   --B--\n\
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\
 *   --C--\n\
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\
 *   --D--\n\
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\
 *   --E--\n\
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\
 *   --F--\n\
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\
 *\n\
 *   Note there is no reason monitors have to be the same size or in a grid.\n\
 */\n\
\n\
THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\n\
\n\
\tthis.fullWidth = fullWidth;\n\
\tthis.fullHeight = fullHeight;\n\
\tthis.x = x;\n\
\tthis.y = y;\n\
\tthis.width = width;\n\
\tthis.height = height;\n\
\n\
\tthis.updateProjectionMatrix();\n\
\n\
};\n\
\n\
\n\
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\n\
\n\
\tif ( this.fullWidth ) {\n\
\n\
\t\tvar aspect = this.fullWidth / this.fullHeight;\n\
\t\tvar top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;\n\
\t\tvar bottom = -top;\n\
\t\tvar left = aspect * bottom;\n\
\t\tvar right = aspect * top;\n\
\t\tvar width = Math.abs( right - left );\n\
\t\tvar height = Math.abs( top - bottom );\n\
\n\
\t\tthis.projectionMatrix.makeFrustum(\n\
\t\t\tleft + this.x * width / this.fullWidth,\n\
\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\n\
\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\n\
\t\t\ttop - this.y * height / this.fullHeight,\n\
\t\t\tthis.near,\n\
\t\t\tthis.far\n\
\t\t);\n\
\n\
\t} else {\n\
\n\
\t\tthis.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.PerspectiveCamera.prototype.clone = function () {\n\
\n\
\tvar camera = new THREE.PerspectiveCamera();\n\
\n\
\tTHREE.Camera.prototype.clone.call( this, camera );\n\
\n\
\tcamera.fov = this.fov;\n\
\tcamera.aspect = this.aspect;\n\
\tcamera.near = this.near;\n\
\tcamera.far = this.far;\n\
\n\
\treturn camera;\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
 \n\
THREE.Light = function ( hex ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.color = new THREE.Color( hex );\n\
\n\
};\n\
\n\
THREE.Light.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.Light.prototype.clone = function ( light ) {\n\
\n\
\tif ( light === undefined ) light = new THREE.Light();\n\
\n\
\tTHREE.Object3D.prototype.clone.call( this, light );\n\
\n\
\tlight.color.copy( this.color );\n\
\n\
\treturn light;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.AmbientLight = function ( hex ) {\n\
\n\
\tTHREE.Light.call( this, hex );\n\
\n\
};\n\
\n\
THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\n\
\n\
THREE.AmbientLight.prototype.clone = function () {\n\
\n\
\tvar light = new THREE.AmbientLight();\n\
\n\
\tTHREE.Light.prototype.clone.call( this, light );\n\
\n\
\treturn light;\n\
\n\
};\n\
\n\
/**\n\
 * @author MPanknin / http://www.redplant.de/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.AreaLight = function ( hex, intensity ) {\n\
\n\
\tTHREE.Light.call( this, hex );\n\
\n\
\tthis.normal = new THREE.Vector3( 0, -1, 0 );\n\
\tthis.right = new THREE.Vector3( 1, 0, 0 );\n\
\n\
\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\
\n\
\tthis.width = 1.0;\n\
\tthis.height = 1.0;\n\
\n\
\tthis.constantAttenuation = 1.5;\n\
\tthis.linearAttenuation = 0.5;\n\
\tthis.quadraticAttenuation = 0.1;\n\
\n\
};\n\
\n\
THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\n\
\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.DirectionalLight = function ( hex, intensity ) {\n\
\n\
\tTHREE.Light.call( this, hex );\n\
\n\
\tthis.position.set( 0, 1, 0 );\n\
\tthis.target = new THREE.Object3D();\n\
\n\
\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\
\n\
\tthis.castShadow = false;\n\
\tthis.onlyShadow = false;\n\
\n\
\t//\n\
\n\
\tthis.shadowCameraNear = 50;\n\
\tthis.shadowCameraFar = 5000;\n\
\n\
\tthis.shadowCameraLeft = -500;\n\
\tthis.shadowCameraRight = 500;\n\
\tthis.shadowCameraTop = 500;\n\
\tthis.shadowCameraBottom = -500;\n\
\n\
\tthis.shadowCameraVisible = false;\n\
\n\
\tthis.shadowBias = 0;\n\
\tthis.shadowDarkness = 0.5;\n\
\n\
\tthis.shadowMapWidth = 512;\n\
\tthis.shadowMapHeight = 512;\n\
\n\
\t//\n\
\n\
\tthis.shadowCascade = false;\n\
\n\
\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );\n\
\tthis.shadowCascadeCount = 2;\n\
\n\
\tthis.shadowCascadeBias = [ 0, 0, 0 ];\n\
\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\n\
\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\n\
\n\
\tthis.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];\n\
\tthis.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];\n\
\n\
\tthis.shadowCascadeArray = [];\n\
\n\
\t//\n\
\n\
\tthis.shadowMap = null;\n\
\tthis.shadowMapSize = null;\n\
\tthis.shadowCamera = null;\n\
\tthis.shadowMatrix = null;\n\
\n\
};\n\
\n\
THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\n\
\n\
THREE.DirectionalLight.prototype.clone = function () {\n\
\n\
\tvar light = new THREE.DirectionalLight();\n\
\n\
\tTHREE.Light.prototype.clone.call( this, light );\n\
\n\
\tlight.target = this.target.clone();\n\
\n\
\tlight.intensity = this.intensity;\n\
\n\
\tlight.castShadow = this.castShadow;\n\
\tlight.onlyShadow = this.onlyShadow;\n\
\n\
\treturn light;\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {\n\
\n\
\tTHREE.Light.call( this, skyColorHex );\n\
\n\
\tthis.position.set( 0, 100, 0 );\n\
\n\
\tthis.groundColor = new THREE.Color( groundColorHex );\n\
\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\
\n\
};\n\
\n\
THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\n\
\n\
THREE.HemisphereLight.prototype.clone = function () {\n\
\n\
\tvar light = new THREE.HemisphereLight();\n\
\n\
\tTHREE.Light.prototype.clone.call( this, light );\n\
\n\
\tlight.groundColor.copy( this.groundColor );\n\
\tlight.intensity = this.intensity;\n\
\n\
\treturn light;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.PointLight = function ( hex, intensity, distance ) {\n\
\n\
\tTHREE.Light.call( this, hex );\n\
\n\
\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\
\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\
\n\
};\n\
\n\
THREE.PointLight.prototype = Object.create( THREE.Light.prototype );\n\
\n\
THREE.PointLight.prototype.clone = function () {\n\
\n\
\tvar light = new THREE.PointLight();\n\
\n\
\tTHREE.Light.prototype.clone.call( this, light );\n\
\n\
\tlight.intensity = this.intensity;\n\
\tlight.distance = this.distance;\n\
\n\
\treturn light;\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {\n\
\n\
\tTHREE.Light.call( this, hex );\n\
\n\
\tthis.position.set( 0, 1, 0 );\n\
\tthis.target = new THREE.Object3D();\n\
\n\
\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\
\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\
\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\
\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\n\
\n\
\tthis.castShadow = false;\n\
\tthis.onlyShadow = false;\n\
\n\
\t//\n\
\n\
\tthis.shadowCameraNear = 50;\n\
\tthis.shadowCameraFar = 5000;\n\
\tthis.shadowCameraFov = 50;\n\
\n\
\tthis.shadowCameraVisible = false;\n\
\n\
\tthis.shadowBias = 0;\n\
\tthis.shadowDarkness = 0.5;\n\
\n\
\tthis.shadowMapWidth = 512;\n\
\tthis.shadowMapHeight = 512;\n\
\n\
\t//\n\
\n\
\tthis.shadowMap = null;\n\
\tthis.shadowMapSize = null;\n\
\tthis.shadowCamera = null;\n\
\tthis.shadowMatrix = null;\n\
\n\
};\n\
\n\
THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\n\
\n\
THREE.SpotLight.prototype.clone = function () {\n\
\n\
\tvar light = new THREE.SpotLight();\n\
\n\
\tTHREE.Light.prototype.clone.call( this, light );\n\
\n\
\tlight.target = this.target.clone();\n\
\n\
\tlight.intensity = this.intensity;\n\
\tlight.distance = this.distance;\n\
\tlight.angle = this.angle;\n\
\tlight.exponent = this.exponent;\n\
\n\
\tlight.castShadow = this.castShadow;\n\
\tlight.onlyShadow = this.onlyShadow;\n\
\n\
\treturn light;\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Loader = function ( showStatus ) {\n\
\n\
\tthis.showStatus = showStatus;\n\
\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\n\
\n\
\tthis.onLoadStart = function () {};\n\
\tthis.onLoadProgress = function () {};\n\
\tthis.onLoadComplete = function () {};\n\
\n\
};\n\
\n\
THREE.Loader.prototype = {\n\
\n\
\tconstructor: THREE.Loader,\n\
\n\
\tcrossOrigin: 'anonymous',\n\
\n\
\taddStatusElement: function () {\n\
\n\
\t\tvar e = document.createElement( \"div\" );\n\
\n\
\t\te.style.position = \"absolute\";\n\
\t\te.style.right = \"0px\";\n\
\t\te.style.top = \"0px\";\n\
\t\te.style.fontSize = \"0.8em\";\n\
\t\te.style.textAlign = \"left\";\n\
\t\te.style.background = \"rgba(0,0,0,0.25)\";\n\
\t\te.style.color = \"#fff\";\n\
\t\te.style.width = \"120px\";\n\
\t\te.style.padding = \"0.5em 0.5em 0.5em 0.5em\";\n\
\t\te.style.zIndex = 1000;\n\
\n\
\t\te.innerHTML = \"Loading ...\";\n\
\n\
\t\treturn e;\n\
\n\
\t},\n\
\n\
\tupdateProgress: function ( progress ) {\n\
\n\
\t\tvar message = \"Loaded \";\n\
\n\
\t\tif ( progress.total ) {\n\
\n\
\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed(0) + \"%\";\n\
\n\
\n\
\t\t} else {\n\
\n\
\t\t\tmessage += ( progress.loaded / 1000 ).toFixed(2) + \" KB\";\n\
\n\
\t\t}\n\
\n\
\t\tthis.statusDomElement.innerHTML = message;\n\
\n\
\t},\n\
\n\
\textractUrlBase: function ( url ) {\n\
\n\
\t\tvar parts = url.split( '/' );\n\
\t\tparts.pop();\n\
\t\treturn ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\n\
\n\
\t},\n\
\n\
\tinitMaterials: function ( materials, texturePath ) {\n\
\n\
\t\tvar array = [];\n\
\n\
\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\
\n\
\t\t\tarray[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );\n\
\n\
\t\t}\n\
\n\
\t\treturn array;\n\
\n\
\t},\n\
\n\
\tneedsTangents: function ( materials ) {\n\
\n\
\t\tfor( var i = 0, il = materials.length; i < il; i ++ ) {\n\
\n\
\t\t\tvar m = materials[ i ];\n\
\n\
\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\n\
\n\
\t\t}\n\
\n\
\t\treturn false;\n\
\n\
\t},\n\
\n\
\tcreateMaterial: function ( m, texturePath ) {\n\
\n\
\t\tvar _this = this;\n\
\n\
\t\tfunction is_pow2( n ) {\n\
\n\
\t\t\tvar l = Math.log( n ) / Math.LN2;\n\
\t\t\treturn Math.floor( l ) == l;\n\
\n\
\t\t}\n\
\n\
\t\tfunction nearest_pow2( n ) {\n\
\n\
\t\t\tvar l = Math.log( n ) / Math.LN2;\n\
\t\t\treturn Math.pow( 2, Math.round(  l ) );\n\
\n\
\t\t}\n\
\n\
\t\tfunction load_image( where, url ) {\n\
\n\
\t\t\tvar image = new Image();\n\
\n\
\t\t\timage.onload = function () {\n\
\n\
\t\t\t\tif ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {\n\
\n\
\t\t\t\t\tvar width = nearest_pow2( this.width );\n\
\t\t\t\t\tvar height = nearest_pow2( this.height );\n\
\n\
\t\t\t\t\twhere.image.width = width;\n\
\t\t\t\t\twhere.image.height = height;\n\
\t\t\t\t\twhere.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\twhere.image = this;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\twhere.needsUpdate = true;\n\
\n\
\t\t\t};\n\
\n\
\t\t\timage.crossOrigin = _this.crossOrigin;\n\
\t\t\timage.src = url;\n\
\n\
\t\t}\n\
\n\
\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\n\
\n\
\t\t\tvar isCompressed = /\\.dds$/i.test( sourceFile );\n\
\t\t\tvar fullPath = texturePath + \"/\" + sourceFile;\n\
\n\
\t\t\tif ( isCompressed ) {\n\
\n\
\t\t\t\tvar texture = THREE.ImageUtils.loadCompressedTexture( fullPath );\n\
\n\
\t\t\t\twhere[ name ] = texture;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tvar texture = document.createElement( 'canvas' );\n\
\n\
\t\t\t\twhere[ name ] = new THREE.Texture( texture );\n\
\n\
\t\t\t}\n\
\n\
\t\t\twhere[ name ].sourceFile = sourceFile;\n\
\n\
\t\t\tif( repeat ) {\n\
\n\
\t\t\t\twhere[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );\n\
\n\
\t\t\t\tif ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;\n\
\t\t\t\tif ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( offset ) {\n\
\n\
\t\t\t\twhere[ name ].offset.set( offset[ 0 ], offset[ 1 ] );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( wrap ) {\n\
\n\
\t\t\t\tvar wrapMap = {\n\
\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\n\
\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];\n\
\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( anisotropy ) {\n\
\n\
\t\t\t\twhere[ name ].anisotropy = anisotropy;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( ! isCompressed ) {\n\
\n\
\t\t\t\tload_image( where[ name ], fullPath );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tfunction rgb2hex( rgb ) {\n\
\n\
\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\n\
\n\
\t\t}\n\
\n\
\t\t// defaults\n\
\n\
\t\tvar mtype = \"MeshLambertMaterial\";\n\
\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\n\
\n\
\t\t// parameters from model file\n\
\n\
\t\tif ( m.shading ) {\n\
\n\
\t\t\tvar shading = m.shading.toLowerCase();\n\
\n\
\t\t\tif ( shading === \"phong\" ) mtype = \"MeshPhongMaterial\";\n\
\t\t\telse if ( shading === \"basic\" ) mtype = \"MeshBasicMaterial\";\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\n\
\n\
\t\t\tmpars.blending = THREE[ m.blending ];\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.transparent !== undefined || m.opacity < 1.0 ) {\n\
\n\
\t\t\tmpars.transparent = m.transparent;\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.depthTest !== undefined ) {\n\
\n\
\t\t\tmpars.depthTest = m.depthTest;\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.depthWrite !== undefined ) {\n\
\n\
\t\t\tmpars.depthWrite = m.depthWrite;\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.visible !== undefined ) {\n\
\n\
\t\t\tmpars.visible = m.visible;\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.flipSided !== undefined ) {\n\
\n\
\t\t\tmpars.side = THREE.BackSide;\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.doubleSided !== undefined ) {\n\
\n\
\t\t\tmpars.side = THREE.DoubleSide;\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.wireframe !== undefined ) {\n\
\n\
\t\t\tmpars.wireframe = m.wireframe;\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.vertexColors !== undefined ) {\n\
\n\
\t\t\tif ( m.vertexColors === \"face\" ) {\n\
\n\
\t\t\t\tmpars.vertexColors = THREE.FaceColors;\n\
\n\
\t\t\t} else if ( m.vertexColors ) {\n\
\n\
\t\t\t\tmpars.vertexColors = THREE.VertexColors;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// colors\n\
\n\
\t\tif ( m.colorDiffuse ) {\n\
\n\
\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\n\
\n\
\t\t} else if ( m.DbgColor ) {\n\
\n\
\t\t\tmpars.color = m.DbgColor;\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.colorSpecular ) {\n\
\n\
\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.colorAmbient ) {\n\
\n\
\t\t\tmpars.ambient = rgb2hex( m.colorAmbient );\n\
\n\
\t\t}\n\
\n\
\t\t// modifiers\n\
\n\
\t\tif ( m.transparency ) {\n\
\n\
\t\t\tmpars.opacity = m.transparency;\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.specularCoef ) {\n\
\n\
\t\t\tmpars.shininess = m.specularCoef;\n\
\n\
\t\t}\n\
\n\
\t\t// textures\n\
\n\
\t\tif ( m.mapDiffuse && texturePath ) {\n\
\n\
\t\t\tcreate_texture( mpars, \"map\", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.mapLight && texturePath ) {\n\
\n\
\t\t\tcreate_texture( mpars, \"lightMap\", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.mapBump && texturePath ) {\n\
\n\
\t\t\tcreate_texture( mpars, \"bumpMap\", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.mapNormal && texturePath ) {\n\
\n\
\t\t\tcreate_texture( mpars, \"normalMap\", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.mapSpecular && texturePath ) {\n\
\n\
\t\t\tcreate_texture( mpars, \"specularMap\", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\
\n\
\t\t}\n\
\n\
\t\t//\n\
\n\
\t\tif ( m.mapBumpScale ) {\n\
\n\
\t\t\tmpars.bumpScale = m.mapBumpScale;\n\
\n\
\t\t}\n\
\n\
\t\t// special case for normal mapped material\n\
\n\
\t\tif ( m.mapNormal ) {\n\
\n\
\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\n\
\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\
\n\
\t\t\tuniforms[ \"tNormal\" ].value = mpars.normalMap;\n\
\n\
\t\t\tif ( m.mapNormalFactor ) {\n\
\n\
\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( m.mapNormalFactor, m.mapNormalFactor );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( mpars.map ) {\n\
\n\
\t\t\t\tuniforms[ \"tDiffuse\" ].value = mpars.map;\n\
\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( mpars.specularMap ) {\n\
\n\
\t\t\t\tuniforms[ \"tSpecular\" ].value = mpars.specularMap;\n\
\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( mpars.lightMap ) {\n\
\n\
\t\t\t\tuniforms[ \"tAO\" ].value = mpars.lightMap;\n\
\t\t\t\tuniforms[ \"enableAO\" ].value = true;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// for the moment don't handle displacement texture\n\
\n\
\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( mpars.color );\n\
\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( mpars.specular );\n\
\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( mpars.ambient );\n\
\n\
\t\t\tuniforms[ \"uShininess\" ].value = mpars.shininess;\n\
\n\
\t\t\tif ( mpars.opacity !== undefined ) {\n\
\n\
\t\t\t\tuniforms[ \"uOpacity\" ].value = mpars.opacity;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\n\
\t\t\tvar material = new THREE.ShaderMaterial( parameters );\n\
\n\
\t\t\tif ( mpars.transparent ) {\n\
\n\
\t\t\t\tmaterial.transparent = true;\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tvar material = new THREE[ mtype ]( mpars );\n\
\n\
\t\t}\n\
\n\
\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\n\
\n\
\t\treturn material;\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.XHRLoader = function ( manager ) {\n\
\n\
\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\
\n\
};\n\
\n\
THREE.XHRLoader.prototype = {\n\
\n\
\tconstructor: THREE.XHRLoader,\n\
\n\
\tload: function ( url, onLoad, onProgress, onError ) {\n\
\n\
\t\tvar scope = this;\n\
\t\tvar request = new XMLHttpRequest();\n\
\n\
\t\tif ( onLoad !== undefined ) {\n\
\n\
\t\t\trequest.addEventListener( 'load', function ( event ) {\n\
\n\
\t\t\t\tonLoad( event.target.responseText );\n\
\t\t\t\tscope.manager.itemEnd( url );\n\
\n\
\t\t\t}, false );\n\
\n\
\t\t}\n\
\n\
\t\tif ( onProgress !== undefined ) {\n\
\n\
\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\
\n\
\t\t\t\tonProgress( event );\n\
\n\
\t\t\t}, false );\n\
\n\
\t\t}\n\
\n\
\t\tif ( onError !== undefined ) {\n\
\n\
\t\t\trequest.addEventListener( 'error', function ( event ) {\n\
\n\
\t\t\t\tonError( event );\n\
\n\
\t\t\t}, false );\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;\n\
\n\
\t\trequest.open( 'GET', url, true );\n\
\t\trequest.send( null );\n\
\n\
\t\tscope.manager.itemStart( url );\n\
\n\
\t},\n\
\n\
\tsetCrossOrigin: function ( value ) {\n\
\n\
\t\tthis.crossOrigin = value;\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.ImageLoader = function ( manager ) {\n\
\n\
\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\
\n\
};\n\
\n\
THREE.ImageLoader.prototype = {\n\
\n\
\tconstructor: THREE.ImageLoader,\n\
\n\
\tload: function ( url, onLoad, onProgress, onError ) {\n\
\n\
\t\tvar scope = this;\n\
\t\tvar image = document.createElement( 'img' );\n\
\n\
\t\tif ( onLoad !== undefined ) {\n\
\n\
\t\t\timage.addEventListener( 'load', function ( event ) {\n\
\n\
\t\t\t\tscope.manager.itemEnd( url );\n\
\t\t\t\tonLoad( this );\n\
\n\
\t\t\t}, false );\n\
\n\
\t\t}\n\
\n\
\t\tif ( onProgress !== undefined ) {\n\
\n\
\t\t\timage.addEventListener( 'progress', function ( event ) {\n\
\n\
\t\t\t\tonProgress( event );\n\
\n\
\t\t\t}, false );\n\
\n\
\t\t}\n\
\n\
\t\tif ( onError !== undefined ) {\n\
\n\
\t\t\timage.addEventListener( 'error', function ( event ) {\n\
\n\
\t\t\t\tonError( event );\n\
\n\
\t\t\t}, false );\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\
\n\
\t\timage.src = url;\n\
\n\
\t\tscope.manager.itemStart( url );\n\
\n\
\t},\n\
\n\
\tsetCrossOrigin: function ( value ) {\n\
\n\
\t\tthis.crossOrigin = value;\n\
\n\
\t}\n\
\n\
}\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.JSONLoader = function ( showStatus ) {\n\
\n\
\tTHREE.Loader.call( this, showStatus );\n\
\n\
\tthis.withCredentials = false;\n\
\n\
};\n\
\n\
THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\n\
\n\
THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\n\
\n\
\tvar scope = this;\n\
\n\
\t// todo: unify load API to for easier SceneLoader use\n\
\n\
\ttexturePath = texturePath && ( typeof texturePath === \"string\" ) ? texturePath : this.extractUrlBase( url );\n\
\n\
\tthis.onLoadStart();\n\
\tthis.loadAjaxJSON( this, url, callback, texturePath );\n\
\n\
};\n\
\n\
THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\n\
\n\
\tvar xhr = new XMLHttpRequest();\n\
\n\
\tvar length = 0;\n\
\n\
\txhr.onreadystatechange = function () {\n\
\n\
\t\tif ( xhr.readyState === xhr.DONE ) {\n\
\n\
\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\n\
\n\
\t\t\t\tif ( xhr.responseText ) {\n\
\n\
\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\n\
\t\t\t\t\tvar result = context.parse( json, texturePath );\n\
\t\t\t\t\tcallback( result.geometry, result.materials );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tconsole.warn( \"THREE.JSONLoader: [\" + url + \"] seems to be unreachable or file there is empty\" );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// in context of more complex asset initialization\n\
\t\t\t\t// do not block on single failed file\n\
\t\t\t\t// maybe should go even one more level up\n\
\n\
\t\t\t\tcontext.onLoadComplete();\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tconsole.error( \"THREE.JSONLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( xhr.readyState === xhr.LOADING ) {\n\
\n\
\t\t\tif ( callbackProgress ) {\n\
\n\
\t\t\t\tif ( length === 0 ) {\n\
\n\
\t\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\n\
\n\
\t\t\tif ( callbackProgress !== undefined ) {\n\
\n\
\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\txhr.open( \"GET\", url, true );\n\
\txhr.withCredentials = this.withCredentials;\n\
\txhr.send( null );\n\
\n\
};\n\
\n\
THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {\n\
\n\
\tvar scope = this,\n\
\tgeometry = new THREE.Geometry(),\n\
\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\
\n\
\tparseModel( scale );\n\
\n\
\tparseSkin();\n\
\tparseMorphing( scale );\n\
\n\
\tgeometry.computeCentroids();\n\
\tgeometry.computeFaceNormals();\n\
\tgeometry.computeBoundingSphere();\n\
\n\
\tfunction parseModel( scale ) {\n\
\n\
\t\tfunction isBitSet( value, position ) {\n\
\n\
\t\t\treturn value & ( 1 << position );\n\
\n\
\t\t}\n\
\n\
\t\tvar i, j, fi,\n\
\n\
\t\toffset, zLength,\n\
\n\
\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\
\n\
\t\ttype,\n\
\t\tisQuad,\n\
\t\thasMaterial,\n\
\t\thasFaceVertexUv,\n\
\t\thasFaceNormal, hasFaceVertexNormal,\n\
\t\thasFaceColor, hasFaceVertexColor,\n\
\n\
\t\tvertex, face, faceA, faceB, color, hex, normal,\n\
\n\
\t\tuvLayer, uv, u, v,\n\
\n\
\t\tfaces = json.faces,\n\
\t\tvertices = json.vertices,\n\
\t\tnormals = json.normals,\n\
\t\tcolors = json.colors,\n\
\n\
\t\tnUvLayers = 0;\n\
\n\
\t\tif ( json.uvs !== undefined ) {\n\
\n\
\t\t\t// disregard empty arrays\n\
\n\
\t\t\tfor ( i = 0; i < json.uvs.length; i++ ) {\n\
\n\
\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\n\
\n\
\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\toffset = 0;\n\
\t\tzLength = vertices.length;\n\
\n\
\t\twhile ( offset < zLength ) {\n\
\n\
\t\t\tvertex = new THREE.Vector3();\n\
\n\
\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\
\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\
\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\
\n\
\t\t\tgeometry.vertices.push( vertex );\n\
\n\
\t\t}\n\
\n\
\t\toffset = 0;\n\
\t\tzLength = faces.length;\n\
\n\
\t\twhile ( offset < zLength ) {\n\
\n\
\t\t\ttype = faces[ offset ++ ];\n\
\n\
\n\
\t\t\tisQuad              = isBitSet( type, 0 );\n\
\t\t\thasMaterial         = isBitSet( type, 1 );\n\
\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\
\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\
\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\
\t\t\thasFaceColor\t    = isBitSet( type, 6 );\n\
\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\
\n\
\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\
\n\
\t\t\tif ( isQuad ) {\n\
\n\
\t\t\t\tfaceA = new THREE.Face3();\n\
\t\t\t\tfaceA.a = faces[ offset ];\n\
\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\
\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\
\n\
\t\t\t\tfaceB = new THREE.Face3();\n\
\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\
\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\
\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\
\n\
\t\t\t\toffset += 4;\n\
\n\
\t\t\t\tif ( hasMaterial ) {\n\
\n\
\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\
\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\
\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// to get face <=> uv index correspondence\n\
\n\
\t\t\t\tfi = geometry.faces.length;\n\
\n\
\t\t\t\tif ( hasFaceVertexUv ) {\n\
\n\
\t\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\n\
\n\
\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\
\n\
\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\
\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = []\n\
\n\
\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\
\n\
\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\
\n\
\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\
\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\
\n\
\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\
\n\
\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\
\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( hasFaceNormal ) {\n\
\n\
\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\
\n\
\t\t\t\t\tfaceA.normal.set(\n\
\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\
\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\
\t\t\t\t\t\tnormals[ normalIndex ]\n\
\t\t\t\t\t);\n\
\n\
\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( hasFaceVertexNormal ) {\n\
\n\
\t\t\t\t\tfor ( i = 0; i < 4; i++ ) {\n\
\n\
\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\
\n\
\t\t\t\t\t\tnormal = new THREE.Vector3(\n\
\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\
\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\
\t\t\t\t\t\t\tnormals[ normalIndex ]\n\
\t\t\t\t\t\t);\n\
\n\
\n\
\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\
\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\n\
\t\t\t\tif ( hasFaceColor ) {\n\
\n\
\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\
\t\t\t\t\thex = colors[ colorIndex ];\n\
\n\
\t\t\t\t\tfaceA.color.setHex( hex );\n\
\t\t\t\t\tfaceB.color.setHex( hex );\n\
\n\
\t\t\t\t}\n\
\n\
\n\
\t\t\t\tif ( hasFaceVertexColor ) {\n\
\n\
\t\t\t\t\tfor ( i = 0; i < 4; i++ ) {\n\
\n\
\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\
\t\t\t\t\t\thex = colors[ colorIndex ];\n\
\n\
\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\
\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tgeometry.faces.push( faceA );\n\
\t\t\t\tgeometry.faces.push( faceB );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tface = new THREE.Face3();\n\
\t\t\t\tface.a = faces[ offset ++ ];\n\
\t\t\t\tface.b = faces[ offset ++ ];\n\
\t\t\t\tface.c = faces[ offset ++ ];\n\
\n\
\t\t\t\tif ( hasMaterial ) {\n\
\n\
\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\
\t\t\t\t\tface.materialIndex = materialIndex;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// to get face <=> uv index correspondence\n\
\n\
\t\t\t\tfi = geometry.faces.length;\n\
\n\
\t\t\t\tif ( hasFaceVertexUv ) {\n\
\n\
\t\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\n\
\n\
\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\
\n\
\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\
\n\
\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\
\n\
\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\
\n\
\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\
\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\
\n\
\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\
\n\
\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( hasFaceNormal ) {\n\
\n\
\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\
\n\
\t\t\t\t\tface.normal.set(\n\
\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\
\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\
\t\t\t\t\t\tnormals[ normalIndex ]\n\
\t\t\t\t\t);\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( hasFaceVertexNormal ) {\n\
\n\
\t\t\t\t\tfor ( i = 0; i < 3; i++ ) {\n\
\n\
\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\
\n\
\t\t\t\t\t\tnormal = new THREE.Vector3(\n\
\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\
\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\
\t\t\t\t\t\t\tnormals[ normalIndex ]\n\
\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\tface.vertexNormals.push( normal );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\n\
\t\t\t\tif ( hasFaceColor ) {\n\
\n\
\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\
\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\
\n\
\t\t\t\t}\n\
\n\
\n\
\t\t\t\tif ( hasFaceVertexColor ) {\n\
\n\
\t\t\t\t\tfor ( i = 0; i < 3; i++ ) {\n\
\n\
\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\
\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tgeometry.faces.push( face );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction parseSkin() {\n\
\n\
\t\tvar i, l, x, y, z, w, a, b, c, d;\n\
\n\
\t\tif ( json.skinWeights ) {\n\
\n\
\t\t\tfor ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {\n\
\n\
\t\t\t\tx = json.skinWeights[ i     ];\n\
\t\t\t\ty = json.skinWeights[ i + 1 ];\n\
\t\t\t\tz = 0;\n\
\t\t\t\tw = 0;\n\
\n\
\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( json.skinIndices ) {\n\
\n\
\t\t\tfor ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {\n\
\n\
\t\t\t\ta = json.skinIndices[ i     ];\n\
\t\t\t\tb = json.skinIndices[ i + 1 ];\n\
\t\t\t\tc = 0;\n\
\t\t\t\td = 0;\n\
\n\
\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tgeometry.bones = json.bones;\n\
\t\tgeometry.animation = json.animation;\n\
\n\
\t};\n\
\n\
\tfunction parseMorphing( scale ) {\n\
\n\
\t\tif ( json.morphTargets !== undefined ) {\n\
\n\
\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\n\
\n\
\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\
\n\
\t\t\t\tgeometry.morphTargets[ i ] = {};\n\
\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\
\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\
\n\
\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\n\
\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\n\
\n\
\t\t\t\tfor( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\
\n\
\t\t\t\t\tvar vertex = new THREE.Vector3();\n\
\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\
\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\
\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\
\n\
\t\t\t\t\tdstVertices.push( vertex );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( json.morphColors !== undefined ) {\n\
\n\
\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\n\
\n\
\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i++ ) {\n\
\n\
\t\t\t\tgeometry.morphColors[ i ] = {};\n\
\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\n\
\t\t\t\tgeometry.morphColors[ i ].colors = [];\n\
\n\
\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\n\
\t\t\t\tsrcColors = json.morphColors [ i ].colors;\n\
\n\
\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\n\
\n\
\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\n\
\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\n\
\t\t\t\t\tdstColors.push( color );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tif ( json.materials === undefined ) {\n\
\n\
\t\treturn { geometry: geometry };\n\
\n\
\t} else {\n\
\n\
\t\tvar materials = this.initMaterials( json.materials, texturePath );\n\
\n\
\t\tif ( this.needsTangents( materials ) ) {\n\
\n\
\t\t\tgeometry.computeTangents();\n\
\n\
\t\t}\n\
\n\
\t\treturn { geometry: geometry, materials: materials };\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\
\n\
\tvar scope = this;\n\
\n\
\tvar loaded = 0, total = 0;\n\
\n\
\tthis.onLoad = onLoad;\n\
\tthis.onProgress = onProgress;\n\
\tthis.onError = onError;\n\
\n\
\tthis.itemStart = function ( url ) {\n\
\n\
\t\ttotal ++;\n\
\n\
\t};\n\
\n\
\tthis.itemEnd = function ( url ) {\n\
\n\
\t\tloaded ++;\n\
\n\
\t\tif ( scope.onProgress !== undefined ) {\n\
\n\
\t\t\tscope.onProgress( url, loaded, total );\n\
\n\
\t\t}\n\
\n\
\t\tif ( loaded === total && scope.onLoad !== undefined ) {\n\
\n\
\t\t\tscope.onLoad();\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
};\n\
\n\
THREE.DefaultLoadingManager = new THREE.LoadingManager();\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.BufferGeometryLoader = function ( manager ) {\n\
\n\
\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\
\n\
};\n\
\n\
THREE.BufferGeometryLoader.prototype = {\n\
\n\
\tconstructor: THREE.BufferGeometryLoader,\n\
\n\
\tload: function ( url, onLoad, onProgress, onError ) {\n\
\n\
\t\tvar scope = this;\n\
\n\
\t\tvar loader = new THREE.XHRLoader();\n\
\t\tloader.setCrossOrigin( this.crossOrigin );\n\
\t\tloader.load( url, function ( text ) {\n\
\n\
\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\
\n\
\t\t} );\n\
\n\
\t},\n\
\n\
\tsetCrossOrigin: function ( value ) {\n\
\n\
\t\tthis.crossOrigin = value;\n\
\n\
\t},\n\
\n\
\tparse: function ( json ) {\n\
\n\
\t\tvar geometry = new THREE.BufferGeometry();\n\
\n\
\t\tvar attributes = json.attributes;\n\
\t\tvar offsets = json.offsets;\n\
\t\tvar boundingSphere = json.boundingSphere;\n\
\n\
\t\tfor ( var key in attributes ) {\n\
\n\
\t\t\tvar attribute = attributes[ key ];\n\
\n\
\t\t\tgeometry.attributes[ key ] = {\n\
\t\t\t\titemSize: attribute.itemSize,\n\
\t\t\t\tarray: new self[ attribute.type ]( attribute.array )\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( offsets !== undefined ) {\n\
\n\
\t\t\tgeometry.offsets = JSON.parse( JSON.stringify( offsets ) );\n\
\n\
\t\t}\n\
\n\
\t\tif ( boundingSphere !== undefined ) {\n\
\n\
\t\t\tgeometry.boundingSphere = new THREE.Sphere(\n\
\t\t\t\tnew THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),\n\
\t\t\t\tboundingSphere.radius\n\
\t\t\t);\n\
\n\
\t\t}\n\
\n\
\t\treturn geometry;\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.GeometryLoader = function ( manager ) {\n\
\n\
\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\
\n\
};\n\
\n\
THREE.GeometryLoader.prototype = {\n\
\n\
\tconstructor: THREE.GeometryLoader,\n\
\n\
\tload: function ( url, onLoad, onProgress, onError ) {\n\
\n\
\t\tvar scope = this;\n\
\n\
\t\tvar loader = new THREE.XHRLoader();\n\
\t\tloader.setCrossOrigin( this.crossOrigin );\n\
\t\tloader.load( url, function ( text ) {\n\
\n\
\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\
\n\
\t\t} );\n\
\n\
\t},\n\
\n\
\tsetCrossOrigin: function ( value ) {\n\
\n\
\t\tthis.crossOrigin = value;\n\
\n\
\t},\n\
\n\
\tparse: function ( json ) {\n\
\n\
\t\t\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.MaterialLoader = function ( manager ) {\n\
\n\
\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\
\n\
};\n\
\n\
THREE.MaterialLoader.prototype = {\n\
\n\
\tconstructor: THREE.MaterialLoader,\n\
\n\
\tload: function ( url, onLoad, onProgress, onError ) {\n\
\n\
\t\tvar scope = this;\n\
\n\
\t\tvar loader = new THREE.XHRLoader();\n\
\t\tloader.setCrossOrigin( this.crossOrigin );\n\
\t\tloader.load( url, function ( text ) {\n\
\n\
\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\
\n\
\t\t} );\n\
\n\
\t},\n\
\n\
\tsetCrossOrigin: function ( value ) {\n\
\n\
\t\tthis.crossOrigin = value;\n\
\n\
\t},\n\
\n\
\tparse: function ( json ) {\n\
\n\
\t\tvar material = new THREE[ json.type ];\n\
\n\
\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\
\t\tif ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );\n\
\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\
\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\
\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\
\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\
\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\
\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\
\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\
\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\
\n\
\t\tif ( json.materials !== undefined ) {\n\
\n\
\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\
\n\
\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn material;\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.ObjectLoader = function ( manager ) {\n\
\n\
\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\
\n\
};\n\
\n\
THREE.ObjectLoader.prototype = {\n\
\n\
\tconstructor: THREE.ObjectLoader,\n\
\n\
\tload: function ( url, onLoad, onProgress, onError ) {\n\
\n\
\t\tvar scope = this;\n\
\n\
\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\
\t\tloader.setCrossOrigin( this.crossOrigin );\n\
\t\tloader.load( url, function ( text ) {\n\
\n\
\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\
\n\
\t\t} );\n\
\n\
\t},\n\
\n\
\tsetCrossOrigin: function ( value ) {\n\
\n\
\t\tthis.crossOrigin = value;\n\
\n\
\t},\n\
\n\
\tparse: function ( json ) {\n\
\n\
\t\tvar geometries = this.parseGeometries( json.geometries );\n\
\t\tvar materials = this.parseMaterials( json.materials );\n\
\t\tvar object = this.parseObject( json.object, geometries, materials );\n\
\n\
\t\treturn object;\n\
\n\
\t},\n\
\n\
\tparseGeometries: function ( json ) {\n\
\n\
\t\tvar geometries = {};\n\
\n\
\t\tif ( json !== undefined ) {\n\
\n\
\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\
\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\
\n\
\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\
\n\
\t\t\t\tvar geometry;\n\
\t\t\t\tvar data = json[ i ];\n\
\n\
\t\t\t\tswitch ( data.type ) {\n\
\n\
\t\t\t\t\tcase 'PlaneGeometry':\n\
\n\
\t\t\t\t\t\tgeometry = new THREE.PlaneGeometry(\n\
\t\t\t\t\t\t\tdata.width,\n\
\t\t\t\t\t\t\tdata.height,\n\
\t\t\t\t\t\t\tdata.widthSegments,\n\
\t\t\t\t\t\t\tdata.heightSegments\n\
\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t\tcase 'CubeGeometry':\n\
\n\
\t\t\t\t\t\tgeometry = new THREE.CubeGeometry(\n\
\t\t\t\t\t\t\tdata.width,\n\
\t\t\t\t\t\t\tdata.height,\n\
\t\t\t\t\t\t\tdata.depth,\n\
\t\t\t\t\t\t\tdata.widthSegments,\n\
\t\t\t\t\t\t\tdata.heightSegments,\n\
\t\t\t\t\t\t\tdata.depthSegments\n\
\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t\tcase 'CylinderGeometry':\n\
\n\
\t\t\t\t\t\tgeometry = new THREE.CylinderGeometry(\n\
\t\t\t\t\t\t\tdata.radiusTop,\n\
\t\t\t\t\t\t\tdata.radiusBottom,\n\
\t\t\t\t\t\t\tdata.height,\n\
\t\t\t\t\t\t\tdata.radiusSegments,\n\
\t\t\t\t\t\t\tdata.heightSegments,\n\
\t\t\t\t\t\t\tdata.openEnded\n\
\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t\tcase 'SphereGeometry':\n\
\n\
\t\t\t\t\t\tgeometry = new THREE.SphereGeometry(\n\
\t\t\t\t\t\t\tdata.radius,\n\
\t\t\t\t\t\t\tdata.widthSegments,\n\
\t\t\t\t\t\t\tdata.heightSegments,\n\
\t\t\t\t\t\t\tdata.phiStart,\n\
\t\t\t\t\t\t\tdata.phiLength,\n\
\t\t\t\t\t\t\tdata.thetaStart,\n\
\t\t\t\t\t\t\tdata.thetaLength\n\
\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t\tcase 'IcosahedronGeometry':\n\
\n\
\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\n\
\t\t\t\t\t\t\tdata.radius,\n\
\t\t\t\t\t\t\tdata.detail\n\
\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t\tcase 'TorusGeometry':\n\
\n\
\t\t\t\t\t\tgeometry = new THREE.TorusGeometry(\n\
\t\t\t\t\t\t\tdata.radius,\n\
\t\t\t\t\t\t\tdata.tube,\n\
\t\t\t\t\t\t\tdata.radialSegments,\n\
\t\t\t\t\t\t\tdata.tubularSegments,\n\
\t\t\t\t\t\t\tdata.arc\n\
\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t\tcase 'TorusKnotGeometry':\n\
\n\
\t\t\t\t\t\tgeometry = new THREE.TorusKnotGeometry(\n\
\t\t\t\t\t\t\tdata.radius,\n\
\t\t\t\t\t\t\tdata.tube,\n\
\t\t\t\t\t\t\tdata.radialSegments,\n\
\t\t\t\t\t\t\tdata.tubularSegments,\n\
\t\t\t\t\t\t\tdata.p,\n\
\t\t\t\t\t\t\tdata.q,\n\
\t\t\t\t\t\t\tdata.heightScale\n\
\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t\tcase 'BufferGeometry':\n\
\n\
\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data.data );\n\
\n\
\t\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t\tcase 'Geometry':\n\
\n\
\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data ).geometry;\n\
\n\
\t\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tgeometry.uuid = data.uuid;\n\
\n\
\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\
\n\
\t\t\t\tgeometries[ data.uuid ] = geometry;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn geometries;\n\
\n\
\t},\n\
\n\
\tparseMaterials: function ( json ) {\n\
\n\
\t\tvar materials = {};\n\
\n\
\t\tif ( json !== undefined ) {\n\
\n\
\t\t\tvar loader = new THREE.MaterialLoader();\n\
\n\
\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\
\n\
\t\t\t\tvar data = json[ i ];\n\
\t\t\t\tvar material = loader.parse( data );\n\
\n\
\t\t\t\tmaterial.uuid = data.uuid;\n\
\n\
\t\t\t\tif ( data.name !== undefined ) material.name = data.name;\n\
\n\
\t\t\t\tmaterials[ data.uuid ] = material;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn materials;\n\
\n\
\t},\n\
\n\
\tparseObject: function () {\n\
\n\
\t\tvar matrix = new THREE.Matrix4();\n\
\n\
\t\treturn function ( data, geometries, materials ) {\n\
\n\
\t\t\tvar object;\n\
\n\
\t\t\tswitch ( data.type ) {\n\
\n\
\t\t\t\tcase 'Scene':\n\
\n\
\t\t\t\t\tobject = new THREE.Scene();\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tcase 'PerspectiveCamera':\n\
\n\
\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tcase 'OrthographicCamera':\n\
\n\
\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tcase 'AmbientLight':\n\
\n\
\t\t\t\t\tobject = new THREE.AmbientLight( data.color );\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tcase 'DirectionalLight':\n\
\n\
\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tcase 'PointLight':\n\
\n\
\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance );\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tcase 'SpotLight':\n\
\n\
\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tcase 'HemisphereLight':\n\
\n\
\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tcase 'Mesh':\n\
\n\
\t\t\t\t\tvar geometry = geometries[ data.geometry ];\n\
\t\t\t\t\tvar material = materials[ data.material ];\n\
\n\
\t\t\t\t\tif ( geometry === undefined ) {\n\
\n\
\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Undefined geometry ' + data.geometry );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tif ( material === undefined ) {\n\
\n\
\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Undefined material ' + data.material );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tdefault:\n\
\n\
\t\t\t\t\tobject = new THREE.Object3D();\n\
\n\
\t\t\t}\n\
\n\
\t\t\tobject.uuid = data.uuid;\n\
\n\
\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\
\t\t\tif ( data.matrix !== undefined ) {\n\
\n\
\t\t\t\tmatrix.fromArray( data.matrix );\n\
\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\
\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\
\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\
\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\
\n\
\t\t\tif ( data.children !== undefined ) {\n\
\n\
\t\t\t\tfor ( var child in data.children ) {\n\
\n\
\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\treturn object;\n\
\n\
\t\t}\n\
\n\
\t}()\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.SceneLoader = function () {\n\
\n\
\tthis.onLoadStart = function () {};\n\
\tthis.onLoadProgress = function() {};\n\
\tthis.onLoadComplete = function () {};\n\
\n\
\tthis.callbackSync = function () {};\n\
\tthis.callbackProgress = function () {};\n\
\n\
\tthis.geometryHandlers = {};\n\
\tthis.hierarchyHandlers = {};\n\
\n\
\tthis.addGeometryHandler( \"ascii\", THREE.JSONLoader );\n\
\n\
};\n\
\n\
THREE.SceneLoader.prototype = {\n\
\n\
\tconstructor: THREE.SceneLoader,\n\
\n\
\tload: function ( url, onLoad, onProgress, onError ) {\n\
\n\
\t\tvar scope = this;\n\
\n\
\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\
\t\tloader.setCrossOrigin( this.crossOrigin );\n\
\t\tloader.load( url, function ( text ) {\n\
\n\
\t\t\tscope.parse( JSON.parse( text ), onLoad, url );\n\
\n\
\t\t} );\n\
\n\
\t},\n\
\n\
\tsetCrossOrigin: function ( value ) {\n\
\n\
\t\tthis.crossOrigin = value;\n\
\n\
\t},\n\
\n\
\taddGeometryHandler: function ( typeID, loaderClass ) {\n\
\n\
\t\tthis.geometryHandlers[ typeID ] = { \"loaderClass\": loaderClass };\n\
\n\
\t},\n\
\n\
\taddHierarchyHandler: function ( typeID, loaderClass ) {\n\
\n\
\t\tthis.hierarchyHandlers[ typeID ] = { \"loaderClass\": loaderClass };\n\
\n\
\t},\n\
\n\
\tparse: function ( json, callbackFinished, url ) {\n\
\n\
\t\tvar scope = this;\n\
\n\
\t\tvar urlBase = THREE.Loader.prototype.extractUrlBase( url );\n\
\n\
\t\tvar geometry, material, camera, fog,\n\
\t\t\ttexture, images, color,\n\
\t\t\tlight, hex, intensity,\n\
\t\t\tcounter_models, counter_textures,\n\
\t\t\ttotal_models, total_textures,\n\
\t\t\tresult;\n\
\n\
\t\tvar target_array = [];\n\
\n\
\t\tvar data = json;\n\
\n\
\t\t// async geometry loaders\n\
\n\
\t\tfor ( var typeID in this.geometryHandlers ) {\n\
\n\
\t\t\tvar loaderClass = this.geometryHandlers[ typeID ][ \"loaderClass\" ];\n\
\t\t\tthis.geometryHandlers[ typeID ][ \"loaderObject\" ] = new loaderClass();\n\
\n\
\t\t}\n\
\n\
\t\t// async hierachy loaders\n\
\n\
\t\tfor ( var typeID in this.hierarchyHandlers ) {\n\
\n\
\t\t\tvar loaderClass = this.hierarchyHandlers[ typeID ][ \"loaderClass\" ];\n\
\t\t\tthis.hierarchyHandlers[ typeID ][ \"loaderObject\" ] = new loaderClass();\n\
\n\
\t\t}\n\
\n\
\t\tcounter_models = 0;\n\
\t\tcounter_textures = 0;\n\
\n\
\t\tresult = {\n\
\n\
\t\t\tscene: new THREE.Scene(),\n\
\t\t\tgeometries: {},\n\
\t\t\tface_materials: {},\n\
\t\t\tmaterials: {},\n\
\t\t\ttextures: {},\n\
\t\t\tobjects: {},\n\
\t\t\tcameras: {},\n\
\t\t\tlights: {},\n\
\t\t\tfogs: {},\n\
\t\t\tempties: {},\n\
\t\t\tgroups: {}\n\
\n\
\t\t};\n\
\n\
\t\tif ( data.transform ) {\n\
\n\
\t\t\tvar position = data.transform.position,\n\
\t\t\t\trotation = data.transform.rotation,\n\
\t\t\t\tscale = data.transform.scale;\n\
\n\
\t\t\tif ( position ) {\n\
\n\
\t\t\t\tresult.scene.position.fromArray( position );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( rotation ) {\n\
\n\
\t\t\t\tresult.scene.rotation.fromArray( rotation );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( scale ) {\n\
\n\
\t\t\t\tresult.scene.scale.fromArray( scale );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( position || rotation || scale ) {\n\
\n\
\t\t\t\tresult.scene.updateMatrix();\n\
\t\t\t\tresult.scene.updateMatrixWorld();\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tfunction get_url( source_url, url_type ) {\n\
\n\
\t\t\tif ( url_type == \"relativeToHTML\" ) {\n\
\n\
\t\t\t\treturn source_url;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\treturn urlBase + \"/\" + source_url;\n\
\n\
\t\t\t}\n\
\n\
\t\t};\n\
\n\
\t\t// toplevel loader function, delegates to handle_children\n\
\n\
\t\tfunction handle_objects() {\n\
\n\
\t\t\thandle_children( result.scene, data.objects );\n\
\n\
\t\t}\n\
\n\
\t\t// handle all the children from the loaded json and attach them to given parent\n\
\n\
\t\tfunction handle_children( parent, children ) {\n\
\n\
\t\t\tvar mat, dst, pos, rot, scl, quat;\n\
\n\
\t\t\tfor ( var objID in children ) {\n\
\n\
\t\t\t\t// check by id if child has already been handled,\n\
\t\t\t\t// if not, create new object\n\
\n\
\t\t\t\tvar object = result.objects[ objID ];\n\
\t\t\t\tvar objJSON = children[ objID ];\n\
\n\
\t\t\t\tif ( object === undefined ) {\n\
\n\
\t\t\t\t\t// meshes\n\
\n\
\t\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {\n\
\n\
\t\t\t\t\t\tif ( objJSON.loading === undefined ) {\n\
\n\
\t\t\t\t\t\t\tvar reservedTypes = {\n\
\t\t\t\t\t\t\t\t\"type\": 1, \"url\": 1, \"material\": 1,\n\
\t\t\t\t\t\t\t\t\"position\": 1, \"rotation\": 1, \"scale\" : 1,\n\
\t\t\t\t\t\t\t\t\"visible\": 1, \"children\": 1, \"userData\": 1,\n\
\t\t\t\t\t\t\t\t\"skin\": 1, \"morph\": 1, \"mirroredLoop\": 1, \"duration\": 1\n\
\t\t\t\t\t\t\t};\n\
\n\
\t\t\t\t\t\t\tvar loaderParameters = {};\n\
\n\
\t\t\t\t\t\t\tfor ( var parType in objJSON ) {\n\
\n\
\t\t\t\t\t\t\t\tif ( ! ( parType in reservedTypes ) ) {\n\
\n\
\t\t\t\t\t\t\t\t\tloaderParameters[ parType ] = objJSON[ parType ];\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\n\
\n\
\t\t\t\t\t\t\tobjJSON.loading = true;\n\
\n\
\t\t\t\t\t\t\tvar loader = scope.hierarchyHandlers[ objJSON.type ][ \"loaderObject\" ];\n\
\n\
\t\t\t\t\t\t\t// ColladaLoader\n\
\n\
\t\t\t\t\t\t\tif ( loader.options ) {\n\
\n\
\t\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );\n\
\n\
\t\t\t\t\t\t\t// UTF8Loader\n\
\t\t\t\t\t\t\t// OBJLoader\n\
\n\
\t\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( objJSON.geometry !== undefined ) {\n\
\n\
\t\t\t\t\t\tgeometry = result.geometries[ objJSON.geometry ];\n\
\n\
\t\t\t\t\t\t// geometry already loaded\n\
\n\
\t\t\t\t\t\tif ( geometry ) {\n\
\n\
\t\t\t\t\t\t\tvar needsTangents = false;\n\
\n\
\t\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\n\
\t\t\t\t\t\t\tneedsTangents = material instanceof THREE.ShaderMaterial;\n\
\n\
\t\t\t\t\t\t\tpos = objJSON.position;\n\
\t\t\t\t\t\t\trot = objJSON.rotation;\n\
\t\t\t\t\t\t\tscl = objJSON.scale;\n\
\t\t\t\t\t\t\tmat = objJSON.matrix;\n\
\t\t\t\t\t\t\tquat = objJSON.quaternion;\n\
\n\
\t\t\t\t\t\t\t// use materials from the model file\n\
\t\t\t\t\t\t\t// if there is no material specified in the object\n\
\n\
\t\t\t\t\t\t\tif ( ! objJSON.material ) {\n\
\n\
\t\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t// use materials from the model file\n\
\t\t\t\t\t\t\t// if there is just empty face material\n\
\t\t\t\t\t\t\t// (must create new material as each model has its own face material)\n\
\n\
\t\t\t\t\t\t\tif ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {\n\
\n\
\t\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\n\
\n\
\t\t\t\t\t\t\t\tfor ( var i = 0; i < material.materials.length; i ++ ) {\n\
\n\
\t\t\t\t\t\t\t\t\tneedsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\tif ( needsTangents ) {\n\
\n\
\t\t\t\t\t\t\t\tgeometry.computeTangents();\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\tif ( objJSON.skin ) {\n\
\n\
\t\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\
\n\
\t\t\t\t\t\t\t} else if ( objJSON.morph ) {\n\
\n\
\t\t\t\t\t\t\t\tobject = new THREE.MorphAnimMesh( geometry, material );\n\
\n\
\t\t\t\t\t\t\t\tif ( objJSON.duration !== undefined ) {\n\
\n\
\t\t\t\t\t\t\t\t\tobject.duration = objJSON.duration;\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\tif ( objJSON.time !== undefined ) {\n\
\n\
\t\t\t\t\t\t\t\t\tobject.time = objJSON.time;\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\tif ( objJSON.mirroredLoop !== undefined ) {\n\
\n\
\t\t\t\t\t\t\t\t\tobject.mirroredLoop = objJSON.mirroredLoop;\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\tif ( material.morphNormals ) {\n\
\n\
\t\t\t\t\t\t\t\t\tgeometry.computeMorphNormals();\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\tobject.name = objID;\n\
\n\
\t\t\t\t\t\t\tif ( mat ) {\n\
\n\
\t\t\t\t\t\t\t\tobject.matrixAutoUpdate = false;\n\
\t\t\t\t\t\t\t\tobject.matrix.set(\n\
\t\t\t\t\t\t\t\t\tmat[0],  mat[1],  mat[2],  mat[3],\n\
\t\t\t\t\t\t\t\t\tmat[4],  mat[5],  mat[6],  mat[7],\n\
\t\t\t\t\t\t\t\t\tmat[8],  mat[9],  mat[10], mat[11],\n\
\t\t\t\t\t\t\t\t\tmat[12], mat[13], mat[14], mat[15]\n\
\t\t\t\t\t\t\t\t);\n\
\n\
\t\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\t\tobject.position.fromArray( pos );\n\
\n\
\t\t\t\t\t\t\t\tif ( quat ) {\n\
\n\
\t\t\t\t\t\t\t\t\tobject.quaternion.fromArray( quat );\n\
\n\
\t\t\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\t\t\tobject.rotation.fromArray( rot );\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\tobject.scale.fromArray( scl );\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\tobject.visible = objJSON.visible;\n\
\t\t\t\t\t\t\tobject.castShadow = objJSON.castShadow;\n\
\t\t\t\t\t\t\tobject.receiveShadow = objJSON.receiveShadow;\n\
\n\
\t\t\t\t\t\t\tparent.add( object );\n\
\n\
\t\t\t\t\t\t\tresult.objects[ objID ] = object;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// lights\n\
\n\
\t\t\t\t\t} else if ( objJSON.type === \"DirectionalLight\" || objJSON.type === \"PointLight\" || objJSON.type === \"AmbientLight\" ) {\n\
\n\
\t\t\t\t\t\thex = ( objJSON.color !== undefined ) ? objJSON.color : 0xffffff;\n\
\t\t\t\t\t\tintensity = ( objJSON.intensity !== undefined ) ? objJSON.intensity : 1;\n\
\n\
\t\t\t\t\t\tif ( objJSON.type === \"DirectionalLight\" ) {\n\
\n\
\t\t\t\t\t\t\tpos = objJSON.direction;\n\
\n\
\t\t\t\t\t\t\tlight = new THREE.DirectionalLight( hex, intensity );\n\
\t\t\t\t\t\t\tlight.position.fromArray( pos );\n\
\n\
\t\t\t\t\t\t\tif ( objJSON.target ) {\n\
\n\
\t\t\t\t\t\t\t\ttarget_array.push( { \"object\": light, \"targetName\" : objJSON.target } );\n\
\n\
\t\t\t\t\t\t\t\t// kill existing default target\n\
\t\t\t\t\t\t\t\t// otherwise it gets added to scene when parent gets added\n\
\n\
\t\t\t\t\t\t\t\tlight.target = null;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t} else if ( objJSON.type === \"PointLight\" ) {\n\
\n\
\t\t\t\t\t\t\tpos = objJSON.position;\n\
\t\t\t\t\t\t\tdst = objJSON.distance;\n\
\n\
\t\t\t\t\t\t\tlight = new THREE.PointLight( hex, intensity, dst );\n\
\t\t\t\t\t\t\tlight.position.fromArray( pos );\n\
\n\
\t\t\t\t\t\t} else if ( objJSON.type === \"AmbientLight\" ) {\n\
\n\
\t\t\t\t\t\t\tlight = new THREE.AmbientLight( hex );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tparent.add( light );\n\
\n\
\t\t\t\t\t\tlight.name = objID;\n\
\t\t\t\t\t\tresult.lights[ objID ] = light;\n\
\t\t\t\t\t\tresult.objects[ objID ] = light;\n\
\n\
\t\t\t\t\t// cameras\n\
\n\
\t\t\t\t\t} else if ( objJSON.type === \"PerspectiveCamera\" || objJSON.type === \"OrthographicCamera\" ) {\n\
\n\
\t\t\t\t\t\tpos = objJSON.position;\n\
\t\t\t\t\t\trot = objJSON.rotation;\n\
\t\t\t\t\t\tquat = objJSON.quaternion;\n\
\n\
\t\t\t\t\t\tif ( objJSON.type === \"PerspectiveCamera\" ) {\n\
\n\
\t\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );\n\
\n\
\t\t\t\t\t\t} else if ( objJSON.type === \"OrthographicCamera\" ) {\n\
\n\
\t\t\t\t\t\t\tcamera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tcamera.name = objID;\n\
\t\t\t\t\t\tcamera.position.fromArray( pos );\n\
\n\
\t\t\t\t\t\tif ( quat !== undefined ) {\n\
\n\
\t\t\t\t\t\t\tcamera.quaternion.fromArray( quat );\n\
\n\
\t\t\t\t\t\t} else if ( rot !== undefined ) {\n\
\n\
\t\t\t\t\t\t\tcamera.rotation.fromArray( rot );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tparent.add( camera );\n\
\n\
\t\t\t\t\t\tresult.cameras[ objID ] = camera;\n\
\t\t\t\t\t\tresult.objects[ objID ] = camera;\n\
\n\
\t\t\t\t\t// pure Object3D\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\tpos = objJSON.position;\n\
\t\t\t\t\t\trot = objJSON.rotation;\n\
\t\t\t\t\t\tscl = objJSON.scale;\n\
\t\t\t\t\t\tquat = objJSON.quaternion;\n\
\n\
\t\t\t\t\t\tobject = new THREE.Object3D();\n\
\t\t\t\t\t\tobject.name = objID;\n\
\t\t\t\t\t\tobject.position.fromArray( pos );\n\
\n\
\t\t\t\t\t\tif ( quat ) {\n\
\n\
\t\t\t\t\t\t\tobject.quaternion.fromArray( quat );\n\
\n\
\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\tobject.rotation.fromArray( rot );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tobject.scale.fromArray( scl );\n\
\t\t\t\t\t\tobject.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;\n\
\n\
\t\t\t\t\t\tparent.add( object );\n\
\n\
\t\t\t\t\t\tresult.objects[ objID ] = object;\n\
\t\t\t\t\t\tresult.empties[ objID ] = object;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tif ( object ) {\n\
\n\
\t\t\t\t\t\tif ( objJSON.userData !== undefined ) {\n\
\n\
\t\t\t\t\t\t\tfor ( var key in objJSON.userData ) {\n\
\n\
\t\t\t\t\t\t\t\tvar value = objJSON.userData[ key ];\n\
\t\t\t\t\t\t\t\tobject.userData[ key ] = value;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tif ( objJSON.groups !== undefined ) {\n\
\n\
\t\t\t\t\t\t\tfor ( var i = 0; i < objJSON.groups.length; i ++ ) {\n\
\n\
\t\t\t\t\t\t\t\tvar groupID = objJSON.groups[ i ];\n\
\n\
\t\t\t\t\t\t\t\tif ( result.groups[ groupID ] === undefined ) {\n\
\n\
\t\t\t\t\t\t\t\t\tresult.groups[ groupID ] = [];\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\tresult.groups[ groupID ].push( objID );\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( object !== undefined && objJSON.children !== undefined ) {\n\
\n\
\t\t\t\t\thandle_children( object, objJSON.children );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t};\n\
\n\
\t\tfunction handle_mesh( geo, mat, id ) {\n\
\n\
\t\t\tresult.geometries[ id ] = geo;\n\
\t\t\tresult.face_materials[ id ] = mat;\n\
\t\t\thandle_objects();\n\
\n\
\t\t};\n\
\n\
\t\tfunction handle_hierarchy( node, id, parent, material, obj ) {\n\
\n\
\t\t\tvar p = obj.position;\n\
\t\t\tvar r = obj.rotation;\n\
\t\t\tvar q = obj.quaternion;\n\
\t\t\tvar s = obj.scale;\n\
\n\
\t\t\tnode.position.fromArray( p );\n\
\n\
\t\t\tif ( q ) {\n\
\n\
\t\t\t\tnode.quaternion.fromArray( q );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tnode.rotation.fromArray( r );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tnode.scale.fromArray( s );\n\
\n\
\t\t\t// override children materials\n\
\t\t\t// if object material was specified in JSON explicitly\n\
\n\
\t\t\tif ( material ) {\n\
\n\
\t\t\t\tnode.traverse( function ( child ) {\n\
\n\
\t\t\t\t\tchild.material = material;\n\
\n\
\t\t\t\t} );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// override children visibility\n\
\t\t\t// with root node visibility as specified in JSON\n\
\n\
\t\t\tvar visible = ( obj.visible !== undefined ) ? obj.visible : true;\n\
\n\
\t\t\tnode.traverse( function ( child ) {\n\
\n\
\t\t\t\tchild.visible = visible;\n\
\n\
\t\t\t} );\n\
\n\
\t\t\tparent.add( node );\n\
\n\
\t\t\tnode.name = id;\n\
\n\
\t\t\tresult.objects[ id ] = node;\n\
\t\t\thandle_objects();\n\
\n\
\t\t};\n\
\n\
\t\tfunction create_callback_geometry( id ) {\n\
\n\
\t\t\treturn function ( geo, mat ) {\n\
\n\
\t\t\t\tgeo.name = id;\n\
\n\
\t\t\t\thandle_mesh( geo, mat, id );\n\
\n\
\t\t\t\tcounter_models -= 1;\n\
\n\
\t\t\t\tscope.onLoadComplete();\n\
\n\
\t\t\t\tasync_callback_gate();\n\
\n\
\t\t\t}\n\
\n\
\t\t};\n\
\n\
\t\tfunction create_callback_hierachy( id, parent, material, obj ) {\n\
\n\
\t\t\treturn function ( event ) {\n\
\n\
\t\t\t\tvar result;\n\
\n\
\t\t\t\t// loaders which use EventDispatcher\n\
\n\
\t\t\t\tif ( event.content ) {\n\
\n\
\t\t\t\t\tresult = event.content;\n\
\n\
\t\t\t\t// ColladaLoader\n\
\n\
\t\t\t\t} else if ( event.dae ) {\n\
\n\
\t\t\t\t\tresult = event.scene;\n\
\n\
\n\
\t\t\t\t// UTF8Loader\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tresult = event;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\thandle_hierarchy( result, id, parent, material, obj );\n\
\n\
\t\t\t\tcounter_models -= 1;\n\
\n\
\t\t\t\tscope.onLoadComplete();\n\
\n\
\t\t\t\tasync_callback_gate();\n\
\n\
\t\t\t}\n\
\n\
\t\t};\n\
\n\
\t\tfunction create_callback_embed( id ) {\n\
\n\
\t\t\treturn function ( geo, mat ) {\n\
\n\
\t\t\t\tgeo.name = id;\n\
\n\
\t\t\t\tresult.geometries[ id ] = geo;\n\
\t\t\t\tresult.face_materials[ id ] = mat;\n\
\n\
\t\t\t}\n\
\n\
\t\t};\n\
\n\
\t\tfunction async_callback_gate() {\n\
\n\
\t\t\tvar progress = {\n\
\n\
\t\t\t\ttotalModels : total_models,\n\
\t\t\t\ttotalTextures : total_textures,\n\
\t\t\t\tloadedModels : total_models - counter_models,\n\
\t\t\t\tloadedTextures : total_textures - counter_textures\n\
\n\
\t\t\t};\n\
\n\
\t\t\tscope.callbackProgress( progress, result );\n\
\n\
\t\t\tscope.onLoadProgress();\n\
\n\
\t\t\tif ( counter_models === 0 && counter_textures === 0 ) {\n\
\n\
\t\t\t\tfinalize();\n\
\t\t\t\tcallbackFinished( result );\n\
\n\
\t\t\t}\n\
\n\
\t\t};\n\
\n\
\t\tfunction finalize() {\n\
\n\
\t\t\t// take care of targets which could be asynchronously loaded objects\n\
\n\
\t\t\tfor ( var i = 0; i < target_array.length; i ++ ) {\n\
\n\
\t\t\t\tvar ta = target_array[ i ];\n\
\n\
\t\t\t\tvar target = result.objects[ ta.targetName ];\n\
\n\
\t\t\t\tif ( target ) {\n\
\n\
\t\t\t\t\tta.object.target = target;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t// if there was error and target of specified name doesn't exist in the scene file\n\
\t\t\t\t\t// create instead dummy target\n\
\t\t\t\t\t// (target must be added to scene explicitly as parent is already added)\n\
\n\
\t\t\t\t\tta.object.target = new THREE.Object3D();\n\
\t\t\t\t\tresult.scene.add( ta.object.target );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tta.object.target.userData.targetInverse = ta.object;\n\
\n\
\t\t\t}\n\
\n\
\t\t};\n\
\n\
\t\tvar callbackTexture = function ( count ) {\n\
\n\
\t\t\tcounter_textures -= count;\n\
\t\t\tasync_callback_gate();\n\
\n\
\t\t\tscope.onLoadComplete();\n\
\n\
\t\t};\n\
\n\
\t\t// must use this instead of just directly calling callbackTexture\n\
\t\t// because of closure in the calling context loop\n\
\n\
\t\tvar generateTextureCallback = function ( count ) {\n\
\n\
\t\t\treturn function () {\n\
\n\
\t\t\t\tcallbackTexture( count );\n\
\n\
\t\t\t};\n\
\n\
\t\t};\n\
\n\
\t\tfunction traverse_json_hierarchy( objJSON, callback ) {\n\
\n\
\t\t\tcallback( objJSON );\n\
\n\
\t\t\tif ( objJSON.children !== undefined ) {\n\
\n\
\t\t\t\tfor ( var objChildID in objJSON.children ) {\n\
\n\
\t\t\t\t\ttraverse_json_hierarchy( objJSON.children[ objChildID ], callback );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t};\n\
\n\
\t\t// first go synchronous elements\n\
\n\
\t\t// fogs\n\
\n\
\t\tvar fogID, fogJSON;\n\
\n\
\t\tfor ( fogID in data.fogs ) {\n\
\n\
\t\t\tfogJSON = data.fogs[ fogID ];\n\
\n\
\t\t\tif ( fogJSON.type === \"linear\" ) {\n\
\n\
\t\t\t\tfog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );\n\
\n\
\t\t\t} else if ( fogJSON.type === \"exp2\" ) {\n\
\n\
\t\t\t\tfog = new THREE.FogExp2( 0x000000, fogJSON.density );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tcolor = fogJSON.color;\n\
\t\t\tfog.color.setRGB( color[0], color[1], color[2] );\n\
\n\
\t\t\tresult.fogs[ fogID ] = fog;\n\
\n\
\t\t}\n\
\n\
\t\t// now come potentially asynchronous elements\n\
\n\
\t\t// geometries\n\
\n\
\t\t// count how many geometries will be loaded asynchronously\n\
\n\
\t\tvar geoID, geoJSON;\n\
\n\
\t\tfor ( geoID in data.geometries ) {\n\
\n\
\t\t\tgeoJSON = data.geometries[ geoID ];\n\
\n\
\t\t\tif ( geoJSON.type in this.geometryHandlers ) {\n\
\n\
\t\t\t\tcounter_models += 1;\n\
\n\
\t\t\t\tscope.onLoadStart();\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// count how many hierarchies will be loaded asynchronously\n\
\n\
\t\tfor ( var objID in data.objects ) {\n\
\n\
\t\t\ttraverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {\n\
\n\
\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {\n\
\n\
\t\t\t\t\tcounter_models += 1;\n\
\n\
\t\t\t\t\tscope.onLoadStart();\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t});\n\
\n\
\t\t}\n\
\n\
\t\ttotal_models = counter_models;\n\
\n\
\t\tfor ( geoID in data.geometries ) {\n\
\n\
\t\t\tgeoJSON = data.geometries[ geoID ];\n\
\n\
\t\t\tif ( geoJSON.type === \"cube\" ) {\n\
\n\
\t\t\t\tgeometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );\n\
\t\t\t\tgeometry.name = geoID;\n\
\t\t\t\tresult.geometries[ geoID ] = geometry;\n\
\n\
\t\t\t} else if ( geoJSON.type === \"plane\" ) {\n\
\n\
\t\t\t\tgeometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );\n\
\t\t\t\tgeometry.name = geoID;\n\
\t\t\t\tresult.geometries[ geoID ] = geometry;\n\
\n\
\t\t\t} else if ( geoJSON.type === \"sphere\" ) {\n\
\n\
\t\t\t\tgeometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );\n\
\t\t\t\tgeometry.name = geoID;\n\
\t\t\t\tresult.geometries[ geoID ] = geometry;\n\
\n\
\t\t\t} else if ( geoJSON.type === \"cylinder\" ) {\n\
\n\
\t\t\t\tgeometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );\n\
\t\t\t\tgeometry.name = geoID;\n\
\t\t\t\tresult.geometries[ geoID ] = geometry;\n\
\n\
\t\t\t} else if ( geoJSON.type === \"torus\" ) {\n\
\n\
\t\t\t\tgeometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );\n\
\t\t\t\tgeometry.name = geoID;\n\
\t\t\t\tresult.geometries[ geoID ] = geometry;\n\
\n\
\t\t\t} else if ( geoJSON.type === \"icosahedron\" ) {\n\
\n\
\t\t\t\tgeometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );\n\
\t\t\t\tgeometry.name = geoID;\n\
\t\t\t\tresult.geometries[ geoID ] = geometry;\n\
\n\
\t\t\t} else if ( geoJSON.type in this.geometryHandlers ) {\n\
\n\
\t\t\t\tvar loaderParameters = {};\n\
\n\
\t\t\t\tfor ( var parType in geoJSON ) {\n\
\n\
\t\t\t\t\tif ( parType !== \"type\" && parType !== \"url\" ) {\n\
\n\
\t\t\t\t\t\tloaderParameters[ parType ] = geoJSON[ parType ];\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tvar loader = this.geometryHandlers[ geoJSON.type ][ \"loaderObject\" ];\n\
\t\t\t\tloader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );\n\
\n\
\t\t\t} else if ( geoJSON.type === \"embedded\" ) {\n\
\n\
\t\t\t\tvar modelJson = data.embeds[ geoJSON.id ],\n\
\t\t\t\t\ttexture_path = \"\";\n\
\n\
\t\t\t\t// pass metadata along to jsonLoader so it knows the format version\n\
\n\
\t\t\t\tmodelJson.metadata = data.metadata;\n\
\n\
\t\t\t\tif ( modelJson ) {\n\
\n\
\t\t\t\t\tvar jsonLoader = this.geometryHandlers[ \"ascii\" ][ \"loaderObject\" ];\n\
\t\t\t\t\tvar model = jsonLoader.parse( modelJson, texture_path );\n\
\t\t\t\t\tcreate_callback_embed( geoID )( model.geometry, model.materials );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// textures\n\
\n\
\t\t// count how many textures will be loaded asynchronously\n\
\n\
\t\tvar textureID, textureJSON;\n\
\n\
\t\tfor ( textureID in data.textures ) {\n\
\n\
\t\t\ttextureJSON = data.textures[ textureID ];\n\
\n\
\t\t\tif ( textureJSON.url instanceof Array ) {\n\
\n\
\t\t\t\tcounter_textures += textureJSON.url.length;\n\
\n\
\t\t\t\tfor( var n = 0; n < textureJSON.url.length; n ++ ) {\n\
\n\
\t\t\t\t\tscope.onLoadStart();\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tcounter_textures += 1;\n\
\n\
\t\t\t\tscope.onLoadStart();\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\ttotal_textures = counter_textures;\n\
\n\
\t\tfor ( textureID in data.textures ) {\n\
\n\
\t\t\ttextureJSON = data.textures[ textureID ];\n\
\n\
\t\t\tif ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {\n\
\n\
\t\t\t\ttextureJSON.mapping = new THREE[ textureJSON.mapping ]();\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( textureJSON.url instanceof Array ) {\n\
\n\
\t\t\t\tvar count = textureJSON.url.length;\n\
\t\t\t\tvar url_array = [];\n\
\n\
\t\t\t\tfor( var i = 0; i < count; i ++ ) {\n\
\n\
\t\t\t\t\turl_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tvar isCompressed = /\\.dds$/i.test( url_array[ 0 ] );\n\
\n\
\t\t\t\tif ( isCompressed ) {\n\
\n\
\t\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\ttexture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tvar isCompressed = /\\.dds$/i.test( textureJSON.url );\n\
\t\t\t\tvar fullUrl = get_url( textureJSON.url, data.urlBaseType );\n\
\t\t\t\tvar textureCallback = generateTextureCallback( 1 );\n\
\n\
\t\t\t\tif ( isCompressed ) {\n\
\n\
\t\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\ttexture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( THREE[ textureJSON.minFilter ] !== undefined )\n\
\t\t\t\t\ttexture.minFilter = THREE[ textureJSON.minFilter ];\n\
\n\
\t\t\t\tif ( THREE[ textureJSON.magFilter ] !== undefined )\n\
\t\t\t\t\ttexture.magFilter = THREE[ textureJSON.magFilter ];\n\
\n\
\t\t\t\tif ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;\n\
\n\
\t\t\t\tif ( textureJSON.repeat ) {\n\
\n\
\t\t\t\t\ttexture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );\n\
\n\
\t\t\t\t\tif ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\
\t\t\t\t\tif ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( textureJSON.offset ) {\n\
\n\
\t\t\t\t\ttexture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// handle wrap after repeat so that default repeat can be overriden\n\
\n\
\t\t\t\tif ( textureJSON.wrap ) {\n\
\n\
\t\t\t\t\tvar wrapMap = {\n\
\t\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\n\
\t\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];\n\
\t\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tresult.textures[ textureID ] = texture;\n\
\n\
\t\t}\n\
\n\
\t\t// materials\n\
\n\
\t\tvar matID, matJSON;\n\
\t\tvar parID;\n\
\n\
\t\tfor ( matID in data.materials ) {\n\
\n\
\t\t\tmatJSON = data.materials[ matID ];\n\
\n\
\t\t\tfor ( parID in matJSON.parameters ) {\n\
\n\
\t\t\t\tif ( parID === \"envMap\" || parID === \"map\" || parID === \"lightMap\" || parID === \"bumpMap\" ) {\n\
\n\
\t\t\t\t\tmatJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];\n\
\n\
\t\t\t\t} else if ( parID === \"shading\" ) {\n\
\n\
\t\t\t\t\tmatJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === \"flat\" ) ? THREE.FlatShading : THREE.SmoothShading;\n\
\n\
\t\t\t\t} else if ( parID === \"side\" ) {\n\
\n\
\t\t\t\t\tif ( matJSON.parameters[ parID ] == \"double\" ) {\n\
\n\
\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.DoubleSide;\n\
\n\
\t\t\t\t\t} else if ( matJSON.parameters[ parID ] == \"back\" ) {\n\
\n\
\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.BackSide;\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FrontSide;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t} else if ( parID === \"blending\" ) {\n\
\n\
\t\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;\n\
\n\
\t\t\t\t} else if ( parID === \"combine\" ) {\n\
\n\
\t\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;\n\
\n\
\t\t\t\t} else if ( parID === \"vertexColors\" ) {\n\
\n\
\t\t\t\t\tif ( matJSON.parameters[ parID ] == \"face\" ) {\n\
\n\
\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FaceColors;\n\
\n\
\t\t\t\t\t// default to vertex colors if \"vertexColors\" is anything else face colors or 0 / null / false\n\
\n\
\t\t\t\t\t} else if ( matJSON.parameters[ parID ] ) {\n\
\n\
\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.VertexColors;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t} else if ( parID === \"wrapRGB\" ) {\n\
\n\
\t\t\t\t\tvar v3 = matJSON.parameters[ parID ];\n\
\t\t\t\t\tmatJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {\n\
\n\
\t\t\t\tmatJSON.parameters.transparent = true;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( matJSON.parameters.normalMap ) {\n\
\n\
\t\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\n\
\t\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\
\n\
\t\t\t\tvar diffuse = matJSON.parameters.color;\n\
\t\t\t\tvar specular = matJSON.parameters.specular;\n\
\t\t\t\tvar ambient = matJSON.parameters.ambient;\n\
\t\t\t\tvar shininess = matJSON.parameters.shininess;\n\
\n\
\t\t\t\tuniforms[ \"tNormal\" ].value = result.textures[ matJSON.parameters.normalMap ];\n\
\n\
\t\t\t\tif ( matJSON.parameters.normalScale ) {\n\
\n\
\t\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( matJSON.parameters.map ) {\n\
\n\
\t\t\t\t\tuniforms[ \"tDiffuse\" ].value = matJSON.parameters.map;\n\
\t\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( matJSON.parameters.envMap ) {\n\
\n\
\t\t\t\t\tuniforms[ \"tCube\" ].value = matJSON.parameters.envMap;\n\
\t\t\t\t\tuniforms[ \"enableReflection\" ].value = true;\n\
\t\t\t\t\tuniforms[ \"uReflectivity\" ].value = matJSON.parameters.reflectivity;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( matJSON.parameters.lightMap ) {\n\
\n\
\t\t\t\t\tuniforms[ \"tAO\" ].value = matJSON.parameters.lightMap;\n\
\t\t\t\t\tuniforms[ \"enableAO\" ].value = true;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( matJSON.parameters.specularMap ) {\n\
\n\
\t\t\t\t\tuniforms[ \"tSpecular\" ].value = result.textures[ matJSON.parameters.specularMap ];\n\
\t\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( matJSON.parameters.displacementMap ) {\n\
\n\
\t\t\t\t\tuniforms[ \"tDisplacement\" ].value = result.textures[ matJSON.parameters.displacementMap ];\n\
\t\t\t\t\tuniforms[ \"enableDisplacement\" ].value = true;\n\
\n\
\t\t\t\t\tuniforms[ \"uDisplacementBias\" ].value = matJSON.parameters.displacementBias;\n\
\t\t\t\t\tuniforms[ \"uDisplacementScale\" ].value = matJSON.parameters.displacementScale;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( diffuse );\n\
\t\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( specular );\n\
\t\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( ambient );\n\
\n\
\t\t\t\tuniforms[ \"uShininess\" ].value = shininess;\n\
\n\
\t\t\t\tif ( matJSON.parameters.opacity ) {\n\
\n\
\t\t\t\t\tuniforms[ \"uOpacity\" ].value = matJSON.parameters.opacity;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\n\
\n\
\t\t\t\tmaterial = new THREE.ShaderMaterial( parameters );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tmaterial = new THREE[ matJSON.type ]( matJSON.parameters );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tmaterial.name = matID;\n\
\n\
\t\t\tresult.materials[ matID ] = material;\n\
\n\
\t\t}\n\
\n\
\t\t// second pass through all materials to initialize MeshFaceMaterials\n\
\t\t// that could be referring to other materials out of order\n\
\n\
\t\tfor ( matID in data.materials ) {\n\
\n\
\t\t\tmatJSON = data.materials[ matID ];\n\
\n\
\t\t\tif ( matJSON.parameters.materials ) {\n\
\n\
\t\t\t\tvar materialArray = [];\n\
\n\
\t\t\t\tfor ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {\n\
\n\
\t\t\t\t\tvar label = matJSON.parameters.materials[ i ];\n\
\t\t\t\t\tmaterialArray.push( result.materials[ label ] );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tresult.materials[ matID ].materials = materialArray;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// objects ( synchronous init of procedural primitives )\n\
\n\
\t\thandle_objects();\n\
\n\
\t\t// defaults\n\
\n\
\t\tif ( result.cameras && data.defaults.camera ) {\n\
\n\
\t\t\tresult.currentCamera = result.cameras[ data.defaults.camera ];\n\
\n\
\t\t}\n\
\n\
\t\tif ( result.fogs && data.defaults.fog ) {\n\
\n\
\t\t\tresult.scene.fog = result.fogs[ data.defaults.fog ];\n\
\n\
\t\t}\n\
\n\
\t\t// synchronous callback\n\
\n\
\t\tscope.callbackSync( result );\n\
\n\
\t\t// just in case there are no async elements\n\
\n\
\t\tasync_callback_gate();\n\
\n\
\t}\n\
\n\
}\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.TextureLoader = function ( manager ) {\n\
\n\
\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\
\n\
};\n\
\n\
THREE.TextureLoader.prototype = {\n\
\n\
\tconstructor: THREE.TextureLoader,\n\
\n\
\tload: function ( url, onLoad, onProgress, onError ) {\n\
\n\
\t\tvar scope = this;\n\
\n\
\t\tvar loader = new THREE.ImageLoader( scope.manager );\n\
\t\tloader.setCrossOrigin( this.crossOrigin );\n\
\t\tloader.load( url, function ( image ) {\n\
\n\
\t\t\tvar texture = new THREE.Texture( image );\n\
\t\t\ttexture.needsUpdate = true;\n\
\n\
\t\t\tif ( onLoad !== undefined ) {\n\
\n\
\t\t\t\tonLoad( texture );\n\
\n\
\t\t\t}\n\
\n\
\t\t} );\n\
\n\
\t},\n\
\n\
\tsetCrossOrigin: function ( value ) {\n\
\n\
\t\tthis.crossOrigin = value;\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Material = function () {\n\
\n\
\tthis.id = THREE.MaterialIdCount ++;\n\
\tthis.uuid = THREE.Math.generateUUID();\n\
\n\
\tthis.name = '';\n\
\n\
\tthis.side = THREE.FrontSide;\n\
\n\
\tthis.opacity = 1;\n\
\tthis.transparent = false;\n\
\n\
\tthis.blending = THREE.NormalBlending;\n\
\n\
\tthis.blendSrc = THREE.SrcAlphaFactor;\n\
\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\
\tthis.blendEquation = THREE.AddEquation;\n\
\n\
\tthis.depthTest = true;\n\
\tthis.depthWrite = true;\n\
\n\
\tthis.polygonOffset = false;\n\
\tthis.polygonOffsetFactor = 0;\n\
\tthis.polygonOffsetUnits = 0;\n\
\n\
\tthis.alphaTest = 0;\n\
\n\
\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\
\n\
\tthis.visible = true;\n\
\n\
\tthis.needsUpdate = true;\n\
\n\
};\n\
\n\
THREE.Material.prototype = {\n\
\n\
\tconstructor: THREE.Material,\n\
\n\
\tsetValues: function ( values ) {\n\
\n\
\t\tif ( values === undefined ) return;\n\
\n\
\t\tfor ( var key in values ) {\n\
\n\
\t\t\tvar newValue = values[ key ];\n\
\n\
\t\t\tif ( newValue === undefined ) {\n\
\n\
\t\t\t\tconsole.warn( 'THREE.Material: \\'' + key + '\\' parameter is undefined.' );\n\
\t\t\t\tcontinue;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( key in this ) {\n\
\n\
\t\t\t\tvar currentValue = this[ key ];\n\
\n\
\t\t\t\tif ( currentValue instanceof THREE.Color ) {\n\
\n\
\t\t\t\t\tcurrentValue.set( newValue );\n\
\n\
\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\
\n\
\t\t\t\t\tcurrentValue.copy( newValue );\n\
\n\
\t\t\t\t} else if ( key == 'overdraw') {\n\
\n\
\t\t\t\t\t// ensure overdraw is backwards-compatable with legacy boolean type\n\
\t\t\t\t\tthis[ key ] = Number(newValue);\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tthis[ key ] = newValue;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\tclone: function ( material ) {\n\
\n\
\t\tif ( material === undefined ) material = new THREE.Material();\n\
\n\
\t\tmaterial.name = this.name;\n\
\n\
\t\tmaterial.side = this.side;\n\
\n\
\t\tmaterial.opacity = this.opacity;\n\
\t\tmaterial.transparent = this.transparent;\n\
\n\
\t\tmaterial.blending = this.blending;\n\
\n\
\t\tmaterial.blendSrc = this.blendSrc;\n\
\t\tmaterial.blendDst = this.blendDst;\n\
\t\tmaterial.blendEquation = this.blendEquation;\n\
\n\
\t\tmaterial.depthTest = this.depthTest;\n\
\t\tmaterial.depthWrite = this.depthWrite;\n\
\n\
\t\tmaterial.polygonOffset = this.polygonOffset;\n\
\t\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\n\
\t\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\n\
\n\
\t\tmaterial.alphaTest = this.alphaTest;\n\
\n\
\t\tmaterial.overdraw = this.overdraw;\n\
\n\
\t\tmaterial.visible = this.visible;\n\
\n\
\t\treturn material;\n\
\n\
\t},\n\
\n\
\tdispose: function () {\n\
\n\
\t\tthis.dispatchEvent( { type: 'dispose' } );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\n\
\n\
THREE.MaterialIdCount = 0;\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * parameters = {\n\
 *  color: <hex>,\n\
 *  opacity: <float>,\n\
 *\n\
 *  blending: THREE.NormalBlending,\n\
 *  depthTest: <bool>,\n\
 *  depthWrite: <bool>,\n\
 *\n\
 *  linewidth: <float>,\n\
 *  linecap: \"round\",\n\
 *  linejoin: \"round\",\n\
 *\n\
 *  vertexColors: <bool>\n\
 *\n\
 *  fog: <bool>\n\
 * }\n\
 */\n\
\n\
THREE.LineBasicMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this );\n\
\n\
\tthis.color = new THREE.Color( 0xffffff );\n\
\n\
\tthis.linewidth = 1;\n\
\tthis.linecap = 'round';\n\
\tthis.linejoin = 'round';\n\
\n\
\tthis.vertexColors = false;\n\
\n\
\tthis.fog = true;\n\
\n\
\tthis.setValues( parameters );\n\
\n\
};\n\
\n\
THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.LineBasicMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.LineBasicMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.color.copy( this.color );\n\
\n\
\tmaterial.linewidth = this.linewidth;\n\
\tmaterial.linecap = this.linecap;\n\
\tmaterial.linejoin = this.linejoin;\n\
\n\
\tmaterial.vertexColors = this.vertexColors;\n\
\n\
\tmaterial.fog = this.fog;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * parameters = {\n\
 *  color: <hex>,\n\
 *  opacity: <float>,\n\
 *\n\
 *  blending: THREE.NormalBlending,\n\
 *  depthTest: <bool>,\n\
 *  depthWrite: <bool>,\n\
 *\n\
 *  linewidth: <float>,\n\
 *\n\
 *  scale: <float>,\n\
 *  dashSize: <float>,\n\
 *  gapSize: <float>,\n\
 *\n\
 *  vertexColors: <bool>\n\
 *\n\
 *  fog: <bool>\n\
 * }\n\
 */\n\
\n\
THREE.LineDashedMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this );\n\
\n\
\tthis.color = new THREE.Color( 0xffffff );\n\
\n\
\tthis.linewidth = 1;\n\
\n\
\tthis.scale = 1;\n\
\tthis.dashSize = 3;\n\
\tthis.gapSize = 1;\n\
\n\
\tthis.vertexColors = false;\n\
\n\
\tthis.fog = true;\n\
\n\
\tthis.setValues( parameters );\n\
\n\
};\n\
\n\
THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.LineDashedMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.LineDashedMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.color.copy( this.color );\n\
\n\
\tmaterial.linewidth = this.linewidth;\n\
\n\
\tmaterial.scale = this.scale;\n\
\tmaterial.dashSize = this.dashSize;\n\
\tmaterial.gapSize = this.gapSize;\n\
\n\
\tmaterial.vertexColors = this.vertexColors;\n\
\n\
\tmaterial.fog = this.fog;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * parameters = {\n\
 *  color: <hex>,\n\
 *  opacity: <float>,\n\
 *  map: new THREE.Texture( <Image> ),\n\
 *\n\
 *  lightMap: new THREE.Texture( <Image> ),\n\
 *\n\
 *  specularMap: new THREE.Texture( <Image> ),\n\
 *\n\
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\
 *  combine: THREE.Multiply,\n\
 *  reflectivity: <float>,\n\
 *  refractionRatio: <float>,\n\
 *\n\
 *  shading: THREE.SmoothShading,\n\
 *  blending: THREE.NormalBlending,\n\
 *  depthTest: <bool>,\n\
 *  depthWrite: <bool>,\n\
 *\n\
 *  wireframe: <boolean>,\n\
 *  wireframeLinewidth: <float>,\n\
 *\n\
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n\
 *\n\
 *  skinning: <bool>,\n\
 *  morphTargets: <bool>,\n\
 *\n\
 *  fog: <bool>\n\
 * }\n\
 */\n\
\n\
THREE.MeshBasicMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this );\n\
\n\
\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\
\n\
\tthis.map = null;\n\
\n\
\tthis.lightMap = null;\n\
\n\
\tthis.specularMap = null;\n\
\n\
\tthis.envMap = null;\n\
\tthis.combine = THREE.MultiplyOperation;\n\
\tthis.reflectivity = 1;\n\
\tthis.refractionRatio = 0.98;\n\
\n\
\tthis.fog = true;\n\
\n\
\tthis.shading = THREE.SmoothShading;\n\
\n\
\tthis.wireframe = false;\n\
\tthis.wireframeLinewidth = 1;\n\
\tthis.wireframeLinecap = 'round';\n\
\tthis.wireframeLinejoin = 'round';\n\
\n\
\tthis.vertexColors = THREE.NoColors;\n\
\n\
\tthis.skinning = false;\n\
\tthis.morphTargets = false;\n\
\n\
\tthis.setValues( parameters );\n\
\n\
};\n\
\n\
THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.MeshBasicMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.MeshBasicMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.color.copy( this.color );\n\
\n\
\tmaterial.map = this.map;\n\
\n\
\tmaterial.lightMap = this.lightMap;\n\
\n\
\tmaterial.specularMap = this.specularMap;\n\
\n\
\tmaterial.envMap = this.envMap;\n\
\tmaterial.combine = this.combine;\n\
\tmaterial.reflectivity = this.reflectivity;\n\
\tmaterial.refractionRatio = this.refractionRatio;\n\
\n\
\tmaterial.fog = this.fog;\n\
\n\
\tmaterial.shading = this.shading;\n\
\n\
\tmaterial.wireframe = this.wireframe;\n\
\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\
\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\
\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\
\n\
\tmaterial.vertexColors = this.vertexColors;\n\
\n\
\tmaterial.skinning = this.skinning;\n\
\tmaterial.morphTargets = this.morphTargets;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * parameters = {\n\
 *  color: <hex>,\n\
 *  ambient: <hex>,\n\
 *  emissive: <hex>,\n\
 *  opacity: <float>,\n\
 *\n\
 *  map: new THREE.Texture( <Image> ),\n\
 *\n\
 *  lightMap: new THREE.Texture( <Image> ),\n\
 *\n\
 *  specularMap: new THREE.Texture( <Image> ),\n\
 *\n\
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\
 *  combine: THREE.Multiply,\n\
 *  reflectivity: <float>,\n\
 *  refractionRatio: <float>,\n\
 *\n\
 *  shading: THREE.SmoothShading,\n\
 *  blending: THREE.NormalBlending,\n\
 *  depthTest: <bool>,\n\
 *  depthWrite: <bool>,\n\
 *\n\
 *  wireframe: <boolean>,\n\
 *  wireframeLinewidth: <float>,\n\
 *\n\
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n\
 *\n\
 *  skinning: <bool>,\n\
 *  morphTargets: <bool>,\n\
 *  morphNormals: <bool>,\n\
 *\n\
 *\tfog: <bool>\n\
 * }\n\
 */\n\
\n\
THREE.MeshLambertMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this );\n\
\n\
\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\
\tthis.ambient = new THREE.Color( 0xffffff );\n\
\tthis.emissive = new THREE.Color( 0x000000 );\n\
\n\
\tthis.wrapAround = false;\n\
\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\n\
\n\
\tthis.map = null;\n\
\n\
\tthis.lightMap = null;\n\
\n\
\tthis.specularMap = null;\n\
\n\
\tthis.envMap = null;\n\
\tthis.combine = THREE.MultiplyOperation;\n\
\tthis.reflectivity = 1;\n\
\tthis.refractionRatio = 0.98;\n\
\n\
\tthis.fog = true;\n\
\n\
\tthis.shading = THREE.SmoothShading;\n\
\n\
\tthis.wireframe = false;\n\
\tthis.wireframeLinewidth = 1;\n\
\tthis.wireframeLinecap = 'round';\n\
\tthis.wireframeLinejoin = 'round';\n\
\n\
\tthis.vertexColors = THREE.NoColors;\n\
\n\
\tthis.skinning = false;\n\
\tthis.morphTargets = false;\n\
\tthis.morphNormals = false;\n\
\n\
\tthis.setValues( parameters );\n\
\n\
};\n\
\n\
THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.MeshLambertMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.MeshLambertMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.color.copy( this.color );\n\
\tmaterial.ambient.copy( this.ambient );\n\
\tmaterial.emissive.copy( this.emissive );\n\
\n\
\tmaterial.wrapAround = this.wrapAround;\n\
\tmaterial.wrapRGB.copy( this.wrapRGB );\n\
\n\
\tmaterial.map = this.map;\n\
\n\
\tmaterial.lightMap = this.lightMap;\n\
\n\
\tmaterial.specularMap = this.specularMap;\n\
\n\
\tmaterial.envMap = this.envMap;\n\
\tmaterial.combine = this.combine;\n\
\tmaterial.reflectivity = this.reflectivity;\n\
\tmaterial.refractionRatio = this.refractionRatio;\n\
\n\
\tmaterial.fog = this.fog;\n\
\n\
\tmaterial.shading = this.shading;\n\
\n\
\tmaterial.wireframe = this.wireframe;\n\
\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\
\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\
\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\
\n\
\tmaterial.vertexColors = this.vertexColors;\n\
\n\
\tmaterial.skinning = this.skinning;\n\
\tmaterial.morphTargets = this.morphTargets;\n\
\tmaterial.morphNormals = this.morphNormals;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * parameters = {\n\
 *  color: <hex>,\n\
 *  ambient: <hex>,\n\
 *  emissive: <hex>,\n\
 *  specular: <hex>,\n\
 *  shininess: <float>,\n\
 *  opacity: <float>,\n\
 *\n\
 *  map: new THREE.Texture( <Image> ),\n\
 *\n\
 *  lightMap: new THREE.Texture( <Image> ),\n\
 *\n\
 *  bumpMap: new THREE.Texture( <Image> ),\n\
 *  bumpScale: <float>,\n\
 *\n\
 *  normalMap: new THREE.Texture( <Image> ),\n\
 *  normalScale: <Vector2>,\n\
 *\n\
 *  specularMap: new THREE.Texture( <Image> ),\n\
 *\n\
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\
 *  combine: THREE.Multiply,\n\
 *  reflectivity: <float>,\n\
 *  refractionRatio: <float>,\n\
 *\n\
 *  shading: THREE.SmoothShading,\n\
 *  blending: THREE.NormalBlending,\n\
 *  depthTest: <bool>,\n\
 *  depthWrite: <bool>,\n\
 *\n\
 *  wireframe: <boolean>,\n\
 *  wireframeLinewidth: <float>,\n\
 *\n\
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n\
 *\n\
 *  skinning: <bool>,\n\
 *  morphTargets: <bool>,\n\
 *  morphNormals: <bool>,\n\
 *\n\
 *\tfog: <bool>\n\
 * }\n\
 */\n\
\n\
THREE.MeshPhongMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this );\n\
\n\
\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\
\tthis.ambient = new THREE.Color( 0xffffff );\n\
\tthis.emissive = new THREE.Color( 0x000000 );\n\
\tthis.specular = new THREE.Color( 0x111111 );\n\
\tthis.shininess = 30;\n\
\n\
\tthis.metal = false;\n\
\tthis.perPixel = true;\n\
\n\
\tthis.wrapAround = false;\n\
\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\n\
\n\
\tthis.map = null;\n\
\n\
\tthis.lightMap = null;\n\
\n\
\tthis.bumpMap = null;\n\
\tthis.bumpScale = 1;\n\
\n\
\tthis.normalMap = null;\n\
\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\
\n\
\tthis.specularMap = null;\n\
\n\
\tthis.envMap = null;\n\
\tthis.combine = THREE.MultiplyOperation;\n\
\tthis.reflectivity = 1;\n\
\tthis.refractionRatio = 0.98;\n\
\n\
\tthis.fog = true;\n\
\n\
\tthis.shading = THREE.SmoothShading;\n\
\n\
\tthis.wireframe = false;\n\
\tthis.wireframeLinewidth = 1;\n\
\tthis.wireframeLinecap = 'round';\n\
\tthis.wireframeLinejoin = 'round';\n\
\n\
\tthis.vertexColors = THREE.NoColors;\n\
\n\
\tthis.skinning = false;\n\
\tthis.morphTargets = false;\n\
\tthis.morphNormals = false;\n\
\n\
\tthis.setValues( parameters );\n\
\n\
};\n\
\n\
THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.MeshPhongMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.MeshPhongMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.color.copy( this.color );\n\
\tmaterial.ambient.copy( this.ambient );\n\
\tmaterial.emissive.copy( this.emissive );\n\
\tmaterial.specular.copy( this.specular );\n\
\tmaterial.shininess = this.shininess;\n\
\n\
\tmaterial.metal = this.metal;\n\
\tmaterial.perPixel = this.perPixel;\n\
\n\
\tmaterial.wrapAround = this.wrapAround;\n\
\tmaterial.wrapRGB.copy( this.wrapRGB );\n\
\n\
\tmaterial.map = this.map;\n\
\n\
\tmaterial.lightMap = this.lightMap;\n\
\n\
\tmaterial.bumpMap = this.bumpMap;\n\
\tmaterial.bumpScale = this.bumpScale;\n\
\n\
\tmaterial.normalMap = this.normalMap;\n\
\tmaterial.normalScale.copy( this.normalScale );\n\
\n\
\tmaterial.specularMap = this.specularMap;\n\
\n\
\tmaterial.envMap = this.envMap;\n\
\tmaterial.combine = this.combine;\n\
\tmaterial.reflectivity = this.reflectivity;\n\
\tmaterial.refractionRatio = this.refractionRatio;\n\
\n\
\tmaterial.fog = this.fog;\n\
\n\
\tmaterial.shading = this.shading;\n\
\n\
\tmaterial.wireframe = this.wireframe;\n\
\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\
\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\
\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\
\n\
\tmaterial.vertexColors = this.vertexColors;\n\
\n\
\tmaterial.skinning = this.skinning;\n\
\tmaterial.morphTargets = this.morphTargets;\n\
\tmaterial.morphNormals = this.morphNormals;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * parameters = {\n\
 *  opacity: <float>,\n\
 *\n\
 *  blending: THREE.NormalBlending,\n\
 *  depthTest: <bool>,\n\
 *  depthWrite: <bool>,\n\
 *\n\
 *  wireframe: <boolean>,\n\
 *  wireframeLinewidth: <float>\n\
 * }\n\
 */\n\
\n\
THREE.MeshDepthMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this );\n\
\n\
\tthis.wireframe = false;\n\
\tthis.wireframeLinewidth = 1;\n\
\n\
\tthis.setValues( parameters );\n\
\n\
};\n\
\n\
THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.MeshDepthMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.MeshDepthMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.wireframe = this.wireframe;\n\
\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 *\n\
 * parameters = {\n\
 *  opacity: <float>,\n\
 *\n\
 *  shading: THREE.FlatShading,\n\
 *  blending: THREE.NormalBlending,\n\
 *  depthTest: <bool>,\n\
 *  depthWrite: <bool>,\n\
 *\n\
 *  wireframe: <boolean>,\n\
 *  wireframeLinewidth: <float>\n\
 * }\n\
 */\n\
\n\
THREE.MeshNormalMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this, parameters );\n\
\n\
\tthis.shading = THREE.FlatShading;\n\
\n\
\tthis.wireframe = false;\n\
\tthis.wireframeLinewidth = 1;\n\
\n\
\tthis.morphTargets = false;\n\
\n\
\tthis.setValues( parameters );\n\
\n\
};\n\
\n\
THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.MeshNormalMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.MeshNormalMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.shading = this.shading;\n\
\n\
\tmaterial.wireframe = this.wireframe;\n\
\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.MeshFaceMaterial = function ( materials ) {\n\
\n\
\tthis.materials = materials instanceof Array ? materials : [];\n\
\n\
};\n\
\n\
THREE.MeshFaceMaterial.prototype.clone = function () {\n\
\n\
\treturn new THREE.MeshFaceMaterial( this.materials.slice( 0 ) );\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * parameters = {\n\
 *  color: <hex>,\n\
 *  opacity: <float>,\n\
 *  map: new THREE.Texture( <Image> ),\n\
 *\n\
 *  size: <float>,\n\
 *\n\
 *  blending: THREE.NormalBlending,\n\
 *  depthTest: <bool>,\n\
 *  depthWrite: <bool>,\n\
 *\n\
 *  vertexColors: <bool>,\n\
 *\n\
 *  fog: <bool>\n\
 * }\n\
 */\n\
\n\
THREE.ParticleBasicMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this );\n\
\n\
\tthis.color = new THREE.Color( 0xffffff );\n\
\n\
\tthis.map = null;\n\
\n\
\tthis.size = 1;\n\
\tthis.sizeAttenuation = true;\n\
\n\
\tthis.vertexColors = false;\n\
\n\
\tthis.fog = true;\n\
\n\
\tthis.setValues( parameters );\n\
\n\
};\n\
\n\
THREE.ParticleBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.ParticleBasicMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.ParticleBasicMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.color.copy( this.color );\n\
\n\
\tmaterial.map = this.map;\n\
\n\
\tmaterial.size = this.size;\n\
\tmaterial.sizeAttenuation = this.sizeAttenuation;\n\
\n\
\tmaterial.vertexColors = this.vertexColors;\n\
\n\
\tmaterial.fog = this.fog;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 *\n\
 * parameters = {\n\
 *  color: <hex>,\n\
 *  program: <function>,\n\
 *  opacity: <float>,\n\
 *  blending: THREE.NormalBlending\n\
 * }\n\
 */\n\
\n\
THREE.ParticleCanvasMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this );\n\
\n\
\tthis.color = new THREE.Color( 0xffffff );\n\
\tthis.program = function ( context, color ) {};\n\
\n\
\tthis.setValues( parameters );\n\
\n\
};\n\
\n\
THREE.ParticleCanvasMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.ParticleCanvasMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.ParticleCanvasMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.color.copy( this.color );\n\
\tmaterial.program = this.program;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * parameters = {\n\
 *  fragmentShader: <string>,\n\
 *  vertexShader: <string>,\n\
 *\n\
 *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\n\
 *\n\
 *  defines: { \"label\" : \"value\" },\n\
 *\n\
 *  shading: THREE.SmoothShading,\n\
 *  blending: THREE.NormalBlending,\n\
 *  depthTest: <bool>,\n\
 *  depthWrite: <bool>,\n\
 *\n\
 *  wireframe: <boolean>,\n\
 *  wireframeLinewidth: <float>,\n\
 *\n\
 *  lights: <bool>,\n\
 *\n\
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n\
 *\n\
 *  skinning: <bool>,\n\
 *  morphTargets: <bool>,\n\
 *  morphNormals: <bool>,\n\
 *\n\
 *\tfog: <bool>\n\
 * }\n\
 */\n\
\n\
THREE.ShaderMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this );\n\
\n\
\tthis.fragmentShader = \"void main() {}\";\n\
\tthis.vertexShader = \"void main() {}\";\n\
\tthis.uniforms = {};\n\
\tthis.defines = {};\n\
\tthis.attributes = null;\n\
\n\
\tthis.shading = THREE.SmoothShading;\n\
\n\
\tthis.linewidth = 1;\n\
\n\
\tthis.wireframe = false;\n\
\tthis.wireframeLinewidth = 1;\n\
\n\
\tthis.fog = false; // set to use scene fog\n\
\n\
\tthis.lights = false; // set to use scene lights\n\
\n\
\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\n\
\n\
\tthis.skinning = false; // set to use skinning attribute streams\n\
\n\
\tthis.morphTargets = false; // set to use morph targets\n\
\tthis.morphNormals = false; // set to use morph normals\n\
\n\
\t// When rendered geometry doesn't include these attributes but the material does,\n\
\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\
\tthis.defaultAttributeValues = {\n\
\t\t\"color\" : [ 1, 1, 1],\n\
\t\t\"uv\" : [ 0, 0 ],\n\
\t\t\"uv2\" : [ 0, 0 ]\n\
\t};\n\
\n\
\t// By default, bind position to attribute index 0. In WebGL, attribute 0\n\
\t// should always be used to avoid potentially expensive emulation.\n\
\tthis.index0AttributeName = \"position\";\n\
\n\
\tthis.setValues( parameters );\n\
\n\
};\n\
\n\
THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.ShaderMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.ShaderMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.fragmentShader = this.fragmentShader;\n\
\tmaterial.vertexShader = this.vertexShader;\n\
\n\
\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\n\
\n\
\tmaterial.attributes = this.attributes;\n\
\tmaterial.defines = this.defines;\n\
\n\
\tmaterial.shading = this.shading;\n\
\n\
\tmaterial.wireframe = this.wireframe;\n\
\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\
\n\
\tmaterial.fog = this.fog;\n\
\n\
\tmaterial.lights = this.lights;\n\
\n\
\tmaterial.vertexColors = this.vertexColors;\n\
\n\
\tmaterial.skinning = this.skinning;\n\
\n\
\tmaterial.morphTargets = this.morphTargets;\n\
\tmaterial.morphNormals = this.morphNormals;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * parameters = {\n\
 *  color: <hex>,\n\
 *  opacity: <float>,\n\
 *  map: new THREE.Texture( <Image> ),\n\
 *\n\
 *  blending: THREE.NormalBlending,\n\
 *  depthTest: <bool>,\n\
 *  depthWrite: <bool>,\n\
 *\n\
 *  useScreenCoordinates: <bool>,\n\
 *  sizeAttenuation: <bool>,\n\
 *  scaleByViewport: <bool>,\n\
 *  alignment: THREE.SpriteAlignment.center,\n\
 *\n\
 *\tuvOffset: new THREE.Vector2(),\n\
 *\tuvScale: new THREE.Vector2(),\n\
 *\n\
 *  fog: <bool>\n\
 * }\n\
 */\n\
\n\
THREE.SpriteMaterial = function ( parameters ) {\n\
\n\
\tTHREE.Material.call( this );\n\
\n\
\t// defaults\n\
\n\
\tthis.color = new THREE.Color( 0xffffff );\n\
\tthis.map = new THREE.Texture();\n\
\n\
\tthis.useScreenCoordinates = true;\n\
\tthis.depthTest = !this.useScreenCoordinates;\n\
\tthis.sizeAttenuation = !this.useScreenCoordinates;\n\
\tthis.scaleByViewport = !this.sizeAttenuation;\n\
\tthis.alignment = THREE.SpriteAlignment.center.clone();\n\
\n\
\tthis.fog = false;\n\
\n\
\tthis.uvOffset = new THREE.Vector2( 0, 0 );\n\
\tthis.uvScale  = new THREE.Vector2( 1, 1 );\n\
\n\
\t// set parameters\n\
\n\
\tthis.setValues( parameters );\n\
\n\
\t// override coupled defaults if not specified explicitly by parameters\n\
\n\
\tparameters = parameters || {};\n\
\n\
\tif ( parameters.depthTest === undefined ) this.depthTest = !this.useScreenCoordinates;\n\
\tif ( parameters.sizeAttenuation === undefined ) this.sizeAttenuation = !this.useScreenCoordinates;\n\
\tif ( parameters.scaleByViewport === undefined ) this.scaleByViewport = !this.sizeAttenuation;\n\
\n\
};\n\
\n\
THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\n\
\n\
THREE.SpriteMaterial.prototype.clone = function () {\n\
\n\
\tvar material = new THREE.SpriteMaterial();\n\
\n\
\tTHREE.Material.prototype.clone.call( this, material );\n\
\n\
\tmaterial.color.copy( this.color );\n\
\tmaterial.map = this.map;\n\
\n\
\tmaterial.useScreenCoordinates = this.useScreenCoordinates;\n\
\tmaterial.sizeAttenuation = this.sizeAttenuation;\n\
\tmaterial.scaleByViewport = this.scaleByViewport;\n\
\tmaterial.alignment.copy( this.alignment );\n\
\n\
\tmaterial.uvOffset.copy( this.uvOffset );\n\
\tmaterial.uvScale.copy( this.uvScale );\n\
\n\
\tmaterial.fog = this.fog;\n\
\n\
\treturn material;\n\
\n\
};\n\
\n\
// Alignment enums\n\
\n\
THREE.SpriteAlignment = {};\n\
THREE.SpriteAlignment.topLeft = new THREE.Vector2( 1, -1 );\n\
THREE.SpriteAlignment.topCenter = new THREE.Vector2( 0, -1 );\n\
THREE.SpriteAlignment.topRight = new THREE.Vector2( -1, -1 );\n\
THREE.SpriteAlignment.centerLeft = new THREE.Vector2( 1, 0 );\n\
THREE.SpriteAlignment.center = new THREE.Vector2( 0, 0 );\n\
THREE.SpriteAlignment.centerRight = new THREE.Vector2( -1, 0 );\n\
THREE.SpriteAlignment.bottomLeft = new THREE.Vector2( 1, 1 );\n\
THREE.SpriteAlignment.bottomCenter = new THREE.Vector2( 0, 1 );\n\
THREE.SpriteAlignment.bottomRight = new THREE.Vector2( -1, 1 );\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author szimek / https://github.com/szimek/\n\
 */\n\
\n\
THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\
\n\
\tthis.id = THREE.TextureIdCount ++;\n\
\tthis.uuid = THREE.Math.generateUUID();\n\
\n\
\tthis.name = '';\n\
\n\
\tthis.image = image;\n\
\tthis.mipmaps = [];\n\
\n\
\tthis.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();\n\
\n\
\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\
\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\
\n\
\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\
\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\
\n\
\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\
\n\
\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\
\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\
\n\
\tthis.offset = new THREE.Vector2( 0, 0 );\n\
\tthis.repeat = new THREE.Vector2( 1, 1 );\n\
\n\
\tthis.generateMipmaps = true;\n\
\tthis.premultiplyAlpha = false;\n\
\tthis.flipY = true;\n\
\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\
\n\
\tthis.needsUpdate = false;\n\
\tthis.onUpdate = null;\n\
\n\
};\n\
\n\
THREE.Texture.prototype = {\n\
\n\
\tconstructor: THREE.Texture,\n\
\n\
\tclone: function ( texture ) {\n\
\n\
\t\tif ( texture === undefined ) texture = new THREE.Texture();\n\
\n\
\t\ttexture.image = this.image;\n\
\t\ttexture.mipmaps = this.mipmaps.slice(0);\n\
\n\
\t\ttexture.mapping = this.mapping;\n\
\n\
\t\ttexture.wrapS = this.wrapS;\n\
\t\ttexture.wrapT = this.wrapT;\n\
\n\
\t\ttexture.magFilter = this.magFilter;\n\
\t\ttexture.minFilter = this.minFilter;\n\
\n\
\t\ttexture.anisotropy = this.anisotropy;\n\
\n\
\t\ttexture.format = this.format;\n\
\t\ttexture.type = this.type;\n\
\n\
\t\ttexture.offset.copy( this.offset );\n\
\t\ttexture.repeat.copy( this.repeat );\n\
\n\
\t\ttexture.generateMipmaps = this.generateMipmaps;\n\
\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\n\
\t\ttexture.flipY = this.flipY;\n\
\t\ttexture.unpackAlignment = this.unpackAlignment;\n\
\n\
\t\treturn texture;\n\
\n\
\t},\n\
\n\
\tdispose: function () {\n\
\n\
\t\tthis.dispatchEvent( { type: 'dispose' } );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\n\
\n\
THREE.TextureIdCount = 0;\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\
\n\
\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\
\n\
\tthis.image = { width: width, height: height };\n\
\tthis.mipmaps = mipmaps;\n\
\n\
\tthis.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file\n\
\n\
};\n\
\n\
THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\n\
\n\
THREE.CompressedTexture.prototype.clone = function () {\n\
\n\
\tvar texture = new THREE.CompressedTexture();\n\
\n\
\tTHREE.Texture.prototype.clone.call( this, texture );\n\
\n\
\treturn texture;\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\
\n\
\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\
\n\
\tthis.image = { data: data, width: width, height: height };\n\
\n\
};\n\
\n\
THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\n\
\n\
THREE.DataTexture.prototype.clone = function () {\n\
\n\
\tvar texture = new THREE.DataTexture();\n\
\n\
\tTHREE.Texture.prototype.clone.call( this, texture );\n\
\n\
\treturn texture;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.Particle = function ( material ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.material = material;\n\
\n\
};\n\
\n\
THREE.Particle.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.Particle.prototype.clone = function ( object ) {\n\
\n\
\tif ( object === undefined ) object = new THREE.Particle( this.material );\n\
\n\
\tTHREE.Object3D.prototype.clone.call( this, object );\n\
\n\
\treturn object;\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.ParticleSystem = function ( geometry, material ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n\
\tthis.material = material !== undefined ? material : new THREE.ParticleBasicMaterial( { color: Math.random() * 0xffffff } );\n\
\n\
\tthis.sortParticles = false;\n\
\tthis.frustumCulled = false;\n\
\n\
};\n\
\n\
THREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.ParticleSystem.prototype.clone = function ( object ) {\n\
\n\
\tif ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );\n\
\n\
\tobject.sortParticles = this.sortParticles;\n\
\n\
\tTHREE.Object3D.prototype.clone.call( this, object );\n\
\n\
\treturn object;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.Line = function ( geometry, material, type ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n\
\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\
\n\
\tthis.type = ( type !== undefined ) ? type : THREE.LineStrip;\n\
\n\
};\n\
\n\
THREE.LineStrip = 0;\n\
THREE.LinePieces = 1;\n\
\n\
THREE.Line.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.Line.prototype.clone = function ( object ) {\n\
\n\
\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );\n\
\n\
\tTHREE.Object3D.prototype.clone.call( this, object );\n\
\n\
\treturn object;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author jonobr1 / http://jonobr1.com/\n\
 */\n\
\n\
THREE.Mesh = function ( geometry, material ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n\
\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\
\n\
\tthis.updateMorphTargets();\n\
\n\
};\n\
\n\
THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.Mesh.prototype.updateMorphTargets = function () {\n\
\n\
\tif ( this.geometry.morphTargets.length > 0 ) {\n\
\n\
\t\tthis.morphTargetBase = -1;\n\
\t\tthis.morphTargetForcedOrder = [];\n\
\t\tthis.morphTargetInfluences = [];\n\
\t\tthis.morphTargetDictionary = {};\n\
\n\
\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\
\n\
\t\t\tthis.morphTargetInfluences.push( 0 );\n\
\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\n\
\n\
\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\
\n\
\t\treturn this.morphTargetDictionary[ name ];\n\
\n\
\t}\n\
\n\
\tconsole.log( \"THREE.Mesh.getMorphTargetIndexByName: morph target \" + name + \" does not exist. Returning 0.\" );\n\
\n\
\treturn 0;\n\
\n\
};\n\
\n\
THREE.Mesh.prototype.clone = function ( object ) {\n\
\n\
\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\n\
\n\
\tTHREE.Object3D.prototype.clone.call( this, object );\n\
\n\
\treturn object;\n\
\n\
};\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Bone = function( belongsToSkin ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.skin = belongsToSkin;\n\
\tthis.skinMatrix = new THREE.Matrix4();\n\
\n\
};\n\
\n\
THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {\n\
\n\
\t// update local\n\
\n\
\tif ( this.matrixAutoUpdate ) {\n\
\n\
\t\tforceUpdate |= this.updateMatrix();\n\
\n\
\t}\n\
\n\
\t// update skin matrix\n\
\n\
\tif ( forceUpdate || this.matrixWorldNeedsUpdate ) {\n\
\n\
\t\tif( parentSkinMatrix ) {\n\
\n\
\t\t\tthis.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );\n\
\n\
\t\t} else {\n\
\n\
\t\t\tthis.skinMatrix.copy( this.matrix );\n\
\n\
\t\t}\n\
\n\
\t\tthis.matrixWorldNeedsUpdate = false;\n\
\t\tforceUpdate = true;\n\
\n\
\t}\n\
\n\
\t// update children\n\
\n\
\tvar child, i, l = this.children.length;\n\
\n\
\tfor ( i = 0; i < l; i ++ ) {\n\
\n\
\t\tthis.children[ i ].update( this.skinMatrix, forceUpdate );\n\
\n\
\t}\n\
\n\
};\n\
\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\
\n\
\tTHREE.Mesh.call( this, geometry, material );\n\
\n\
\t//\n\
\n\
\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\
\n\
\t// init bones\n\
\n\
\tthis.identityMatrix = new THREE.Matrix4();\n\
\n\
\tthis.bones = [];\n\
\tthis.boneMatrices = [];\n\
\n\
\tvar b, bone, gbone, p, q, s;\n\
\n\
\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\
\n\
\t\tfor ( b = 0; b < this.geometry.bones.length; b ++ ) {\n\
\n\
\t\t\tgbone = this.geometry.bones[ b ];\n\
\n\
\t\t\tp = gbone.pos;\n\
\t\t\tq = gbone.rotq;\n\
\t\t\ts = gbone.scl;\n\
\n\
\t\t\tbone = this.addBone();\n\
\n\
\t\t\tbone.name = gbone.name;\n\
\t\t\tbone.position.set( p[0], p[1], p[2] );\n\
\t\t\tbone.quaternion.set( q[0], q[1], q[2], q[3] );\n\
\t\t\n\
\t\t\tif ( s !== undefined ) {\n\
\n\
\t\t\t\tbone.scale.set( s[0], s[1], s[2] );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tbone.scale.set( 1, 1, 1 );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tfor ( b = 0; b < this.bones.length; b ++ ) {\n\
\n\
\t\t\tgbone = this.geometry.bones[ b ];\n\
\t\t\tbone = this.bones[ b ];\n\
\n\
\t\t\tif ( gbone.parent === -1 ) {\n\
\n\
\t\t\t\tthis.add( bone );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tthis.bones[ gbone.parent ].add( bone );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t//\n\
\n\
\t\tvar nBones = this.bones.length;\n\
\n\
\t\tif ( this.useVertexTexture ) {\n\
\n\
\t\t\t// layout (1 matrix = 4 pixels)\n\
\t\t\t//\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\
\t\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\n\
\t\t\t//  \t 16x16 pixel texture max   64 bones (16 * 16 / 4)\n\
\t\t\t//  \t 32x32 pixel texture max  256 bones (32 * 32 / 4)\n\
\t\t\t//  \t 64x64 pixel texture max 1024 bones (64 * 64 / 4)\n\
\n\
\t\t\tvar size;\n\
\n\
\t\t\tif ( nBones > 256 )\n\
\t\t\t\tsize = 64;\n\
\t\t\telse if ( nBones > 64 )\n\
\t\t\t\tsize = 32;\n\
\t\t\telse if ( nBones > 16 )\n\
\t\t\t\tsize = 16;\n\
\t\t\telse\n\
\t\t\t\tsize = 8;\n\
\n\
\t\t\tthis.boneTextureWidth = size;\n\
\t\t\tthis.boneTextureHeight = size;\n\
\n\
\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\
\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\
\t\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\n\
\t\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\n\
\t\t\tthis.boneTexture.generateMipmaps = false;\n\
\t\t\tthis.boneTexture.flipY = false;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tthis.boneMatrices = new Float32Array( 16 * nBones );\n\
\n\
\t\t}\n\
\n\
\t\tthis.pose();\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\n\
\n\
THREE.SkinnedMesh.prototype.addBone = function( bone ) {\n\
\n\
\tif ( bone === undefined ) {\n\
\n\
\t\tbone = new THREE.Bone( this );\n\
\n\
\t}\n\
\n\
\tthis.bones.push( bone );\n\
\n\
\treturn bone;\n\
\n\
};\n\
\n\
THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {\n\
\n\
\tvar offsetMatrix = new THREE.Matrix4();\n\
\n\
\treturn function ( force ) {\n\
\n\
\t\tthis.matrixAutoUpdate && this.updateMatrix();\n\
\n\
\t\t// update matrixWorld\n\
\n\
\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\
\n\
\t\t\tif ( this.parent ) {\n\
\n\
\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tthis.matrixWorldNeedsUpdate = false;\n\
\n\
\t\t\tforce = true;\n\
\n\
\t\t}\n\
\n\
\t\t// update children\n\
\n\
\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\
\n\
\t\t\tvar child = this.children[ i ];\n\
\n\
\t\t\tif ( child instanceof THREE.Bone ) {\n\
\n\
\t\t\t\tchild.update( this.identityMatrix, false );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tchild.updateMatrixWorld( true );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// make a snapshot of the bones' rest position\n\
\n\
\t\tif ( this.boneInverses == undefined ) {\n\
\n\
\t\t\tthis.boneInverses = [];\n\
\n\
\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\
\n\
\t\t\t\tvar inverse = new THREE.Matrix4();\n\
\n\
\t\t\t\tinverse.getInverse( this.bones[ b ].skinMatrix );\n\
\n\
\t\t\t\tthis.boneInverses.push( inverse );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// flatten bone matrices to array\n\
\n\
\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\
\n\
\t\t\t// compute the offset between the current and the original transform;\n\
\n\
\t\t\t// TODO: we could get rid of this multiplication step if the skinMatrix\n\
\t\t\t// was already representing the offset; however, this requires some\n\
\t\t\t// major changes to the animation system\n\
\n\
\t\t\toffsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );\n\
\t\t\toffsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.useVertexTexture ) {\n\
\n\
\t\t\tthis.boneTexture.needsUpdate = true;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
}();\n\
\n\
THREE.SkinnedMesh.prototype.pose = function () {\n\
\n\
\tthis.updateMatrixWorld( true );\n\
\n\
\tthis.normalizeSkinWeights();\n\
\n\
};\n\
\n\
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\n\
\n\
\tif ( this.geometry instanceof THREE.Geometry ) {\n\
\n\
\t\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\n\
\n\
\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\
\n\
\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\
\n\
\t\t\tif ( scale !== Infinity ) {\n\
\n\
\t\t\t\tsw.multiplyScalar( scale );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t} else {\n\
\n\
\t\t// skinning weights assumed to be normalized for THREE.BufferGeometry\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.SkinnedMesh.prototype.clone = function ( object ) {\n\
\n\
\tif ( object === undefined ) {\n\
\n\
\t\tobject = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\n\
\n\
\t}\n\
\n\
\tTHREE.Mesh.prototype.clone.call( this, object );\n\
\n\
\treturn object;\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.MorphAnimMesh = function ( geometry, material ) {\n\
\n\
\tTHREE.Mesh.call( this, geometry, material );\n\
\n\
\t// API\n\
\n\
\tthis.duration = 1000; // milliseconds\n\
\tthis.mirroredLoop = false;\n\
\tthis.time = 0;\n\
\n\
\t// internals\n\
\n\
\tthis.lastKeyframe = 0;\n\
\tthis.currentKeyframe = 0;\n\
\n\
\tthis.direction = 1;\n\
\tthis.directionBackwards = false;\n\
\n\
\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\n\
\n\
};\n\
\n\
THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\n\
\n\
THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\n\
\n\
\tthis.startKeyframe = start;\n\
\tthis.endKeyframe = end;\n\
\n\
\tthis.length = this.endKeyframe - this.startKeyframe + 1;\n\
\n\
};\n\
\n\
THREE.MorphAnimMesh.prototype.setDirectionForward = function () {\n\
\n\
\tthis.direction = 1;\n\
\tthis.directionBackwards = false;\n\
\n\
};\n\
\n\
THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\n\
\n\
\tthis.direction = -1;\n\
\tthis.directionBackwards = true;\n\
\n\
};\n\
\n\
THREE.MorphAnimMesh.prototype.parseAnimations = function () {\n\
\n\
\tvar geometry = this.geometry;\n\
\n\
\tif ( ! geometry.animations ) geometry.animations = {};\n\
\n\
\tvar firstAnimation, animations = geometry.animations;\n\
\n\
\tvar pattern = /([a-z]+)(\\d+)/;\n\
\n\
\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\
\n\
\t\tvar morph = geometry.morphTargets[ i ];\n\
\t\tvar parts = morph.name.match( pattern );\n\
\n\
\t\tif ( parts && parts.length > 1 ) {\n\
\n\
\t\t\tvar label = parts[ 1 ];\n\
\t\t\tvar num = parts[ 2 ];\n\
\n\
\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };\n\
\n\
\t\t\tvar animation = animations[ label ];\n\
\n\
\t\t\tif ( i < animation.start ) animation.start = i;\n\
\t\t\tif ( i > animation.end ) animation.end = i;\n\
\n\
\t\t\tif ( ! firstAnimation ) firstAnimation = label;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tgeometry.firstAnimation = firstAnimation;\n\
\n\
};\n\
\n\
THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\n\
\n\
\tif ( ! this.geometry.animations ) this.geometry.animations = {};\n\
\n\
\tthis.geometry.animations[ label ] = { start: start, end: end };\n\
\n\
};\n\
\n\
THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\n\
\n\
\tvar animation = this.geometry.animations[ label ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\tthis.setFrameRange( animation.start, animation.end );\n\
\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\n\
\t\tthis.time = 0;\n\
\n\
\t} else {\n\
\n\
\t\tconsole.warn( \"animation[\" + label + \"] undefined\" );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\n\
\n\
\tvar frameTime = this.duration / this.length;\n\
\n\
\tthis.time += this.direction * delta;\n\
\n\
\tif ( this.mirroredLoop ) {\n\
\n\
\t\tif ( this.time > this.duration || this.time < 0 ) {\n\
\n\
\t\t\tthis.direction *= -1;\n\
\n\
\t\t\tif ( this.time > this.duration ) {\n\
\n\
\t\t\t\tthis.time = this.duration;\n\
\t\t\t\tthis.directionBackwards = true;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( this.time < 0 ) {\n\
\n\
\t\t\t\tthis.time = 0;\n\
\t\t\t\tthis.directionBackwards = false;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t} else {\n\
\n\
\t\tthis.time = this.time % this.duration;\n\
\n\
\t\tif ( this.time < 0 ) this.time += this.duration;\n\
\n\
\t}\n\
\n\
\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\n\
\n\
\tif ( keyframe !== this.currentKeyframe ) {\n\
\n\
\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\n\
\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\n\
\n\
\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\
\n\
\t\tthis.lastKeyframe = this.currentKeyframe;\n\
\t\tthis.currentKeyframe = keyframe;\n\
\n\
\t}\n\
\n\
\tvar mix = ( this.time % frameTime ) / frameTime;\n\
\n\
\tif ( this.directionBackwards ) {\n\
\n\
\t\tmix = 1 - mix;\n\
\n\
\t}\n\
\n\
\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\n\
\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\n\
\n\
};\n\
\n\
THREE.MorphAnimMesh.prototype.clone = function ( object ) {\n\
\n\
\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\n\
\n\
\tobject.duration = this.duration;\n\
\tobject.mirroredLoop = this.mirroredLoop;\n\
\tobject.time = this.time;\n\
\n\
\tobject.lastKeyframe = this.lastKeyframe;\n\
\tobject.currentKeyframe = this.currentKeyframe;\n\
\n\
\tobject.direction = this.direction;\n\
\tobject.directionBackwards = this.directionBackwards;\n\
\n\
\tTHREE.Mesh.prototype.clone.call( this, object );\n\
\n\
\treturn object;\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Ribbon = function ( geometry, material ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.geometry = geometry;\n\
\tthis.material = material;\n\
\n\
};\n\
\n\
THREE.Ribbon.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.Ribbon.prototype.clone = function ( object ) {\n\
\n\
\tif ( object === undefined ) object = new THREE.Ribbon( this.geometry, this.material );\n\
\n\
\tTHREE.Object3D.prototype.clone.call( this, object );\n\
\n\
\treturn object;\n\
\n\
};\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.LOD = function () {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.objects = [];\n\
\n\
};\n\
\n\
\n\
THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.LOD.prototype.addLevel = function ( object, distance ) {\n\
\n\
\tif ( distance === undefined ) distance = 0;\n\
\n\
\tdistance = Math.abs( distance );\n\
\n\
\tfor ( var l = 0; l < this.objects.length; l ++ ) {\n\
\n\
\t\tif ( distance < this.objects[ l ].distance ) {\n\
\n\
\t\t\tbreak;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tthis.objects.splice( l, 0, { distance: distance, object: object } );\n\
\tthis.add( object );\n\
\n\
};\n\
\n\
THREE.LOD.prototype.getObjectForDistance = function ( distance ) {\n\
\n\
\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\n\
\n\
\t\tif ( distance < this.objects[ i ].distance ) {\n\
\n\
\t\t\tbreak;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\treturn this.objects[ i - 1 ].object;\n\
\n\
};\n\
\n\
THREE.LOD.prototype.update = function () {\n\
\n\
\tvar v1 = new THREE.Vector3();\n\
\tvar v2 = new THREE.Vector3();\n\
\n\
\treturn function ( camera ) {\n\
\n\
\t\tif ( this.objects.length > 1 ) {\n\
\n\
\t\t\tv1.getPositionFromMatrix( camera.matrixWorld );\n\
\t\t\tv2.getPositionFromMatrix( this.matrixWorld );\n\
\n\
\t\t\tvar distance = v1.distanceTo( v2 );\n\
\n\
\t\t\tthis.objects[ 0 ].object.visible = true;\n\
\n\
\t\t\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\n\
\n\
\t\t\t\tif ( distance >= this.objects[ i ].distance ) {\n\
\n\
\t\t\t\t\tthis.objects[ i - 1 ].object.visible = false;\n\
\t\t\t\t\tthis.objects[ i     ].object.visible = true;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfor( ; i < l; i ++ ) {\n\
\n\
\t\t\t\tthis.objects[ i ].object.visible = false;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
}();\n\
\n\
THREE.LOD.prototype.clone = function () {\n\
\n\
\t// TODO\n\
\n\
};\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Sprite = function ( material ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\
\n\
\tthis.rotation3d = this.rotation;\n\
\tthis.rotation = 0;\n\
\n\
};\n\
\n\
THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
/*\n\
 * Custom update matrix\n\
 */\n\
\n\
THREE.Sprite.prototype.updateMatrix = function () {\n\
\n\
\tthis.rotation3d.set( 0, 0, this.rotation, this.rotation3d.order );\n\
\tthis.quaternion.setFromEuler( this.rotation3d );\n\
\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\
\n\
\tthis.matrixWorldNeedsUpdate = true;\n\
\n\
};\n\
\n\
THREE.Sprite.prototype.clone = function ( object ) {\n\
\n\
\tif ( object === undefined ) object = new THREE.Sprite( this.material );\n\
\n\
\tTHREE.Object3D.prototype.clone.call( this, object );\n\
\n\
\treturn object;\n\
\n\
};\n\
\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.Scene = function () {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.fog = null;\n\
\tthis.overrideMaterial = null;\n\
\n\
\tthis.autoUpdate = true; // checked by the renderer\n\
\tthis.matrixAutoUpdate = false;\n\
\n\
\tthis.__objects = [];\n\
\tthis.__lights = [];\n\
\n\
\tthis.__objectsAdded = [];\n\
\tthis.__objectsRemoved = [];\n\
\n\
};\n\
\n\
THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.Scene.prototype.__addObject = function ( object ) {\n\
\n\
\tif ( object instanceof THREE.Light ) {\n\
\n\
\t\tif ( this.__lights.indexOf( object ) === - 1 ) {\n\
\n\
\t\t\tthis.__lights.push( object );\n\
\n\
\t\t}\n\
\n\
\t\tif ( object.target && object.target.parent === undefined ) {\n\
\n\
\t\t\tthis.add( object.target );\n\
\n\
\t\t}\n\
\n\
\t} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {\n\
\n\
\t\tif ( this.__objects.indexOf( object ) === - 1 ) {\n\
\n\
\t\t\tthis.__objects.push( object );\n\
\t\t\tthis.__objectsAdded.push( object );\n\
\n\
\t\t\t// check if previously removed\n\
\n\
\t\t\tvar i = this.__objectsRemoved.indexOf( object );\n\
\n\
\t\t\tif ( i !== -1 ) {\n\
\n\
\t\t\t\tthis.__objectsRemoved.splice( i, 1 );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfor ( var c = 0; c < object.children.length; c ++ ) {\n\
\n\
\t\tthis.__addObject( object.children[ c ] );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.Scene.prototype.__removeObject = function ( object ) {\n\
\n\
\tif ( object instanceof THREE.Light ) {\n\
\n\
\t\tvar i = this.__lights.indexOf( object );\n\
\n\
\t\tif ( i !== -1 ) {\n\
\n\
\t\t\tthis.__lights.splice( i, 1 );\n\
\n\
\t\t}\n\
\n\
\t} else if ( !( object instanceof THREE.Camera ) ) {\n\
\n\
\t\tvar i = this.__objects.indexOf( object );\n\
\n\
\t\tif( i !== -1 ) {\n\
\n\
\t\t\tthis.__objects.splice( i, 1 );\n\
\t\t\tthis.__objectsRemoved.push( object );\n\
\n\
\t\t\t// check if previously added\n\
\n\
\t\t\tvar ai = this.__objectsAdded.indexOf( object );\n\
\n\
\t\t\tif ( ai !== -1 ) {\n\
\n\
\t\t\t\tthis.__objectsAdded.splice( ai, 1 );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfor ( var c = 0; c < object.children.length; c ++ ) {\n\
\n\
\t\tthis.__removeObject( object.children[ c ] );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.Scene.prototype.clone = function ( object ) {\n\
\n\
\tif ( object === undefined ) object = new THREE.Scene();\n\
\n\
\tTHREE.Object3D.prototype.clone.call(this, object);\n\
\n\
\tif ( this.fog !== null ) object.fog = this.fog.clone();\n\
\tif ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();\n\
\n\
\tobject.autoUpdate = this.autoUpdate;\n\
\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\n\
\n\
\treturn object;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Fog = function ( hex, near, far ) {\n\
\n\
\tthis.name = '';\n\
\n\
\tthis.color = new THREE.Color( hex );\n\
\n\
\tthis.near = ( near !== undefined ) ? near : 1;\n\
\tthis.far = ( far !== undefined ) ? far : 1000;\n\
\n\
};\n\
\n\
THREE.Fog.prototype.clone = function () {\n\
\n\
\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.FogExp2 = function ( hex, density ) {\n\
\n\
\tthis.name = '';\n\
\n\
\tthis.color = new THREE.Color( hex );\n\
\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\
\n\
};\n\
\n\
THREE.FogExp2.prototype.clone = function () {\n\
\n\
\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.CanvasRenderer = function ( parameters ) {\n\
\n\
\tconsole.log( 'THREE.CanvasRenderer', THREE.REVISION );\n\
\n\
\tvar smoothstep = THREE.Math.smoothstep;\n\
\n\
\tparameters = parameters || {};\n\
\n\
\tvar _this = this,\n\
\t_renderData, _elements, _lights,\n\
\t_projector = new THREE.Projector(),\n\
\n\
\t_canvas = parameters.canvas !== undefined\n\
\t\t\t? parameters.canvas\n\
\t\t\t: document.createElement( 'canvas' ),\n\
\n\
\t_canvasWidth, _canvasHeight, _canvasWidthHalf, _canvasHeightHalf,\n\
\t_context = _canvas.getContext( '2d' ),\n\
\n\
\t_clearColor = new THREE.Color( 0x000000 ),\n\
\t_clearAlpha = 0,\n\
\n\
\t_contextGlobalAlpha = 1,\n\
\t_contextGlobalCompositeOperation = 0,\n\
\t_contextStrokeStyle = null,\n\
\t_contextFillStyle = null,\n\
\t_contextLineWidth = null,\n\
\t_contextLineCap = null,\n\
\t_contextLineJoin = null,\n\
\t_contextDashSize = null,\n\
\t_contextGapSize = 0,\n\
\n\
\t_camera,\n\
\n\
\t_v1, _v2, _v3, _v4,\n\
\t_v5 = new THREE.RenderableVertex(),\n\
\t_v6 = new THREE.RenderableVertex(),\n\
\n\
\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\n\
\t_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,\n\
\n\
\t_color = new THREE.Color(),\n\
\t_color1 = new THREE.Color(),\n\
\t_color2 = new THREE.Color(),\n\
\t_color3 = new THREE.Color(),\n\
\t_color4 = new THREE.Color(),\n\
\n\
\t_diffuseColor = new THREE.Color(),\n\
\t_emissiveColor = new THREE.Color(),\n\
\n\
\t_lightColor = new THREE.Color(),\n\
\n\
\t_patterns = {}, _imagedatas = {},\n\
\n\
\t_near, _far,\n\
\n\
\t_image, _uvs,\n\
\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\n\
\n\
\t_clipBox = new THREE.Box2(),\n\
\t_clearBox = new THREE.Box2(),\n\
\t_elemBox = new THREE.Box2(),\n\
\n\
\t_ambientLight = new THREE.Color(),\n\
\t_directionalLights = new THREE.Color(),\n\
\t_pointLights = new THREE.Color(),\n\
\n\
\t_vector3 = new THREE.Vector3(), // Needed for PointLight\n\
\n\
\t_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,\n\
\t_gradientMap, _gradientMapContext, _gradientMapQuality = 16;\n\
\n\
\t_pixelMap = document.createElement( 'canvas' );\n\
\t_pixelMap.width = _pixelMap.height = 2;\n\
\n\
\t_pixelMapContext = _pixelMap.getContext( '2d' );\n\
\t_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';\n\
\t_pixelMapContext.fillRect( 0, 0, 2, 2 );\n\
\n\
\t_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );\n\
\t_pixelMapData = _pixelMapImage.data;\n\
\n\
\t_gradientMap = document.createElement( 'canvas' );\n\
\t_gradientMap.width = _gradientMap.height = _gradientMapQuality;\n\
\n\
\t_gradientMapContext = _gradientMap.getContext( '2d' );\n\
\t_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );\n\
\t_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );\n\
\n\
\t_gradientMapQuality --; // Fix UVs\n\
\n\
\t// dash+gap fallbacks for Firefox and everything else\n\
\n\
\tif ( _context.setLineDash === undefined ) {\n\
\n\
\t\tif ( _context.mozDash !== undefined ) {\n\
\n\
\t\t\t_context.setLineDash = function ( values ) {\n\
\n\
\t\t\t\t_context.mozDash = values[ 0 ] !== null ? values : null;\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_context.setLineDash = function () {}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tthis.domElement = _canvas;\n\
\n\
\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\n\
\t\t\t\t? parameters.devicePixelRatio\n\
\t\t\t\t: window.devicePixelRatio !== undefined\n\
\t\t\t\t\t? window.devicePixelRatio\n\
\t\t\t\t\t: 1;\n\
\n\
\tthis.autoClear = true;\n\
\tthis.sortObjects = true;\n\
\tthis.sortElements = true;\n\
\n\
\tthis.info = {\n\
\n\
\t\trender: {\n\
\n\
\t\t\tvertices: 0,\n\
\t\t\tfaces: 0\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\t// WebGLRenderer compatibility\n\
\n\
\tthis.supportsVertexTextures = function () {};\n\
\tthis.setFaceCulling = function () {};\n\
\n\
\tthis.setSize = function ( width, height, updateStyle ) {\n\
\n\
\t\t_canvasWidth = width * this.devicePixelRatio;\n\
\t\t_canvasHeight = height * this.devicePixelRatio;\n\
\n\
\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\n\
\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\n\
\n\
\t\t_canvas.width = _canvasWidth;\n\
\t\t_canvas.height = _canvasHeight;\n\
\n\
\t\tif ( this.devicePixelRatio !== 1 && updateStyle !== false ) {\n\
\n\
\t\t\t_canvas.style.width = width + 'px';\n\
\t\t\t_canvas.style.height = height + 'px';\n\
\n\
\t\t}\n\
\n\
\t\t_clipBox.set(\n\
\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\
\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\
\t\t);\n\
\n\
\t\t_clearBox.set(\n\
\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\
\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\
\t\t);\n\
\n\
\t\t_contextGlobalAlpha = 1;\n\
\t\t_contextGlobalCompositeOperation = 0;\n\
\t\t_contextStrokeStyle = null;\n\
\t\t_contextFillStyle = null;\n\
\t\t_contextLineWidth = null;\n\
\t\t_contextLineCap = null;\n\
\t\t_contextLineJoin = null;\n\
\n\
\t};\n\
\n\
\tthis.setClearColor = function ( color, alpha ) {\n\
\n\
\t\t_clearColor.set( color );\n\
\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\
\n\
\t\t_clearBox.set(\n\
\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\
\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\
\t\t);\n\
\n\
\t};\n\
\n\
\tthis.setClearColorHex = function ( hex, alpha ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\n\
\t\tthis.setClearColor( hex, alpha );\n\
\n\
\t};\n\
\n\
\tthis.getMaxAnisotropy = function () {\n\
\n\
\t\treturn 0;\n\
\n\
\t};\n\
\n\
\tthis.clear = function () {\n\
\n\
\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\n\
\n\
\t\tif ( _clearBox.empty() === false ) {\n\
\n\
\t\t\t_clearBox.intersect( _clipBox );\n\
\t\t\t_clearBox.expandByScalar( 2 );\n\
\n\
\t\t\tif ( _clearAlpha < 1 ) {\n\
\n\
\t\t\t\t_context.clearRect(\n\
\t\t\t\t\t_clearBox.min.x | 0,\n\
\t\t\t\t\t_clearBox.min.y | 0,\n\
\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\
\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\n\
\t\t\t\t);\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( _clearAlpha > 0 ) {\n\
\n\
\t\t\t\tsetBlending( THREE.NormalBlending );\n\
\t\t\t\tsetOpacity( 1 );\n\
\n\
\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );\n\
\n\
\t\t\t\t_context.fillRect(\n\
\t\t\t\t\t_clearBox.min.x | 0,\n\
\t\t\t\t\t_clearBox.min.y | 0,\n\
\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\
\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\n\
\t\t\t\t);\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_clearBox.makeEmpty();\n\
\n\
\t\t}\n\
\n\
\n\
\t};\n\
\n\
\tthis.render = function ( scene, camera ) {\n\
\n\
\t\tif ( camera instanceof THREE.Camera === false ) {\n\
\n\
\t\t\tconsole.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );\n\
\t\t\treturn;\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.autoClear === true ) this.clear();\n\
\n\
\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\n\
\n\
\t\t_this.info.render.vertices = 0;\n\
\t\t_this.info.render.faces = 0;\n\
\n\
\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\n\
\t\t_elements = _renderData.elements;\n\
\t\t_lights = _renderData.lights;\n\
\t\t_camera = camera;\n\
\n\
\t\t/* DEBUG\n\
\t\tsetFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\n\
\t\t_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\n\
\t\t*/\n\
\n\
\t\tcalculateLights();\n\
\n\
\t\tfor ( var e = 0, el = _elements.length; e < el; e++ ) {\n\
\n\
\t\t\tvar element = _elements[ e ];\n\
\n\
\t\t\tvar material = element.material;\n\
\n\
\t\t\tif ( material === undefined || material.visible === false ) continue;\n\
\n\
\t\t\t_elemBox.makeEmpty();\n\
\n\
\t\t\tif ( element instanceof THREE.RenderableParticle ) {\n\
\n\
\t\t\t\t_v1 = element;\n\
\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\n\
\n\
\t\t\t\trenderParticle( _v1, element, material );\n\
\n\
\t\t\t} else if ( element instanceof THREE.RenderableLine ) {\n\
\n\
\t\t\t\t_v1 = element.v1; _v2 = element.v2;\n\
\n\
\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\
\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\
\n\
\t\t\t\t_elemBox.setFromPoints( [\n\
\t\t\t\t\t_v1.positionScreen,\n\
\t\t\t\t\t_v2.positionScreen\n\
\t\t\t\t] );\n\
\n\
\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\n\
\n\
\t\t\t\t\trenderLine( _v1, _v2, element, material );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( element instanceof THREE.RenderableFace3 ) {\n\
\n\
\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\n\
\n\
\t\t\t\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\n\
\t\t\t\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\n\
\t\t\t\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\n\
\n\
\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\
\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\
\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\n\
\n\
\t\t\t\tif ( material.overdraw > 0 ) {\n\
\n\
\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen, material.overdraw );\n\
\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen, material.overdraw );\n\
\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen, material.overdraw );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_elemBox.setFromPoints( [\n\
\t\t\t\t\t_v1.positionScreen,\n\
\t\t\t\t\t_v2.positionScreen,\n\
\t\t\t\t\t_v3.positionScreen\n\
\t\t\t\t] );\n\
\n\
\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\n\
\n\
\t\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\t/* DEBUG\n\
\t\t\tsetLineWidth( 1 );\n\
\t\t\tsetStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\n\
\t\t\t_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\n\
\t\t\t*/\n\
\n\
\t\t\t_clearBox.union( _elemBox );\n\
\n\
\t\t}\n\
\n\
\t\t/* DEBUG\n\
\t\tsetLineWidth( 1 );\n\
\t\tsetStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\n\
\t\t_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\n\
\t\t*/\n\
\n\
\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\n\
\n\
\t};\n\
\n\
\t//\n\
\n\
\tfunction calculateLights() {\n\
\n\
\t\t_ambientLight.setRGB( 0, 0, 0 );\n\
\t\t_directionalLights.setRGB( 0, 0, 0 );\n\
\t\t_pointLights.setRGB( 0, 0, 0 );\n\
\n\
\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\
\n\
\t\t\tvar light = _lights[ l ];\n\
\t\t\tvar lightColor = light.color;\n\
\n\
\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\
\n\
\t\t\t\t_ambientLight.add( lightColor );\n\
\n\
\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\
\n\
\t\t\t\t// for particles\n\
\n\
\t\t\t\t_directionalLights.add( lightColor );\n\
\n\
\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\
\n\
\t\t\t\t// for particles\n\
\n\
\t\t\t\t_pointLights.add( lightColor );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction calculateLight( position, normal, color ) {\n\
\n\
\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\
\n\
\t\t\tvar light = _lights[ l ];\n\
\n\
\t\t\t_lightColor.copy( light.color );\n\
\n\
\t\t\tif ( light instanceof THREE.DirectionalLight ) {\n\
\n\
\t\t\t\tvar lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld ).normalize();\n\
\n\
\t\t\t\tvar amount = normal.dot( lightPosition );\n\
\n\
\t\t\t\tif ( amount <= 0 ) continue;\n\
\n\
\t\t\t\tamount *= light.intensity;\n\
\n\
\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\
\n\
\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\
\n\
\t\t\t\tvar lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld );\n\
\n\
\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\n\
\n\
\t\t\t\tif ( amount <= 0 ) continue;\n\
\n\
\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\n\
\n\
\t\t\t\tif ( amount == 0 ) continue;\n\
\n\
\t\t\t\tamount *= light.intensity;\n\
\n\
\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction renderParticle( v1, element, material ) {\n\
\n\
\t\tsetOpacity( material.opacity );\n\
\t\tsetBlending( material.blending );\n\
\n\
\t\tvar width, height, scaleX, scaleY,\n\
\t\tbitmap, bitmapWidth, bitmapHeight;\n\
\n\
\t\tif ( material instanceof THREE.ParticleBasicMaterial ) {\n\
\n\
\t\t\tif ( material.map === null ) {\n\
\n\
\t\t\t\tscaleX = element.object.scale.x;\n\
\t\t\t\tscaleY = element.object.scale.y;\n\
\n\
\t\t\t\t// TODO: Be able to disable this\n\
\n\
\t\t\t\tscaleX *= element.scale.x * _canvasWidthHalf;\n\
\t\t\t\tscaleY *= element.scale.y * _canvasHeightHalf;\n\
\n\
\t\t\t\t_elemBox.min.set( v1.x - scaleX, v1.y - scaleY );\n\
\t\t\t\t_elemBox.max.set( v1.x + scaleX, v1.y + scaleY );\n\
\n\
\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\n\
\n\
\t\t\t\t\t_elemBox.makeEmpty();\n\
\t\t\t\t\treturn;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tsetFillStyle( material.color.getStyle() );\n\
\n\
\t\t\t\t_context.save();\n\
\t\t\t\t_context.translate( v1.x, v1.y );\n\
\t\t\t\t_context.rotate( - element.rotation );\n\
\t\t\t\t_context.scale( scaleX, scaleY );\n\
\t\t\t\t_context.fillRect( -1, -1, 2, 2 );\n\
\t\t\t\t_context.restore();\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tbitmap = material.map.image;\n\
\t\t\t\tbitmapWidth = bitmap.width >> 1;\n\
\t\t\t\tbitmapHeight = bitmap.height >> 1;\n\
\n\
\t\t\t\tscaleX = element.scale.x * _canvasWidthHalf;\n\
\t\t\t\tscaleY = element.scale.y * _canvasHeightHalf;\n\
\n\
\t\t\t\twidth = scaleX * bitmapWidth;\n\
\t\t\t\theight = scaleY * bitmapHeight;\n\
\n\
\t\t\t\t// TODO: Rotations break this...\n\
\n\
\t\t\t\t_elemBox.min.set( v1.x - width, v1.y - height );\n\
\t\t\t\t_elemBox.max.set( v1.x + width, v1.y + height );\n\
\n\
\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\n\
\n\
\t\t\t\t\t_elemBox.makeEmpty();\n\
\t\t\t\t\treturn;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_context.save();\n\
\t\t\t\t_context.translate( v1.x, v1.y );\n\
\t\t\t\t_context.rotate( - element.rotation );\n\
\t\t\t\t_context.scale( scaleX, - scaleY );\n\
\n\
\t\t\t\t_context.translate( - bitmapWidth, - bitmapHeight );\n\
\t\t\t\t_context.drawImage( bitmap, 0, 0 );\n\
\t\t\t\t_context.restore();\n\
\n\
\t\t\t}\n\
\n\
\t\t\t/* DEBUG\n\
\t\t\tsetStrokeStyle( 'rgb(255,255,0)' );\n\
\t\t\t_context.beginPath();\n\
\t\t\t_context.moveTo( v1.x - 10, v1.y );\n\
\t\t\t_context.lineTo( v1.x + 10, v1.y );\n\
\t\t\t_context.moveTo( v1.x, v1.y - 10 );\n\
\t\t\t_context.lineTo( v1.x, v1.y + 10 );\n\
\t\t\t_context.stroke();\n\
\t\t\t*/\n\
\n\
\t\t} else if ( material instanceof THREE.ParticleCanvasMaterial ) {\n\
\n\
\t\t\twidth = element.scale.x * _canvasWidthHalf;\n\
\t\t\theight = element.scale.y * _canvasHeightHalf;\n\
\n\
\t\t\t_elemBox.min.set( v1.x - width, v1.y - height );\n\
\t\t\t_elemBox.max.set( v1.x + width, v1.y + height );\n\
\n\
\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\n\
\n\
\t\t\t\t_elemBox.makeEmpty();\n\
\t\t\t\treturn;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tsetStrokeStyle( material.color.getStyle() );\n\
\t\t\tsetFillStyle( material.color.getStyle() );\n\
\n\
\t\t\t_context.save();\n\
\t\t\t_context.translate( v1.x, v1.y );\n\
\t\t\t_context.rotate( - element.rotation );\n\
\t\t\t_context.scale( width, height );\n\
\n\
\t\t\tmaterial.program( _context );\n\
\n\
\t\t\t_context.restore();\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction renderLine( v1, v2, element, material ) {\n\
\n\
\t\tsetOpacity( material.opacity );\n\
\t\tsetBlending( material.blending );\n\
\n\
\t\t_context.beginPath();\n\
\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\n\
\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\n\
\n\
\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\
\n\
\t\t\tsetLineWidth( material.linewidth );\n\
\t\t\tsetLineCap( material.linecap );\n\
\t\t\tsetLineJoin( material.linejoin );\n\
\n\
\t\t\tif ( material.vertexColors !== THREE.VertexColors ) {\n\
\n\
\t\t\t\tsetStrokeStyle( material.color.getStyle() );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tvar colorStyle1 = element.vertexColors[0].getStyle();\n\
\t\t\t\tvar colorStyle2 = element.vertexColors[1].getStyle();\n\
\n\
\t\t\t\tif ( colorStyle1 === colorStyle2 ) {\n\
\n\
\t\t\t\t\tsetStrokeStyle( colorStyle1 );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\ttry {\n\
\n\
\t\t\t\t\t\tvar grad = _context.createLinearGradient(\n\
\t\t\t\t\t\t\tv1.positionScreen.x,\n\
\t\t\t\t\t\t\tv1.positionScreen.y,\n\
\t\t\t\t\t\t\tv2.positionScreen.x,\n\
\t\t\t\t\t\t\tv2.positionScreen.y\n\
\t\t\t\t\t\t);\n\
\t\t\t\t\t\tgrad.addColorStop( 0, colorStyle1 );\n\
\t\t\t\t\t\tgrad.addColorStop( 1, colorStyle2 );\n\
\n\
\t\t\t\t\t} catch ( exception ) {\n\
\n\
\t\t\t\t\t\tgrad = colorStyle1;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tsetStrokeStyle( grad );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_context.stroke();\n\
\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\
\n\
\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\
\n\
\t\t\tsetLineWidth( material.linewidth );\n\
\t\t\tsetLineCap( material.linecap );\n\
\t\t\tsetLineJoin( material.linejoin );\n\
\t\t\tsetStrokeStyle( material.color.getStyle() );\n\
\t\t\tsetDashAndGap( material.dashSize, material.gapSize );\n\
\n\
\t\t\t_context.stroke();\n\
\n\
\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\
\n\
\t\t\tsetDashAndGap( null, null );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {\n\
\n\
\t\t_this.info.render.vertices += 3;\n\
\t\t_this.info.render.faces ++;\n\
\n\
\t\tsetOpacity( material.opacity );\n\
\t\tsetBlending( material.blending );\n\
\n\
\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\n\
\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\n\
\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\n\
\n\
\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\n\
\n\
\t\tif ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {\n\
\n\
\t\t\t_diffuseColor.copy( material.color );\n\
\t\t\t_emissiveColor.copy( material.emissive );\n\
\n\
\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\
\n\
\t\t\t\t_diffuseColor.multiply( element.color );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 3 ) {\n\
\n\
\t\t\t\t_color1.copy( _ambientLight );\n\
\t\t\t\t_color2.copy( _ambientLight );\n\
\t\t\t\t_color3.copy( _ambientLight );\n\
\n\
\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );\n\
\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );\n\
\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );\n\
\n\
\t\t\t\t_color1.multiply( _diffuseColor ).add( _emissiveColor );\n\
\t\t\t\t_color2.multiply( _diffuseColor ).add( _emissiveColor );\n\
\t\t\t\t_color3.multiply( _diffuseColor ).add( _emissiveColor );\n\
\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\
\n\
\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\
\n\
\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_color.copy( _ambientLight );\n\
\n\
\t\t\t\tcalculateLight( element.centroidModel, element.normalModel, _color );\n\
\n\
\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\n\
\n\
\t\t\t\tmaterial.wireframe === true\n\
\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\
\t\t\t\t\t: fillPath( _color );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\n\
\n\
\t\t\tif ( material.map !== null ) {\n\
\n\
\t\t\t\tif ( material.map.mapping instanceof THREE.UVMapping ) {\n\
\n\
\t\t\t\t\t_uvs = element.uvs[ 0 ];\n\
\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );\n\
\n\
\t\t\t\t}\n\
\n\
\n\
\t\t\t} else if ( material.envMap !== null ) {\n\
\n\
\t\t\t\tif ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {\n\
\n\
\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv1 ] );\n\
\t\t\t\t\t_uv1x = 0.5 * _vector3.x + 0.5;\n\
\t\t\t\t\t_uv1y = 0.5 * _vector3.y + 0.5;\n\
\n\
\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv2 ] );\n\
\t\t\t\t\t_uv2x = 0.5 * _vector3.x + 0.5;\n\
\t\t\t\t\t_uv2y = 0.5 * _vector3.y + 0.5;\n\
\n\
\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv3 ] );\n\
\t\t\t\t\t_uv3x = 0.5 * _vector3.x + 0.5;\n\
\t\t\t\t\t_uv3y = 0.5 * _vector3.y + 0.5;\n\
\n\
\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\n\
\n\
\t\t\t\t}/* else if ( material.envMap.mapping == THREE.SphericalRefractionMapping ) {\n\
\n\
\n\
\n\
\t\t\t\t}*/\n\
\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_color.copy( material.color );\n\
\n\
\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\
\n\
\t\t\t\t\t_color.multiply( element.color );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tmaterial.wireframe === true\n\
\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\
\t\t\t\t\t: fillPath( _color );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\
\n\
\t\t\t_near = _camera.near;\n\
\t\t\t_far = _camera.far;\n\
\n\
\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );\n\
\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );\n\
\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );\n\
\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\
\n\
\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\
\n\
\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\
\n\
\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\
\n\
\t\t\tvar normal;\n\
\n\
\t\t\tif ( material.shading == THREE.FlatShading ) {\n\
\n\
\t\t\t\tnormal = element.normalModelView;\n\
\n\
\t\t\t\t_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\
\n\
\t\t\t\tmaterial.wireframe === true\n\
\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\
\t\t\t\t\t: fillPath( _color );\n\
\n\
\t\t\t} else if ( material.shading == THREE.SmoothShading ) {\n\
\n\
\t\t\t\tnormal = element.vertexNormalsModelView[ uv1 ];\n\
\t\t\t\t_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\
\n\
\t\t\t\tnormal = element.vertexNormalsModelView[ uv2 ];\n\
\t\t\t\t_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\
\n\
\t\t\t\tnormal = element.vertexNormalsModelView[ uv3 ];\n\
\t\t\t\t_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\
\n\
\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\
\n\
\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\
\n\
\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\t//\n\
\n\
\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\n\
\n\
\t\t_context.beginPath();\n\
\t\t_context.moveTo( x0, y0 );\n\
\t\t_context.lineTo( x1, y1 );\n\
\t\t_context.lineTo( x2, y2 );\n\
\t\t_context.closePath();\n\
\n\
\t}\n\
\n\
\tfunction strokePath( color, linewidth, linecap, linejoin ) {\n\
\n\
\t\tsetLineWidth( linewidth );\n\
\t\tsetLineCap( linecap );\n\
\t\tsetLineJoin( linejoin );\n\
\t\tsetStrokeStyle( color.getStyle() );\n\
\n\
\t\t_context.stroke();\n\
\n\
\t\t_elemBox.expandByScalar( linewidth * 2 );\n\
\n\
\t}\n\
\n\
\tfunction fillPath( color ) {\n\
\n\
\t\tsetFillStyle( color.getStyle() );\n\
\t\t_context.fill();\n\
\n\
\t}\n\
\n\
\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\n\
\n\
\t\tif ( texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width == 0 ) return;\n\
\n\
\t\tif ( texture.needsUpdate === true ) {\n\
\n\
\t\t\tvar repeatX = texture.wrapS == THREE.RepeatWrapping;\n\
\t\t\tvar repeatY = texture.wrapT == THREE.RepeatWrapping;\n\
\n\
\t\t\t_patterns[ texture.id ] = _context.createPattern(\n\
\t\t\t\ttexture.image, repeatX === true && repeatY === true\n\
\t\t\t\t\t? 'repeat'\n\
\t\t\t\t\t: repeatX === true && repeatY === false\n\
\t\t\t\t\t\t? 'repeat-x'\n\
\t\t\t\t\t\t: repeatX === false && repeatY === true\n\
\t\t\t\t\t\t\t? 'repeat-y'\n\
\t\t\t\t\t\t\t: 'no-repeat'\n\
\t\t\t);\n\
\n\
\t\t\ttexture.needsUpdate = false;\n\
\n\
\t\t}\n\
\n\
\t\t_patterns[ texture.id ] === undefined\n\
\t\t\t? setFillStyle( 'rgba(0,0,0,1)' )\n\
\t\t\t: setFillStyle( _patterns[ texture.id ] );\n\
\n\
\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\
\n\
\t\tvar a, b, c, d, e, f, det, idet,\n\
\t\toffsetX = texture.offset.x / texture.repeat.x,\n\
\t\toffsetY = texture.offset.y / texture.repeat.y,\n\
\t\twidth = texture.image.width * texture.repeat.x,\n\
\t\theight = texture.image.height * texture.repeat.y;\n\
\n\
\t\tu0 = ( u0 + offsetX ) * width;\n\
\t\tv0 = ( 1.0 - v0 + offsetY ) * height;\n\
\n\
\t\tu1 = ( u1 + offsetX ) * width;\n\
\t\tv1 = ( 1.0 - v1 + offsetY ) * height;\n\
\n\
\t\tu2 = ( u2 + offsetX ) * width;\n\
\t\tv2 = ( 1.0 - v2 + offsetY ) * height;\n\
\n\
\t\tx1 -= x0; y1 -= y0;\n\
\t\tx2 -= x0; y2 -= y0;\n\
\n\
\t\tu1 -= u0; v1 -= v0;\n\
\t\tu2 -= u0; v2 -= v0;\n\
\n\
\t\tdet = u1 * v2 - u2 * v1;\n\
\n\
\t\tif ( det === 0 ) {\n\
\n\
\t\t\tif ( _imagedatas[ texture.id ] === undefined ) {\n\
\n\
\t\t\t\tvar canvas = document.createElement( 'canvas' )\n\
\t\t\t\tcanvas.width = texture.image.width;\n\
\t\t\t\tcanvas.height = texture.image.height;\n\
\n\
\t\t\t\tvar context = canvas.getContext( '2d' );\n\
\t\t\t\tcontext.drawImage( texture.image, 0, 0 );\n\
\n\
\t\t\t\t_imagedatas[ texture.id ] = context.getImageData( 0, 0, texture.image.width, texture.image.height ).data;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar data = _imagedatas[ texture.id ];\n\
\t\t\tvar index = ( Math.floor( u0 ) + Math.floor( v0 ) * texture.image.width ) * 4;\n\
\n\
\t\t\t_color.setRGB( data[ index ] / 255, data[ index + 1 ] / 255, data[ index + 2 ] / 255 );\n\
\t\t\tfillPath( _color );\n\
\n\
\t\t\treturn;\n\
\n\
\t\t}\n\
\n\
\t\tidet = 1 / det;\n\
\n\
\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\
\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\
\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\
\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\
\n\
\t\te = x0 - a * u0 - c * v0;\n\
\t\tf = y0 - b * u0 - d * v0;\n\
\n\
\t\t_context.save();\n\
\t\t_context.transform( a, b, c, d, e, f );\n\
\t\t_context.fill();\n\
\t\t_context.restore();\n\
\n\
\t}\n\
\n\
\tfunction clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {\n\
\n\
\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\
\n\
\t\tvar a, b, c, d, e, f, det, idet,\n\
\t\twidth = image.width - 1,\n\
\t\theight = image.height - 1;\n\
\n\
\t\tu0 *= width; v0 *= height;\n\
\t\tu1 *= width; v1 *= height;\n\
\t\tu2 *= width; v2 *= height;\n\
\n\
\t\tx1 -= x0; y1 -= y0;\n\
\t\tx2 -= x0; y2 -= y0;\n\
\n\
\t\tu1 -= u0; v1 -= v0;\n\
\t\tu2 -= u0; v2 -= v0;\n\
\n\
\t\tdet = u1 * v2 - u2 * v1;\n\
\n\
\t\tidet = 1 / det;\n\
\n\
\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\
\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\
\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\
\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\
\n\
\t\te = x0 - a * u0 - c * v0;\n\
\t\tf = y0 - b * u0 - d * v0;\n\
\n\
\t\t_context.save();\n\
\t\t_context.transform( a, b, c, d, e, f );\n\
\t\t_context.clip();\n\
\t\t_context.drawImage( image, 0, 0 );\n\
\t\t_context.restore();\n\
\n\
\t}\n\
\n\
\tfunction getGradientTexture( color1, color2, color3, color4 ) {\n\
\n\
\t\t// http://mrdoob.com/blog/post/710\n\
\n\
\t\t_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;\n\
\t\t_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;\n\
\t\t_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;\n\
\n\
\t\t_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;\n\
\t\t_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;\n\
\t\t_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;\n\
\n\
\t\t_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;\n\
\t\t_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;\n\
\t\t_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;\n\
\n\
\t\t_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;\n\
\t\t_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;\n\
\t\t_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;\n\
\n\
\t\t_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );\n\
\t\t_gradientMapContext.drawImage( _pixelMap, 0, 0 );\n\
\n\
\t\treturn _gradientMap;\n\
\n\
\t}\n\
\n\
\t// Hide anti-alias gaps\n\
\n\
\tfunction expand( v1, v2, pixels ) {\n\
\n\
\t\tvar x = v2.x - v1.x, y = v2.y - v1.y,\n\
\t\tdet = x * x + y * y, idet;\n\
\n\
\t\tif ( det === 0 ) return;\n\
\n\
\t\tidet = pixels / Math.sqrt( det );\n\
\n\
\t\tx *= idet; y *= idet;\n\
\n\
\t\tv2.x += x; v2.y += y;\n\
\t\tv1.x -= x; v1.y -= y;\n\
\n\
\t}\n\
\n\
\t// Context cached methods.\n\
\n\
\tfunction setOpacity( value ) {\n\
\n\
\t\tif ( _contextGlobalAlpha !== value ) {\n\
\n\
\t\t\t_context.globalAlpha = value;\n\
\t\t\t_contextGlobalAlpha = value;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction setBlending( value ) {\n\
\n\
\t\tif ( _contextGlobalCompositeOperation !== value ) {\n\
\n\
\t\t\tif ( value === THREE.NormalBlending ) {\n\
\n\
\t\t\t\t_context.globalCompositeOperation = 'source-over';\n\
\n\
\t\t\t} else if ( value === THREE.AdditiveBlending ) {\n\
\n\
\t\t\t\t_context.globalCompositeOperation = 'lighter';\n\
\n\
\t\t\t} else if ( value === THREE.SubtractiveBlending ) {\n\
\n\
\t\t\t\t_context.globalCompositeOperation = 'darker';\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_contextGlobalCompositeOperation = value;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction setLineWidth( value ) {\n\
\n\
\t\tif ( _contextLineWidth !== value ) {\n\
\n\
\t\t\t_context.lineWidth = value;\n\
\t\t\t_contextLineWidth = value;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction setLineCap( value ) {\n\
\n\
\t\t// \"butt\", \"round\", \"square\"\n\
\n\
\t\tif ( _contextLineCap !== value ) {\n\
\n\
\t\t\t_context.lineCap = value;\n\
\t\t\t_contextLineCap = value;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction setLineJoin( value ) {\n\
\n\
\t\t// \"round\", \"bevel\", \"miter\"\n\
\n\
\t\tif ( _contextLineJoin !== value ) {\n\
\n\
\t\t\t_context.lineJoin = value;\n\
\t\t\t_contextLineJoin = value;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction setStrokeStyle( value ) {\n\
\n\
\t\tif ( _contextStrokeStyle !== value ) {\n\
\n\
\t\t\t_context.strokeStyle = value;\n\
\t\t\t_contextStrokeStyle = value;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction setFillStyle( value ) {\n\
\n\
\t\tif ( _contextFillStyle !== value ) {\n\
\n\
\t\t\t_context.fillStyle = value;\n\
\t\t\t_contextFillStyle = value;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction setDashAndGap( dashSizeValue, gapSizeValue ) {\n\
\n\
\t\tif ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {\n\
\n\
\t\t\t_context.setLineDash( [ dashSizeValue, gapSizeValue ] );\n\
\t\t\t_contextDashSize = dashSizeValue;\n\
\t\t\t_contextGapSize = gapSizeValue;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author mikael emtinger / http://gomo.se/\n\
 */\n\
\n\
THREE.ShaderChunk = {\n\
\n\
\t// FOG\n\
\n\
\tfog_pars_fragment: [\n\
\n\
\t\t\"#ifdef USE_FOG\",\n\
\n\
\t\t\t\"uniform vec3 fogColor;\",\n\
\n\
\t\t\t\"#ifdef FOG_EXP2\",\n\
\n\
\t\t\t\t\"uniform float fogDensity;\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\t\"uniform float fogNear;\",\n\
\t\t\t\t\"uniform float fogFar;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tfog_fragment: [\n\
\n\
\t\t\"#ifdef USE_FOG\",\n\
\n\
\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\
\n\
\t\t\t\"#ifdef FOG_EXP2\",\n\
\n\
\t\t\t\t\"const float LOG2 = 1.442695;\",\n\
\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\n\
\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\t\"float fogFactor = smoothstep( fogNear, fogFar, depth );\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// ENVIRONMENT MAP\n\
\n\
\tenvmap_pars_fragment: [\n\
\n\
\t\t\"#ifdef USE_ENVMAP\",\n\
\n\
\t\t\t\"uniform float reflectivity;\",\n\
\t\t\t\"uniform samplerCube envMap;\",\n\
\t\t\t\"uniform float flipEnvMap;\",\n\
\t\t\t\"uniform int combine;\",\n\
\n\
\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n\
\n\
\t\t\t\t\"uniform bool useRefract;\",\n\
\t\t\t\t\"uniform float refractionRatio;\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\t\"varying vec3 vReflect;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tenvmap_fragment: [\n\
\n\
\t\t\"#ifdef USE_ENVMAP\",\n\
\n\
\t\t\t\"vec3 reflectVec;\",\n\
\n\
\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n\
\n\
\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n\
\n\
\t\t\t\t\"if ( useRefract ) {\",\n\
\n\
\t\t\t\t\t\"reflectVec = refract( cameraToVertex, normal, refractionRatio );\",\n\
\n\
\t\t\t\t\"} else { \",\n\
\n\
\t\t\t\t\t\"reflectVec = reflect( cameraToVertex, normal );\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\t\"reflectVec = vReflect;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n\
\t\t\t\t\"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\t\"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#ifdef GAMMA_INPUT\",\n\
\n\
\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"if ( combine == 1 ) {\",\n\
\n\
\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\",\n\
\n\
\t\t\t\"} else if ( combine == 2 ) {\",\n\
\n\
\t\t\t\t\"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\",\n\
\n\
\t\t\t\"} else {\",\n\
\n\
\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tenvmap_pars_vertex: [\n\
\n\
\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n\
\n\
\t\t\t\"varying vec3 vReflect;\",\n\
\n\
\t\t\t\"uniform float refractionRatio;\",\n\
\t\t\t\"uniform bool useRefract;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tworldpos_vertex : [\n\
\n\
\t\t\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\",\n\
\n\
\t\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\t\"vec4 worldPosition = modelMatrix * skinned;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n\
\n\
\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n\
\n\
\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tenvmap_vertex : [\n\
\n\
\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n\
\n\
\t\t\t\"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\",\n\
\t\t\t\"worldNormal = normalize( worldNormal );\",\n\
\n\
\t\t\t\"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\",\n\
\n\
\t\t\t\"if ( useRefract ) {\",\n\
\n\
\t\t\t\t\"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\",\n\
\n\
\t\t\t\"} else {\",\n\
\n\
\t\t\t\t\"vReflect = reflect( cameraToVertex, worldNormal );\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// COLOR MAP (particles)\n\
\n\
\tmap_particle_pars_fragment: [\n\
\n\
\t\t\"#ifdef USE_MAP\",\n\
\n\
\t\t\t\"uniform sampler2D map;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\n\
\tmap_particle_fragment: [\n\
\n\
\t\t\"#ifdef USE_MAP\",\n\
\n\
\t\t\t\"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// COLOR MAP (triangles)\n\
\n\
\tmap_pars_vertex: [\n\
\n\
\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\
\n\
\t\t\t\"varying vec2 vUv;\",\n\
\t\t\t\"uniform vec4 offsetRepeat;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tmap_pars_fragment: [\n\
\n\
\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\
\n\
\t\t\t\"varying vec2 vUv;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#ifdef USE_MAP\",\n\
\n\
\t\t\t\"uniform sampler2D map;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tmap_vertex: [\n\
\n\
\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\
\n\
\t\t\t\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tmap_fragment: [\n\
\n\
\t\t\"#ifdef USE_MAP\",\n\
\n\
\t\t\t\"vec4 texelColor = texture2D( map, vUv );\",\n\
\n\
\t\t\t\"#ifdef GAMMA_INPUT\",\n\
\n\
\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// LIGHT MAP\n\
\n\
\tlightmap_pars_fragment: [\n\
\n\
\t\t\"#ifdef USE_LIGHTMAP\",\n\
\n\
\t\t\t\"varying vec2 vUv2;\",\n\
\t\t\t\"uniform sampler2D lightMap;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tlightmap_pars_vertex: [\n\
\n\
\t\t\"#ifdef USE_LIGHTMAP\",\n\
\n\
\t\t\t\"varying vec2 vUv2;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tlightmap_fragment: [\n\
\n\
\t\t\"#ifdef USE_LIGHTMAP\",\n\
\n\
\t\t\t\"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tlightmap_vertex: [\n\
\n\
\t\t\"#ifdef USE_LIGHTMAP\",\n\
\n\
\t\t\t\"vUv2 = uv2;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// BUMP MAP\n\
\n\
\tbumpmap_pars_fragment: [\n\
\n\
\t\t\"#ifdef USE_BUMPMAP\",\n\
\n\
\t\t\t\"uniform sampler2D bumpMap;\",\n\
\t\t\t\"uniform float bumpScale;\",\n\
\n\
\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\
\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\
\n\
\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\
\n\
\t\t\t\"vec2 dHdxy_fwd() {\",\n\
\n\
\t\t\t\t\"vec2 dSTdx = dFdx( vUv );\",\n\
\t\t\t\t\"vec2 dSTdy = dFdy( vUv );\",\n\
\n\
\t\t\t\t\"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\",\n\
\t\t\t\t\"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\",\n\
\t\t\t\t\"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\",\n\
\n\
\t\t\t\t\"return vec2( dBx, dBy );\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\t\"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\",\n\
\n\
\t\t\t\t\"vec3 vSigmaX = dFdx( surf_pos );\",\n\
\t\t\t\t\"vec3 vSigmaY = dFdy( surf_pos );\",\n\
\t\t\t\t\"vec3 vN = surf_norm;\",\t\t// normalized\n\
\n\
\t\t\t\t\"vec3 R1 = cross( vSigmaY, vN );\",\n\
\t\t\t\t\"vec3 R2 = cross( vN, vSigmaX );\",\n\
\n\
\t\t\t\t\"float fDet = dot( vSigmaX, R1 );\",\n\
\n\
\t\t\t\t\"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\",\n\
\t\t\t\t\"return normalize( abs( fDet ) * surf_norm - vGrad );\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// NORMAL MAP\n\
\n\
\tnormalmap_pars_fragment: [\n\
\n\
\t\t\"#ifdef USE_NORMALMAP\",\n\
\n\
\t\t\t\"uniform sampler2D normalMap;\",\n\
\t\t\t\"uniform vec2 normalScale;\",\n\
\n\
\t\t\t// Per-Pixel Tangent Space Normal Mapping\n\
\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\
\n\
\t\t\t\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\",\n\
\n\
\t\t\t\t\"vec3 q0 = dFdx( eye_pos.xyz );\",\n\
\t\t\t\t\"vec3 q1 = dFdy( eye_pos.xyz );\",\n\
\t\t\t\t\"vec2 st0 = dFdx( vUv.st );\",\n\
\t\t\t\t\"vec2 st1 = dFdy( vUv.st );\",\n\
\n\
\t\t\t\t\"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );\",\n\
\t\t\t\t\"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\",\n\
\t\t\t\t\"vec3 N = normalize( surf_norm );\",\n\
\n\
\t\t\t\t\"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\",\n\
\t\t\t\t\"mapN.xy = normalScale * mapN.xy;\",\n\
\t\t\t\t\"mat3 tsn = mat3( S, T, N );\",\n\
\t\t\t\t\"return normalize( tsn * mapN );\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// SPECULAR MAP\n\
\n\
\tspecularmap_pars_fragment: [\n\
\n\
\t\t\"#ifdef USE_SPECULARMAP\",\n\
\n\
\t\t\t\"uniform sampler2D specularMap;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tspecularmap_fragment: [\n\
\n\
\t\t\"float specularStrength;\",\n\
\n\
\t\t\"#ifdef USE_SPECULARMAP\",\n\
\n\
\t\t\t\"vec4 texelSpecular = texture2D( specularMap, vUv );\",\n\
\t\t\t\"specularStrength = texelSpecular.r;\",\n\
\n\
\t\t\"#else\",\n\
\n\
\t\t\t\"specularStrength = 1.0;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// LIGHTS LAMBERT\n\
\n\
\tlights_lambert_pars_vertex: [\n\
\n\
\t\t\"uniform vec3 ambient;\",\n\
\t\t\"uniform vec3 diffuse;\",\n\
\t\t\"uniform vec3 emissive;\",\n\
\n\
\t\t\"uniform vec3 ambientLightColor;\",\n\
\n\
\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\
\n\
\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\
\n\
\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\
\n\
\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\
\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\
\n\
\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\"uniform vec3 wrapRGB;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tlights_lambert_vertex: [\n\
\n\
\t\t\"vLightFront = vec3( 0.0 );\",\n\
\n\
\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\"vLightBack = vec3( 0.0 );\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"transformedNormal = normalize( transformedNormal );\",\n\
\n\
\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\
\n\
\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\
\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\
\n\
\t\t\t\"float dotProduct = dot( transformedNormal, dirVector );\",\n\
\t\t\t\"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\
\n\
\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\
\n\
\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\
\t\t\t\t\"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\",\n\
\n\
\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\t\"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\",\n\
\n\
\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\"}\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\
\n\
\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\
\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\
\n\
\t\t\t\t\"float lDistance = 1.0;\",\n\
\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\
\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\
\n\
\t\t\t\t\"lVector = normalize( lVector );\",\n\
\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\
\n\
\t\t\t\t\"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\
\n\
\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\t\"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\
\n\
\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\t\"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\
\t\t\t\t\t\"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\",\n\
\n\
\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\t\t\"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\",\n\
\n\
\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\t\"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\
\n\
\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\
\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\
\n\
\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\",\n\
\n\
\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\
\n\
\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\
\n\
\t\t\t\t\t\"float lDistance = 1.0;\",\n\
\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\
\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\
\n\
\t\t\t\t\t\"lVector = normalize( lVector );\",\n\
\n\
\t\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\
\t\t\t\t\t\"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\
\n\
\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\t\t\"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\
\n\
\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\t\t\"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\
\n\
\t\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\t\"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\
\t\t\t\t\t\t\"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\",\n\
\n\
\t\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\t\t\t\"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\",\n\
\n\
\t\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\",\n\
\n\
\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\t\t\"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\
\n\
\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\
\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\
\n\
\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\
\n\
\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\
\t\t\t\t\"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\",\n\
\n\
\t\t\t\t\"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\
\n\
\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\t\"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\",\n\
\n\
\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// LIGHTS PHONG\n\
\n\
\tlights_phong_pars_vertex: [\n\
\n\
\t\t\"#ifndef PHONG_PER_PIXEL\",\n\
\n\
\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\
\n\
\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\
\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\
\n\
\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\
\n\
\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\
\n\
\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\
\n\
\t\t\t\"varying vec3 vWorldPosition;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\n\
\tlights_phong_vertex: [\n\
\n\
\t\t\"#ifndef PHONG_PER_PIXEL\",\n\
\n\
\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\
\n\
\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\
\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\
\n\
\t\t\t\t\"float lDistance = 1.0;\",\n\
\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\
\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\
\n\
\t\t\t\t\"vPointLight[ i ] = vec4( lVector, lDistance );\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\
\n\
\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\
\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\
\n\
\t\t\t\t\"float lDistance = 1.0;\",\n\
\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\
\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\
\n\
\t\t\t\t\"vSpotLight[ i ] = vec4( lVector, lDistance );\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\
\n\
\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tlights_phong_pars_fragment: [\n\
\n\
\t\t\"uniform vec3 ambientLightColor;\",\n\
\n\
\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\
\n\
\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\
\n\
\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\
\n\
\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\
\n\
\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\
\n\
\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\
\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\
\n\
\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\
\n\
\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\
\n\
\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\
\n\
\t\t\t\"varying vec3 vWorldPosition;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\"uniform vec3 wrapRGB;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"varying vec3 vViewPosition;\",\n\
\t\t\"varying vec3 vNormal;\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tlights_phong_fragment: [\n\
\n\
\t\t\"vec3 normal = normalize( vNormal );\",\n\
\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\
\n\
\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#ifdef USE_NORMALMAP\",\n\
\n\
\t\t\t\"normal = perturbNormal2Arb( -vViewPosition, normal );\",\n\
\n\
\t\t\"#elif defined( USE_BUMPMAP )\",\n\
\n\
\t\t\t\"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\
\n\
\t\t\t\"vec3 pointDiffuse  = vec3( 0.0 );\",\n\
\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\n\
\n\
\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\
\n\
\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\
\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n\
\n\
\t\t\t\t\t\"float lDistance = 1.0;\",\n\
\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\
\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\
\n\
\t\t\t\t\t\"lVector = normalize( lVector );\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"vec3 lVector = normalize( vPointLight[ i ].xyz );\",\n\
\t\t\t\t\t\"float lDistance = vPointLight[ i ].w;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t// diffuse\n\
\n\
\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\
\n\
\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\"float pointDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\
\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\
\n\
\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"float pointDiffuseWeight = max( dotProduct, 0.0 );\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\",\n\
\n\
\t\t\t\t// specular\n\
\n\
\t\t\t\t\"vec3 pointHalfVector = normalize( lVector + viewPosition );\",\n\
\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\
\t\t\t\t\"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\n\
\n\
\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\
\n\
\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\
\n\
\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\
\n\
\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\",\n\
\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\
\n\
\t\t\t\"vec3 spotDiffuse  = vec3( 0.0 );\",\n\
\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\n\
\n\
\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\
\n\
\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\
\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n\
\n\
\t\t\t\t\t\"float lDistance = 1.0;\",\n\
\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\
\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\
\n\
\t\t\t\t\t\"lVector = normalize( lVector );\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"vec3 lVector = normalize( vSpotLight[ i ].xyz );\",\n\
\t\t\t\t\t\"float lDistance = vSpotLight[ i ].w;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n\
\n\
\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\
\n\
\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\
\n\
\t\t\t\t\t// diffuse\n\
\n\
\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\
\n\
\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\
\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\
\n\
\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n\
\n\
\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\"float spotDiffuseWeight = max( dotProduct, 0.0 );\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\",\n\
\n\
\t\t\t\t\t// specular\n\
\n\
\t\t\t\t\t\"vec3 spotHalfVector = normalize( lVector + viewPosition );\",\n\
\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n\
\t\t\t\t\t\"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\n\
\n\
\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\
\n\
\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\
\n\
\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\
\n\
\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\",\n\
\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\",\n\
\n\
\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\"spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\
\n\
\t\t\t\"vec3 dirDiffuse  = vec3( 0.0 );\",\n\
\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\" ,\n\
\n\
\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\
\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\
\n\
\t\t\t\t// diffuse\n\
\n\
\t\t\t\t\"float dotProduct = dot( normal, dirVector );\",\n\
\n\
\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\"float dirDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\
\t\t\t\t\t\"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\
\n\
\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"float dirDiffuseWeight = max( dotProduct, 0.0 );\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\",\n\
\n\
\t\t\t\t// specular\n\
\n\
\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\
\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\
\t\t\t\t\"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\n\
\n\
\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\
\n\
\t\t\t\t\t/*\n\
\t\t\t\t\t// fresnel term from skin shader\n\
\t\t\t\t\t\"const float F0 = 0.128;\",\n\
\n\
\t\t\t\t\t\"float base = 1.0 - dot( viewPosition, dirHalfVector );\",\n\
\t\t\t\t\t\"float exponential = pow( base, 5.0 );\",\n\
\n\
\t\t\t\t\t\"float fresnel = exponential + F0 * ( 1.0 - exponential );\",\n\
\t\t\t\t\t*/\n\
\n\
\t\t\t\t\t/*\n\
\t\t\t\t\t// fresnel term from fresnel shader\n\
\t\t\t\t\t\"const float mFresnelBias = 0.08;\",\n\
\t\t\t\t\t\"const float mFresnelScale = 0.3;\",\n\
\t\t\t\t\t\"const float mFresnelPower = 5.0;\",\n\
\n\
\t\t\t\t\t\"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\",\n\
\t\t\t\t\t*/\n\
\n\
\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\
\n\
\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\
\n\
\t\t\t\t\t//\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\",\n\
\n\
\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n\
\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\
\n\
\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\
\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\n\
\n\
\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\
\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\
\n\
\t\t\t\t// diffuse\n\
\n\
\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\
\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\
\n\
\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\
\n\
\t\t\t\t\"hemiDiffuse += diffuse * hemiColor;\",\n\
\n\
\t\t\t\t// specular (sky light)\n\
\n\
\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\
\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\
\t\t\t\t\"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\n\
\n\
\t\t\t\t// specular (ground light)\n\
\n\
\t\t\t\t\"vec3 lVectorGround = -lVector;\",\n\
\n\
\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\
\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\
\t\t\t\t\"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\n\
\n\
\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\
\n\
\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\n\
\n\
\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\
\n\
\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\
\n\
\t\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n\
\t\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n\
\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\n\
\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\n\
\n\
\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\
\n\
\t\t\t\"totalDiffuse += dirDiffuse;\",\n\
\t\t\t\"totalSpecular += dirSpecular;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\
\n\
\t\t\t\"totalDiffuse += hemiDiffuse;\",\n\
\t\t\t\"totalSpecular += hemiSpecular;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\
\n\
\t\t\t\"totalDiffuse += pointDiffuse;\",\n\
\t\t\t\"totalSpecular += pointSpecular;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\
\n\
\t\t\t\"totalDiffuse += spotDiffuse;\",\n\
\t\t\t\"totalSpecular += spotSpecular;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#ifdef METAL\",\n\
\n\
\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\n\
\n\
\t\t\"#else\",\n\
\n\
\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// VERTEX COLORS\n\
\n\
\tcolor_pars_fragment: [\n\
\n\
\t\t\"#ifdef USE_COLOR\",\n\
\n\
\t\t\t\"varying vec3 vColor;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\n\
\tcolor_fragment: [\n\
\n\
\t\t\"#ifdef USE_COLOR\",\n\
\n\
\t\t\t\"gl_FragColor = gl_FragColor * vec4( vColor, opacity );\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tcolor_pars_vertex: [\n\
\n\
\t\t\"#ifdef USE_COLOR\",\n\
\n\
\t\t\t\"varying vec3 vColor;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\n\
\tcolor_vertex: [\n\
\n\
\t\t\"#ifdef USE_COLOR\",\n\
\n\
\t\t\t\"#ifdef GAMMA_INPUT\",\n\
\n\
\t\t\t\t\"vColor = color * color;\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\t\"vColor = color;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// SKINNING\n\
\n\
\tskinning_pars_vertex: [\n\
\n\
\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\"#ifdef BONE_TEXTURE\",\n\
\n\
\t\t\t\t\"uniform sampler2D boneTexture;\",\n\
\n\
\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\n\
\n\
\t\t\t\t\t\"float j = i * 4.0;\",\n\
\t\t\t\t\t\"float x = mod( j, N_BONE_PIXEL_X );\",\n\
\t\t\t\t\t\"float y = floor( j / N_BONE_PIXEL_X );\",\n\
\n\
\t\t\t\t\t\"const float dx = 1.0 / N_BONE_PIXEL_X;\",\n\
\t\t\t\t\t\"const float dy = 1.0 / N_BONE_PIXEL_Y;\",\n\
\n\
\t\t\t\t\t\"y = dy * ( y + 0.5 );\",\n\
\n\
\t\t\t\t\t\"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\",\n\
\t\t\t\t\t\"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\",\n\
\t\t\t\t\t\"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\",\n\
\t\t\t\t\t\"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\",\n\
\n\
\t\t\t\t\t\"mat4 bone = mat4( v1, v2, v3, v4 );\",\n\
\n\
\t\t\t\t\t\"return bone;\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\t\"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\",\n\
\n\
\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\n\
\n\
\t\t\t\t\t\"mat4 bone = boneGlobalMatrices[ int(i) ];\",\n\
\t\t\t\t\t\"return bone;\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tskinbase_vertex: [\n\
\n\
\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\"mat4 boneMatX = getBoneMatrix( skinIndex.x );\",\n\
\t\t\t\"mat4 boneMatY = getBoneMatrix( skinIndex.y );\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tskinning_vertex: [\n\
\n\
\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\"#ifdef USE_MORPHTARGETS\",\n\
\n\
\t\t\t\"vec4 skinVertex = vec4( morphed, 1.0 );\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\
\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// MORPHING\n\
\n\
\tmorphtarget_pars_vertex: [\n\
\n\
\t\t\"#ifdef USE_MORPHTARGETS\",\n\
\n\
\t\t\t\"#ifndef USE_MORPHNORMALS\",\n\
\n\
\t\t\t\"uniform float morphTargetInfluences[ 8 ];\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\"uniform float morphTargetInfluences[ 4 ];\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tmorphtarget_vertex: [\n\
\n\
\t\t\"#ifdef USE_MORPHTARGETS\",\n\
\n\
\t\t\t\"vec3 morphed = vec3( 0.0 );\",\n\
\t\t\t\"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\",\n\
\t\t\t\"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\",\n\
\t\t\t\"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\",\n\
\t\t\t\"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\",\n\
\n\
\t\t\t\"#ifndef USE_MORPHNORMALS\",\n\
\n\
\t\t\t\"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\",\n\
\t\t\t\"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\",\n\
\t\t\t\"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\",\n\
\t\t\t\"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"morphed += position;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tdefault_vertex : [\n\
\n\
\t\t\"vec4 mvPosition;\",\n\
\n\
\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\"mvPosition = modelViewMatrix * skinned;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\",\n\
\n\
\t\t\t\"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\",\n\
\n\
\t\t\t\"mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"gl_Position = projectionMatrix * mvPosition;\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tmorphnormal_vertex: [\n\
\n\
\t\t\"#ifdef USE_MORPHNORMALS\",\n\
\n\
\t\t\t\"vec3 morphedNormal = vec3( 0.0 );\",\n\
\n\
\t\t\t\"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\",\n\
\t\t\t\"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\",\n\
\t\t\t\"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\",\n\
\t\t\t\"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\",\n\
\n\
\t\t\t\"morphedNormal += normal;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tskinnormal_vertex: [\n\
\n\
\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\"mat4 skinMatrix = skinWeight.x * boneMatX;\",\n\
\t\t\t\"skinMatrix \t+= skinWeight.y * boneMatY;\",\n\
\n\
\t\t\t\"#ifdef USE_MORPHNORMALS\",\n\
\n\
\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\",\n\
\n\
\t\t\t\"#else\",\n\
\n\
\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tdefaultnormal_vertex: [\n\
\n\
\t\t\"vec3 objectNormal;\",\n\
\n\
\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\"objectNormal = skinnedNormal.xyz;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\",\n\
\n\
\t\t\t\"objectNormal = morphedNormal;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\",\n\
\n\
\t\t\t\"objectNormal = normal;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"#ifdef FLIP_SIDED\",\n\
\n\
\t\t\t\"objectNormal = -objectNormal;\",\n\
\n\
\t\t\"#endif\",\n\
\n\
\t\t\"vec3 transformedNormal = normalMatrix * objectNormal;\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// SHADOW MAP\n\
\n\
\t// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples\n\
\t//  http://spidergl.org/example.php?id=6\n\
\t// \thttp://fabiensanglard.net/shadowmapping\n\
\n\
\tshadowmap_pars_fragment: [\n\
\n\
\t\t\"#ifdef USE_SHADOWMAP\",\n\
\n\
\t\t\t\"uniform sampler2D shadowMap[ MAX_SHADOWS ];\",\n\
\t\t\t\"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\",\n\
\n\
\t\t\t\"uniform float shadowDarkness[ MAX_SHADOWS ];\",\n\
\t\t\t\"uniform float shadowBias[ MAX_SHADOWS ];\",\n\
\n\
\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n\
\n\
\t\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\n\
\n\
\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n\
\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\n\
\t\t\t\t\"return depth;\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tshadowmap_fragment: [\n\
\n\
\t\t\"#ifdef USE_SHADOWMAP\",\n\
\n\
\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\n\
\n\
\t\t\t\t\"vec3 frustumColors[3];\",\n\
\t\t\t\t\"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\",\n\
\t\t\t\t\"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\",\n\
\t\t\t\t\"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\
\n\
\t\t\t\t\"int inFrustumCount = 0;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"float fDepth;\",\n\
\t\t\t\"vec3 shadowColor = vec3( 1.0 );\",\n\
\n\
\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\
\n\
\t\t\t\t\"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\",\n\
\n\
\t\t\t\t// \"if ( something && something )\" \t\t breaks ATI OpenGL shader compiler\n\
\t\t\t\t// \"if ( all( something, something ) )\"  using this instead\n\
\n\
\t\t\t\t\"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\",\n\
\t\t\t\t\"bool inFrustum = all( inFrustumVec );\",\n\
\n\
\t\t\t\t// don't shadow pixels outside of light frustum\n\
\t\t\t\t// use just first frustum (for cascades)\n\
\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\
\n\
\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\
\n\
\t\t\t\t\t\"inFrustumCount += int( inFrustum );\",\n\
\t\t\t\t\t\"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"bool frustumTest = all( frustumTestVec );\",\n\
\n\
\t\t\t\t\"if ( frustumTest ) {\",\n\
\n\
\t\t\t\t\t\"shadowCoord.z += shadowBias[ i ];\",\n\
\n\
\t\t\t\t\t\"#if defined( SHADOWMAP_TYPE_PCF )\",\n\
\n\
\t\t\t\t\t\t// Percentage-close filtering\n\
\t\t\t\t\t\t// (9 pixel kernel)\n\
\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\
\n\
\t\t\t\t\t\t\"float shadow = 0.0;\",\n\
\n\
\t\t\t\t\t\t/*\n\
\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\
\t\t\t\t\t\t// must enroll loop manually\n\
\n\
\t\t\t\t\t\t\"for ( float y = -1.25; y <= 1.25; y += 1.25 )\",\n\
\t\t\t\t\t\t\t\"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\",\n\
\n\
\t\t\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\",\n\
\n\
\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple \"texture2D\" lookup\n\
\t\t\t\t\t\t\t\t//\"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\",\n\
\n\
\t\t\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\
\n\
\t\t\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\
\t\t\t\t\t\t\t\t\t\"shadow += 1.0;\",\n\
\n\
\t\t\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\t\t\"shadow /= 9.0;\",\n\
\n\
\t\t\t\t\t\t*/\n\
\n\
\t\t\t\t\t\t\"const float shadowDelta = 1.0 / 9.0;\",\n\
\n\
\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n\
\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n\
\n\
\t\t\t\t\t\t\"float dx0 = -1.25 * xPixelOffset;\",\n\
\t\t\t\t\t\t\"float dy0 = -1.25 * yPixelOffset;\",\n\
\t\t\t\t\t\t\"float dx1 = 1.25 * xPixelOffset;\",\n\
\t\t\t\t\t\t\"float dy1 = 1.25 * yPixelOffset;\",\n\
\n\
\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n\
\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\
\n\
\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n\
\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\
\n\
\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n\
\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\
\n\
\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n\
\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\
\n\
\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n\
\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\
\n\
\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n\
\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\
\n\
\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n\
\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\
\n\
\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n\
\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\
\n\
\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n\
\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\
\n\
\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n\
\n\
\t\t\t\t\t\"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\",\n\
\n\
\t\t\t\t\t\t// Percentage-close filtering\n\
\t\t\t\t\t\t// (9 pixel kernel)\n\
\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\
\n\
\t\t\t\t\t\t\"float shadow = 0.0;\",\n\
\n\
\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n\
\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n\
\n\
\t\t\t\t\t\t\"float dx0 = -1.0 * xPixelOffset;\",\n\
\t\t\t\t\t\t\"float dy0 = -1.0 * yPixelOffset;\",\n\
\t\t\t\t\t\t\"float dx1 = 1.0 * xPixelOffset;\",\n\
\t\t\t\t\t\t\"float dy1 = 1.0 * yPixelOffset;\",\n\
\n\
\t\t\t\t\t\t\"mat3 shadowKernel;\",\n\
\t\t\t\t\t\t\"mat3 depthKernel;\",\n\
\n\
\t\t\t\t\t\t\"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n\
\t\t\t\t\t\t\"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n\
\t\t\t\t\t\t\"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n\
\t\t\t\t\t\t\"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n\
\t\t\t\t\t\t\"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n\
\t\t\t\t\t\t\"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n\
\t\t\t\t\t\t\"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n\
\t\t\t\t\t\t\"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n\
\t\t\t\t\t\t\"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n\
\n\
\t\t\t\t\t\t\"vec3 shadowZ = vec3( shadowCoord.z );\",\n\
\t\t\t\t\t\t\"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\",\n\
\t\t\t\t\t\t\"shadowKernel[0] *= vec3(0.25);\",\n\
\t\t\t\t\t\t\t\t\t\t\t\t\t\n\
\t\t\t\t\t\t\"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\",\n\
\t\t\t\t\t\t\"shadowKernel[1] *= vec3(0.25);\",\n\
\n\
\t\t\t\t\t\t\"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\",\n\
\t\t\t\t\t\t\"shadowKernel[2] *= vec3(0.25);\",\n\
\n\
\t\t\t\t\t\t\"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\",\n\
\n\
\t\t\t\t\t\t\"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\",\n\
\t\t\t\t\t\t\"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\",\n\
\n\
\t\t\t\t\t\t\"vec4 shadowValues;\",\n\
\t\t\t\t\t\t\"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\",\n\
\t\t\t\t\t\t\"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\",\n\
\t\t\t\t\t\t\"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\",\n\
\t\t\t\t\t\t\"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\",\n\
\n\
\t\t\t\t\t\t\"shadow = dot( shadowValues, vec4( 1.0 ) );\",\n\
\n\
\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n\
\n\
\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\",\n\
\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\
\n\
\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\
\n\
\t\t\t\t\t\t\t// spot with multiple shadows is darker\n\
\n\
\t\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\",\n\
\n\
\t\t\t\t\t\t\t// spot with multiple shadows has the same color as single shadow spot\n\
\n\
\t\t\t\t\t\t\t//\"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\n\
\t\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\n\
\n\
\t\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\
\n\
\t\t\t\t\t\t\"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\",\n\
\n\
\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\t\"#ifdef GAMMA_OUTPUT\",\n\
\n\
\t\t\t\t\"shadowColor *= shadowColor;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tshadowmap_pars_vertex: [\n\
\n\
\t\t\"#ifdef USE_SHADOWMAP\",\n\
\n\
\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n\
\t\t\t\"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\tshadowmap_vertex: [\n\
\n\
\t\t\"#ifdef USE_SHADOWMAP\",\n\
\n\
\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\
\n\
\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// ALPHATEST\n\
\n\
\talphatest_fragment: [\n\
\n\
\t\t\"#ifdef ALPHATEST\",\n\
\n\
\t\t\t\"if ( gl_FragColor.a < ALPHATEST ) discard;\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\"),\n\
\n\
\t// LINEAR SPACE\n\
\n\
\tlinear_to_gamma_fragment: [\n\
\n\
\t\t\"#ifdef GAMMA_OUTPUT\",\n\
\n\
\t\t\t\"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\",\n\
\n\
\t\t\"#endif\"\n\
\n\
\t].join(\"\\n\
\")\n\
\n\
\n\
};\n\
\n\
THREE.UniformsUtils = {\n\
\n\
\tmerge: function ( uniforms ) {\n\
\n\
\t\tvar u, p, tmp, merged = {};\n\
\n\
\t\tfor ( u = 0; u < uniforms.length; u ++ ) {\n\
\n\
\t\t\ttmp = this.clone( uniforms[ u ] );\n\
\n\
\t\t\tfor ( p in tmp ) {\n\
\n\
\t\t\t\tmerged[ p ] = tmp[ p ];\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn merged;\n\
\n\
\t},\n\
\n\
\tclone: function ( uniforms_src ) {\n\
\n\
\t\tvar u, p, parameter, parameter_src, uniforms_dst = {};\n\
\n\
\t\tfor ( u in uniforms_src ) {\n\
\n\
\t\t\tuniforms_dst[ u ] = {};\n\
\n\
\t\t\tfor ( p in uniforms_src[ u ] ) {\n\
\n\
\t\t\t\tparameter_src = uniforms_src[ u ][ p ];\n\
\n\
\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\
\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\
\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\
\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\
\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\
\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\
\n\
\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\
\n\
\t\t\t\t} else if ( parameter_src instanceof Array ) {\n\
\n\
\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn uniforms_dst;\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.UniformsLib = {\n\
\n\
\tcommon: {\n\
\n\
\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\n\
\t\t\"opacity\" : { type: \"f\", value: 1.0 },\n\
\n\
\t\t\"map\" : { type: \"t\", value: null },\n\
\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\
\n\
\t\t\"lightMap\" : { type: \"t\", value: null },\n\
\t\t\"specularMap\" : { type: \"t\", value: null },\n\
\n\
\t\t\"envMap\" : { type: \"t\", value: null },\n\
\t\t\"flipEnvMap\" : { type: \"f\", value: -1 },\n\
\t\t\"useRefract\" : { type: \"i\", value: 0 },\n\
\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\n\
\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\n\
\t\t\"combine\" : { type: \"i\", value: 0 },\n\
\n\
\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\n\
\n\
\t},\n\
\n\
\tbump: {\n\
\n\
\t\t\"bumpMap\" : { type: \"t\", value: null },\n\
\t\t\"bumpScale\" : { type: \"f\", value: 1 }\n\
\n\
\t},\n\
\n\
\tnormalmap: {\n\
\n\
\t\t\"normalMap\" : { type: \"t\", value: null },\n\
\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\n\
\t},\n\
\n\
\tfog : {\n\
\n\
\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\n\
\t\t\"fogNear\" : { type: \"f\", value: 1 },\n\
\t\t\"fogFar\" : { type: \"f\", value: 2000 },\n\
\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\
\n\
\t},\n\
\n\
\tlights: {\n\
\n\
\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\n\
\n\
\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\n\
\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\n\
\n\
\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\n\
\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\n\
\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\n\
\n\
\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\n\
\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\n\
\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\n\
\n\
\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\n\
\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\n\
\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\n\
\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\n\
\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\n\
\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] }\n\
\n\
\t},\n\
\n\
\tparticle: {\n\
\n\
\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\n\
\t\t\"opacity\" : { type: \"f\", value: 1.0 },\n\
\t\t\"size\" : { type: \"f\", value: 1.0 },\n\
\t\t\"scale\" : { type: \"f\", value: 1.0 },\n\
\t\t\"map\" : { type: \"t\", value: null },\n\
\n\
\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\n\
\t\t\"fogNear\" : { type: \"f\", value: 1 },\n\
\t\t\"fogFar\" : { type: \"f\", value: 2000 },\n\
\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\
\n\
\t},\n\
\n\
\tshadowmap: {\n\
\n\
\t\t\"shadowMap\": { type: \"tv\", value: [] },\n\
\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\n\
\n\
\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\n\
\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\n\
\n\
\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.ShaderLib = {\n\
\n\
\t'basic': {\n\
\n\
\t\tuniforms: THREE.UniformsUtils.merge( [\n\
\n\
\t\t\tTHREE.UniformsLib[ \"common\" ],\n\
\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\
\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\n\
\n\
\t\t] ),\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\
\n\
\t\t\t\t\"#ifdef USE_ENVMAP\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\"),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform vec3 diffuse;\",\n\
\t\t\t\"uniform float opacity;\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\")\n\
\n\
\t},\n\
\n\
\t'lambert': {\n\
\n\
\t\tuniforms: THREE.UniformsUtils.merge( [\n\
\n\
\t\t\tTHREE.UniformsLib[ \"common\" ],\n\
\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\
\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\
\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\
\n\
\t\t\t{\n\
\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\
\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n\
\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\
\t\t\t}\n\
\n\
\t\t] ),\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"#define LAMBERT\",\n\
\n\
\t\t\t\"varying vec3 vLightFront;\",\n\
\n\
\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\"varying vec3 vLightBack;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\"),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform float opacity;\",\n\
\n\
\t\t\t\"varying vec3 vLightFront;\",\n\
\n\
\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\"varying vec3 vLightBack;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\
\n\
\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\
\n\
\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\n\
\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\n\
\n\
\t\t\t\t\t\"if ( gl_FrontFacing )\",\n\
\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\n\
\t\t\t\t\t\"else\",\n\
\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightBack;\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\")\n\
\n\
\t},\n\
\n\
\t'phong': {\n\
\n\
\t\tuniforms: THREE.UniformsUtils.merge( [\n\
\n\
\t\t\tTHREE.UniformsLib[ \"common\" ],\n\
\t\t\tTHREE.UniformsLib[ \"bump\" ],\n\
\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\n\
\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\
\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\
\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\
\n\
\t\t\t{\n\
\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\
\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n\
\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\n\
\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\n\
\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\
\t\t\t}\n\
\n\
\t\t] ),\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"#define PHONG\",\n\
\n\
\t\t\t\"varying vec3 vViewPosition;\",\n\
\t\t\t\"varying vec3 vNormal;\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\
\n\
\t\t\t\t\"vNormal = normalize( transformedNormal );\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\
\n\
\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\"),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform vec3 diffuse;\",\n\
\t\t\t\"uniform float opacity;\",\n\
\n\
\t\t\t\"uniform vec3 ambient;\",\n\
\t\t\t\"uniform vec3 emissive;\",\n\
\t\t\t\"uniform vec3 specular;\",\n\
\t\t\t\"uniform float shininess;\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\")\n\
\n\
\t},\n\
\n\
\t'particle_basic': {\n\
\n\
\t\tuniforms:  THREE.UniformsUtils.merge( [\n\
\n\
\t\t\tTHREE.UniformsLib[ \"particle\" ],\n\
\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\n\
\n\
\t\t] ),\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"uniform float size;\",\n\
\t\t\t\"uniform float scale;\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\
\n\
\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\
\n\
\t\t\t\t\"#ifdef USE_SIZEATTENUATION\",\n\
\t\t\t\t\t\"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\n\
\t\t\t\t\"#else\",\n\
\t\t\t\t\t\"gl_PointSize = size;\",\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\"),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform vec3 psColor;\",\n\
\t\t\t\"uniform float opacity;\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"gl_FragColor = vec4( psColor, opacity );\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\")\n\
\n\
\t},\n\
\n\
\t'dashed': {\n\
\n\
\t\tuniforms: THREE.UniformsUtils.merge( [\n\
\n\
\t\t\tTHREE.UniformsLib[ \"common\" ],\n\
\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\
\n\
\t\t\t{\n\
\t\t\t\t\"scale\":     { type: \"f\", value: 1 },\n\
\t\t\t\t\"dashSize\":  { type: \"f\", value: 1 },\n\
\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\n\
\t\t\t}\n\
\n\
\t\t] ),\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"uniform float scale;\",\n\
\t\t\t\"attribute float lineDistance;\",\n\
\n\
\t\t\t\"varying float vLineDistance;\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\
\n\
\t\t\t\t\"vLineDistance = scale * lineDistance;\",\n\
\n\
\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\
\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\"),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform vec3 diffuse;\",\n\
\t\t\t\"uniform float opacity;\",\n\
\n\
\t\t\t\"uniform float dashSize;\",\n\
\t\t\t\"uniform float totalSize;\",\n\
\n\
\t\t\t\"varying float vLineDistance;\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\n\
\n\
\t\t\t\t\t\"discard;\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\")\n\
\n\
\t},\n\
\n\
\t'depth': {\n\
\n\
\t\tuniforms: {\n\
\n\
\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\n\
\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\n\
\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\n\
\n\
\t\t},\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\"),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform float mNear;\",\n\
\t\t\t\"uniform float mFar;\",\n\
\t\t\t\"uniform float opacity;\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\
\t\t\t\t\"float color = 1.0 - smoothstep( mNear, mFar, depth );\",\n\
\t\t\t\t\"gl_FragColor = vec4( vec3( color ), opacity );\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\")\n\
\n\
\t},\n\
\n\
\t'normal': {\n\
\n\
\t\tuniforms: {\n\
\n\
\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\n\
\n\
\t\t},\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"varying vec3 vNormal;\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\"),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform float opacity;\",\n\
\t\t\t\"varying vec3 vNormal;\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\")\n\
\n\
\t},\n\
\n\
\t/* -------------------------------------------------------------------------\n\
\t//\tNormal map shader\n\
\t//\t\t- Blinn-Phong\n\
\t//\t\t- normal + diffuse + specular + AO + displacement + reflection + shadow maps\n\
\t//\t\t- point and directional lights (use with \"lights: true\" material option)\n\
\t ------------------------------------------------------------------------- */\n\
\n\
\t'normalmap' : {\n\
\n\
\t\tuniforms: THREE.UniformsUtils.merge( [\n\
\n\
\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\
\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\
\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\
\n\
\t\t\t{\n\
\n\
\t\t\t\"enableAO\"\t\t  : { type: \"i\", value: 0 },\n\
\t\t\t\"enableDiffuse\"\t  : { type: \"i\", value: 0 },\n\
\t\t\t\"enableSpecular\"  : { type: \"i\", value: 0 },\n\
\t\t\t\"enableReflection\": { type: \"i\", value: 0 },\n\
\t\t\t\"enableDisplacement\": { type: \"i\", value: 0 },\n\
\n\
\t\t\t\"tDisplacement\": { type: \"t\", value: null }, // must go first as this is vertex texture\n\
\t\t\t\"tDiffuse\"\t   : { type: \"t\", value: null },\n\
\t\t\t\"tCube\"\t\t   : { type: \"t\", value: null },\n\
\t\t\t\"tNormal\"\t   : { type: \"t\", value: null },\n\
\t\t\t\"tSpecular\"\t   : { type: \"t\", value: null },\n\
\t\t\t\"tAO\"\t\t   : { type: \"t\", value: null },\n\
\n\
\t\t\t\"uNormalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\
\n\
\t\t\t\"uDisplacementBias\": { type: \"f\", value: 0.0 },\n\
\t\t\t\"uDisplacementScale\": { type: \"f\", value: 1.0 },\n\
\n\
\t\t\t\"uDiffuseColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\
\t\t\t\"uSpecularColor\": { type: \"c\", value: new THREE.Color( 0x111111 ) },\n\
\t\t\t\"uAmbientColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\
\t\t\t\"uShininess\": { type: \"f\", value: 30 },\n\
\t\t\t\"uOpacity\": { type: \"f\", value: 1 },\n\
\n\
\t\t\t\"useRefract\": { type: \"i\", value: 0 },\n\
\t\t\t\"uRefractionRatio\": { type: \"f\", value: 0.98 },\n\
\t\t\t\"uReflectivity\": { type: \"f\", value: 0.5 },\n\
\n\
\t\t\t\"uOffset\" : { type: \"v2\", value: new THREE.Vector2( 0, 0 ) },\n\
\t\t\t\"uRepeat\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\
\n\
\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\
\n\
\t\t\t}\n\
\n\
\t\t] ),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform vec3 uAmbientColor;\",\n\
\t\t\t\"uniform vec3 uDiffuseColor;\",\n\
\t\t\t\"uniform vec3 uSpecularColor;\",\n\
\t\t\t\"uniform float uShininess;\",\n\
\t\t\t\"uniform float uOpacity;\",\n\
\n\
\t\t\t\"uniform bool enableDiffuse;\",\n\
\t\t\t\"uniform bool enableSpecular;\",\n\
\t\t\t\"uniform bool enableAO;\",\n\
\t\t\t\"uniform bool enableReflection;\",\n\
\n\
\t\t\t\"uniform sampler2D tDiffuse;\",\n\
\t\t\t\"uniform sampler2D tNormal;\",\n\
\t\t\t\"uniform sampler2D tSpecular;\",\n\
\t\t\t\"uniform sampler2D tAO;\",\n\
\n\
\t\t\t\"uniform samplerCube tCube;\",\n\
\n\
\t\t\t\"uniform vec2 uNormalScale;\",\n\
\n\
\t\t\t\"uniform bool useRefract;\",\n\
\t\t\t\"uniform float uRefractionRatio;\",\n\
\t\t\t\"uniform float uReflectivity;\",\n\
\n\
\t\t\t\"varying vec3 vTangent;\",\n\
\t\t\t\"varying vec3 vBinormal;\",\n\
\t\t\t\"varying vec3 vNormal;\",\n\
\t\t\t\"varying vec2 vUv;\",\n\
\n\
\t\t\t\"uniform vec3 ambientLightColor;\",\n\
\n\
\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\
\n\
\t\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\
\t\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\
\n\
\t\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\
\t\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\
\t\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\
\n\
\t\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\
\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\
\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\
\n\
\t\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\
\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\"uniform vec3 wrapRGB;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"varying vec3 vWorldPosition;\",\n\
\t\t\t\"varying vec3 vViewPosition;\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"gl_FragColor = vec4( vec3( 1.0 ), uOpacity );\",\n\
\n\
\t\t\t\t\"vec3 specularTex = vec3( 1.0 );\",\n\
\n\
\t\t\t\t\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\n\
\t\t\t\t\"normalTex.xy *= uNormalScale;\",\n\
\t\t\t\t\"normalTex = normalize( normalTex );\",\n\
\n\
\t\t\t\t\"if( enableDiffuse ) {\",\n\
\n\
\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\
\n\
\t\t\t\t\t\t\"vec4 texelColor = texture2D( tDiffuse, vUv );\",\n\
\t\t\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\n\
\n\
\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\n\
\n\
\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"if( enableAO ) {\",\n\
\n\
\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\
\n\
\t\t\t\t\t\t\"vec4 aoColor = texture2D( tAO, vUv );\",\n\
\t\t\t\t\t\t\"aoColor.xyz *= aoColor.xyz;\",\n\
\n\
\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\",\n\
\n\
\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"if( enableSpecular )\",\n\
\t\t\t\t\t\"specularTex = texture2D( tSpecular, vUv ).xyz;\",\n\
\n\
\t\t\t\t\"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\",\n\
\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\n\
\n\
\t\t\t\t\"#ifdef FLIP_SIDED\",\n\
\n\
\t\t\t\t\t\"finalNormal = -finalNormal;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"vec3 normal = normalize( finalNormal );\",\n\
\t\t\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\
\n\
\t\t\t\t// point lights\n\
\n\
\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\
\n\
\t\t\t\t\t\"vec3 pointDiffuse = vec3( 0.0 );\",\n\
\t\t\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\n\
\n\
\t\t\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\
\t\t\t\t\t\t\"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\",\n\
\n\
\t\t\t\t\t\t\"float pointDistance = 1.0;\",\n\
\t\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\
\t\t\t\t\t\t\t\"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\
\n\
\t\t\t\t\t\t\"pointVector = normalize( pointVector );\",\n\
\n\
\t\t\t\t\t\t// diffuse\n\
\n\
\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\t\t\"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\",\n\
\t\t\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\",\n\
\n\
\t\t\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n\
\n\
\t\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\n\
\n\
\t\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\t\"pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;\",\n\
\n\
\t\t\t\t\t\t// specular\n\
\n\
\t\t\t\t\t\t\"vec3 pointHalfVector = normalize( pointVector + viewPosition );\",\n\
\t\t\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\
\t\t\t\t\t\t\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );\",\n\
\n\
\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\
\n\
\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\
\n\
\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\
\n\
\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\",\n\
\t\t\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\",\n\
\n\
\t\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\t\"pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;\",\n\
\n\
\t\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t// spot lights\n\
\n\
\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\
\n\
\t\t\t\t\t\"vec3 spotDiffuse = vec3( 0.0 );\",\n\
\t\t\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\n\
\n\
\t\t\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\
\t\t\t\t\t\t\"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\",\n\
\n\
\t\t\t\t\t\t\"float spotDistance = 1.0;\",\n\
\t\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\
\t\t\t\t\t\t\t\"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\
\n\
\t\t\t\t\t\t\"spotVector = normalize( spotVector );\",\n\
\n\
\t\t\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n\
\n\
\t\t\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\
\n\
\t\t\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\
\n\
\t\t\t\t\t\t\t// diffuse\n\
\n\
\t\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\",\n\
\t\t\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\",\n\
\n\
\t\t\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n\
\n\
\t\t\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\t\t\"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\",\n\
\n\
\t\t\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\t\t\"spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;\",\n\
\n\
\t\t\t\t\t\t\t// specular\n\
\n\
\t\t\t\t\t\t\t\"vec3 spotHalfVector = normalize( spotVector + viewPosition );\",\n\
\t\t\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n\
\t\t\t\t\t\t\t\"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );\",\n\
\n\
\t\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\
\n\
\t\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\
\n\
\t\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\
\n\
\t\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\",\n\
\t\t\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\",\n\
\n\
\t\t\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\t\t\"spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;\",\n\
\n\
\t\t\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t// directional lights\n\
\n\
\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\
\n\
\t\t\t\t\t\"vec3 dirDiffuse = vec3( 0.0 );\",\n\
\t\t\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\",\n\
\n\
\t\t\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\",\n\
\n\
\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\
\t\t\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\
\n\
\t\t\t\t\t\t// diffuse\n\
\n\
\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\
\n\
\t\t\t\t\t\t\t\"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\",\n\
\t\t\t\t\t\t\t\"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\n\
\n\
\t\t\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\",\n\
\n\
\t\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\n\
\n\
\t\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\t\"dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;\",\n\
\n\
\t\t\t\t\t\t// specular\n\
\n\
\t\t\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\
\t\t\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\
\t\t\t\t\t\t\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );\",\n\
\n\
\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\
\n\
\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\
\n\
\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\
\n\
\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n\
\t\t\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n\
\n\
\t\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\t\"dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;\",\n\
\n\
\t\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t// hemisphere lights\n\
\n\
\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\
\n\
\t\t\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\
\t\t\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\n\
\n\
\t\t\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\
\n\
\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\
\t\t\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\
\n\
\t\t\t\t\t\t// diffuse\n\
\n\
\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\
\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\
\n\
\t\t\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\
\n\
\t\t\t\t\t\t\"hemiDiffuse += uDiffuseColor * hemiColor;\",\n\
\n\
\t\t\t\t\t\t// specular (sky light)\n\
\n\
\n\
\t\t\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\
\t\t\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\
\t\t\t\t\t\t\"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );\",\n\
\n\
\t\t\t\t\t\t// specular (ground light)\n\
\n\
\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\n\
\n\
\t\t\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\
\t\t\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\
\t\t\t\t\t\t\"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );\",\n\
\n\
\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\n\
\n\
\t\t\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\n\
\n\
\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\
\n\
\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\n\
\n\
\t\t\t\t\t\t\t\"vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n\
\t\t\t\t\t\t\t\"vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n\
\t\t\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n\
\n\
\t\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\t\"hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\n\
\n\
\t\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t// all lights contribution summation\n\
\n\
\t\t\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\n\
\t\t\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\n\
\n\
\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\
\n\
\t\t\t\t\t\"totalDiffuse += dirDiffuse;\",\n\
\t\t\t\t\t\"totalSpecular += dirSpecular;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\
\n\
\t\t\t\t\t\"totalDiffuse += hemiDiffuse;\",\n\
\t\t\t\t\t\"totalSpecular += hemiSpecular;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\
\n\
\t\t\t\t\t\"totalDiffuse += pointDiffuse;\",\n\
\t\t\t\t\t\"totalSpecular += pointSpecular;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\
\n\
\t\t\t\t\t\"totalDiffuse += spotDiffuse;\",\n\
\t\t\t\t\t\"totalSpecular += spotSpecular;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"#ifdef METAL\",\n\
\n\
\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"if ( enableReflection ) {\",\n\
\n\
\t\t\t\t\t\"vec3 vReflect;\",\n\
\t\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n\
\n\
\t\t\t\t\t\"if ( useRefract ) {\",\n\
\n\
\t\t\t\t\t\t\"vReflect = refract( cameraToVertex, normal, uRefractionRatio );\",\n\
\n\
\t\t\t\t\t\"} else {\",\n\
\n\
\t\t\t\t\t\t\"vReflect = reflect( cameraToVertex, normal );\",\n\
\n\
\t\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\t\"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n\
\n\
\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\
\n\
\t\t\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\"),\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"attribute vec4 tangent;\",\n\
\n\
\t\t\t\"uniform vec2 uOffset;\",\n\
\t\t\t\"uniform vec2 uRepeat;\",\n\
\n\
\t\t\t\"uniform bool enableDisplacement;\",\n\
\n\
\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\
\n\
\t\t\t\t\"uniform sampler2D tDisplacement;\",\n\
\t\t\t\t\"uniform float uDisplacementScale;\",\n\
\t\t\t\t\"uniform float uDisplacementBias;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"varying vec3 vTangent;\",\n\
\t\t\t\"varying vec3 vBinormal;\",\n\
\t\t\t\"varying vec3 vNormal;\",\n\
\t\t\t\"varying vec2 vUv;\",\n\
\n\
\t\t\t\"varying vec3 vWorldPosition;\",\n\
\t\t\t\"varying vec3 vViewPosition;\",\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\
\n\
\t\t\t\t// normal, tangent and binormal vectors\n\
\n\
\t\t\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\t\t\"vNormal = normalize( normalMatrix * skinnedNormal.xyz );\",\n\
\n\
\t\t\t\t\t\"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\",\n\
\t\t\t\t\t\"vTangent = normalize( normalMatrix * skinnedTangent.xyz );\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\
\t\t\t\t\t\"vTangent = normalize( normalMatrix * tangent.xyz );\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\",\n\
\n\
\t\t\t\t\"vUv = uv * uRepeat + uOffset;\",\n\
\n\
\t\t\t\t// displacement mapping\n\
\n\
\t\t\t\t\"vec3 displacedPosition;\",\n\
\n\
\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\
\n\
\t\t\t\t\t\"if ( enableDisplacement ) {\",\n\
\n\
\t\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\n\
\t\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\n\
\t\t\t\t\t\t\"displacedPosition = position + normalize( normal ) * df;\",\n\
\n\
\t\t\t\t\t\"} else {\",\n\
\n\
\t\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\
\n\
\t\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\
\t\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\
\n\
\t\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\n\
\n\
\t\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\t\"displacedPosition = position;\",\n\
\n\
\t\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\
\n\
\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\
\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\
\n\
\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\n\
\n\
\t\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\t\"displacedPosition = position;\",\n\
\n\
\t\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\t//\n\
\n\
\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\n\
\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\n\
\n\
\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\
\n\
\t\t\t\t//\n\
\n\
\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\
\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\
\n\
\t\t\t\t// shadows\n\
\n\
\t\t\t\t\"#ifdef USE_SHADOWMAP\",\n\
\n\
\t\t\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\
\n\
\t\t\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\n\
\n\
\t\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\")\n\
\n\
\t},\n\
\n\
\t/* -------------------------------------------------------------------------\n\
\t//\tCube map shader\n\
\t ------------------------------------------------------------------------- */\n\
\n\
\t'cube': {\n\
\n\
\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\n\
\t\t\t\t\t\"tFlip\": { type: \"f\", value: -1 } },\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"varying vec3 vWorldPosition;\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\
\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\
\n\
\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\"),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform samplerCube tCube;\",\n\
\t\t\t\"uniform float tFlip;\",\n\
\n\
\t\t\t\"varying vec3 vWorldPosition;\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\")\n\
\n\
\t},\n\
\n\
\t// Depth encoding into RGBA texture\n\
\t// \tbased on SpiderGL shadow map example\n\
\t// \t\thttp://spidergl.org/example.php?id=6\n\
\t// \toriginally from\n\
\t//\t\thttp://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\n\
\t// \tsee also here:\n\
\t//\t\thttp://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n\
\n\
\t'depthRGBA': {\n\
\n\
\t\tuniforms: {},\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\
\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\
\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\"),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"vec4 pack_depth( const in float depth ) {\",\n\
\n\
\t\t\t\t\"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\n\
\t\t\t\t\"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\n\
\t\t\t\t\"vec4 res = fract( depth * bit_shift );\",\n\
\t\t\t\t\"res -= res.xxyz * bit_mask;\",\n\
\t\t\t\t\"return res;\",\n\
\n\
\t\t\t\"}\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\n\
\n\
\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\n\
\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\n\
\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\n\
\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join(\"\\n\
\")\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author supereggbert / http://www.paulbrunt.co.uk/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author szimek / https://github.com/szimek/\n\
 */\n\
\n\
THREE.WebGLRenderer = function ( parameters ) {\n\
\n\
\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\
\n\
\tparameters = parameters || {};\n\
\n\
\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\n\
\n\
\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\n\
\n\
\t_alpha = parameters.alpha !== undefined ? parameters.alpha : true,\n\
\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\
\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\
\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\
\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\
\n\
\t_clearColor = new THREE.Color( 0x000000 ),\n\
\t_clearAlpha = 0;\n\
\n\
\tif ( parameters.clearColor !== undefined ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: clearColor in WebGLRenderer constructor parameters is being removed. Use .setClearColor() instead.' );\n\
\t\t_clearColor.setHex( parameters.clearColor );\n\
\n\
\t}\n\
\n\
\tif ( parameters.clearAlpha !== undefined ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: clearAlpha in WebGLRenderer constructor parameters is being removed. Use .setClearColor() instead.' );\n\
\t\t_clearAlpha = parameters.clearAlpha;\n\
\n\
\t}\n\
\n\
\t// public properties\n\
\n\
\tthis.domElement = _canvas;\n\
\tthis.context = null;\n\
\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\n\
\t\t\t\t? parameters.devicePixelRatio\n\
\t\t\t\t: window.devicePixelRatio !== undefined\n\
\t\t\t\t\t? window.devicePixelRatio\n\
\t\t\t\t\t: 1;\n\
\n\
\t// clearing\n\
\n\
\tthis.autoClear = true;\n\
\tthis.autoClearColor = true;\n\
\tthis.autoClearDepth = true;\n\
\tthis.autoClearStencil = true;\n\
\n\
\t// scene graph\n\
\n\
\tthis.sortObjects = true;\n\
\tthis.autoUpdateObjects = true;\n\
\n\
\t// physically based shading\n\
\n\
\tthis.gammaInput = false;\n\
\tthis.gammaOutput = false;\n\
\tthis.physicallyBasedShading = false;\n\
\n\
\t// shadow map\n\
\n\
\tthis.shadowMapEnabled = false;\n\
\tthis.shadowMapAutoUpdate = true;\n\
\tthis.shadowMapType = THREE.PCFShadowMap;\n\
\tthis.shadowMapCullFace = THREE.CullFaceFront;\n\
\tthis.shadowMapDebug = false;\n\
\tthis.shadowMapCascade = false;\n\
\n\
\t// morphs\n\
\n\
\tthis.maxMorphTargets = 8;\n\
\tthis.maxMorphNormals = 4;\n\
\n\
\t// flags\n\
\n\
\tthis.autoScaleCubemaps = true;\n\
\n\
\t// custom render plugins\n\
\n\
\tthis.renderPluginsPre = [];\n\
\tthis.renderPluginsPost = [];\n\
\n\
\t// info\n\
\n\
\tthis.info = {\n\
\n\
\t\tmemory: {\n\
\n\
\t\t\tprograms: 0,\n\
\t\t\tgeometries: 0,\n\
\t\t\ttextures: 0\n\
\n\
\t\t},\n\
\n\
\t\trender: {\n\
\n\
\t\t\tcalls: 0,\n\
\t\t\tvertices: 0,\n\
\t\t\tfaces: 0,\n\
\t\t\tpoints: 0\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// internal properties\n\
\n\
\tvar _this = this,\n\
\n\
\t_programs = [],\n\
\t_programs_counter = 0,\n\
\n\
\t// internal state cache\n\
\n\
\t_currentProgram = null,\n\
\t_currentFramebuffer = null,\n\
\t_currentMaterialId = -1,\n\
\t_currentGeometryGroupHash = null,\n\
\t_currentCamera = null,\n\
\t_geometryGroupCounter = 0,\n\
\n\
\t_usedTextureUnits = 0,\n\
\n\
\t// GL state cache\n\
\n\
\t_oldDoubleSided = -1,\n\
\t_oldFlipSided = -1,\n\
\n\
\t_oldBlending = -1,\n\
\n\
\t_oldBlendEquation = -1,\n\
\t_oldBlendSrc = -1,\n\
\t_oldBlendDst = -1,\n\
\n\
\t_oldDepthTest = -1,\n\
\t_oldDepthWrite = -1,\n\
\n\
\t_oldPolygonOffset = null,\n\
\t_oldPolygonOffsetFactor = null,\n\
\t_oldPolygonOffsetUnits = null,\n\
\n\
\t_oldLineWidth = null,\n\
\n\
\t_viewportX = 0,\n\
\t_viewportY = 0,\n\
\t_viewportWidth = 0,\n\
\t_viewportHeight = 0,\n\
\t_currentWidth = 0,\n\
\t_currentHeight = 0,\n\
\n\
\t_enabledAttributes = {},\n\
\n\
\t// frustum\n\
\n\
\t_frustum = new THREE.Frustum(),\n\
\n\
\t // camera matrices cache\n\
\n\
\t_projScreenMatrix = new THREE.Matrix4(),\n\
\t_projScreenMatrixPS = new THREE.Matrix4(),\n\
\n\
\t_vector3 = new THREE.Vector3(),\n\
\n\
\t// light arrays cache\n\
\n\
\t_direction = new THREE.Vector3(),\n\
\n\
\t_lightsNeedUpdate = true,\n\
\n\
\t_lights = {\n\
\n\
\t\tambient: [ 0, 0, 0 ],\n\
\t\tdirectional: { length: 0, colors: new Array(), positions: new Array() },\n\
\t\tpoint: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },\n\
\t\tspot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },\n\
\t\themi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }\n\
\n\
\t};\n\
\n\
\t// initialize\n\
\n\
\tvar _gl;\n\
\n\
\tvar _glExtensionTextureFloat;\n\
\tvar _glExtensionTextureFloatLinear;\n\
\tvar _glExtensionStandardDerivatives;\n\
\tvar _glExtensionTextureFilterAnisotropic;\n\
\tvar _glExtensionCompressedTextureS3TC;\n\
\n\
\tinitGL();\n\
\n\
\tsetDefaultGLState();\n\
\n\
\tthis.context = _gl;\n\
\n\
\t// GPU capabilities\n\
\n\
\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\n\
\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\
\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\n\
\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\
\n\
\tvar _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\n\
\n\
\tvar _supportsVertexTextures = ( _maxVertexTextures > 0 );\n\
\tvar _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;\n\
\n\
\tvar _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];\n\
\n\
\t//\n\
\n\
\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\n\
\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\n\
\tvar _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );\n\
\n\
\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\n\
\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\n\
\tvar _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );\n\
\n\
\tvar _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );\n\
\tvar _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );\n\
\tvar _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );\n\
\n\
\tvar _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );\n\
\tvar _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );\n\
\tvar _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );\n\
\n\
\t// clamp precision to maximum available\n\
\n\
\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\n\
\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\n\
\n\
\tif ( _precision === \"highp\" && ! highpAvailable ) {\n\
\n\
\t\tif ( mediumpAvailable ) {\n\
\n\
\t\t\t_precision = \"mediump\";\n\
\t\t\tconsole.warn( \"WebGLRenderer: highp not supported, using mediump\" );\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_precision = \"lowp\";\n\
\t\t\tconsole.warn( \"WebGLRenderer: highp and mediump not supported, using lowp\" );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tif ( _precision === \"mediump\" && ! mediumpAvailable ) {\n\
\n\
\t\t_precision = \"lowp\";\n\
\t\tconsole.warn( \"WebGLRenderer: mediump not supported, using lowp\" );\n\
\n\
\t}\n\
\n\
\t// API\n\
\n\
\tthis.getContext = function () {\n\
\n\
\t\treturn _gl;\n\
\n\
\t};\n\
\n\
\tthis.supportsVertexTextures = function () {\n\
\n\
\t\treturn _supportsVertexTextures;\n\
\n\
\t};\n\
\n\
\tthis.supportsFloatTextures = function () {\n\
\n\
\t\treturn _glExtensionTextureFloat;\n\
\n\
\t};\n\
\n\
\tthis.supportsStandardDerivatives = function () {\n\
\n\
\t\treturn _glExtensionStandardDerivatives;\n\
\n\
\t};\n\
\n\
\tthis.supportsCompressedTextureS3TC = function () {\n\
\n\
\t\treturn _glExtensionCompressedTextureS3TC;\n\
\n\
\t};\n\
\n\
\tthis.getMaxAnisotropy  = function () {\n\
\n\
\t\treturn _maxAnisotropy;\n\
\n\
\t};\n\
\n\
\tthis.getPrecision = function () {\n\
\n\
\t\treturn _precision;\n\
\n\
\t};\n\
\n\
\tthis.setSize = function ( width, height, updateStyle ) {\n\
\n\
\t\t_canvas.width = width * this.devicePixelRatio;\n\
\t\t_canvas.height = height * this.devicePixelRatio;\n\
\n\
\t\tif ( this.devicePixelRatio !== 1 && updateStyle !== false ) {\n\
\n\
\t\t\t_canvas.style.width = width + 'px';\n\
\t\t\t_canvas.style.height = height + 'px';\n\
\n\
\t\t}\n\
\n\
\t\tthis.setViewport( 0, 0, _canvas.width, _canvas.height );\n\
\n\
\t};\n\
\n\
\tthis.setViewport = function ( x, y, width, height ) {\n\
\n\
\t\t_viewportX = x !== undefined ? x : 0;\n\
\t\t_viewportY = y !== undefined ? y : 0;\n\
\n\
\t\t_viewportWidth = width !== undefined ? width : _canvas.width;\n\
\t\t_viewportHeight = height !== undefined ? height : _canvas.height;\n\
\n\
\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\n\
\n\
\t};\n\
\n\
\tthis.setScissor = function ( x, y, width, height ) {\n\
\n\
\t\t_gl.scissor( x, y, width, height );\n\
\n\
\t};\n\
\n\
\tthis.enableScissorTest = function ( enable ) {\n\
\n\
\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\n\
\n\
\t};\n\
\n\
\t// Clearing\n\
\n\
\tthis.setClearColor = function ( color, alpha ) {\n\
\n\
\t\t_clearColor.set( color );\n\
\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\
\n\
\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\
\n\
\t};\n\
\n\
\tthis.setClearColorHex = function ( hex, alpha ) {\n\
\n\
\t\tconsole.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\n\
\t\tthis.setClearColor( hex, alpha );\n\
\n\
\t};\n\
\n\
\tthis.getClearColor = function () {\n\
\n\
\t\treturn _clearColor;\n\
\n\
\t};\n\
\n\
\tthis.getClearAlpha = function () {\n\
\n\
\t\treturn _clearAlpha;\n\
\n\
\t};\n\
\n\
\tthis.clear = function ( color, depth, stencil ) {\n\
\n\
\t\tvar bits = 0;\n\
\n\
\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\
\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\
\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\
\n\
\t\t_gl.clear( bits );\n\
\n\
\t};\n\
\n\
\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\
\n\
\t\tthis.setRenderTarget( renderTarget );\n\
\t\tthis.clear( color, depth, stencil );\n\
\n\
\t};\n\
\n\
\t// Plugins\n\
\n\
\tthis.addPostPlugin = function ( plugin ) {\n\
\n\
\t\tplugin.init( this );\n\
\t\tthis.renderPluginsPost.push( plugin );\n\
\n\
\t};\n\
\n\
\tthis.addPrePlugin = function ( plugin ) {\n\
\n\
\t\tplugin.init( this );\n\
\t\tthis.renderPluginsPre.push( plugin );\n\
\n\
\t};\n\
\n\
\t// Rendering\n\
\n\
\tthis.updateShadowMap = function ( scene, camera ) {\n\
\n\
\t\t_currentProgram = null;\n\
\t\t_oldBlending = -1;\n\
\t\t_oldDepthTest = -1;\n\
\t\t_oldDepthWrite = -1;\n\
\t\t_currentGeometryGroupHash = -1;\n\
\t\t_currentMaterialId = -1;\n\
\t\t_lightsNeedUpdate = true;\n\
\t\t_oldDoubleSided = -1;\n\
\t\t_oldFlipSided = -1;\n\
\n\
\t\tthis.shadowMapPlugin.update( scene, camera );\n\
\n\
\t};\n\
\n\
\t// Internal functions\n\
\n\
\t// Buffer allocation\n\
\n\
\tfunction createParticleBuffers ( geometry ) {\n\
\n\
\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\
\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\
\n\
\t\t_this.info.memory.geometries ++;\n\
\n\
\t};\n\
\n\
\tfunction createLineBuffers ( geometry ) {\n\
\n\
\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\
\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\
\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\n\
\n\
\t\t_this.info.memory.geometries ++;\n\
\n\
\t};\n\
\n\
\tfunction createRibbonBuffers ( geometry ) {\n\
\n\
\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\
\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\
\t\tgeometry.__webglNormalBuffer = _gl.createBuffer();\n\
\n\
\t\t_this.info.memory.geometries ++;\n\
\n\
\t};\n\
\n\
\tfunction createMeshBuffers ( geometryGroup ) {\n\
\n\
\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\n\
\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\n\
\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\n\
\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\n\
\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\n\
\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\n\
\n\
\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\n\
\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\n\
\n\
\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\n\
\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\n\
\n\
\t\tvar m, ml;\n\
\n\
\t\tif ( geometryGroup.numMorphTargets ) {\n\
\n\
\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\n\
\n\
\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\
\n\
\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( geometryGroup.numMorphNormals ) {\n\
\n\
\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\n\
\n\
\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\
\n\
\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t_this.info.memory.geometries ++;\n\
\n\
\t};\n\
\n\
\t// Events\n\
\n\
\tvar onGeometryDispose = function ( event ) {\n\
\n\
\t\tvar geometry = event.target;\n\
\n\
\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\
\n\
\t\tdeallocateGeometry( geometry );\n\
\n\
\t};\n\
\n\
\tvar onTextureDispose = function ( event ) {\n\
\n\
\t\tvar texture = event.target;\n\
\n\
\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\
\n\
\t\tdeallocateTexture( texture );\n\
\n\
\t\t_this.info.memory.textures --;\n\
\n\
\n\
\t};\n\
\n\
\tvar onRenderTargetDispose = function ( event ) {\n\
\n\
\t\tvar renderTarget = event.target;\n\
\n\
\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\
\n\
\t\tdeallocateRenderTarget( renderTarget );\n\
\n\
\t\t_this.info.memory.textures --;\n\
\n\
\t};\n\
\n\
\tvar onMaterialDispose = function ( event ) {\n\
\n\
\t\tvar material = event.target;\n\
\n\
\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\
\n\
\t\tdeallocateMaterial( material );\n\
\n\
\t};\n\
\n\
\t// Buffer deallocation\n\
\n\
\tvar deleteBuffers = function ( geometry ) {\n\
\n\
\t\tif ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );\n\
\t\tif ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );\n\
\t\tif ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );\n\
\t\tif ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );\n\
\t\tif ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );\n\
\t\tif ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );\n\
\n\
\t\tif ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );\n\
\t\tif ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );\n\
\n\
\t\tif ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );\n\
\t\tif ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );\n\
\n\
\t\tif ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\n\
\t\t// custom attributes\n\
\n\
\t\tif ( geometry.__webglCustomAttributesList !== undefined ) {\n\
\n\
\t\t\tfor ( var id in geometry.__webglCustomAttributesList ) {\n\
\n\
\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t_this.info.memory.geometries --;\n\
\n\
\t};\n\
\n\
\tvar deallocateGeometry = function ( geometry ) {\n\
\n\
\t\tgeometry.__webglInit = undefined;\n\
\n\
\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\
\n\
\t\t\tvar attributes = geometry.attributes;\n\
\n\
\t\t\tfor ( var key in attributes ) {\n\
\n\
\t\t\t\tif ( attributes[ key ].buffer !== undefined ) {\n\
\n\
\t\t\t\t\t_gl.deleteBuffer( attributes[ key ].buffer );\n\
\t\t\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_this.info.memory.geometries --;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tif ( geometry.geometryGroups !== undefined ) {\n\
\n\
\t\t\t\tfor ( var g in geometry.geometryGroups ) {\n\
\n\
\t\t\t\t\tvar geometryGroup = geometry.geometryGroups[ g ];\n\
\n\
\t\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\n\
\n\
\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\
\n\
\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\n\
\n\
\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\
\n\
\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tdeleteBuffers( geometryGroup );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tdeleteBuffers( geometry );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tvar deallocateTexture = function ( texture ) {\n\
\n\
\t\tif ( texture.image && texture.image.__webglTextureCube ) {\n\
\n\
\t\t\t// cube texture\n\
\n\
\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\n\
\n\
\t\t} else {\n\
\n\
\t\t\t// 2D texture\n\
\n\
\t\t\tif ( ! texture.__webglInit ) return;\n\
\n\
\t\t\ttexture.__webglInit = false;\n\
\t\t\t_gl.deleteTexture( texture.__webglTexture );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tvar deallocateRenderTarget = function ( renderTarget ) {\n\
\n\
\t\tif ( !renderTarget || ! renderTarget.__webglTexture ) return;\n\
\n\
\t\t_gl.deleteTexture( renderTarget.__webglTexture );\n\
\n\
\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\
\n\
\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\
\n\
\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\n\
\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\n\
\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tvar deallocateMaterial = function ( material ) {\n\
\n\
\t\tvar program = material.program;\n\
\n\
\t\tif ( program === undefined ) return;\n\
\n\
\t\tmaterial.program = undefined;\n\
\n\
\t\t// only deallocate GL program if this was the last use of shared program\n\
\t\t// assumed there is only single copy of any program in the _programs list\n\
\t\t// (that's how it's constructed)\n\
\n\
\t\tvar i, il, programInfo;\n\
\t\tvar deleteProgram = false;\n\
\n\
\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\n\
\n\
\t\t\tprogramInfo = _programs[ i ];\n\
\n\
\t\t\tif ( programInfo.program === program ) {\n\
\n\
\t\t\t\tprogramInfo.usedTimes --;\n\
\n\
\t\t\t\tif ( programInfo.usedTimes === 0 ) {\n\
\n\
\t\t\t\t\tdeleteProgram = true;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tbreak;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( deleteProgram === true ) {\n\
\n\
\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\n\
\n\
\t\t\tvar newPrograms = [];\n\
\n\
\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tprogramInfo = _programs[ i ];\n\
\n\
\t\t\t\tif ( programInfo.program !== program ) {\n\
\n\
\t\t\t\t\tnewPrograms.push( programInfo );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_programs = newPrograms;\n\
\n\
\t\t\t_gl.deleteProgram( program );\n\
\n\
\t\t\t_this.info.memory.programs --;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Buffer initialization\n\
\n\
\tfunction initCustomAttributes ( geometry, object ) {\n\
\n\
\t\tvar nvertices = geometry.vertices.length;\n\
\n\
\t\tvar material = object.material;\n\
\n\
\t\tif ( material.attributes ) {\n\
\n\
\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\n\
\n\
\t\t\t\tgeometry.__webglCustomAttributesList = [];\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfor ( var a in material.attributes ) {\n\
\n\
\t\t\t\tvar attribute = material.attributes[ a ];\n\
\n\
\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\n\
\n\
\t\t\t\t\tattribute.__webglInitialized = true;\n\
\n\
\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\n\
\n\
\t\t\t\t\tif ( attribute.type === \"v2\" ) size = 2;\n\
\t\t\t\t\telse if ( attribute.type === \"v3\" ) size = 3;\n\
\t\t\t\t\telse if ( attribute.type === \"v4\" ) size = 4;\n\
\t\t\t\t\telse if ( attribute.type === \"c\"  ) size = 3;\n\
\n\
\t\t\t\t\tattribute.size = size;\n\
\n\
\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\n\
\n\
\t\t\t\t\tattribute.buffer = _gl.createBuffer();\n\
\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\n\
\n\
\t\t\t\t\tattribute.needsUpdate = true;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction initParticleBuffers ( geometry, object ) {\n\
\n\
\t\tvar nvertices = geometry.vertices.length;\n\
\n\
\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\
\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\
\n\
\t\tgeometry.__sortArray = [];\n\
\n\
\t\tgeometry.__webglParticleCount = nvertices;\n\
\n\
\t\tinitCustomAttributes ( geometry, object );\n\
\n\
\t};\n\
\n\
\tfunction initLineBuffers ( geometry, object ) {\n\
\n\
\t\tvar nvertices = geometry.vertices.length;\n\
\n\
\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\
\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\
\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\n\
\n\
\t\tgeometry.__webglLineCount = nvertices;\n\
\n\
\t\tinitCustomAttributes ( geometry, object );\n\
\n\
\t};\n\
\n\
\tfunction initRibbonBuffers ( geometry, object ) {\n\
\n\
\t\tvar nvertices = geometry.vertices.length;\n\
\n\
\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\
\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\
\t\tgeometry.__normalArray = new Float32Array( nvertices * 3 );\n\
\n\
\t\tgeometry.__webglVertexCount = nvertices;\n\
\n\
\t\tinitCustomAttributes ( geometry, object );\n\
\n\
\t};\n\
\n\
\tfunction initMeshBuffers ( geometryGroup, object ) {\n\
\n\
\t\tvar geometry = object.geometry,\n\
\t\t\tfaces3 = geometryGroup.faces3,\n\
\n\
\t\t\tnvertices = faces3.length * 3,\n\
\t\t\tntris     = faces3.length * 1,\n\
\t\t\tnlines    = faces3.length * 3,\n\
\n\
\t\t\tmaterial = getBufferMaterial( object, geometryGroup ),\n\
\n\
\t\t\tuvType = bufferGuessUVType( material ),\n\
\t\t\tnormalType = bufferGuessNormalType( material ),\n\
\t\t\tvertexColorType = bufferGuessVertexColorType( material );\n\
\n\
\t\t// console.log( \"uvType\", uvType, \"normalType\", normalType, \"vertexColorType\", vertexColorType, object, geometryGroup, material );\n\
\n\
\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\n\
\n\
\t\tif ( normalType ) {\n\
\n\
\t\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\n\
\n\
\t\t}\n\
\n\
\t\tif ( geometry.hasTangents ) {\n\
\n\
\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\n\
\n\
\t\t}\n\
\n\
\t\tif ( vertexColorType ) {\n\
\n\
\t\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\n\
\n\
\t\t}\n\
\n\
\t\tif ( uvType ) {\n\
\n\
\t\t\tif ( geometry.faceVertexUvs.length > 0 ) {\n\
\n\
\t\t\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( geometry.faceVertexUvs.length > 1 ) {\n\
\n\
\t\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\n\
\n\
\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\n\
\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\n\
\n\
\t\t}\n\
\n\
\t\tgeometryGroup.__faceArray = new Uint16Array( ntris * 3 );\n\
\t\tgeometryGroup.__lineArray = new Uint16Array( nlines * 2 );\n\
\n\
\t\tvar m, ml;\n\
\n\
\t\tif ( geometryGroup.numMorphTargets ) {\n\
\n\
\t\t\tgeometryGroup.__morphTargetsArrays = [];\n\
\n\
\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\
\n\
\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( geometryGroup.numMorphNormals ) {\n\
\n\
\t\t\tgeometryGroup.__morphNormalsArrays = [];\n\
\n\
\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\
\n\
\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tgeometryGroup.__webglFaceCount = ntris * 3;\n\
\t\tgeometryGroup.__webglLineCount = nlines * 2;\n\
\n\
\n\
\t\t// custom attributes\n\
\n\
\t\tif ( material.attributes ) {\n\
\n\
\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\n\
\n\
\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfor ( var a in material.attributes ) {\n\
\n\
\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\n\
\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\n\
\n\
\t\t\t\tvar originalAttribute = material.attributes[ a ];\n\
\n\
\t\t\t\tvar attribute = {};\n\
\n\
\t\t\t\tfor ( var property in originalAttribute ) {\n\
\n\
\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\n\
\n\
\t\t\t\t\tattribute.__webglInitialized = true;\n\
\n\
\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\n\
\n\
\t\t\t\t\tif( attribute.type === \"v2\" ) size = 2;\n\
\t\t\t\t\telse if( attribute.type === \"v3\" ) size = 3;\n\
\t\t\t\t\telse if( attribute.type === \"v4\" ) size = 4;\n\
\t\t\t\t\telse if( attribute.type === \"c\"  ) size = 3;\n\
\n\
\t\t\t\t\tattribute.size = size;\n\
\n\
\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\n\
\n\
\t\t\t\t\tattribute.buffer = _gl.createBuffer();\n\
\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\n\
\n\
\t\t\t\t\toriginalAttribute.needsUpdate = true;\n\
\t\t\t\t\tattribute.__original = originalAttribute;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tgeometryGroup.__inittedArrays = true;\n\
\n\
\t};\n\
\n\
\tfunction getBufferMaterial( object, geometryGroup ) {\n\
\n\
\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\
\t\t\t? object.material.materials[ geometryGroup.materialIndex ]\n\
\t\t\t: object.material;\n\
\n\
\t};\n\
\n\
\tfunction materialNeedsSmoothNormals ( material ) {\n\
\n\
\t\treturn material && material.shading !== undefined && material.shading === THREE.SmoothShading;\n\
\n\
\t};\n\
\n\
\tfunction bufferGuessNormalType ( material ) {\n\
\n\
\t\t// only MeshBasicMaterial and MeshDepthMaterial don't need normals\n\
\n\
\t\tif ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {\n\
\n\
\t\t\treturn false;\n\
\n\
\t\t}\n\
\n\
\t\tif ( materialNeedsSmoothNormals( material ) ) {\n\
\n\
\t\t\treturn THREE.SmoothShading;\n\
\n\
\t\t} else {\n\
\n\
\t\t\treturn THREE.FlatShading;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction bufferGuessVertexColorType( material ) {\n\
\n\
\t\tif ( material.vertexColors ) {\n\
\n\
\t\t\treturn material.vertexColors;\n\
\n\
\t\t}\n\
\n\
\t\treturn false;\n\
\n\
\t};\n\
\n\
\tfunction bufferGuessUVType( material ) {\n\
\n\
\t\t// material must use some texture to require uvs\n\
\n\
\t\tif ( material.map ||\n\
\t\t     material.lightMap ||\n\
\t\t     material.bumpMap ||\n\
\t\t     material.normalMap ||\n\
\t\t     material.specularMap ||\n\
\t\t     material instanceof THREE.ShaderMaterial ) {\n\
\n\
\t\t\treturn true;\n\
\n\
\t\t}\n\
\n\
\t\treturn false;\n\
\n\
\t};\n\
\n\
\t//\n\
\n\
\tfunction initDirectBuffers( geometry ) {\n\
\n\
\t\tvar a, attribute, type;\n\
\n\
\t\tfor ( a in geometry.attributes ) {\n\
\n\
\t\t\tif ( a === \"index\" ) {\n\
\n\
\t\t\t\ttype = _gl.ELEMENT_ARRAY_BUFFER;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\ttype = _gl.ARRAY_BUFFER;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tattribute = geometry.attributes[ a ];\n\
\n\
\t\t\tif ( attribute.numItems === undefined ) {\n\
\n\
\t\t\t\tattribute.numItems = attribute.array.length;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tattribute.buffer = _gl.createBuffer();\n\
\n\
\t\t\t_gl.bindBuffer( type, attribute.buffer );\n\
\t\t\t_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Buffer setting\n\
\n\
\tfunction setParticleBuffers ( geometry, hint, object ) {\n\
\n\
\t\tvar v, c, vertex, offset, index, color,\n\
\n\
\t\tvertices = geometry.vertices,\n\
\t\tvl = vertices.length,\n\
\n\
\t\tcolors = geometry.colors,\n\
\t\tcl = colors.length,\n\
\n\
\t\tvertexArray = geometry.__vertexArray,\n\
\t\tcolorArray = geometry.__colorArray,\n\
\n\
\t\tsortArray = geometry.__sortArray,\n\
\n\
\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\
\t\tdirtyElements = geometry.elementsNeedUpdate,\n\
\t\tdirtyColors = geometry.colorsNeedUpdate,\n\
\n\
\t\tcustomAttributes = geometry.__webglCustomAttributesList,\n\
\t\ti, il,\n\
\t\ta, ca, cal, value,\n\
\t\tcustomAttribute;\n\
\n\
\t\tif ( object.sortParticles ) {\n\
\n\
\t\t\t_projScreenMatrixPS.copy( _projScreenMatrix );\n\
\t\t\t_projScreenMatrixPS.multiply( object.matrixWorld );\n\
\n\
\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\
\n\
\t\t\t\tvertex = vertices[ v ];\n\
\n\
\t\t\t\t_vector3.copy( vertex );\n\
\t\t\t\t_vector3.applyProjection( _projScreenMatrixPS );\n\
\n\
\t\t\t\tsortArray[ v ] = [ _vector3.z, v ];\n\
\n\
\t\t\t}\n\
\n\
\t\t\tsortArray.sort( numericalSort );\n\
\n\
\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\
\n\
\t\t\t\tvertex = vertices[ sortArray[v][1] ];\n\
\n\
\t\t\t\toffset = v * 3;\n\
\n\
\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\
\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\
\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\
\n\
\t\t\t\toffset = c * 3;\n\
\n\
\t\t\t\tcolor = colors[ sortArray[c][1] ];\n\
\n\
\t\t\t\tcolorArray[ offset ]     = color.r;\n\
\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\
\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( customAttributes ) {\n\
\n\
\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\tcustomAttribute = customAttributes[ i ];\n\
\n\
\t\t\t\t\tif ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) ) continue;\n\
\n\
\t\t\t\t\toffset = 0;\n\
\n\
\t\t\t\t\tcal = customAttribute.value.length;\n\
\n\
\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\
\n\
\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ index ];\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\
\n\
\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\
\n\
\t\t\t\t\t\t\toffset += 2;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\
\n\
\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\
\n\
\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\
\n\
\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\
\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]     = value.r;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\
\n\
\t\t\t\t\t\t\t\toffset += 3;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\
\n\
\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\
\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\
\n\
\t\t\t\t\t\t\t\toffset += 3;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\
\n\
\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\
\n\
\t\t\t\t\t\t\toffset += 4;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tif ( dirtyVertices ) {\n\
\n\
\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\
\n\
\t\t\t\t\tvertex = vertices[ v ];\n\
\n\
\t\t\t\t\toffset = v * 3;\n\
\n\
\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\
\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\
\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( dirtyColors ) {\n\
\n\
\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\
\n\
\t\t\t\t\tcolor = colors[ c ];\n\
\n\
\t\t\t\t\toffset = c * 3;\n\
\n\
\t\t\t\t\tcolorArray[ offset ]     = color.r;\n\
\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\
\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( customAttributes ) {\n\
\n\
\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\tcustomAttribute = customAttributes[ i ];\n\
\n\
\t\t\t\t\tif ( customAttribute.needsUpdate &&\n\
\t\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\
\t\t\t\t\t\t   customAttribute.boundTo === \"vertices\") ) {\n\
\n\
\t\t\t\t\t\tcal = customAttribute.value.length;\n\
\n\
\t\t\t\t\t\toffset = 0;\n\
\n\
\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\
\n\
\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\
\n\
\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\
\n\
\t\t\t\t\t\t\t\toffset += 2;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\
\n\
\t\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\
\n\
\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\
\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\
\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\
\n\
\t\t\t\t\t\t\t\t\toffset += 3;\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\
\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\
\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\
\n\
\t\t\t\t\t\t\t\t\toffset += 3;\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\
\n\
\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\
\n\
\t\t\t\t\t\t\t\toffset += 4;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyVertices || object.sortParticles ) {\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyColors || object.sortParticles ) {\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( customAttributes ) {\n\
\n\
\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tcustomAttribute = customAttributes[ i ];\n\
\n\
\t\t\t\tif ( customAttribute.needsUpdate || object.sortParticles ) {\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\
\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\n\
\t};\n\
\n\
\tfunction setLineBuffers ( geometry, hint ) {\n\
\n\
\t\tvar v, c, d, vertex, offset, color,\n\
\n\
\t\tvertices = geometry.vertices,\n\
\t\tcolors = geometry.colors,\n\
\t\tlineDistances = geometry.lineDistances,\n\
\n\
\t\tvl = vertices.length,\n\
\t\tcl = colors.length,\n\
\t\tdl = lineDistances.length,\n\
\n\
\t\tvertexArray = geometry.__vertexArray,\n\
\t\tcolorArray = geometry.__colorArray,\n\
\t\tlineDistanceArray = geometry.__lineDistanceArray,\n\
\n\
\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\
\t\tdirtyColors = geometry.colorsNeedUpdate,\n\
\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\n\
\n\
\t\tcustomAttributes = geometry.__webglCustomAttributesList,\n\
\n\
\t\ti, il,\n\
\t\ta, ca, cal, value,\n\
\t\tcustomAttribute;\n\
\n\
\t\tif ( dirtyVertices ) {\n\
\n\
\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\
\n\
\t\t\t\tvertex = vertices[ v ];\n\
\n\
\t\t\t\toffset = v * 3;\n\
\n\
\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\
\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\
\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyColors ) {\n\
\n\
\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\
\n\
\t\t\t\tcolor = colors[ c ];\n\
\n\
\t\t\t\toffset = c * 3;\n\
\n\
\t\t\t\tcolorArray[ offset ]     = color.r;\n\
\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\
\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyLineDistances ) {\n\
\n\
\t\t\tfor ( d = 0; d < dl; d ++ ) {\n\
\n\
\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( customAttributes ) {\n\
\n\
\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tcustomAttribute = customAttributes[ i ];\n\
\n\
\t\t\t\tif ( customAttribute.needsUpdate &&\n\
\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\
\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\n\
\n\
\t\t\t\t\toffset = 0;\n\
\n\
\t\t\t\t\tcal = customAttribute.value.length;\n\
\n\
\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\
\n\
\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\
\n\
\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\
\n\
\t\t\t\t\t\t\toffset += 2;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\
\n\
\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\
\n\
\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\
\n\
\t\t\t\t\t\t\t\toffset += 3;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\
\n\
\t\t\t\t\t\t\t\toffset += 3;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\
\n\
\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\
\n\
\t\t\t\t\t\t\toffset += 4;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\
\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction setRibbonBuffers ( geometry, hint ) {\n\
\n\
\t\tvar v, c, n, vertex, offset, color, normal,\n\
\n\
\t\ti, il, ca, cal, customAttribute, value,\n\
\n\
\t\tvertices = geometry.vertices,\n\
\t\tcolors = geometry.colors,\n\
\t\tnormals = geometry.normals,\n\
\n\
\t\tvl = vertices.length,\n\
\t\tcl = colors.length,\n\
\t\tnl = normals.length,\n\
\n\
\t\tvertexArray = geometry.__vertexArray,\n\
\t\tcolorArray = geometry.__colorArray,\n\
\t\tnormalArray = geometry.__normalArray,\n\
\n\
\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\
\t\tdirtyColors = geometry.colorsNeedUpdate,\n\
\t\tdirtyNormals = geometry.normalsNeedUpdate,\n\
\n\
\t\tcustomAttributes = geometry.__webglCustomAttributesList;\n\
\n\
\t\tif ( dirtyVertices ) {\n\
\n\
\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\
\n\
\t\t\t\tvertex = vertices[ v ];\n\
\n\
\t\t\t\toffset = v * 3;\n\
\n\
\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\
\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\
\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyColors ) {\n\
\n\
\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\
\n\
\t\t\t\tcolor = colors[ c ];\n\
\n\
\t\t\t\toffset = c * 3;\n\
\n\
\t\t\t\tcolorArray[ offset ]     = color.r;\n\
\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\
\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyNormals ) {\n\
\n\
\t\t\tfor ( n = 0; n < nl; n ++ ) {\n\
\n\
\t\t\t\tnormal = normals[ n ];\n\
\n\
\t\t\t\toffset = n * 3;\n\
\n\
\t\t\t\tnormalArray[ offset ]     = normal.x;\n\
\t\t\t\tnormalArray[ offset + 1 ] = normal.y;\n\
\t\t\t\tnormalArray[ offset + 2 ] = normal.z;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglNormalBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( customAttributes ) {\n\
\n\
\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tcustomAttribute = customAttributes[ i ];\n\
\n\
\t\t\t\tif ( customAttribute.needsUpdate &&\n\
\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\
\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\n\
\n\
\t\t\t\t\toffset = 0;\n\
\n\
\t\t\t\t\tcal = customAttribute.value.length;\n\
\n\
\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\
\n\
\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\
\n\
\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\
\n\
\t\t\t\t\t\t\toffset += 2;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\
\n\
\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\
\n\
\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\
\n\
\t\t\t\t\t\t\t\toffset += 3;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\
\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\
\n\
\t\t\t\t\t\t\t\toffset += 3;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\
\n\
\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\
\n\
\t\t\t\t\t\t\toffset += 4;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\
\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\n\
\n\
\t\tif ( ! geometryGroup.__inittedArrays ) {\n\
\n\
\t\t\treturn;\n\
\n\
\t\t}\n\
\n\
\t\tvar normalType = bufferGuessNormalType( material ),\n\
\t\tvertexColorType = bufferGuessVertexColorType( material ),\n\
\t\tuvType = bufferGuessUVType( material ),\n\
\n\
\t\tneedsSmoothNormals = ( normalType === THREE.SmoothShading );\n\
\n\
\t\tvar f, fl, fi, face,\n\
\t\tvertexNormals, faceNormal, normal,\n\
\t\tvertexColors, faceColor,\n\
\t\tvertexTangents,\n\
\t\tuv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,\n\
\t\tc1, c2, c3, c4,\n\
\t\tsw1, sw2, sw3, sw4,\n\
\t\tsi1, si2, si3, si4,\n\
\t\tsa1, sa2, sa3, sa4,\n\
\t\tsb1, sb2, sb3, sb4,\n\
\t\tm, ml, i, il,\n\
\t\tvn, uvi, uv2i,\n\
\t\tvk, vkl, vka,\n\
\t\tnka, chf, faceVertexNormals,\n\
\t\ta,\n\
\n\
\t\tvertexIndex = 0,\n\
\n\
\t\toffset = 0,\n\
\t\toffset_uv = 0,\n\
\t\toffset_uv2 = 0,\n\
\t\toffset_face = 0,\n\
\t\toffset_normal = 0,\n\
\t\toffset_tangent = 0,\n\
\t\toffset_line = 0,\n\
\t\toffset_color = 0,\n\
\t\toffset_skin = 0,\n\
\t\toffset_morphTarget = 0,\n\
\t\toffset_custom = 0,\n\
\t\toffset_customSrc = 0,\n\
\n\
\t\tvalue,\n\
\n\
\t\tvertexArray = geometryGroup.__vertexArray,\n\
\t\tuvArray = geometryGroup.__uvArray,\n\
\t\tuv2Array = geometryGroup.__uv2Array,\n\
\t\tnormalArray = geometryGroup.__normalArray,\n\
\t\ttangentArray = geometryGroup.__tangentArray,\n\
\t\tcolorArray = geometryGroup.__colorArray,\n\
\n\
\t\tskinIndexArray = geometryGroup.__skinIndexArray,\n\
\t\tskinWeightArray = geometryGroup.__skinWeightArray,\n\
\n\
\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\n\
\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\n\
\n\
\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\n\
\t\tcustomAttribute,\n\
\n\
\t\tfaceArray = geometryGroup.__faceArray,\n\
\t\tlineArray = geometryGroup.__lineArray,\n\
\n\
\t\tgeometry = object.geometry, // this is shared for all chunks\n\
\n\
\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\
\t\tdirtyElements = geometry.elementsNeedUpdate,\n\
\t\tdirtyUvs = geometry.uvsNeedUpdate,\n\
\t\tdirtyNormals = geometry.normalsNeedUpdate,\n\
\t\tdirtyTangents = geometry.tangentsNeedUpdate,\n\
\t\tdirtyColors = geometry.colorsNeedUpdate,\n\
\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\n\
\n\
\t\tvertices = geometry.vertices,\n\
\t\tchunk_faces3 = geometryGroup.faces3,\n\
\t\tobj_faces = geometry.faces,\n\
\n\
\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\n\
\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\n\
\n\
\t\tobj_colors = geometry.colors,\n\
\n\
\t\tobj_skinIndices = geometry.skinIndices,\n\
\t\tobj_skinWeights = geometry.skinWeights,\n\
\n\
\t\tmorphTargets = geometry.morphTargets,\n\
\t\tmorphNormals = geometry.morphNormals;\n\
\n\
\t\tif ( dirtyVertices ) {\n\
\n\
\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\n\
\n\
\t\t\t\tv1 = vertices[ face.a ];\n\
\t\t\t\tv2 = vertices[ face.b ];\n\
\t\t\t\tv3 = vertices[ face.c ];\n\
\n\
\t\t\t\tvertexArray[ offset ]     = v1.x;\n\
\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\n\
\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\n\
\n\
\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\n\
\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\n\
\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\n\
\n\
\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\n\
\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\n\
\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\n\
\n\
\t\t\t\toffset += 9;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyMorphTargets ) {\n\
\n\
\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\n\
\n\
\t\t\t\toffset_morphTarget = 0;\n\
\n\
\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\tchf = chunk_faces3[ f ];\n\
\t\t\t\t\tface = obj_faces[ chf ];\n\
\n\
\t\t\t\t\t// morph positions\n\
\n\
\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\n\
\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\n\
\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\n\
\n\
\t\t\t\t\tvka = morphTargetsArrays[ vk ];\n\
\n\
\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\n\
\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\n\
\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\n\
\n\
\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\n\
\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\n\
\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\n\
\n\
\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\n\
\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\n\
\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\n\
\n\
\t\t\t\t\t// morph normals\n\
\n\
\t\t\t\t\tif ( material.morphNormals ) {\n\
\n\
\t\t\t\t\t\tif ( needsSmoothNormals ) {\n\
\n\
\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\n\
\n\
\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\n\
\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\n\
\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\n\
\n\
\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\n\
\t\t\t\t\t\t\tn2 = n1;\n\
\t\t\t\t\t\t\tn3 = n1;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\n\
\n\
\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\n\
\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\n\
\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\n\
\n\
\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\n\
\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\n\
\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\n\
\n\
\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\n\
\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\n\
\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t//\n\
\n\
\t\t\t\t\toffset_morphTarget += 9;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\n\
\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\n\
\n\
\t\t\t\tif ( material.morphNormals ) {\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\n\
\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( obj_skinWeights.length ) {\n\
\n\
\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\
\n\
\t\t\t\t// weights\n\
\n\
\t\t\t\tsw1 = obj_skinWeights[ face.a ];\n\
\t\t\t\tsw2 = obj_skinWeights[ face.b ];\n\
\t\t\t\tsw3 = obj_skinWeights[ face.c ];\n\
\n\
\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\n\
\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\n\
\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\n\
\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\n\
\n\
\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\n\
\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\n\
\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\n\
\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\n\
\n\
\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\n\
\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\n\
\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\n\
\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\n\
\n\
\t\t\t\t// indices\n\
\n\
\t\t\t\tsi1 = obj_skinIndices[ face.a ];\n\
\t\t\t\tsi2 = obj_skinIndices[ face.b ];\n\
\t\t\t\tsi3 = obj_skinIndices[ face.c ];\n\
\n\
\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\n\
\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\n\
\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\n\
\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\n\
\n\
\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\n\
\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\n\
\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\n\
\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\n\
\n\
\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\n\
\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\n\
\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\n\
\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\n\
\n\
\t\t\t\toffset_skin += 12;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( offset_skin > 0 ) {\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\n\
\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\n\
\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyColors && vertexColorType ) {\n\
\n\
\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\
\n\
\t\t\t\tvertexColors = face.vertexColors;\n\
\t\t\t\tfaceColor = face.color;\n\
\n\
\t\t\t\tif ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {\n\
\n\
\t\t\t\t\tc1 = vertexColors[ 0 ];\n\
\t\t\t\t\tc2 = vertexColors[ 1 ];\n\
\t\t\t\t\tc3 = vertexColors[ 2 ];\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tc1 = faceColor;\n\
\t\t\t\t\tc2 = faceColor;\n\
\t\t\t\t\tc3 = faceColor;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tcolorArray[ offset_color ]     = c1.r;\n\
\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\n\
\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\n\
\n\
\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\n\
\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\n\
\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\n\
\n\
\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\n\
\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\n\
\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\n\
\n\
\t\t\t\toffset_color += 9;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( offset_color > 0 ) {\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\n\
\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyTangents && geometry.hasTangents ) {\n\
\n\
\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\
\n\
\t\t\t\tvertexTangents = face.vertexTangents;\n\
\n\
\t\t\t\tt1 = vertexTangents[ 0 ];\n\
\t\t\t\tt2 = vertexTangents[ 1 ];\n\
\t\t\t\tt3 = vertexTangents[ 2 ];\n\
\n\
\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\n\
\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\n\
\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\n\
\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\n\
\n\
\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\n\
\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\n\
\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\n\
\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\n\
\n\
\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\n\
\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\n\
\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\n\
\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\n\
\n\
\t\t\t\toffset_tangent += 12;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyNormals && normalType ) {\n\
\n\
\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\
\n\
\t\t\t\tvertexNormals = face.vertexNormals;\n\
\t\t\t\tfaceNormal = face.normal;\n\
\n\
\t\t\t\tif ( vertexNormals.length === 3 && needsSmoothNormals ) {\n\
\n\
\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\
\n\
\t\t\t\t\t\tvn = vertexNormals[ i ];\n\
\n\
\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\n\
\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\n\
\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\n\
\n\
\t\t\t\t\t\toffset_normal += 3;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\
\n\
\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\n\
\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\n\
\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\n\
\n\
\t\t\t\t\t\toffset_normal += 3;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyUvs && obj_uvs && uvType ) {\n\
\n\
\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tfi = chunk_faces3[ f ];\n\
\n\
\t\t\t\tuv = obj_uvs[ fi ];\n\
\n\
\t\t\t\tif ( uv === undefined ) continue;\n\
\n\
\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\
\n\
\t\t\t\t\tuvi = uv[ i ];\n\
\n\
\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\n\
\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\n\
\n\
\t\t\t\t\toffset_uv += 2;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( offset_uv > 0 ) {\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\n\
\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyUvs && obj_uvs2 && uvType ) {\n\
\n\
\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tfi = chunk_faces3[ f ];\n\
\n\
\t\t\t\tuv2 = obj_uvs2[ fi ];\n\
\n\
\t\t\t\tif ( uv2 === undefined ) continue;\n\
\n\
\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\
\n\
\t\t\t\t\tuv2i = uv2[ i ];\n\
\n\
\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\n\
\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\n\
\n\
\t\t\t\t\toffset_uv2 += 2;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( offset_uv2 > 0 ) {\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\n\
\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( dirtyElements ) {\n\
\n\
\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\tfaceArray[ offset_face ] \t = vertexIndex;\n\
\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\n\
\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\n\
\n\
\t\t\t\toffset_face += 3;\n\
\n\
\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\n\
\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\n\
\n\
\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\n\
\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\n\
\n\
\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\n\
\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\n\
\n\
\t\t\t\toffset_line += 6;\n\
\n\
\t\t\t\tvertexIndex += 3;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\n\
\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\n\
\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\n\
\n\
\t\t}\n\
\n\
\t\tif ( customAttributes ) {\n\
\n\
\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tcustomAttribute = customAttributes[ i ];\n\
\n\
\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\n\
\n\
\t\t\t\toffset_custom = 0;\n\
\t\t\t\toffset_customSrc = 0;\n\
\n\
\t\t\t\tif ( customAttribute.size === 1 ) {\n\
\n\
\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\
\n\
\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\n\
\n\
\t\t\t\t\t\t\toffset_custom += 3;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\
\n\
\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\n\
\n\
\t\t\t\t\t\t\toffset_custom += 3;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\
\n\
\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\
\n\
\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\
\n\
\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\
\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\
\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\
\n\
\t\t\t\t\t\t\toffset_custom += 6;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\
\n\
\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\
\n\
\t\t\t\t\t\t\tv1 = value;\n\
\t\t\t\t\t\t\tv2 = value;\n\
\t\t\t\t\t\t\tv3 = value;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\
\n\
\t\t\t\t\t\t\toffset_custom += 6;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\
\n\
\t\t\t\t\tvar pp;\n\
\n\
\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\
\n\
\t\t\t\t\t\tpp = [ \"r\", \"g\", \"b\" ];\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\tpp = [ \"x\", \"y\", \"z\" ];\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\
\n\
\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\
\n\
\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\
\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\
\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\
\n\
\t\t\t\t\t\t\toffset_custom += 9;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\
\n\
\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\
\n\
\t\t\t\t\t\t\tv1 = value;\n\
\t\t\t\t\t\t\tv2 = value;\n\
\t\t\t\t\t\t\tv3 = value;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\
\n\
\t\t\t\t\t\t\toffset_custom += 9;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\n\
\n\
\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\
\n\
\t\t\t\t\t\t\tv1 = value[ 0 ];\n\
\t\t\t\t\t\t\tv2 = value[ 1 ];\n\
\t\t\t\t\t\t\tv3 = value[ 2 ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\
\n\
\t\t\t\t\t\t\toffset_custom += 9;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\
\n\
\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\
\n\
\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\
\n\
\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\
\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\
\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\
\n\
\t\t\t\t\t\t\toffset_custom += 12;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\
\n\
\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\
\n\
\t\t\t\t\t\t\tv1 = value;\n\
\t\t\t\t\t\t\tv2 = value;\n\
\t\t\t\t\t\t\tv3 = value;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\
\n\
\t\t\t\t\t\t\toffset_custom += 12;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\n\
\n\
\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\
\n\
\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\
\n\
\t\t\t\t\t\t\tv1 = value[ 0 ];\n\
\t\t\t\t\t\t\tv2 = value[ 1 ];\n\
\t\t\t\t\t\t\tv3 = value[ 2 ];\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\
\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\
\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\
\n\
\t\t\t\t\t\t\toffset_custom += 12;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\
\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( dispose ) {\n\
\n\
\t\t\tdelete geometryGroup.__inittedArrays;\n\
\t\t\tdelete geometryGroup.__colorArray;\n\
\t\t\tdelete geometryGroup.__normalArray;\n\
\t\t\tdelete geometryGroup.__tangentArray;\n\
\t\t\tdelete geometryGroup.__uvArray;\n\
\t\t\tdelete geometryGroup.__uv2Array;\n\
\t\t\tdelete geometryGroup.__faceArray;\n\
\t\t\tdelete geometryGroup.__vertexArray;\n\
\t\t\tdelete geometryGroup.__lineArray;\n\
\t\t\tdelete geometryGroup.__skinIndexArray;\n\
\t\t\tdelete geometryGroup.__skinWeightArray;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction setDirectBuffers ( geometry, hint, dispose ) {\n\
\n\
\t\tvar attributes = geometry.attributes;\n\
\n\
\t\tvar attributeName, attributeItem;\n\
\n\
\t\tfor ( attributeName in attributes ) {\n\
\n\
\t\t\tattributeItem = attributes[ attributeName ];\n\
\n\
\t\t\tif ( attributeItem.needsUpdate ) {\n\
\n\
\t\t\t\tif ( attributeName === 'index' ) {\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );\n\
\t\t\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\
\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tattributeItem.needsUpdate = false;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( dispose && ! attributeItem.dynamic ) {\n\
\n\
\t\t\t\tattributeItem.array = null;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Buffer rendering\n\
\n\
\tthis.renderBufferImmediate = function ( object, program, material ) {\n\
\n\
\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\n\
\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\n\
\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\n\
\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\n\
\n\
\t\tif ( object.hasPositions ) {\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\
\t\t\t_gl.enableVertexAttribArray( program.attributes.position );\n\
\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t}\n\
\n\
\t\tif ( object.hasNormals ) {\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\n\
\n\
\t\t\tif ( material.shading === THREE.FlatShading ) {\n\
\n\
\t\t\t\tvar nx, ny, nz,\n\
\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\n\
\t\t\t\t\tnormalArray,\n\
\t\t\t\t\ti, il = object.count * 3;\n\
\n\
\t\t\t\tfor( i = 0; i < il; i += 9 ) {\n\
\n\
\t\t\t\t\tnormalArray = object.normalArray;\n\
\n\
\t\t\t\t\tnax  = normalArray[ i ];\n\
\t\t\t\t\tnay  = normalArray[ i + 1 ];\n\
\t\t\t\t\tnaz  = normalArray[ i + 2 ];\n\
\n\
\t\t\t\t\tnbx  = normalArray[ i + 3 ];\n\
\t\t\t\t\tnby  = normalArray[ i + 4 ];\n\
\t\t\t\t\tnbz  = normalArray[ i + 5 ];\n\
\n\
\t\t\t\t\tncx  = normalArray[ i + 6 ];\n\
\t\t\t\t\tncy  = normalArray[ i + 7 ];\n\
\t\t\t\t\tncz  = normalArray[ i + 8 ];\n\
\n\
\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\n\
\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\n\
\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\n\
\n\
\t\t\t\t\tnormalArray[ i ] \t = nx;\n\
\t\t\t\t\tnormalArray[ i + 1 ] = ny;\n\
\t\t\t\t\tnormalArray[ i + 2 ] = nz;\n\
\n\
\t\t\t\t\tnormalArray[ i + 3 ] = nx;\n\
\t\t\t\t\tnormalArray[ i + 4 ] = ny;\n\
\t\t\t\t\tnormalArray[ i + 5 ] = nz;\n\
\n\
\t\t\t\t\tnormalArray[ i + 6 ] = nx;\n\
\t\t\t\t\tnormalArray[ i + 7 ] = ny;\n\
\t\t\t\t\tnormalArray[ i + 8 ] = nz;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\
\t\t\t_gl.enableVertexAttribArray( program.attributes.normal );\n\
\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t}\n\
\n\
\t\tif ( object.hasUvs && material.map ) {\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\
\t\t\t_gl.enableVertexAttribArray( program.attributes.uv );\n\
\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t}\n\
\n\
\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\n\
\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\
\t\t\t_gl.enableVertexAttribArray( program.attributes.color );\n\
\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t}\n\
\n\
\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\
\n\
\t\tobject.count = 0;\n\
\n\
\t};\n\
\n\
\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\n\
\n\
\t\tif ( material.visible === false ) return;\n\
\n\
\t\tvar linewidth, a, attribute;\n\
\t\tvar attributeItem, attributeName, attributePointer, attributeSize;\n\
\n\
\t\tvar program = setProgram( camera, lights, fog, material, object );\n\
\n\
\t\tvar programAttributes = program.attributes;\n\
\t\tvar geometryAttributes = geometry.attributes;\n\
\n\
\t\tvar updateBuffers = false,\n\
\t\t\twireframeBit = material.wireframe ? 1 : 0,\n\
\t\t\tgeometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\n\
\n\
\t\tif ( geometryHash !== _currentGeometryGroupHash ) {\n\
\n\
\t\t\t_currentGeometryGroupHash = geometryHash;\n\
\t\t\tupdateBuffers = true;\n\
\n\
\t\t}\n\
\n\
\t\tif ( updateBuffers ) {\n\
\n\
\t\t\tdisableAttributes();\n\
\n\
\t\t}\n\
\n\
\t\t// render mesh\n\
\n\
\t\tif ( object instanceof THREE.Mesh ) {\n\
\n\
\t\t\tvar index = geometryAttributes[ \"index\" ];\n\
\n\
\t\t\t// indexed triangles\n\
\n\
\t\t\tif ( index ) {\n\
\n\
\t\t\t\tvar offsets = geometry.offsets;\n\
\n\
\t\t\t\t// if there is more than 1 chunk\n\
\t\t\t\t// must set attribute pointers to use new offsets for each chunk\n\
\t\t\t\t// even if geometry and materials didn't change\n\
\n\
\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\n\
\n\
\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\tvar startIndex = offsets[ i ].index;\n\
\n\
\t\t\t\t\tif ( updateBuffers ) {\n\
\n\
\t\t\t\t\t\tfor ( attributeName in programAttributes ) {\n\
\n\
\t\t\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\
\t\t\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\
\n\
\t\t\t\t\t\t\tif ( attributePointer >= 0 ) {\n\
\n\
\t\t\t\t\t\t\t\tif ( attributeItem ) {\n\
\n\
\t\t\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\
\t\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\
\t\t\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\
\t\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32\n\
\n\
\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\
\n\
\t\t\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\
\n\
\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\
\n\
\t\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\
\n\
\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\
\n\
\t\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t// indices\n\
\n\
\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// render indexed triangles\n\
\n\
\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16\n\
\n\
\t\t\t\t\t_this.info.render.calls ++;\n\
\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\n\
\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t// non-indexed triangles\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tif ( updateBuffers ) {\n\
\n\
\t\t\t\t\tfor ( attributeName in programAttributes ) {\n\
\n\
\t\t\t\t\t\tif ( attributeName === 'index') continue;\n\
\n\
\t\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\
\t\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\
\t\t\t\t\t\t\n\
\t\t\t\t\t\tif ( attributePointer >= 0 ) {\n\
\n\
\t\t\t\t\t\t\tif ( attributeItem ) {\n\
\n\
\t\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\
\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\
\t\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\
\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\n\
\n\
\t\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\
\n\
\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\
\n\
\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\
\n\
\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\
\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tvar position = geometry.attributes[ \"position\" ];\n\
\n\
\t\t\t\t// render non-indexed triangles\n\
\n\
\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );\n\
\n\
\t\t\t\t_this.info.render.calls ++;\n\
\t\t\t\t_this.info.render.vertices += position.numItems / 3;\n\
\t\t\t\t_this.info.render.faces += position.numItems / 3 / 3;\n\
\n\
\t\t\t}\n\
\n\
\t\t// render particles\n\
\n\
\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\
\n\
\t\t\tif ( updateBuffers ) {\n\
\n\
\t\t\t\tfor ( attributeName in programAttributes ) {\n\
\n\
\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\
\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\
\t\t\t\t\t\n\
\t\t\t\t\tif ( attributePointer >= 0 ) {\n\
\n\
\t\t\t\t\t\tif ( attributeItem ) {\n\
\n\
\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\
\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\
\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\
\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\n\
\n\
\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\
\n\
\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\
\n\
\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\
\n\
\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tvar position = geometryAttributes[ \"position\" ];\n\
\n\
\t\t\t\t// render particles\n\
\n\
\t\t\t\t_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );\n\
\n\
\t\t\t\t_this.info.render.calls ++;\n\
\t\t\t\t_this.info.render.points += position.numItems / 3;\n\
\n\
\t\t\t}\n\
\n\
\t\t} else if ( object instanceof THREE.Line ) {\n\
\n\
\t\t\tif ( updateBuffers ) {\n\
\n\
\t\t\t\tfor ( attributeName in programAttributes ) {\n\
\n\
\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\
\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\
\t\t\t\t\t\n\
\t\t\t\t\tif ( attributePointer >= 0 ) {\n\
\n\
\t\t\t\t\t\tif ( attributeItem ) {\n\
\n\
\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\
\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\
\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\
\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\n\
\n\
\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\
\n\
\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\
\n\
\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\
\n\
\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// render lines\n\
\n\
\t\t\t\tvar primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\n\
\n\
\t\t\t\tsetLineWidth( material.linewidth );\n\
\n\
\t\t\t\tvar position = geometryAttributes[ \"position\" ];\n\
\n\
\t\t\t\t_gl.drawArrays( primitives, 0, position.numItems / 3 );\n\
\n\
\t\t\t\t_this.info.render.calls ++;\n\
\t\t\t\t_this.info.render.points += position.numItems;\n\
\n\
\t\t\t}\n\
\n\
    \t}\n\
\n\
\t};\n\
\n\
\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\n\
\n\
\t\tif ( material.visible === false ) return;\n\
\n\
\t\tvar linewidth, a, attribute, i, il;\n\
\n\
\t\tvar program = setProgram( camera, lights, fog, material, object );\n\
\n\
\t\tvar attributes = program.attributes;\n\
\n\
\t\tvar updateBuffers = false,\n\
\t\t\twireframeBit = material.wireframe ? 1 : 0,\n\
\t\t\tgeometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\n\
\n\
\t\tif ( geometryGroupHash !== _currentGeometryGroupHash ) {\n\
\n\
\t\t\t_currentGeometryGroupHash = geometryGroupHash;\n\
\t\t\tupdateBuffers = true;\n\
\n\
\t\t}\n\
\n\
\t\tif ( updateBuffers ) {\n\
\n\
\t\t\tdisableAttributes();\n\
\n\
\t\t}\n\
\n\
\t\t// vertices\n\
\n\
\t\tif ( !material.morphTargets && attributes.position >= 0 ) {\n\
\n\
\t\t\tif ( updateBuffers ) {\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\
\t\t\t\tenableAttribute( attributes.position );\n\
\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tif ( object.morphTargetBase ) {\n\
\n\
\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\n\
\t\tif ( updateBuffers ) {\n\
\n\
\t\t\t// custom attributes\n\
\n\
\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\n\
\n\
\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\n\
\n\
\t\t\t\tfor ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\tattribute = geometryGroup.__webglCustomAttributesList[ i ];\n\
\n\
\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\n\
\n\
\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\n\
\t\t\t\t\t\tenableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\n\
\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\n\
\t\t\t// colors\n\
\n\
\t\t\tif ( attributes.color >= 0 ) {\n\
\n\
\t\t\t\tif ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\n\
\t\t\t\t\tenableAttribute( attributes.color );\n\
\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\
\n\
\n\
\t\t\t\t\t_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// normals\n\
\n\
\t\t\tif ( attributes.normal >= 0 ) {\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\n\
\t\t\t\tenableAttribute( attributes.normal );\n\
\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// tangents\n\
\n\
\t\t\tif ( attributes.tangent >= 0 ) {\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\n\
\t\t\t\tenableAttribute( attributes.tangent );\n\
\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// uvs\n\
\n\
\t\t\tif ( attributes.uv >= 0 ) {\n\
\n\
\t\t\t\tif ( object.geometry.faceVertexUvs[0] ) {\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\n\
\t\t\t\t\tenableAttribute( attributes.uv );\n\
\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\
\n\
\n\
\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( attributes.uv2 >= 0 ) {\n\
\n\
\t\t\t\tif ( object.geometry.faceVertexUvs[1] ) {\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\n\
\t\t\t\t\tenableAttribute( attributes.uv2 );\n\
\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\
\n\
\n\
\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( material.skinning &&\n\
\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\n\
\t\t\t\tenableAttribute( attributes.skinIndex );\n\
\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\n\
\t\t\t\tenableAttribute( attributes.skinWeight );\n\
\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// line distances\n\
\n\
\t\t\tif ( attributes.lineDistance >= 0 ) {\n\
\n\
\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\n\
\t\t\t\tenableAttribute( attributes.lineDistance );\n\
\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// render mesh\n\
\n\
\t\tif ( object instanceof THREE.Mesh ) {\n\
\n\
\t\t\t// wireframe\n\
\n\
\t\t\tif ( material.wireframe ) {\n\
\n\
\t\t\t\tsetLineWidth( material.wireframeLinewidth );\n\
\n\
\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\n\
\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );\n\
\n\
\t\t\t// triangles\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\n\
\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_this.info.render.calls ++;\n\
\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\n\
\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\n\
\n\
\t\t// render lines\n\
\n\
\t\t} else if ( object instanceof THREE.Line ) {\n\
\n\
\t\t\tvar primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\n\
\n\
\t\t\tsetLineWidth( material.linewidth );\n\
\n\
\t\t\t_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );\n\
\n\
\t\t\t_this.info.render.calls ++;\n\
\n\
\t\t// render particles\n\
\n\
\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\
\n\
\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\n\
\n\
\t\t\t_this.info.render.calls ++;\n\
\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\n\
\n\
\t\t// render ribbon\n\
\n\
\t\t} else if ( object instanceof THREE.Ribbon ) {\n\
\n\
\t\t\t_gl.drawArrays( _gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );\n\
\n\
\t\t\t_this.info.render.calls ++;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction enableAttribute( attribute ) {\n\
\n\
\t\tif ( ! _enabledAttributes[ attribute ] ) {\n\
\n\
\t\t\t_gl.enableVertexAttribArray( attribute );\n\
\t\t\t_enabledAttributes[ attribute ] = true;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction disableAttributes() {\n\
\n\
\t\tfor ( var attribute in _enabledAttributes ) {\n\
\n\
\t\t\tif ( _enabledAttributes[ attribute ] ) {\n\
\n\
\t\t\t\t_gl.disableVertexAttribArray( attribute );\n\
\t\t\t\t_enabledAttributes[ attribute ] = false;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction setupMorphTargets ( material, geometryGroup, object ) {\n\
\n\
\t\t// set base\n\
\n\
\t\tvar attributes = material.program.attributes;\n\
\n\
\t\tif ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\n\
\t\t\tenableAttribute( attributes.position );\n\
\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t} else if ( attributes.position >= 0 ) {\n\
\n\
\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\
\t\t\tenableAttribute( attributes.position );\n\
\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t}\n\
\n\
\t\tif ( object.morphTargetForcedOrder.length ) {\n\
\n\
\t\t\t// set forced order\n\
\n\
\t\t\tvar m = 0;\n\
\t\t\tvar order = object.morphTargetForcedOrder;\n\
\t\t\tvar influences = object.morphTargetInfluences;\n\
\n\
\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\n\
\n\
\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\n\
\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\n\
\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\n\
\n\
\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\n\
\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\n\
\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\n\
\n\
\t\t\t\tm ++;\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\t// find the most influencing\n\
\n\
\t\t\tvar influence, activeInfluenceIndices = [];\n\
\t\t\tvar influences = object.morphTargetInfluences;\n\
\t\t\tvar i, il = influences.length;\n\
\n\
\t\t\tfor ( i = 0; i < il; i ++ ) {\n\
\n\
\t\t\t\tinfluence = influences[ i ];\n\
\n\
\t\t\t\tif ( influence > 0 ) {\n\
\n\
\t\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\n\
\n\
\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\n\
\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\n\
\n\
\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\n\
\n\
\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\n\
\n\
\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\n\
\n\
\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\n\
\n\
\t\t\t};\n\
\n\
\t\t\tvar influenceIndex, m = 0;\n\
\n\
\t\t\twhile ( m < material.numSupportedMorphTargets ) {\n\
\n\
\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\n\
\n\
\t\t\t\t\tinfluenceIndex = activeInfluenceIndices[ m ][ 1 ];\n\
\n\
\t\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\n\
\n\
\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\n\
\t\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\n\
\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\n\
\n\
\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\n\
\t\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\n\
\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t/*\n\
\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t\tif ( material.morphNormals ) {\n\
\n\
\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\
\n\
\t\t\t\t\t}\n\
\t\t\t\t\t*/\n\
\n\
\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tm ++;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// load updated influences uniform\n\
\n\
\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\n\
\n\
\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Sorting\n\
\n\
\tfunction painterSortStable ( a, b ) {\n\
\n\
\t\tif ( a.z !== b.z ) {\n\
\n\
\t\t\treturn b.z - a.z;\n\
\n\
\t\t} else {\n\
\n\
\t\t\treturn a.id - b.id;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction numericalSort ( a, b ) {\n\
\n\
\t\treturn b[ 0 ] - a[ 0 ];\n\
\n\
\t};\n\
\n\
\n\
\t// Rendering\n\
\n\
\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\
\n\
\t\tif ( camera instanceof THREE.Camera === false ) {\n\
\n\
\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\
\t\t\treturn;\n\
\n\
\t\t}\n\
\n\
\t\tvar i, il,\n\
\n\
\t\twebglObject, object,\n\
\t\trenderList,\n\
\n\
\t\tlights = scene.__lights,\n\
\t\tfog = scene.fog;\n\
\n\
\t\t// reset caching for this frame\n\
\n\
\t\t_currentMaterialId = -1;\n\
\t\t_lightsNeedUpdate = true;\n\
\n\
\t\t// update scene graph\n\
\n\
\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\
\n\
\t\t// update camera matrices and frustum\n\
\n\
\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\
\n\
\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\
\n\
\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\
\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\
\n\
\t\t// update WebGL objects\n\
\n\
\t\tif ( this.autoUpdateObjects ) this.initWebGLObjects( scene );\n\
\n\
\t\t// custom render plugins (pre pass)\n\
\n\
\t\trenderPlugins( this.renderPluginsPre, scene, camera );\n\
\n\
\t\t//\n\
\n\
\t\t_this.info.render.calls = 0;\n\
\t\t_this.info.render.vertices = 0;\n\
\t\t_this.info.render.faces = 0;\n\
\t\t_this.info.render.points = 0;\n\
\n\
\t\tthis.setRenderTarget( renderTarget );\n\
\n\
\t\tif ( this.autoClear || forceClear ) {\n\
\n\
\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\
\n\
\t\t}\n\
\n\
\t\t// set matrices for regular objects (frustum culled)\n\
\n\
\t\trenderList = scene.__webglObjects;\n\
\n\
\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\n\
\n\
\t\t\twebglObject = renderList[ i ];\n\
\t\t\tobject = webglObject.object;\n\
\n\
\t\t\twebglObject.id = i;\n\
\t\t\twebglObject.render = false;\n\
\n\
\t\t\tif ( object.visible ) {\n\
\n\
\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\
\n\
\t\t\t\t\tsetupMatrices( object, camera );\n\
\n\
\t\t\t\t\tunrollBufferMaterial( webglObject );\n\
\n\
\t\t\t\t\twebglObject.render = true;\n\
\n\
\t\t\t\t\tif ( this.sortObjects === true ) {\n\
\n\
\t\t\t\t\t\tif ( object.renderDepth !== null ) {\n\
\n\
\t\t\t\t\t\t\twebglObject.z = object.renderDepth;\n\
\n\
\t\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\n\
\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\
\n\
\t\t\t\t\t\t\twebglObject.z = _vector3.z;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( this.sortObjects ) {\n\
\n\
\t\t\trenderList.sort( painterSortStable );\n\
\n\
\t\t}\n\
\n\
\t\t// set matrices for immediate objects\n\
\n\
\t\trenderList = scene.__webglObjectsImmediate;\n\
\n\
\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\n\
\n\
\t\t\twebglObject = renderList[ i ];\n\
\t\t\tobject = webglObject.object;\n\
\n\
\t\t\tif ( object.visible ) {\n\
\n\
\t\t\t\tsetupMatrices( object, camera );\n\
\n\
\t\t\t\tunrollImmediateBufferMaterial( webglObject );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( scene.overrideMaterial ) {\n\
\n\
\t\t\tvar material = scene.overrideMaterial;\n\
\n\
\t\t\tthis.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\
\t\t\tthis.setDepthTest( material.depthTest );\n\
\t\t\tthis.setDepthWrite( material.depthWrite );\n\
\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\
\n\
\t\t\trenderObjects( scene.__webglObjects, false, \"\", camera, lights, fog, true, material );\n\
\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"\", camera, lights, fog, false, material );\n\
\n\
\t\t} else {\n\
\n\
\t\t\tvar material = null;\n\
\n\
\t\t\t// opaque pass (front-to-back order)\n\
\n\
\t\t\tthis.setBlending( THREE.NoBlending );\n\
\n\
\t\t\trenderObjects( scene.__webglObjects, true, \"opaque\", camera, lights, fog, false, material );\n\
\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"opaque\", camera, lights, fog, false, material );\n\
\n\
\t\t\t// transparent pass (back-to-front order)\n\
\n\
\t\t\trenderObjects( scene.__webglObjects, false, \"transparent\", camera, lights, fog, true, material );\n\
\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"transparent\", camera, lights, fog, true, material );\n\
\n\
\t\t}\n\
\n\
\t\t// custom render plugins (post pass)\n\
\n\
\t\trenderPlugins( this.renderPluginsPost, scene, camera );\n\
\n\
\n\
\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\
\n\
\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\n\
\n\
\t\t\tupdateRenderTargetMipmap( renderTarget );\n\
\n\
\t\t}\n\
\n\
\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\
\n\
\t\tthis.setDepthTest( true );\n\
\t\tthis.setDepthWrite( true );\n\
\n\
\t\t// _gl.finish();\n\
\n\
\t};\n\
\n\
\tfunction renderPlugins( plugins, scene, camera ) {\n\
\n\
\t\tif ( ! plugins.length ) return;\n\
\n\
\t\tfor ( var i = 0, il = plugins.length; i < il; i ++ ) {\n\
\n\
\t\t\t// reset state for plugin (to start from clean slate)\n\
\n\
\t\t\t_currentProgram = null;\n\
\t\t\t_currentCamera = null;\n\
\n\
\t\t\t_oldBlending = -1;\n\
\t\t\t_oldDepthTest = -1;\n\
\t\t\t_oldDepthWrite = -1;\n\
\t\t\t_oldDoubleSided = -1;\n\
\t\t\t_oldFlipSided = -1;\n\
\t\t\t_currentGeometryGroupHash = -1;\n\
\t\t\t_currentMaterialId = -1;\n\
\n\
\t\t\t_lightsNeedUpdate = true;\n\
\n\
\t\t\tplugins[ i ].render( scene, camera, _currentWidth, _currentHeight );\n\
\n\
\t\t\t// reset state after plugin (anything could have changed)\n\
\n\
\t\t\t_currentProgram = null;\n\
\t\t\t_currentCamera = null;\n\
\n\
\t\t\t_oldBlending = -1;\n\
\t\t\t_oldDepthTest = -1;\n\
\t\t\t_oldDepthWrite = -1;\n\
\t\t\t_oldDoubleSided = -1;\n\
\t\t\t_oldFlipSided = -1;\n\
\t\t\t_currentGeometryGroupHash = -1;\n\
\t\t\t_currentMaterialId = -1;\n\
\n\
\t\t\t_lightsNeedUpdate = true;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\n\
\n\
\t\tvar webglObject, object, buffer, material, start, end, delta;\n\
\n\
\t\tif ( reverse ) {\n\
\n\
\t\t\tstart = renderList.length - 1;\n\
\t\t\tend = -1;\n\
\t\t\tdelta = -1;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tstart = 0;\n\
\t\t\tend = renderList.length;\n\
\t\t\tdelta = 1;\n\
\t\t}\n\
\n\
\t\tfor ( var i = start; i !== end; i += delta ) {\n\
\n\
\t\t\twebglObject = renderList[ i ];\n\
\n\
\t\t\tif ( webglObject.render ) {\n\
\n\
\t\t\t\tobject = webglObject.object;\n\
\t\t\t\tbuffer = webglObject.buffer;\n\
\n\
\t\t\t\tif ( overrideMaterial ) {\n\
\n\
\t\t\t\t\tmaterial = overrideMaterial;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tmaterial = webglObject[ materialType ];\n\
\n\
\t\t\t\t\tif ( ! material ) continue;\n\
\n\
\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\
\n\
\t\t\t\t\t_this.setDepthTest( material.depthTest );\n\
\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\n\
\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_this.setMaterialFaces( material );\n\
\n\
\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\
\n\
\t\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\n\
\n\
\t\tvar webglObject, object, material, program;\n\
\n\
\t\tfor ( var i = 0, il = renderList.length; i < il; i ++ ) {\n\
\n\
\t\t\twebglObject = renderList[ i ];\n\
\t\t\tobject = webglObject.object;\n\
\n\
\t\t\tif ( object.visible ) {\n\
\n\
\t\t\t\tif ( overrideMaterial ) {\n\
\n\
\t\t\t\t\tmaterial = overrideMaterial;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tmaterial = webglObject[ materialType ];\n\
\n\
\t\t\t\t\tif ( ! material ) continue;\n\
\n\
\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\
\n\
\t\t\t\t\t_this.setDepthTest( material.depthTest );\n\
\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\n\
\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\n\
\n\
\t\tvar program = setProgram( camera, lights, fog, material, object );\n\
\n\
\t\t_currentGeometryGroupHash = -1;\n\
\n\
\t\t_this.setMaterialFaces( material );\n\
\n\
\t\tif ( object.immediateRenderCallback ) {\n\
\n\
\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\n\
\n\
\t\t} else {\n\
\n\
\t\t\tobject.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction unrollImmediateBufferMaterial ( globject ) {\n\
\n\
\t\tvar object = globject.object,\n\
\t\t\tmaterial = object.material;\n\
\n\
\t\tif ( material.transparent ) {\n\
\n\
\t\t\tglobject.transparent = material;\n\
\t\t\tglobject.opaque = null;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tglobject.opaque = material;\n\
\t\t\tglobject.transparent = null;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction unrollBufferMaterial ( globject ) {\n\
\n\
\t\tvar object = globject.object,\n\
\t\t\tbuffer = globject.buffer,\n\
\t\t\tmaterial, materialIndex, meshMaterial;\n\
\n\
\t\tmeshMaterial = object.material;\n\
\n\
\t\tif ( meshMaterial instanceof THREE.MeshFaceMaterial ) {\n\
\n\
\t\t\tmaterialIndex = buffer.materialIndex;\n\
\n\
\t\t\tmaterial = meshMaterial.materials[ materialIndex ];\n\
\n\
\t\t\tif ( material.transparent ) {\n\
\n\
\t\t\t\tglobject.transparent = material;\n\
\t\t\t\tglobject.opaque = null;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tglobject.opaque = material;\n\
\t\t\t\tglobject.transparent = null;\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tmaterial = meshMaterial;\n\
\n\
\t\t\tif ( material ) {\n\
\n\
\t\t\t\tif ( material.transparent ) {\n\
\n\
\t\t\t\t\tglobject.transparent = material;\n\
\t\t\t\t\tglobject.opaque = null;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tglobject.opaque = material;\n\
\t\t\t\t\tglobject.transparent = null;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Geometry splitting\n\
\n\
\tfunction sortFacesByMaterial ( geometry, material ) {\n\
\n\
\t\tvar f, fl, face, materialIndex, vertices,\n\
\t\t\tgroupHash, hash_map = {};\n\
\n\
\t\tvar numMorphTargets = geometry.morphTargets.length;\n\
\t\tvar numMorphNormals = geometry.morphNormals.length;\n\
\n\
\t\tvar usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n\
\n\
\t\tgeometry.geometryGroups = {};\n\
\n\
\t\tfor ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\
\n\
\t\t\tface = geometry.faces[ f ];\n\
\t\t\tmaterialIndex = usesFaceMaterial ? face.materialIndex : 0;\n\
\n\
\t\t\tif ( hash_map[ materialIndex ] === undefined ) {\n\
\n\
\t\t\t\thash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };\n\
\n\
\t\t\t}\n\
\n\
\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\n\
\n\
\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\n\
\n\
\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvertices = 3;\n\
\n\
\t\t\tif ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {\n\
\n\
\t\t\t\thash_map[ materialIndex ].counter += 1;\n\
\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\n\
\n\
\t\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\n\
\n\
\t\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tgeometry.geometryGroups[ groupHash ].faces3.push( f );\n\
\t\t\tgeometry.geometryGroups[ groupHash ].vertices += vertices;\n\
\n\
\t\t}\n\
\n\
\t\tgeometry.geometryGroupsList = [];\n\
\n\
\t\tfor ( var g in geometry.geometryGroups ) {\n\
\n\
\t\t\tgeometry.geometryGroups[ g ].id = _geometryGroupCounter ++;\n\
\n\
\t\t\tgeometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Objects refresh\n\
\n\
\tthis.initWebGLObjects = function ( scene ) {\n\
\n\
\t\tif ( !scene.__webglObjects ) {\n\
\n\
\t\t\tscene.__webglObjects = [];\n\
\t\t\tscene.__webglObjectsImmediate = [];\n\
\t\t\tscene.__webglSprites = [];\n\
\t\t\tscene.__webglFlares = [];\n\
\n\
\t\t}\n\
\n\
\t\twhile ( scene.__objectsAdded.length ) {\n\
\n\
\t\t\taddObject( scene.__objectsAdded[ 0 ], scene );\n\
\t\t\tscene.__objectsAdded.splice( 0, 1 );\n\
\n\
\t\t}\n\
\n\
\t\twhile ( scene.__objectsRemoved.length ) {\n\
\n\
\t\t\tremoveObject( scene.__objectsRemoved[ 0 ], scene );\n\
\t\t\tscene.__objectsRemoved.splice( 0, 1 );\n\
\n\
\t\t}\n\
\n\
\t\t// update must be called after objects adding / removal\n\
\n\
\t\tfor ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {\n\
\n\
\t\t\tvar object = scene.__webglObjects[ o ].object;\n\
\n\
\t\t\t// TODO: Remove this hack (WebGLRenderer refactoring)\n\
\n\
\t\t\tif ( object.__webglInit === undefined ) {\n\
\n\
\t\t\t\tif ( object.__webglActive !== undefined ) {\n\
\n\
\t\t\t\t\tremoveObject( object, scene );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\taddObject( object, scene );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tupdateObject( object );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Objects adding\n\
\n\
\tfunction addObject( object, scene ) {\n\
\n\
\t\tvar g, geometry, material, geometryGroup;\n\
\n\
\t\tif ( object.__webglInit === undefined ) {\n\
\n\
\t\t\tobject.__webglInit = true;\n\
\n\
\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\n\
\t\t\tobject._normalMatrix = new THREE.Matrix3();\n\
\n\
\t\t\tif ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {\n\
\n\
\t\t\t\tobject.geometry.__webglInit = true;\n\
\t\t\t\tobject.geometry.addEventListener( 'dispose', onGeometryDispose );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tgeometry = object.geometry;\n\
\n\
\t\t\tif ( geometry === undefined ) {\n\
\n\
\t\t\t\t// fail silently for now\n\
\n\
\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\
\n\
\t\t\t\tinitDirectBuffers( geometry );\n\
\n\
\t\t\t} else if ( object instanceof THREE.Mesh ) {\n\
\n\
\t\t\t\tmaterial = object.material;\n\
\n\
\t\t\t\tif ( geometry.geometryGroups === undefined ) {\n\
\n\
\t\t\t\t\tsortFacesByMaterial( geometry, material );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// create separate VBOs per geometry chunk\n\
\n\
\t\t\t\tfor ( g in geometry.geometryGroups ) {\n\
\n\
\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\n\
\n\
\t\t\t\t\t// initialise VBO on the first access\n\
\n\
\t\t\t\t\tif ( ! geometryGroup.__webglVertexBuffer ) {\n\
\n\
\t\t\t\t\t\tcreateMeshBuffers( geometryGroup );\n\
\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\n\
\n\
\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\
\t\t\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\n\
\t\t\t\t\t\tgeometry.elementsNeedUpdate = true;\n\
\t\t\t\t\t\tgeometry.uvsNeedUpdate = true;\n\
\t\t\t\t\t\tgeometry.normalsNeedUpdate = true;\n\
\t\t\t\t\t\tgeometry.tangentsNeedUpdate = true;\n\
\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( object instanceof THREE.Ribbon ) {\n\
\n\
\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\
\n\
\t\t\t\t\tcreateRibbonBuffers( geometry );\n\
\t\t\t\t\tinitRibbonBuffers( geometry, object );\n\
\n\
\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\
\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\
\t\t\t\t\tgeometry.normalsNeedUpdate = true;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( object instanceof THREE.Line ) {\n\
\n\
\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\
\n\
\t\t\t\t\tcreateLineBuffers( geometry );\n\
\t\t\t\t\tinitLineBuffers( geometry, object );\n\
\n\
\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\
\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\
\t\t\t\t\tgeometry.lineDistancesNeedUpdate = true;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\
\n\
\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\
\n\
\t\t\t\t\tcreateParticleBuffers( geometry );\n\
\t\t\t\t\tinitParticleBuffers( geometry, object );\n\
\n\
\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\
\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( object.__webglActive === undefined ) {\n\
\n\
\t\t\tif ( object instanceof THREE.Mesh ) {\n\
\n\
\t\t\t\tgeometry = object.geometry;\n\
\n\
\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\
\n\
\t\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\n\
\n\
\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\
\n\
\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\n\
\n\
\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\n\
\n\
\t\t\t\t\t\taddBuffer( scene.__webglObjects, geometryGroup, object );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( object instanceof THREE.Ribbon ||\n\
\t\t\t\t\t\tobject instanceof THREE.Line ||\n\
\t\t\t\t\t\tobject instanceof THREE.ParticleSystem ) {\n\
\n\
\t\t\t\tgeometry = object.geometry;\n\
\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\n\
\n\
\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\n\
\n\
\t\t\t\taddBufferImmediate( scene.__webglObjectsImmediate, object );\n\
\n\
\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\
\n\
\t\t\t\tscene.__webglSprites.push( object );\n\
\n\
\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\
\n\
\t\t\t\tscene.__webglFlares.push( object );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tobject.__webglActive = true;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction addBuffer( objlist, buffer, object ) {\n\
\n\
\t\tobjlist.push(\n\
\t\t\t{\n\
\t\t\t\tid: null,\n\
\t\t\t\tbuffer: buffer,\n\
\t\t\t\tobject: object,\n\
\t\t\t\topaque: null,\n\
\t\t\t\ttransparent: null,\n\
\t\t\t\tz: 0\n\
\t\t\t}\n\
\t\t);\n\
\n\
\t};\n\
\n\
\tfunction addBufferImmediate( objlist, object ) {\n\
\n\
\t\tobjlist.push(\n\
\t\t\t{\n\
\t\t\t\tid: null,\n\
\t\t\t\tobject: object,\n\
\t\t\t\topaque: null,\n\
\t\t\t\ttransparent: null,\n\
\t\t\t\tz: 0\n\
\t\t\t}\n\
\t\t);\n\
\n\
\t};\n\
\n\
\t// Objects updates\n\
\n\
\tfunction updateObject( object ) {\n\
\n\
\t\tvar geometry = object.geometry,\n\
\t\t\tgeometryGroup, customAttributesDirty, material;\n\
\n\
\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\
\n\
\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\n\
\n\
\t\t} else if ( object instanceof THREE.Mesh ) {\n\
\n\
\t\t\t// check all geometry groups\n\
\n\
\t\t\tfor( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tgeometryGroup = geometry.geometryGroupsList[ i ];\n\
\n\
\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\n\
\n\
\t\t\t\tif ( geometry.buffersNeedUpdate ) {\n\
\n\
\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\
\n\
\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\n\
\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\n\
\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\n\
\n\
\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tgeometry.verticesNeedUpdate = false;\n\
\t\t\tgeometry.morphTargetsNeedUpdate = false;\n\
\t\t\tgeometry.elementsNeedUpdate = false;\n\
\t\t\tgeometry.uvsNeedUpdate = false;\n\
\t\t\tgeometry.normalsNeedUpdate = false;\n\
\t\t\tgeometry.colorsNeedUpdate = false;\n\
\t\t\tgeometry.tangentsNeedUpdate = false;\n\
\n\
\t\t\tgeometry.buffersNeedUpdate = false;\n\
\n\
\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\
\n\
\t\t} else if ( object instanceof THREE.Ribbon ) {\n\
\n\
\t\t\tmaterial = getBufferMaterial( object, geometry );\n\
\n\
\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\
\n\
\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate || customAttributesDirty ) {\n\
\n\
\t\t\t\tsetRibbonBuffers( geometry, _gl.DYNAMIC_DRAW );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tgeometry.verticesNeedUpdate = false;\n\
\t\t\tgeometry.colorsNeedUpdate = false;\n\
\t\t\tgeometry.normalsNeedUpdate = false;\n\
\n\
\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\
\n\
\t\t} else if ( object instanceof THREE.Line ) {\n\
\n\
\t\t\tmaterial = getBufferMaterial( object, geometry );\n\
\n\
\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\
\n\
\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\n\
\n\
\t\t\t\tsetLineBuffers( geometry, _gl.DYNAMIC_DRAW );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tgeometry.verticesNeedUpdate = false;\n\
\t\t\tgeometry.colorsNeedUpdate = false;\n\
\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\
\n\
\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\
\n\
\n\
\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\
\n\
\t\t\tmaterial = getBufferMaterial( object, geometry );\n\
\n\
\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\
\n\
\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {\n\
\n\
\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tgeometry.verticesNeedUpdate = false;\n\
\t\t\tgeometry.colorsNeedUpdate = false;\n\
\n\
\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Objects updates - custom attributes check\n\
\n\
\tfunction areCustomAttributesDirty( material ) {\n\
\n\
\t\tfor ( var a in material.attributes ) {\n\
\n\
\t\t\tif ( material.attributes[ a ].needsUpdate ) return true;\n\
\n\
\t\t}\n\
\n\
\t\treturn false;\n\
\n\
\t};\n\
\n\
\tfunction clearCustomAttributes( material ) {\n\
\n\
\t\tfor ( var a in material.attributes ) {\n\
\n\
\t\t\tmaterial.attributes[ a ].needsUpdate = false;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Objects removal\n\
\n\
\tfunction removeObject( object, scene ) {\n\
\n\
\t\tif ( object instanceof THREE.Mesh  ||\n\
\t\t\t object instanceof THREE.ParticleSystem ||\n\
\t\t\t object instanceof THREE.Ribbon ||\n\
\t\t\t object instanceof THREE.Line ) {\n\
\n\
\t\t\tremoveInstances( scene.__webglObjects, object );\n\
\n\
\t\t} else if ( object instanceof THREE.Sprite ) {\n\
\n\
\t\t\tremoveInstancesDirect( scene.__webglSprites, object );\n\
\n\
\t\t} else if ( object instanceof THREE.LensFlare ) {\n\
\n\
\t\t\tremoveInstancesDirect( scene.__webglFlares, object );\n\
\n\
\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\n\
\n\
\t\t\tremoveInstances( scene.__webglObjectsImmediate, object );\n\
\n\
\t\t}\n\
\n\
\t\tdelete object.__webglActive;\n\
\n\
\t};\n\
\n\
\tfunction removeInstances( objlist, object ) {\n\
\n\
\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\n\
\n\
\t\t\tif ( objlist[ o ].object === object ) {\n\
\n\
\t\t\t\tobjlist.splice( o, 1 );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction removeInstancesDirect( objlist, object ) {\n\
\n\
\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\n\
\n\
\t\t\tif ( objlist[ o ] === object ) {\n\
\n\
\t\t\t\tobjlist.splice( o, 1 );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Materials\n\
\n\
\tthis.initMaterial = function ( material, lights, fog, object ) {\n\
\n\
\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\
\n\
\t\tvar u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;\n\
\n\
\t\tif ( material instanceof THREE.MeshDepthMaterial ) {\n\
\n\
\t\t\tshaderID = 'depth';\n\
\n\
\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\
\n\
\t\t\tshaderID = 'normal';\n\
\n\
\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\n\
\n\
\t\t\tshaderID = 'basic';\n\
\n\
\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\
\n\
\t\t\tshaderID = 'lambert';\n\
\n\
\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\
\n\
\t\t\tshaderID = 'phong';\n\
\n\
\t\t} else if ( material instanceof THREE.LineBasicMaterial ) {\n\
\n\
\t\t\tshaderID = 'basic';\n\
\n\
\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\
\n\
\t\t\tshaderID = 'dashed';\n\
\n\
\t\t} else if ( material instanceof THREE.ParticleBasicMaterial ) {\n\
\n\
\t\t\tshaderID = 'particle_basic';\n\
\n\
\t\t}\n\
\n\
\t\tif ( shaderID ) {\n\
\n\
\t\t\tsetMaterialShaders( material, THREE.ShaderLib[ shaderID ] );\n\
\n\
\t\t}\n\
\n\
\t\t// heuristics to create shader parameters according to lights in the scene\n\
\t\t// (not to blow over maxLights budget)\n\
\n\
\t\tmaxLightCount = allocateLights( lights );\n\
\n\
\t\tmaxShadows = allocateShadows( lights );\n\
\n\
\t\tmaxBones = allocateBones( object );\n\
\n\
\t\tparameters = {\n\
\n\
\t\t\tmap: !!material.map,\n\
\t\t\tenvMap: !!material.envMap,\n\
\t\t\tlightMap: !!material.lightMap,\n\
\t\t\tbumpMap: !!material.bumpMap,\n\
\t\t\tnormalMap: !!material.normalMap,\n\
\t\t\tspecularMap: !!material.specularMap,\n\
\n\
\t\t\tvertexColors: material.vertexColors,\n\
\n\
\t\t\tfog: fog,\n\
\t\t\tuseFog: material.fog,\n\
\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\
\n\
\t\t\tsizeAttenuation: material.sizeAttenuation,\n\
\n\
\t\t\tskinning: material.skinning,\n\
\t\t\tmaxBones: maxBones,\n\
\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,\n\
\t\t\tboneTextureWidth: object && object.boneTextureWidth,\n\
\t\t\tboneTextureHeight: object && object.boneTextureHeight,\n\
\n\
\t\t\tmorphTargets: material.morphTargets,\n\
\t\t\tmorphNormals: material.morphNormals,\n\
\t\t\tmaxMorphTargets: this.maxMorphTargets,\n\
\t\t\tmaxMorphNormals: this.maxMorphNormals,\n\
\n\
\t\t\tmaxDirLights: maxLightCount.directional,\n\
\t\t\tmaxPointLights: maxLightCount.point,\n\
\t\t\tmaxSpotLights: maxLightCount.spot,\n\
\t\t\tmaxHemiLights: maxLightCount.hemi,\n\
\n\
\t\t\tmaxShadows: maxShadows,\n\
\t\t\tshadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,\n\
\t\t\tshadowMapType: this.shadowMapType,\n\
\t\t\tshadowMapDebug: this.shadowMapDebug,\n\
\t\t\tshadowMapCascade: this.shadowMapCascade,\n\
\n\
\t\t\talphaTest: material.alphaTest,\n\
\t\t\tmetal: material.metal,\n\
\t\t\tperPixel: material.perPixel,\n\
\t\t\twrapAround: material.wrapAround,\n\
\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\
\t\t\tflipSided: material.side === THREE.BackSide\n\
\n\
\t\t};\n\
\n\
\t\tmaterial.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName );\n\
\n\
\t\tvar attributes = material.program.attributes;\n\
\n\
\t\tif ( material.morphTargets ) {\n\
\n\
\t\t\tmaterial.numSupportedMorphTargets = 0;\n\
\n\
\t\t\tvar id, base = \"morphTarget\";\n\
\n\
\t\t\tfor ( i = 0; i < this.maxMorphTargets; i ++ ) {\n\
\n\
\t\t\t\tid = base + i;\n\
\n\
\t\t\t\tif ( attributes[ id ] >= 0 ) {\n\
\n\
\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( material.morphNormals ) {\n\
\n\
\t\t\tmaterial.numSupportedMorphNormals = 0;\n\
\n\
\t\t\tvar id, base = \"morphNormal\";\n\
\n\
\t\t\tfor ( i = 0; i < this.maxMorphNormals; i ++ ) {\n\
\n\
\t\t\t\tid = base + i;\n\
\n\
\t\t\t\tif ( attributes[ id ] >= 0 ) {\n\
\n\
\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tmaterial.uniformsList = [];\n\
\n\
\t\tfor ( u in material.uniforms ) {\n\
\n\
\t\t\tmaterial.uniformsList.push( [ material.uniforms[ u ], u ] );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction setMaterialShaders( material, shaders ) {\n\
\n\
\t\tmaterial.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );\n\
\t\tmaterial.vertexShader = shaders.vertexShader;\n\
\t\tmaterial.fragmentShader = shaders.fragmentShader;\n\
\n\
\t};\n\
\n\
\tfunction setProgram( camera, lights, fog, material, object ) {\n\
\n\
\t\t_usedTextureUnits = 0;\n\
\n\
\t\tif ( material.needsUpdate ) {\n\
\n\
\t\t\tif ( material.program ) deallocateMaterial( material );\n\
\n\
\t\t\t_this.initMaterial( material, lights, fog, object );\n\
\t\t\tmaterial.needsUpdate = false;\n\
\n\
\t\t}\n\
\n\
\t\tif ( material.morphTargets ) {\n\
\n\
\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\n\
\n\
\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tvar refreshMaterial = false;\n\
\n\
\t\tvar program = material.program,\n\
\t\t\tp_uniforms = program.uniforms,\n\
\t\t\tm_uniforms = material.uniforms;\n\
\n\
\t\tif ( program !== _currentProgram ) {\n\
\n\
\t\t\t_gl.useProgram( program );\n\
\t\t\t_currentProgram = program;\n\
\n\
\t\t\trefreshMaterial = true;\n\
\n\
\t\t}\n\
\n\
\t\tif ( material.id !== _currentMaterialId ) {\n\
\n\
\t\t\t_currentMaterialId = material.id;\n\
\t\t\trefreshMaterial = true;\n\
\n\
\t\t}\n\
\n\
\t\tif ( refreshMaterial || camera !== _currentCamera ) {\n\
\n\
\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\
\n\
\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\n\
\n\
\t\t}\n\
\n\
\t\t// skinning uniforms must be set even if material didn't change\n\
\t\t// auto-setting of texture unit for bone texture must go before other textures\n\
\t\t// not sure why, but otherwise weird things happen\n\
\n\
\t\tif ( material.skinning ) {\n\
\n\
\t\t\tif ( _supportsBoneTextures && object.useVertexTexture ) {\n\
\n\
\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\n\
\n\
\t\t\t\t\tvar textureUnit = getTextureUnit();\n\
\n\
\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\n\
\t\t\t\t\t_this.setTexture( object.boneTexture, textureUnit );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\n\
\n\
\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( refreshMaterial ) {\n\
\n\
\t\t\t// refresh uniforms common to several materials\n\
\n\
\t\t\tif ( fog && material.fog ) {\n\
\n\
\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\
\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\
\t\t\t\t material.lights ) {\n\
\n\
\t\t\t\tif ( _lightsNeedUpdate ) {\n\
\n\
\t\t\t\t\tsetupLights( program, lights );\n\
\t\t\t\t\t_lightsNeedUpdate = false;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\
\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\
\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\n\
\n\
\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// refresh single material specific uniforms\n\
\n\
\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\
\n\
\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\
\n\
\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\
\n\
\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\
\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\
\n\
\t\t\t} else if ( material instanceof THREE.ParticleBasicMaterial ) {\n\
\n\
\t\t\t\trefreshUniformsParticle( m_uniforms, material );\n\
\n\
\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\
\n\
\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\
\n\
\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\
\n\
\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\
\n\
\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\
\n\
\t\t\t\tm_uniforms.mNear.value = camera.near;\n\
\t\t\t\tm_uniforms.mFar.value = camera.far;\n\
\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\
\n\
\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\
\n\
\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\n\
\n\
\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// load common uniforms\n\
\n\
\t\t\tloadUniformsGeneric( program, material.uniformsList );\n\
\n\
\t\t\t// load material specific uniforms\n\
\t\t\t// (shader material also gets them for the sake of genericity)\n\
\n\
\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\
\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\
\t\t\t\t material.envMap ) {\n\
\n\
\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\n\
\n\
\t\t\t\t\t_vector3.getPositionFromMatrix( camera.matrixWorld );\n\
\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\
\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\
\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\
\t\t\t\t material.skinning ) {\n\
\n\
\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\n\
\n\
\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tloadUniformsMatrices( p_uniforms, object );\n\
\n\
\t\tif ( p_uniforms.modelMatrix !== null ) {\n\
\n\
\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\n\
\n\
\t\t}\n\
\n\
\t\treturn program;\n\
\n\
\t};\n\
\n\
\t// Uniforms (refresh uniforms objects)\n\
\n\
\tfunction refreshUniformsCommon ( uniforms, material ) {\n\
\n\
\t\tuniforms.opacity.value = material.opacity;\n\
\n\
\t\tif ( _this.gammaInput ) {\n\
\n\
\t\t\tuniforms.diffuse.value.copyGammaToLinear( material.color );\n\
\n\
\t\t} else {\n\
\n\
\t\t\tuniforms.diffuse.value = material.color;\n\
\n\
\t\t}\n\
\n\
\t\tuniforms.map.value = material.map;\n\
\t\tuniforms.lightMap.value = material.lightMap;\n\
\t\tuniforms.specularMap.value = material.specularMap;\n\
\n\
\t\tif ( material.bumpMap ) {\n\
\n\
\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\
\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\
\n\
\t\t}\n\
\n\
\t\tif ( material.normalMap ) {\n\
\n\
\t\t\tuniforms.normalMap.value = material.normalMap;\n\
\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\
\n\
\t\t}\n\
\n\
\t\t// uv repeat and offset setting priorities\n\
\t\t//\t1. color map\n\
\t\t//\t2. specular map\n\
\t\t//\t3. normal map\n\
\t\t//\t4. bump map\n\
\n\
\t\tvar uvScaleMap;\n\
\n\
\t\tif ( material.map ) {\n\
\n\
\t\t\tuvScaleMap = material.map;\n\
\n\
\t\t} else if ( material.specularMap ) {\n\
\n\
\t\t\tuvScaleMap = material.specularMap;\n\
\n\
\t\t} else if ( material.normalMap ) {\n\
\n\
\t\t\tuvScaleMap = material.normalMap;\n\
\n\
\t\t} else if ( material.bumpMap ) {\n\
\n\
\t\t\tuvScaleMap = material.bumpMap;\n\
\n\
\t\t}\n\
\n\
\t\tif ( uvScaleMap !== undefined ) {\n\
\n\
\t\t\tvar offset = uvScaleMap.offset;\n\
\t\t\tvar repeat = uvScaleMap.repeat;\n\
\n\
\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\
\n\
\t\t}\n\
\n\
\t\tuniforms.envMap.value = material.envMap;\n\
\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;\n\
\n\
\t\tif ( _this.gammaInput ) {\n\
\n\
\t\t\t//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;\n\
\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\
\n\
\t\t}\n\
\n\
\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\
\t\tuniforms.combine.value = material.combine;\n\
\t\tuniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;\n\
\n\
\t};\n\
\n\
\tfunction refreshUniformsLine ( uniforms, material ) {\n\
\n\
\t\tuniforms.diffuse.value = material.color;\n\
\t\tuniforms.opacity.value = material.opacity;\n\
\n\
\t};\n\
\n\
\tfunction refreshUniformsDash ( uniforms, material ) {\n\
\n\
\t\tuniforms.dashSize.value = material.dashSize;\n\
\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\
\t\tuniforms.scale.value = material.scale;\n\
\n\
\t};\n\
\n\
\tfunction refreshUniformsParticle ( uniforms, material ) {\n\
\n\
\t\tuniforms.psColor.value = material.color;\n\
\t\tuniforms.opacity.value = material.opacity;\n\
\t\tuniforms.size.value = material.size;\n\
\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\n\
\n\
\t\tuniforms.map.value = material.map;\n\
\n\
\t};\n\
\n\
\tfunction refreshUniformsFog ( uniforms, fog ) {\n\
\n\
\t\tuniforms.fogColor.value = fog.color;\n\
\n\
\t\tif ( fog instanceof THREE.Fog ) {\n\
\n\
\t\t\tuniforms.fogNear.value = fog.near;\n\
\t\t\tuniforms.fogFar.value = fog.far;\n\
\n\
\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\
\n\
\t\t\tuniforms.fogDensity.value = fog.density;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction refreshUniformsPhong ( uniforms, material ) {\n\
\n\
\t\tuniforms.shininess.value = material.shininess;\n\
\n\
\t\tif ( _this.gammaInput ) {\n\
\n\
\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\n\
\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\n\
\t\t\tuniforms.specular.value.copyGammaToLinear( material.specular );\n\
\n\
\t\t} else {\n\
\n\
\t\t\tuniforms.ambient.value = material.ambient;\n\
\t\t\tuniforms.emissive.value = material.emissive;\n\
\t\t\tuniforms.specular.value = material.specular;\n\
\n\
\t\t}\n\
\n\
\t\tif ( material.wrapAround ) {\n\
\n\
\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction refreshUniformsLambert ( uniforms, material ) {\n\
\n\
\t\tif ( _this.gammaInput ) {\n\
\n\
\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\n\
\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\n\
\n\
\t\t} else {\n\
\n\
\t\t\tuniforms.ambient.value = material.ambient;\n\
\t\t\tuniforms.emissive.value = material.emissive;\n\
\n\
\t\t}\n\
\n\
\t\tif ( material.wrapAround ) {\n\
\n\
\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction refreshUniformsLights ( uniforms, lights ) {\n\
\n\
\t\tuniforms.ambientLightColor.value = lights.ambient;\n\
\n\
\t\tuniforms.directionalLightColor.value = lights.directional.colors;\n\
\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\n\
\n\
\t\tuniforms.pointLightColor.value = lights.point.colors;\n\
\t\tuniforms.pointLightPosition.value = lights.point.positions;\n\
\t\tuniforms.pointLightDistance.value = lights.point.distances;\n\
\n\
\t\tuniforms.spotLightColor.value = lights.spot.colors;\n\
\t\tuniforms.spotLightPosition.value = lights.spot.positions;\n\
\t\tuniforms.spotLightDistance.value = lights.spot.distances;\n\
\t\tuniforms.spotLightDirection.value = lights.spot.directions;\n\
\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\n\
\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\n\
\n\
\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\n\
\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\n\
\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\n\
\n\
\t};\n\
\n\
\tfunction refreshUniformsShadow ( uniforms, lights ) {\n\
\n\
\t\tif ( uniforms.shadowMatrix ) {\n\
\n\
\t\t\tvar j = 0;\n\
\n\
\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tvar light = lights[ i ];\n\
\n\
\t\t\t\tif ( ! light.castShadow ) continue;\n\
\n\
\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\n\
\n\
\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\n\
\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\n\
\n\
\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\n\
\n\
\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\n\
\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\n\
\n\
\t\t\t\t\tj ++;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Uniforms (load to GPU)\n\
\n\
\tfunction loadUniformsMatrices ( uniforms, object ) {\n\
\n\
\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\n\
\n\
\t\tif ( uniforms.normalMatrix ) {\n\
\n\
\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction getTextureUnit() {\n\
\n\
\t\tvar textureUnit = _usedTextureUnits;\n\
\n\
\t\tif ( textureUnit >= _maxTextures ) {\n\
\n\
\t\t\tconsole.warn( \"WebGLRenderer: trying to use \" + textureUnit + \" texture units while this GPU supports only \" + _maxTextures );\n\
\n\
\t\t}\n\
\n\
\t\t_usedTextureUnits += 1;\n\
\n\
\t\treturn textureUnit;\n\
\n\
\t};\n\
\n\
\tfunction loadUniformsGeneric ( program, uniforms ) {\n\
\n\
\t\tvar uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;\n\
\n\
\t\tfor ( j = 0, jl = uniforms.length; j < jl; j ++ ) {\n\
\n\
\t\t\tlocation = program.uniforms[ uniforms[ j ][ 1 ] ];\n\
\t\t\tif ( !location ) continue;\n\
\n\
\t\t\tuniform = uniforms[ j ][ 0 ];\n\
\n\
\t\t\ttype = uniform.type;\n\
\t\t\tvalue = uniform.value;\n\
\n\
\t\t\tif ( type === \"i\" ) { // single integer\n\
\n\
\t\t\t\t_gl.uniform1i( location, value );\n\
\n\
\t\t\t} else if ( type === \"f\" ) { // single float\n\
\n\
\t\t\t\t_gl.uniform1f( location, value );\n\
\n\
\t\t\t} else if ( type === \"v2\" ) { // single THREE.Vector2\n\
\n\
\t\t\t\t_gl.uniform2f( location, value.x, value.y );\n\
\n\
\t\t\t} else if ( type === \"v3\" ) { // single THREE.Vector3\n\
\n\
\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\n\
\n\
\t\t\t} else if ( type === \"v4\" ) { // single THREE.Vector4\n\
\n\
\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\n\
\n\
\t\t\t} else if ( type === \"c\" ) { // single THREE.Color\n\
\n\
\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\n\
\n\
\t\t\t} else if ( type === \"iv1\" ) { // flat array of integers (JS or typed array)\n\
\n\
\t\t\t\t_gl.uniform1iv( location, value );\n\
\n\
\t\t\t} else if ( type === \"iv\" ) { // flat array of integers with 3 x N size (JS or typed array)\n\
\n\
\t\t\t\t_gl.uniform3iv( location, value );\n\
\n\
\t\t\t} else if ( type === \"fv1\" ) { // flat array of floats (JS or typed array)\n\
\n\
\t\t\t\t_gl.uniform1fv( location, value );\n\
\n\
\t\t\t} else if ( type === \"fv\" ) { // flat array of floats with 3 x N size (JS or typed array)\n\
\n\
\t\t\t\t_gl.uniform3fv( location, value );\n\
\n\
\t\t\t} else if ( type === \"v2v\" ) { // array of THREE.Vector2\n\
\n\
\t\t\t\tif ( uniform._array === undefined ) {\n\
\n\
\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\toffset = i * 2;\n\
\n\
\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\
\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_gl.uniform2fv( location, uniform._array );\n\
\n\
\t\t\t} else if ( type === \"v3v\" ) { // array of THREE.Vector3\n\
\n\
\t\t\t\tif ( uniform._array === undefined ) {\n\
\n\
\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\toffset = i * 3;\n\
\n\
\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\
\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\
\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_gl.uniform3fv( location, uniform._array );\n\
\n\
\t\t\t} else if ( type === \"v4v\" ) { // array of THREE.Vector4\n\
\n\
\t\t\t\tif ( uniform._array === undefined ) {\n\
\n\
\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\toffset = i * 4;\n\
\n\
\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\
\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\
\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\n\
\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_gl.uniform4fv( location, uniform._array );\n\
\n\
\t\t\t} else if ( type === \"m4\") { // single THREE.Matrix4\n\
\n\
\t\t\t\tif ( uniform._array === undefined ) {\n\
\n\
\t\t\t\t\tuniform._array = new Float32Array( 16 );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tvalue.flattenToArray( uniform._array );\n\
\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\n\
\n\
\t\t\t} else if ( type === \"m4v\" ) { // array of THREE.Matrix4\n\
\n\
\t\t\t\tif ( uniform._array === undefined ) {\n\
\n\
\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\n\
\n\
\t\t\t} else if ( type === \"t\" ) { // single THREE.Texture (2d or cube)\n\
\n\
\t\t\t\ttexture = value;\n\
\t\t\t\ttextureUnit = getTextureUnit();\n\
\n\
\t\t\t\t_gl.uniform1i( location, textureUnit );\n\
\n\
\t\t\t\tif ( !texture ) continue;\n\
\n\
\t\t\t\tif ( texture.image instanceof Array && texture.image.length === 6 ) {\n\
\n\
\t\t\t\t\tsetCubeTexture( texture, textureUnit );\n\
\n\
\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\
\n\
\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t_this.setTexture( texture, textureUnit );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( type === \"tv\" ) { // array of THREE.Texture (2d)\n\
\n\
\t\t\t\tif ( uniform._array === undefined ) {\n\
\n\
\t\t\t\t\tuniform._array = [];\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_gl.uniform1iv( location, uniform._array );\n\
\n\
\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\ttexture = uniform.value[ i ];\n\
\t\t\t\t\ttextureUnit = uniform._array[ i ];\n\
\n\
\t\t\t\t\tif ( !texture ) continue;\n\
\n\
\t\t\t\t\t_this.setTexture( texture, textureUnit );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction setupMatrices ( object, camera ) {\n\
\n\
\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\
\t\tobject._normalMatrix.getNormalMatrix( object._modelViewMatrix );\n\
\n\
\t};\n\
\n\
\t//\n\
\n\
\tfunction setColorGamma( array, offset, color, intensitySq ) {\n\
\n\
\t\tarray[ offset ]     = color.r * color.r * intensitySq;\n\
\t\tarray[ offset + 1 ] = color.g * color.g * intensitySq;\n\
\t\tarray[ offset + 2 ] = color.b * color.b * intensitySq;\n\
\n\
\t};\n\
\n\
\tfunction setColorLinear( array, offset, color, intensity ) {\n\
\n\
\t\tarray[ offset ]     = color.r * intensity;\n\
\t\tarray[ offset + 1 ] = color.g * intensity;\n\
\t\tarray[ offset + 2 ] = color.b * intensity;\n\
\n\
\t};\n\
\n\
\tfunction setupLights ( program, lights ) {\n\
\n\
\t\tvar l, ll, light, n,\n\
\t\tr = 0, g = 0, b = 0,\n\
\t\tcolor, skyColor, groundColor,\n\
\t\tintensity,  intensitySq,\n\
\t\tposition,\n\
\t\tdistance,\n\
\n\
\t\tzlights = _lights,\n\
\n\
\t\tdirColors = zlights.directional.colors,\n\
\t\tdirPositions = zlights.directional.positions,\n\
\n\
\t\tpointColors = zlights.point.colors,\n\
\t\tpointPositions = zlights.point.positions,\n\
\t\tpointDistances = zlights.point.distances,\n\
\n\
\t\tspotColors = zlights.spot.colors,\n\
\t\tspotPositions = zlights.spot.positions,\n\
\t\tspotDistances = zlights.spot.distances,\n\
\t\tspotDirections = zlights.spot.directions,\n\
\t\tspotAnglesCos = zlights.spot.anglesCos,\n\
\t\tspotExponents = zlights.spot.exponents,\n\
\n\
\t\themiSkyColors = zlights.hemi.skyColors,\n\
\t\themiGroundColors = zlights.hemi.groundColors,\n\
\t\themiPositions = zlights.hemi.positions,\n\
\n\
\t\tdirLength = 0,\n\
\t\tpointLength = 0,\n\
\t\tspotLength = 0,\n\
\t\themiLength = 0,\n\
\n\
\t\tdirCount = 0,\n\
\t\tpointCount = 0,\n\
\t\tspotCount = 0,\n\
\t\themiCount = 0,\n\
\n\
\t\tdirOffset = 0,\n\
\t\tpointOffset = 0,\n\
\t\tspotOffset = 0,\n\
\t\themiOffset = 0;\n\
\n\
\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\
\n\
\t\t\tlight = lights[ l ];\n\
\n\
\t\t\tif ( light.onlyShadow ) continue;\n\
\n\
\t\t\tcolor = light.color;\n\
\t\t\tintensity = light.intensity;\n\
\t\t\tdistance = light.distance;\n\
\n\
\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\
\n\
\t\t\t\tif ( ! light.visible ) continue;\n\
\n\
\t\t\t\tif ( _this.gammaInput ) {\n\
\n\
\t\t\t\t\tr += color.r * color.r;\n\
\t\t\t\t\tg += color.g * color.g;\n\
\t\t\t\t\tb += color.b * color.b;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tr += color.r;\n\
\t\t\t\t\tg += color.g;\n\
\t\t\t\t\tb += color.b;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\
\n\
\t\t\t\tdirCount += 1;\n\
\n\
\t\t\t\tif ( ! light.visible ) continue;\n\
\n\
\t\t\t\t_direction.getPositionFromMatrix( light.matrixWorld );\n\
\t\t\t\t_vector3.getPositionFromMatrix( light.target.matrixWorld );\n\
\t\t\t\t_direction.sub( _vector3 );\n\
\t\t\t\t_direction.normalize();\n\
\n\
\t\t\t\t// skip lights with undefined direction\n\
\t\t\t\t// these create troubles in OpenGL (making pixel black)\n\
\n\
\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\n\
\n\
\t\t\t\tdirOffset = dirLength * 3;\n\
\n\
\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\n\
\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\n\
\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\n\
\n\
\t\t\t\tif ( _this.gammaInput ) {\n\
\n\
\t\t\t\t\tsetColorGamma( dirColors, dirOffset, color, intensity * intensity );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tdirLength += 1;\n\
\n\
\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\
\n\
\t\t\t\tpointCount += 1;\n\
\n\
\t\t\t\tif ( ! light.visible ) continue;\n\
\n\
\t\t\t\tpointOffset = pointLength * 3;\n\
\n\
\t\t\t\tif ( _this.gammaInput ) {\n\
\n\
\t\t\t\t\tsetColorGamma( pointColors, pointOffset, color, intensity * intensity );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_vector3.getPositionFromMatrix( light.matrixWorld );\n\
\n\
\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\n\
\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\n\
\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\n\
\n\
\t\t\t\tpointDistances[ pointLength ] = distance;\n\
\n\
\t\t\t\tpointLength += 1;\n\
\n\
\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\
\n\
\t\t\t\tspotCount += 1;\n\
\n\
\t\t\t\tif ( ! light.visible ) continue;\n\
\n\
\t\t\t\tspotOffset = spotLength * 3;\n\
\n\
\t\t\t\tif ( _this.gammaInput ) {\n\
\n\
\t\t\t\t\tsetColorGamma( spotColors, spotOffset, color, intensity * intensity );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_vector3.getPositionFromMatrix( light.matrixWorld );\n\
\n\
\t\t\t\tspotPositions[ spotOffset ]     = _vector3.x;\n\
\t\t\t\tspotPositions[ spotOffset + 1 ] = _vector3.y;\n\
\t\t\t\tspotPositions[ spotOffset + 2 ] = _vector3.z;\n\
\n\
\t\t\t\tspotDistances[ spotLength ] = distance;\n\
\n\
\t\t\t\t_direction.copy( _vector3 );\n\
\t\t\t\t_vector3.getPositionFromMatrix( light.target.matrixWorld );\n\
\t\t\t\t_direction.sub( _vector3 );\n\
\t\t\t\t_direction.normalize();\n\
\n\
\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\n\
\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\n\
\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\n\
\n\
\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\n\
\t\t\t\tspotExponents[ spotLength ] = light.exponent;\n\
\n\
\t\t\t\tspotLength += 1;\n\
\n\
\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\
\n\
\t\t\t\themiCount += 1;\n\
\n\
\t\t\t\tif ( ! light.visible ) continue;\n\
\n\
\t\t\t\t_direction.getPositionFromMatrix( light.matrixWorld );\n\
\t\t\t\t_direction.normalize();\n\
\n\
\t\t\t\t// skip lights with undefined direction\n\
\t\t\t\t// these create troubles in OpenGL (making pixel black)\n\
\n\
\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\n\
\n\
\t\t\t\themiOffset = hemiLength * 3;\n\
\n\
\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\n\
\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\n\
\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\n\
\n\
\t\t\t\tskyColor = light.color;\n\
\t\t\t\tgroundColor = light.groundColor;\n\
\n\
\t\t\t\tif ( _this.gammaInput ) {\n\
\n\
\t\t\t\t\tintensitySq = intensity * intensity;\n\
\n\
\t\t\t\t\tsetColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );\n\
\t\t\t\t\tsetColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\n\
\t\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\themiLength += 1;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// null eventual remains from removed lights\n\
\t\t// (this is to avoid if in shader)\n\
\n\
\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\n\
\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\n\
\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\n\
\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\n\
\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\n\
\n\
\t\tzlights.directional.length = dirLength;\n\
\t\tzlights.point.length = pointLength;\n\
\t\tzlights.spot.length = spotLength;\n\
\t\tzlights.hemi.length = hemiLength;\n\
\n\
\t\tzlights.ambient[ 0 ] = r;\n\
\t\tzlights.ambient[ 1 ] = g;\n\
\t\tzlights.ambient[ 2 ] = b;\n\
\n\
\t};\n\
\n\
\t// GL state setting\n\
\n\
\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\
\n\
\t\tif ( cullFace === THREE.CullFaceNone ) {\n\
\n\
\t\t\t_gl.disable( _gl.CULL_FACE );\n\
\n\
\t\t} else {\n\
\n\
\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\n\
\n\
\t\t\t\t_gl.frontFace( _gl.CW );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_gl.frontFace( _gl.CCW );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\
\n\
\t\t\t\t_gl.cullFace( _gl.BACK );\n\
\n\
\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\
\n\
\t\t\t\t_gl.cullFace( _gl.FRONT );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.enable( _gl.CULL_FACE );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tthis.setMaterialFaces = function ( material ) {\n\
\n\
\t\tvar doubleSided = material.side === THREE.DoubleSide;\n\
\t\tvar flipSided = material.side === THREE.BackSide;\n\
\n\
\t\tif ( _oldDoubleSided !== doubleSided ) {\n\
\n\
\t\t\tif ( doubleSided ) {\n\
\n\
\t\t\t\t_gl.disable( _gl.CULL_FACE );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_gl.enable( _gl.CULL_FACE );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_oldDoubleSided = doubleSided;\n\
\n\
\t\t}\n\
\n\
\t\tif ( _oldFlipSided !== flipSided ) {\n\
\n\
\t\t\tif ( flipSided ) {\n\
\n\
\t\t\t\t_gl.frontFace( _gl.CW );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_gl.frontFace( _gl.CCW );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_oldFlipSided = flipSided;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tthis.setDepthTest = function ( depthTest ) {\n\
\n\
\t\tif ( _oldDepthTest !== depthTest ) {\n\
\n\
\t\t\tif ( depthTest ) {\n\
\n\
\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_oldDepthTest = depthTest;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tthis.setDepthWrite = function ( depthWrite ) {\n\
\n\
\t\tif ( _oldDepthWrite !== depthWrite ) {\n\
\n\
\t\t\t_gl.depthMask( depthWrite );\n\
\t\t\t_oldDepthWrite = depthWrite;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction setLineWidth ( width ) {\n\
\n\
\t\tif ( width !== _oldLineWidth ) {\n\
\n\
\t\t\t_gl.lineWidth( width );\n\
\n\
\t\t\t_oldLineWidth = width;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction setPolygonOffset ( polygonoffset, factor, units ) {\n\
\n\
\t\tif ( _oldPolygonOffset !== polygonoffset ) {\n\
\n\
\t\t\tif ( polygonoffset ) {\n\
\n\
\t\t\t\t_gl.enable( _gl.POLYGON_OFFSET_FILL );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_gl.disable( _gl.POLYGON_OFFSET_FILL );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_oldPolygonOffset = polygonoffset;\n\
\n\
\t\t}\n\
\n\
\t\tif ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {\n\
\n\
\t\t\t_gl.polygonOffset( factor, units );\n\
\n\
\t\t\t_oldPolygonOffsetFactor = factor;\n\
\t\t\t_oldPolygonOffsetUnits = units;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {\n\
\n\
\t\tif ( blending !== _oldBlending ) {\n\
\n\
\t\t\tif ( blending === THREE.NoBlending ) {\n\
\n\
\t\t\t\t_gl.disable( _gl.BLEND );\n\
\n\
\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\n\
\n\
\t\t\t\t_gl.enable( _gl.BLEND );\n\
\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\
\t\t\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );\n\
\n\
\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\
\n\
\t\t\t\t// TODO: Find blendFuncSeparate() combination\n\
\t\t\t\t_gl.enable( _gl.BLEND );\n\
\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\
\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );\n\
\n\
\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\
\n\
\t\t\t\t// TODO: Find blendFuncSeparate() combination\n\
\t\t\t\t_gl.enable( _gl.BLEND );\n\
\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\
\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );\n\
\n\
\t\t\t} else if ( blending === THREE.CustomBlending ) {\n\
\n\
\t\t\t\t_gl.enable( _gl.BLEND );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_gl.enable( _gl.BLEND );\n\
\t\t\t\t_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );\n\
\t\t\t\t_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_oldBlending = blending;\n\
\n\
\t\t}\n\
\n\
\t\tif ( blending === THREE.CustomBlending ) {\n\
\n\
\t\t\tif ( blendEquation !== _oldBlendEquation ) {\n\
\n\
\t\t\t\t_gl.blendEquation( paramThreeToGL( blendEquation ) );\n\
\n\
\t\t\t\t_oldBlendEquation = blendEquation;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {\n\
\n\
\t\t\t\t_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );\n\
\n\
\t\t\t\t_oldBlendSrc = blendSrc;\n\
\t\t\t\t_oldBlendDst = blendDst;\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_oldBlendEquation = null;\n\
\t\t\t_oldBlendSrc = null;\n\
\t\t\t_oldBlendDst = null;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Defines\n\
\n\
\tfunction generateDefines ( defines ) {\n\
\n\
\t\tvar value, chunk, chunks = [];\n\
\n\
\t\tfor ( var d in defines ) {\n\
\n\
\t\t\tvalue = defines[ d ];\n\
\t\t\tif ( value === false ) continue;\n\
\n\
\t\t\tchunk = \"#define \" + d + \" \" + value;\n\
\t\t\tchunks.push( chunk );\n\
\n\
\t\t}\n\
\n\
\t\treturn chunks.join( \"\\n\
\" );\n\
\n\
\t};\n\
\n\
\t// Shaders\n\
\n\
\tfunction buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName ) {\n\
\n\
\t\tvar p, pl, d, program, code;\n\
\t\tvar chunks = [];\n\
\n\
\t\t// Generate code\n\
\n\
\t\tif ( shaderID ) {\n\
\n\
\t\t\tchunks.push( shaderID );\n\
\n\
\t\t} else {\n\
\n\
\t\t\tchunks.push( fragmentShader );\n\
\t\t\tchunks.push( vertexShader );\n\
\n\
\t\t}\n\
\n\
\t\tfor ( d in defines ) {\n\
\n\
\t\t\tchunks.push( d );\n\
\t\t\tchunks.push( defines[ d ] );\n\
\n\
\t\t}\n\
\n\
\t\tfor ( p in parameters ) {\n\
\n\
\t\t\tchunks.push( p );\n\
\t\t\tchunks.push( parameters[ p ] );\n\
\n\
\t\t}\n\
\n\
\t\tcode = chunks.join();\n\
\n\
\t\t// Check if code has been already compiled\n\
\n\
\t\tfor ( p = 0, pl = _programs.length; p < pl; p ++ ) {\n\
\n\
\t\t\tvar programInfo = _programs[ p ];\n\
\n\
\t\t\tif ( programInfo.code === code ) {\n\
\n\
\t\t\t\t// console.log( \"Code already compiled.\" /*: \\n\
\\n\
\" + code*/ );\n\
\n\
\t\t\t\tprogramInfo.usedTimes ++;\n\
\n\
\t\t\t\treturn programInfo.program;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tvar shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\n\
\n\
\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\
\n\
\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF\";\n\
\n\
\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\
\n\
\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\n\
\n\
\t\t}\n\
\n\
\t\t// console.log( \"building new program \" );\n\
\n\
\t\t//\n\
\n\
\t\tvar customDefines = generateDefines( defines );\n\
\n\
\t\t//\n\
\n\
\t\tprogram = _gl.createProgram();\n\
\n\
\t\tvar prefix_vertex = [\n\
\n\
\t\t\t\"precision \" + _precision + \" float;\",\n\
\t\t\t\"precision \" + _precision + \" int;\",\n\
\n\
\t\t\tcustomDefines,\n\
\n\
\t\t\t_supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\n\
\n\
\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n\
\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n\
\t\t\t_this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\n\
\n\
\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n\
\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n\
\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n\
\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n\
\n\
\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\n\
\n\
\t\t\t\"#define MAX_BONES \" + parameters.maxBones,\n\
\n\
\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\n\
\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n\
\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n\
\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n\
\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n\
\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n\
\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n\
\n\
\t\t\tparameters.skinning ? \"#define USE_SKINNING\" : \"\",\n\
\t\t\tparameters.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\n\
\t\t\tparameters.boneTextureWidth ? \"#define N_BONE_PIXEL_X \" + parameters.boneTextureWidth.toFixed( 1 ) : \"\",\n\
\t\t\tparameters.boneTextureHeight ? \"#define N_BONE_PIXEL_Y \" + parameters.boneTextureHeight.toFixed( 1 ) : \"\",\n\
\n\
\t\t\tparameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\n\
\t\t\tparameters.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\",\n\
\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n\
\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n\
\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n\
\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n\
\n\
\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n\
\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n\
\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n\
\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n\
\n\
\t\t\tparameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\n\
\n\
\t\t\t\"uniform mat4 modelMatrix;\",\n\
\t\t\t\"uniform mat4 modelViewMatrix;\",\n\
\t\t\t\"uniform mat4 projectionMatrix;\",\n\
\t\t\t\"uniform mat4 viewMatrix;\",\n\
\t\t\t\"uniform mat3 normalMatrix;\",\n\
\t\t\t\"uniform vec3 cameraPosition;\",\n\
\n\
\t\t\t\"attribute vec3 position;\",\n\
\t\t\t\"attribute vec3 normal;\",\n\
\t\t\t\"attribute vec2 uv;\",\n\
\t\t\t\"attribute vec2 uv2;\",\n\
\n\
\t\t\t\"#ifdef USE_COLOR\",\n\
\n\
\t\t\t\t\"attribute vec3 color;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#ifdef USE_MORPHTARGETS\",\n\
\n\
\t\t\t\t\"attribute vec3 morphTarget0;\",\n\
\t\t\t\t\"attribute vec3 morphTarget1;\",\n\
\t\t\t\t\"attribute vec3 morphTarget2;\",\n\
\t\t\t\t\"attribute vec3 morphTarget3;\",\n\
\n\
\t\t\t\t\"#ifdef USE_MORPHNORMALS\",\n\
\n\
\t\t\t\t\t\"attribute vec3 morphNormal0;\",\n\
\t\t\t\t\t\"attribute vec3 morphNormal1;\",\n\
\t\t\t\t\t\"attribute vec3 morphNormal2;\",\n\
\t\t\t\t\t\"attribute vec3 morphNormal3;\",\n\
\n\
\t\t\t\t\"#else\",\n\
\n\
\t\t\t\t\t\"attribute vec3 morphTarget4;\",\n\
\t\t\t\t\t\"attribute vec3 morphTarget5;\",\n\
\t\t\t\t\t\"attribute vec3 morphTarget6;\",\n\
\t\t\t\t\t\"attribute vec3 morphTarget7;\",\n\
\n\
\t\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"#ifdef USE_SKINNING\",\n\
\n\
\t\t\t\t\"attribute vec4 skinIndex;\",\n\
\t\t\t\t\"attribute vec4 skinWeight;\",\n\
\n\
\t\t\t\"#endif\",\n\
\n\
\t\t\t\"\"\n\
\n\
\t\t].join(\"\\n\
\");\n\
\n\
\t\tvar prefix_fragment = [\n\
\n\
\t\t\t\"precision \" + _precision + \" float;\",\n\
\t\t\t\"precision \" + _precision + \" int;\",\n\
\n\
\t\t\t( parameters.bumpMap || parameters.normalMap ) ? \"#extension GL_OES_standard_derivatives : enable\" : \"\",\n\
\n\
\t\t\tcustomDefines,\n\
\n\
\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n\
\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n\
\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n\
\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n\
\n\
\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\n\
\n\
\t\t\tparameters.alphaTest ? \"#define ALPHATEST \" + parameters.alphaTest: \"\",\n\
\n\
\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n\
\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n\
\t\t\t_this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\n\
\n\
\t\t\t( parameters.useFog && parameters.fog ) ? \"#define USE_FOG\" : \"\",\n\
\t\t\t( parameters.useFog && parameters.fogExp ) ? \"#define FOG_EXP2\" : \"\",\n\
\n\
\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\n\
\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n\
\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n\
\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n\
\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n\
\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n\
\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n\
\n\
\t\t\tparameters.metal ? \"#define METAL\" : \"\",\n\
\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n\
\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n\
\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n\
\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n\
\n\
\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n\
\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n\
\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n\
\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n\
\n\
\t\t\t\"uniform mat4 viewMatrix;\",\n\
\t\t\t\"uniform vec3 cameraPosition;\",\n\
\t\t\t\"\"\n\
\n\
\t\t].join(\"\\n\
\");\n\
\n\
\t\tvar glVertexShader = getShader( \"vertex\", prefix_vertex + vertexShader );\n\
\t\tvar glFragmentShader = getShader( \"fragment\", prefix_fragment + fragmentShader );\n\
\n\
\t\t_gl.attachShader( program, glVertexShader );\n\
\t\t_gl.attachShader( program, glFragmentShader );\n\
\n\
\t\t//Force a particular attribute to index 0.\n\
\t\t// because potentially expensive emulation is done by browser if attribute 0 is disabled.\n\
\t\t//And, color, for example is often automatically bound to index 0 so disabling it\n\
\t\tif ( index0AttributeName ) {\n\
\t\t\t_gl.bindAttribLocation( program, 0, index0AttributeName );\n\
\t\t}\n\
\n\
\t\t_gl.linkProgram( program );\n\
\n\
\t\tif ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {\n\
\n\
\t\t\tconsole.error( \"Could not initialise shader\\n\
\" + \"VALIDATE_STATUS: \" + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + \", gl error [\" + _gl.getError() + \"]\" );\n\
\t\t\tconsole.error( \"Program Info Log: \" + _gl.getProgramInfoLog( program ) );\n\
\t\t}\n\
\n\
\t\t// clean up\n\
\n\
\t\t_gl.deleteShader( glFragmentShader );\n\
\t\t_gl.deleteShader( glVertexShader );\n\
\n\
\t\t// console.log( prefix_fragment + fragmentShader );\n\
\t\t// console.log( prefix_vertex + vertexShader );\n\
\n\
\t\tprogram.uniforms = {};\n\
\t\tprogram.attributes = {};\n\
\n\
\t\tvar identifiers, u, a, i;\n\
\n\
\t\t// cache uniform locations\n\
\n\
\t\tidentifiers = [\n\
\n\
\t\t\t'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',\n\
\t\t\t'morphTargetInfluences'\n\
\n\
\t\t];\n\
\n\
\t\tif ( parameters.useVertexTexture ) {\n\
\n\
\t\t\tidentifiers.push( 'boneTexture' );\n\
\n\
\t\t} else {\n\
\n\
\t\t\tidentifiers.push( 'boneGlobalMatrices' );\n\
\n\
\t\t}\n\
\n\
\t\tfor ( u in uniforms ) {\n\
\n\
\t\t\tidentifiers.push( u );\n\
\n\
\t\t}\n\
\n\
\t\tcacheUniformLocations( program, identifiers );\n\
\n\
\t\t// cache attributes locations\n\
\n\
\t\tidentifiers = [\n\
\n\
\t\t\t\"position\", \"normal\", \"uv\", \"uv2\", \"tangent\", \"color\",\n\
\t\t\t\"skinIndex\", \"skinWeight\", \"lineDistance\"\n\
\n\
\t\t];\n\
\n\
\t\tfor ( i = 0; i < parameters.maxMorphTargets; i ++ ) {\n\
\n\
\t\t\tidentifiers.push( \"morphTarget\" + i );\n\
\n\
\t\t}\n\
\n\
\t\tfor ( i = 0; i < parameters.maxMorphNormals; i ++ ) {\n\
\n\
\t\t\tidentifiers.push( \"morphNormal\" + i );\n\
\n\
\t\t}\n\
\n\
\t\tfor ( a in attributes ) {\n\
\n\
\t\t\tidentifiers.push( a );\n\
\n\
\t\t}\n\
\n\
\t\tcacheAttributeLocations( program, identifiers );\n\
\n\
\t\tprogram.id = _programs_counter ++;\n\
\n\
\t\t_programs.push( { program: program, code: code, usedTimes: 1 } );\n\
\n\
\t\t_this.info.memory.programs = _programs.length;\n\
\n\
\t\treturn program;\n\
\n\
\t};\n\
\n\
\t// Shader parameters cache\n\
\n\
\tfunction cacheUniformLocations ( program, identifiers ) {\n\
\n\
\t\tvar i, l, id;\n\
\n\
\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\n\
\n\
\t\t\tid = identifiers[ i ];\n\
\t\t\tprogram.uniforms[ id ] = _gl.getUniformLocation( program, id );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction cacheAttributeLocations ( program, identifiers ) {\n\
\n\
\t\tvar i, l, id;\n\
\n\
\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\n\
\n\
\t\t\tid = identifiers[ i ];\n\
\t\t\tprogram.attributes[ id ] = _gl.getAttribLocation( program, id );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction addLineNumbers ( string ) {\n\
\n\
\t\tvar chunks = string.split( \"\\n\
\" );\n\
\n\
\t\tfor ( var i = 0, il = chunks.length; i < il; i ++ ) {\n\
\n\
\t\t\t// Chrome reports shader errors on lines\n\
\t\t\t// starting counting from 1\n\
\n\
\t\t\tchunks[ i ] = ( i + 1 ) + \": \" + chunks[ i ];\n\
\n\
\t\t}\n\
\n\
\t\treturn chunks.join( \"\\n\
\" );\n\
\n\
\t};\n\
\n\
\tfunction getShader ( type, string ) {\n\
\n\
\t\tvar shader;\n\
\n\
\t\tif ( type === \"fragment\" ) {\n\
\n\
\t\t\tshader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\
\n\
\t\t} else if ( type === \"vertex\" ) {\n\
\n\
\t\t\tshader = _gl.createShader( _gl.VERTEX_SHADER );\n\
\n\
\t\t}\n\
\n\
\t\t_gl.shaderSource( shader, string );\n\
\t\t_gl.compileShader( shader );\n\
\n\
\t\tif ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {\n\
\n\
\t\t\tconsole.error( _gl.getShaderInfoLog( shader ) );\n\
\t\t\tconsole.error( addLineNumbers( string ) );\n\
\t\t\treturn null;\n\
\n\
\t\t}\n\
\n\
\t\treturn shader;\n\
\n\
\t};\n\
\n\
\t// Textures\n\
\n\
\n\
\tfunction isPowerOfTwo ( value ) {\n\
\n\
\t\treturn ( value & ( value - 1 ) ) === 0;\n\
\n\
\t};\n\
\n\
\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\n\
\n\
\t\tif ( isImagePowerOfTwo ) {\n\
\n\
\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\
\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\
\n\
\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\
\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\
\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\
\n\
\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\
\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\
\n\
\t\t}\n\
\n\
\t\tif ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {\n\
\n\
\t\t\tif ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {\n\
\n\
\t\t\t\t_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );\n\
\t\t\t\ttexture.__oldAnisotropy = texture.anisotropy;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tthis.setTexture = function ( texture, slot ) {\n\
\n\
\t\tif ( texture.needsUpdate ) {\n\
\n\
\t\t\tif ( ! texture.__webglInit ) {\n\
\n\
\t\t\t\ttexture.__webglInit = true;\n\
\n\
\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\
\n\
\t\t\t\ttexture.__webglTexture = _gl.createTexture();\n\
\n\
\t\t\t\t_this.info.memory.textures ++;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\
\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\n\
\n\
\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\
\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\
\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\
\n\
\t\t\tvar image = texture.image,\n\
\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\n\
\t\t\tglFormat = paramThreeToGL( texture.format ),\n\
\t\t\tglType = paramThreeToGL( texture.type );\n\
\n\
\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\n\
\n\
\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\
\n\
\t\t\tif ( texture instanceof THREE.DataTexture ) {\n\
\n\
\t\t\t\t// use manually created mipmaps if available\n\
\t\t\t\t// if there are no manual mipmaps\n\
\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\
\n\
\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\n\
\n\
\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\
\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\ttexture.generateMipmaps = false;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\
\n\
\t\t\t\t// compressed textures can only use manually created mipmaps\n\
\t\t\t\t// WebGL can't generate mipmaps for DDS textures\n\
\n\
\t\t\t\tfor( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\tmipmap = mipmaps[ i ];\n\
\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else { // regular Texture (image, video, canvas)\n\
\n\
\t\t\t\t// use manually created mipmaps if available\n\
\t\t\t\t// if there are no manual mipmaps\n\
\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\
\n\
\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\n\
\n\
\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\
\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\ttexture.generateMipmaps = false;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\
\n\
\t\t\ttexture.needsUpdate = false;\n\
\n\
\t\t\tif ( texture.onUpdate ) texture.onUpdate();\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\
\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction clampToMaxSize ( image, maxSize ) {\n\
\n\
\t\tif ( image.width <= maxSize && image.height <= maxSize ) {\n\
\n\
\t\t\treturn image;\n\
\n\
\t\t}\n\
\n\
\t\t// Warning: Scaling through the canvas will only work with images that use\n\
\t\t// premultiplied alpha.\n\
\n\
\t\tvar maxDimension = Math.max( image.width, image.height );\n\
\t\tvar newWidth = Math.floor( image.width * maxSize / maxDimension );\n\
\t\tvar newHeight = Math.floor( image.height * maxSize / maxDimension );\n\
\n\
\t\tvar canvas = document.createElement( 'canvas' );\n\
\t\tcanvas.width = newWidth;\n\
\t\tcanvas.height = newHeight;\n\
\n\
\t\tvar ctx = canvas.getContext( \"2d\" );\n\
\t\tctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );\n\
\n\
\t\treturn canvas;\n\
\n\
\t}\n\
\n\
\tfunction setCubeTexture ( texture, slot ) {\n\
\n\
\t\tif ( texture.image.length === 6 ) {\n\
\n\
\t\t\tif ( texture.needsUpdate ) {\n\
\n\
\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\n\
\n\
\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\
\n\
\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\n\
\n\
\t\t\t\t\t_this.info.memory.textures ++;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\
\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\n\
\n\
\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\
\n\
\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\
\n\
\t\t\t\tvar cubeImage = [];\n\
\n\
\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\
\n\
\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed ) {\n\
\n\
\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\tcubeImage[ i ] = texture.image[ i ];\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tvar image = cubeImage[ 0 ],\n\
\t\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\n\
\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\
\t\t\t\tglType = paramThreeToGL( texture.type );\n\
\n\
\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\n\
\n\
\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\
\n\
\t\t\t\t\tif ( isCompressed ) {\n\
\n\
\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\
\n\
\t\t\t\t\t\tfor( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\
\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\n\
\n\
\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\ttexture.needsUpdate = false;\n\
\n\
\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\
\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction setCubeTextureDynamic ( texture, slot ) {\n\
\n\
\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\
\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\n\
\n\
\t};\n\
\n\
\t// Render targets\n\
\n\
\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\n\
\n\
\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\
\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\n\
\n\
\t};\n\
\n\
\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\n\
\n\
\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\
\n\
\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\
\n\
\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\
\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\
\n\
\t\t/* For some reason this is not working. Defaulting to RGBA4.\n\
\t\t} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\
\n\
\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\n\
\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\
\t\t*/\n\
\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\
\n\
\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\
\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tthis.setRenderTarget = function ( renderTarget ) {\n\
\n\
\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\
\n\
\t\tif ( renderTarget && ! renderTarget.__webglFramebuffer ) {\n\
\n\
\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\n\
\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\n\
\n\
\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\
\n\
\t\t\trenderTarget.__webglTexture = _gl.createTexture();\n\
\n\
\t\t\t_this.info.memory.textures ++;\n\
\n\
\t\t\t// Setup texture, create render and frame buffers\n\
\n\
\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),\n\
\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\n\
\t\t\t\tglType = paramThreeToGL( renderTarget.type );\n\
\n\
\t\t\tif ( isCube ) {\n\
\n\
\t\t\t\trenderTarget.__webglFramebuffer = [];\n\
\t\t\t\trenderTarget.__webglRenderbuffer = [];\n\
\n\
\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\n\
\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\n\
\n\
\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\
\n\
\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\
\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\n\
\n\
\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\
\n\
\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\
\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\n\
\n\
\t\t\t\tif ( renderTarget.shareDepthFrom ) {\n\
\n\
\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\n\
\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\n\
\n\
\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\
\n\
\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\n\
\n\
\t\t\t\tif ( renderTarget.shareDepthFrom ) {\n\
\n\
\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\
\n\
\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\n\
\n\
\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\
\n\
\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// Release everything\n\
\n\
\t\t\tif ( isCube ) {\n\
\n\
\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\
\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\
\n\
\t\t}\n\
\n\
\t\tvar framebuffer, width, height, vx, vy;\n\
\n\
\t\tif ( renderTarget ) {\n\
\n\
\t\t\tif ( isCube ) {\n\
\n\
\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\n\
\n\
\t\t\t}\n\
\n\
\t\t\twidth = renderTarget.width;\n\
\t\t\theight = renderTarget.height;\n\
\n\
\t\t\tvx = 0;\n\
\t\t\tvy = 0;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tframebuffer = null;\n\
\n\
\t\t\twidth = _viewportWidth;\n\
\t\t\theight = _viewportHeight;\n\
\n\
\t\t\tvx = _viewportX;\n\
\t\t\tvy = _viewportY;\n\
\n\
\t\t}\n\
\n\
\t\tif ( framebuffer !== _currentFramebuffer ) {\n\
\n\
\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\
\t\t\t_gl.viewport( vx, vy, width, height );\n\
\n\
\t\t\t_currentFramebuffer = framebuffer;\n\
\n\
\t\t}\n\
\n\
\t\t_currentWidth = width;\n\
\t\t_currentHeight = height;\n\
\n\
\t};\n\
\n\
\tfunction updateRenderTargetMipmap ( renderTarget ) {\n\
\n\
\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\
\n\
\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\n\
\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\
\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\n\
\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\n\
\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t// Fallback filters for non-power-of-2 textures\n\
\n\
\tfunction filterFallback ( f ) {\n\
\n\
\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\
\n\
\t\t\treturn _gl.NEAREST;\n\
\n\
\t\t}\n\
\n\
\t\treturn _gl.LINEAR;\n\
\n\
\t};\n\
\n\
\t// Map three.js constants to WebGL constants\n\
\n\
\tfunction paramThreeToGL ( p ) {\n\
\n\
\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\
\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\
\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\
\n\
\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\
\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\
\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\
\n\
\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\
\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\
\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\
\n\
\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\
\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\
\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\
\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\
\n\
\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\
\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\
\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\
\t\tif ( p === THREE.IntType ) return _gl.INT;\n\
\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\
\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\
\n\
\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\
\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\
\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\
\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\
\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\
\n\
\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\
\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\
\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\
\n\
\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\
\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\
\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\
\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\
\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\
\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\
\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\
\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\
\n\
\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\
\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\
\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\
\n\
\t\tif ( _glExtensionCompressedTextureS3TC !== undefined ) {\n\
\n\
\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\
\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\
\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\
\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\
\n\
\t\t}\n\
\n\
\t\treturn 0;\n\
\n\
\t};\n\
\n\
\t// Allocations\n\
\n\
\tfunction allocateBones ( object ) {\n\
\n\
\t\tif ( _supportsBoneTextures && object && object.useVertexTexture ) {\n\
\n\
\t\t\treturn 1024;\n\
\n\
\t\t} else {\n\
\n\
\t\t\t// default for when object is not specified\n\
\t\t\t// ( for example when prebuilding shader\n\
\t\t\t//   to be used with multiple objects )\n\
\t\t\t//\n\
\t\t\t// \t- leave some extra space for other uniforms\n\
\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\
\t\t\t//    (up to 54 should be safe)\n\
\n\
\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\n\
\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\
\n\
\t\t\tvar maxBones = nVertexMatrices;\n\
\n\
\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\
\n\
\t\t\t\tmaxBones = Math.min( object.bones.length, maxBones );\n\
\n\
\t\t\t\tif ( maxBones < object.bones.length ) {\n\
\n\
\t\t\t\t\tconsole.warn( \"WebGLRenderer: too many bones - \" + object.bones.length + \", this GPU supports just \" + maxBones + \" (try OpenGL instead of ANGLE)\" );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\treturn maxBones;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction allocateLights( lights ) {\n\
\n\
\t\tvar dirLights = 0;\n\
\t\tvar pointLights = 0;\n\
\t\tvar spotLights = 0;\n\
\t\tvar hemiLights = 0;\n\
\n\
\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\n\
\n\
\t\t\tvar light = lights[ l ];\n\
\n\
\t\t\tif ( light.onlyShadow ) continue;\n\
\n\
\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\n\
\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\n\
\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\n\
\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\n\
\n\
\t\t}\n\
\n\
\t\treturn { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };\n\
\n\
\t};\n\
\n\
\tfunction allocateShadows( lights ) {\n\
\n\
\t\tvar maxShadows = 0;\n\
\n\
\t\tfor ( var l = 0, ll = lights.length; l < ll; l++ ) {\n\
\n\
\t\t\tvar light = lights[ l ];\n\
\n\
\t\t\tif ( ! light.castShadow ) continue;\n\
\n\
\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\n\
\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\n\
\n\
\t\t}\n\
\n\
\t\treturn maxShadows;\n\
\n\
\t};\n\
\n\
\t// Initialization\n\
\n\
\tfunction initGL() {\n\
\n\
\t\ttry {\n\
\n\
\t\t\tvar attributes = {\n\
\t\t\t\talpha: _alpha,\n\
\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\
\t\t\t\tantialias: _antialias,\n\
\t\t\t\tstencil: _stencil,\n\
\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\
\t\t\t};\n\
\n\
\t\t\t_gl = _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\
\n\
\t\t\tif ( _gl === null ) {\n\
\n\
\t\t\t\tthrow 'Error creating WebGL context.';\n\
\n\
\t\t\t}\n\
\n\
\t\t} catch ( error ) {\n\
\n\
\t\t\tconsole.error( error );\n\
\n\
\t\t}\n\
\n\
\t\t_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );\n\
\t\t_glExtensionTextureFloatLinear = _gl.getExtension( 'OES_texture_float_linear' );\n\
\t\t_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );\n\
\n\
\t\t_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\
\n\
\t\t_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\
\n\
\t\tif ( ! _glExtensionTextureFloat ) {\n\
\n\
\t\t\tconsole.log( 'THREE.WebGLRenderer: Float textures not supported.' );\n\
\n\
\t\t}\n\
\n\
\t\tif ( ! _glExtensionStandardDerivatives ) {\n\
\n\
\t\t\tconsole.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );\n\
\n\
\t\t}\n\
\n\
\t\tif ( ! _glExtensionTextureFilterAnisotropic ) {\n\
\n\
\t\t\tconsole.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );\n\
\n\
\t\t}\n\
\n\
\t\tif ( ! _glExtensionCompressedTextureS3TC ) {\n\
\n\
\t\t\tconsole.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );\n\
\n\
\t\t}\n\
\n\
\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\
\n\
\t\t\t_gl.getShaderPrecisionFormat = function() {\n\
\n\
\t\t\t\treturn {\n\
\t\t\t\t\t\"rangeMin\"  : 1,\n\
\t\t\t\t\t\"rangeMax\"  : 1,\n\
\t\t\t\t\t\"precision\" : 1\n\
\t\t\t\t};\n\
\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction setDefaultGLState () {\n\
\n\
\t\t_gl.clearColor( 0, 0, 0, 1 );\n\
\t\t_gl.clearDepth( 1 );\n\
\t\t_gl.clearStencil( 0 );\n\
\n\
\t\t_gl.enable( _gl.DEPTH_TEST );\n\
\t\t_gl.depthFunc( _gl.LEQUAL );\n\
\n\
\t\t_gl.frontFace( _gl.CCW );\n\
\t\t_gl.cullFace( _gl.BACK );\n\
\t\t_gl.enable( _gl.CULL_FACE );\n\
\n\
\t\t_gl.enable( _gl.BLEND );\n\
\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\
\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\n\
\n\
\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\
\n\
\t};\n\
\n\
\t// default plugins (order is important)\n\
\n\
\tthis.shadowMapPlugin = new THREE.ShadowMapPlugin();\n\
\tthis.addPrePlugin( this.shadowMapPlugin );\n\
\n\
\tthis.addPostPlugin( new THREE.SpritePlugin() );\n\
\tthis.addPostPlugin( new THREE.LensFlarePlugin() );\n\
\n\
};\n\
\n\
/**\n\
 * @author szimek / https://github.com/szimek/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.WebGLRenderTarget = function ( width, height, options ) {\n\
\n\
\tthis.width = width;\n\
\tthis.height = height;\n\
\n\
\toptions = options || {};\n\
\n\
\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\n\
\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\n\
\n\
\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\n\
\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\n\
\n\
\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\n\
\n\
\tthis.offset = new THREE.Vector2( 0, 0 );\n\
\tthis.repeat = new THREE.Vector2( 1, 1 );\n\
\n\
\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\n\
\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\n\
\n\
\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\
\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\
\n\
\tthis.generateMipmaps = true;\n\
\n\
\tthis.shareDepthFrom = null;\n\
\n\
};\n\
\n\
THREE.WebGLRenderTarget.prototype = {\n\
\n\
\tconstructor: THREE.WebGLRenderTarget,\n\
\n\
\tclone: function () {\n\
\n\
\t\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\n\
\n\
\t\ttmp.wrapS = this.wrapS;\n\
\t\ttmp.wrapT = this.wrapT;\n\
\n\
\t\ttmp.magFilter = this.magFilter;\n\
\t\ttmp.minFilter = this.minFilter;\n\
\n\
\t\ttmp.anisotropy = this.anisotropy;\n\
\n\
\t\ttmp.offset.copy( this.offset );\n\
\t\ttmp.repeat.copy( this.repeat );\n\
\n\
\t\ttmp.format = this.format;\n\
\t\ttmp.type = this.type;\n\
\n\
\t\ttmp.depthBuffer = this.depthBuffer;\n\
\t\ttmp.stencilBuffer = this.stencilBuffer;\n\
\n\
\t\ttmp.generateMipmaps = this.generateMipmaps;\n\
\n\
\t\ttmp.shareDepthFrom = this.shareDepthFrom;\n\
\n\
\t\treturn tmp;\n\
\n\
\t},\n\
\n\
\tdispose: function () {\n\
\n\
\t\tthis.dispatchEvent( { type: 'dispose' } );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com\n\
 */\n\
\n\
THREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\
\n\
\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\
\n\
\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\
\n\
};\n\
\n\
THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.RenderableVertex = function () {\n\
\n\
\tthis.positionWorld = new THREE.Vector3();\n\
\tthis.positionScreen = new THREE.Vector4();\n\
\n\
\tthis.visible = true;\n\
\n\
};\n\
\n\
THREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\
\n\
\tthis.positionWorld.copy( vertex.positionWorld );\n\
\tthis.positionScreen.copy( vertex.positionScreen );\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.RenderableFace3 = function () {\n\
\n\
\tthis.id = 0;\n\
\n\
\tthis.v1 = new THREE.RenderableVertex();\n\
\tthis.v2 = new THREE.RenderableVertex();\n\
\tthis.v3 = new THREE.RenderableVertex();\n\
\n\
\tthis.centroidModel = new THREE.Vector3();\n\
\n\
\tthis.normalModel = new THREE.Vector3();\n\
\tthis.normalModelView = new THREE.Vector3();\n\
\n\
\tthis.vertexNormalsLength = 0;\n\
\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\
\tthis.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\
\n\
\tthis.color = null;\n\
\tthis.material = null;\n\
\tthis.uvs = [[]];\n\
\n\
\tthis.z = 0;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.RenderableObject = function () {\n\
\n\
\tthis.id = 0;\n\
\n\
\tthis.object = null;\n\
\tthis.z = 0;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.RenderableParticle = function () {\n\
\n\
\tthis.id = 0;\n\
\n\
\tthis.object = null;\n\
\n\
\tthis.x = 0;\n\
\tthis.y = 0;\n\
\tthis.z = 0;\n\
\n\
\tthis.rotation = null;\n\
\tthis.scale = new THREE.Vector2();\n\
\n\
\tthis.material = null;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.RenderableLine = function () {\n\
\n\
\tthis.id = 0;\n\
\n\
\tthis.v1 = new THREE.RenderableVertex();\n\
\tthis.v2 = new THREE.RenderableVertex();\n\
\n\
\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\n\
\tthis.material = null;\n\
\n\
\tthis.z = 0;\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.GeometryUtils = {\n\
\n\
\t// Merge two geometries or geometry and geometry from object (using object's transform)\n\
\n\
\tmerge: function ( geometry1, object2 /* mesh | geometry */, materialIndexOffset ) {\n\
\n\
\t\tvar matrix, normalMatrix,\n\
\t\tvertexOffset = geometry1.vertices.length,\n\
\t\tuvPosition = geometry1.faceVertexUvs[ 0 ].length,\n\
\t\tgeometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,\n\
\t\tvertices1 = geometry1.vertices,\n\
\t\tvertices2 = geometry2.vertices,\n\
\t\tfaces1 = geometry1.faces,\n\
\t\tfaces2 = geometry2.faces,\n\
\t\tuvs1 = geometry1.faceVertexUvs[ 0 ],\n\
\t\tuvs2 = geometry2.faceVertexUvs[ 0 ];\n\
\n\
\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\
\n\
\t\tif ( object2 instanceof THREE.Mesh ) {\n\
\n\
\t\t\tobject2.matrixAutoUpdate && object2.updateMatrix();\n\
\n\
\t\t\tmatrix = object2.matrix;\n\
\n\
\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\
\n\
\t\t}\n\
\n\
\t\t// vertices\n\
\n\
\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\
\n\
\t\t\tvar vertex = vertices2[ i ];\n\
\n\
\t\t\tvar vertexCopy = vertex.clone();\n\
\n\
\t\t\tif ( matrix ) vertexCopy.applyMatrix4( matrix );\n\
\n\
\t\t\tvertices1.push( vertexCopy );\n\
\n\
\t\t}\n\
\n\
\t\t// faces\n\
\n\
\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\
\n\
\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\
\t\t\tfaceVertexNormals = face.vertexNormals,\n\
\t\t\tfaceVertexColors = face.vertexColors;\n\
\n\
\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\
\t\t\tfaceCopy.normal.copy( face.normal );\n\
\n\
\t\t\tif ( normalMatrix ) {\n\
\n\
\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\
\n\
\t\t\t\tif ( normalMatrix ) {\n\
\n\
\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfaceCopy.color.copy( face.color );\n\
\n\
\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\tcolor = faceVertexColors[ j ];\n\
\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\
\n\
\t\t\tfaceCopy.centroid.copy( face.centroid );\n\
\n\
\t\t\tif ( matrix ) {\n\
\n\
\t\t\t\tfaceCopy.centroid.applyMatrix4( matrix );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfaces1.push( faceCopy );\n\
\n\
\t\t}\n\
\n\
\t\t// uvs\n\
\n\
\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\
\n\
\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\
\n\
\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tuvs1.push( uvCopy );\n\
\n\
\t\t}\n\
\n\
\t},\n\
\n\
\t// Get random point in triangle (via barycentric coordinates)\n\
\t// \t(uniform distribution)\n\
\t// \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\n\
\n\
\trandomPointInTriangle: function () {\n\
\n\
\t\tvar vector = new THREE.Vector3();\n\
\n\
\t\treturn function ( vectorA, vectorB, vectorC ) {\n\
\n\
\t\t\tvar point = new THREE.Vector3();\n\
\n\
\t\t\tvar a = THREE.Math.random16();\n\
\t\t\tvar b = THREE.Math.random16();\n\
\n\
\t\t\tif ( ( a + b ) > 1 ) {\n\
\n\
\t\t\t\ta = 1 - a;\n\
\t\t\t\tb = 1 - b;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar c = 1 - a - b;\n\
\n\
\t\t\tpoint.copy( vectorA );\n\
\t\t\tpoint.multiplyScalar( a );\n\
\n\
\t\t\tvector.copy( vectorB );\n\
\t\t\tvector.multiplyScalar( b );\n\
\n\
\t\t\tpoint.add( vector );\n\
\n\
\t\t\tvector.copy( vectorC );\n\
\t\t\tvector.multiplyScalar( c );\n\
\n\
\t\t\tpoint.add( vector );\n\
\n\
\t\t\treturn point;\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\t// Get random point in face (triangle / quad)\n\
\t// (uniform distribution)\n\
\n\
\trandomPointInFace: function ( face, geometry, useCachedAreas ) {\n\
\n\
\t\tvar vA, vB, vC, vD;\n\
\n\
\t\tvA = geometry.vertices[ face.a ];\n\
\t\tvB = geometry.vertices[ face.b ];\n\
\t\tvC = geometry.vertices[ face.c ];\n\
\n\
\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\n\
\n\
\t},\n\
\n\
\t// Get uniformly distributed random points in mesh\n\
\t// \t- create array with cumulative sums of face areas\n\
\t//  - pick random number from 0 to total area\n\
\t//  - find corresponding place in area array by binary search\n\
\t//\t- get random point in face\n\
\n\
\trandomPointsInGeometry: function ( geometry, n ) {\n\
\n\
\t\tvar face, i,\n\
\t\t\tfaces = geometry.faces,\n\
\t\t\tvertices = geometry.vertices,\n\
\t\t\til = faces.length,\n\
\t\t\ttotalArea = 0,\n\
\t\t\tcumulativeAreas = [],\n\
\t\t\tvA, vB, vC, vD;\n\
\n\
\t\t// precompute face areas\n\
\n\
\t\tfor ( i = 0; i < il; i ++ ) {\n\
\n\
\t\t\tface = faces[ i ];\n\
\n\
\t\t\tvA = vertices[ face.a ];\n\
\t\t\tvB = vertices[ face.b ];\n\
\t\t\tvC = vertices[ face.c ];\n\
\n\
\t\t\tface._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );\n\
\n\
\t\t\ttotalArea += face._area;\n\
\n\
\t\t\tcumulativeAreas[ i ] = totalArea;\n\
\n\
\t\t}\n\
\n\
\t\t// binary search cumulative areas array\n\
\n\
\t\tfunction binarySearchIndices( value ) {\n\
\n\
\t\t\tfunction binarySearch( start, end ) {\n\
\n\
\t\t\t\t// return closest larger index\n\
\t\t\t\t// if exact number is not found\n\
\n\
\t\t\t\tif ( end < start )\n\
\t\t\t\t\treturn start;\n\
\n\
\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\n\
\n\
\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\n\
\n\
\t\t\t\t\treturn binarySearch( start, mid - 1 );\n\
\n\
\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\n\
\n\
\t\t\t\t\treturn binarySearch( mid + 1, end );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\treturn mid;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 )\n\
\t\t\treturn result;\n\
\n\
\t\t}\n\
\n\
\t\t// pick random face weighted by face area\n\
\n\
\t\tvar r, index,\n\
\t\t\tresult = [];\n\
\n\
\t\tvar stats = {};\n\
\n\
\t\tfor ( i = 0; i < n; i ++ ) {\n\
\n\
\t\t\tr = THREE.Math.random16() * totalArea;\n\
\n\
\t\t\tindex = binarySearchIndices( r );\n\
\n\
\t\t\tresult[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\n\
\n\
\t\t\tif ( ! stats[ index ] ) {\n\
\n\
\t\t\t\tstats[ index ] = 1;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tstats[ index ] += 1;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn result;\n\
\n\
\t},\n\
\n\
\t// Get triangle area (half of parallelogram)\n\
\t//\thttp://mathworld.wolfram.com/TriangleArea.html\n\
\n\
\ttriangleArea: function () {\n\
\n\
\t\tvar vector1 = new THREE.Vector3();\n\
\t\tvar vector2 = new THREE.Vector3();\n\
\n\
\t\treturn function ( vectorA, vectorB, vectorC ) {\n\
\n\
\t\t\tvector1.subVectors( vectorB, vectorA );\n\
\t\t\tvector2.subVectors( vectorC, vectorA );\n\
\t\t\tvector1.cross( vector2 );\n\
\n\
\t\t\treturn 0.5 * vector1.length();\n\
\n\
\t\t};\n\
\n\
\t}(),\n\
\n\
\t// Center geometry so that 0,0,0 is in center of bounding box\n\
\n\
\tcenter: function ( geometry ) {\n\
\n\
\t\tgeometry.computeBoundingBox();\n\
\n\
\t\tvar bb = geometry.boundingBox;\n\
\n\
\t\tvar offset = new THREE.Vector3();\n\
\n\
\t\toffset.addVectors( bb.min, bb.max );\n\
\t\toffset.multiplyScalar( -0.5 );\n\
\n\
\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );\n\
\t\tgeometry.computeBoundingBox();\n\
\n\
\t\treturn offset;\n\
\n\
\t},\n\
\n\
\ttriangulateQuads: function ( geometry ) {\n\
\n\
\t\tvar i, il, j, jl;\n\
\n\
\t\tvar faces = [];\n\
\t\tvar faceVertexUvs = [];\n\
\n\
\t\tfor ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\
\n\
\t\t\tfaceVertexUvs[ i ] = [];\n\
\n\
\t\t}\n\
\n\
\t\tfor ( i = 0, il = geometry.faces.length; i < il; i ++ ) {\n\
\n\
\t\t\tvar face = geometry.faces[ i ];\n\
\n\
\t\t\tfaces.push( face );\n\
\n\
\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tgeometry.faces = faces;\n\
\t\tgeometry.faceVertexUvs = faceVertexUvs;\n\
\n\
\t\tgeometry.computeCentroids();\n\
\t\tgeometry.computeFaceNormals();\n\
\t\tgeometry.computeVertexNormals();\n\
\n\
\t\tif ( geometry.hasTangents ) geometry.computeTangents();\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.ImageUtils = {\n\
\n\
\tcrossOrigin: 'anonymous',\n\
\n\
\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\
\n\
\t\tvar image = new Image();\n\
\t\tvar texture = new THREE.Texture( image, mapping );\n\
\n\
\t\tvar loader = new THREE.ImageLoader();\n\
\t\tloader.crossOrigin = this.crossOrigin;\n\
\t\tloader.load( url, function ( image ) {\n\
\n\
\t\t\ttexture.image = image;\n\
\t\t\ttexture.needsUpdate = true;\n\
\n\
\t\t\tif ( onLoad ) onLoad( texture );\n\
\n\
\t\t} );\n\
\n\
\t\ttexture.sourceFile = url;\n\
\n\
\t\treturn texture;\n\
\n\
\t},\n\
\n\
\tloadCompressedTexture: function ( url, mapping, onLoad, onError ) {\n\
\n\
\t\tvar texture = new THREE.CompressedTexture();\n\
\t\ttexture.mapping = mapping;\n\
\n\
\t\tvar request = new XMLHttpRequest();\n\
\n\
\t\trequest.onload = function () {\n\
\n\
\t\t\tvar buffer = request.response;\n\
\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\
\n\
\t\t\ttexture.format = dds.format;\n\
\n\
\t\t\ttexture.mipmaps = dds.mipmaps;\n\
\t\t\ttexture.image.width = dds.width;\n\
\t\t\ttexture.image.height = dds.height;\n\
\n\
\t\t\t// gl.generateMipmap fails for compressed textures\n\
\t\t\t// mipmaps must be embedded in the DDS file\n\
\t\t\t// or texture filters must not use mipmapping\n\
\n\
\t\t\ttexture.generateMipmaps = false;\n\
\n\
\t\t\ttexture.needsUpdate = true;\n\
\n\
\t\t\tif ( onLoad ) onLoad( texture );\n\
\n\
\t\t}\n\
\n\
\t\trequest.onerror = onError;\n\
\n\
\t\trequest.open( 'GET', url, true );\n\
\t\trequest.responseType = \"arraybuffer\";\n\
\t\trequest.send( null );\n\
\n\
\t\treturn texture;\n\
\n\
\t},\n\
\n\
\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\n\
\n\
\t\tvar images = [];\n\
\t\timages.loadCount = 0;\n\
\n\
\t\tvar texture = new THREE.Texture();\n\
\t\ttexture.image = images;\n\
\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\
\n\
\t\t// no flipping needed for cube textures\n\
\n\
\t\ttexture.flipY = false;\n\
\n\
\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\n\
\n\
\t\t\tvar cubeImage = new Image();\n\
\t\t\timages[ i ] = cubeImage;\n\
\n\
\t\t\tcubeImage.onload = function () {\n\
\n\
\t\t\t\timages.loadCount += 1;\n\
\n\
\t\t\t\tif ( images.loadCount === 6 ) {\n\
\n\
\t\t\t\t\ttexture.needsUpdate = true;\n\
\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t};\n\
\n\
\t\t\tcubeImage.onerror = onError;\n\
\n\
\t\t\tcubeImage.crossOrigin = this.crossOrigin;\n\
\t\t\tcubeImage.src = array[ i ];\n\
\n\
\t\t}\n\
\n\
\t\treturn texture;\n\
\n\
\t},\n\
\n\
\tloadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {\n\
\n\
\t\tvar images = [];\n\
\t\timages.loadCount = 0;\n\
\n\
\t\tvar texture = new THREE.CompressedTexture();\n\
\t\ttexture.image = images;\n\
\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\
\n\
\t\t// no flipping for cube textures\n\
\t\t// (also flipping doesn't work for compressed textures )\n\
\n\
\t\ttexture.flipY = false;\n\
\n\
\t\t// can't generate mipmaps for compressed textures\n\
\t\t// mips must be embedded in DDS files\n\
\n\
\t\ttexture.generateMipmaps = false;\n\
\n\
\t\tvar generateCubeFaceCallback = function ( rq, img ) {\n\
\n\
\t\t\treturn function () {\n\
\n\
\t\t\t\tvar buffer = rq.response;\n\
\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\
\n\
\t\t\t\timg.format = dds.format;\n\
\n\
\t\t\t\timg.mipmaps = dds.mipmaps;\n\
\t\t\t\timg.width = dds.width;\n\
\t\t\t\timg.height = dds.height;\n\
\n\
\t\t\t\timages.loadCount += 1;\n\
\n\
\t\t\t\tif ( images.loadCount === 6 ) {\n\
\n\
\t\t\t\t\ttexture.format = dds.format;\n\
\t\t\t\t\ttexture.needsUpdate = true;\n\
\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// compressed cubemap textures as 6 separate DDS files\n\
\n\
\t\tif ( array instanceof Array ) {\n\
\n\
\t\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\n\
\n\
\t\t\t\tvar cubeImage = {};\n\
\t\t\t\timages[ i ] = cubeImage;\n\
\n\
\t\t\t\tvar request = new XMLHttpRequest();\n\
\n\
\t\t\t\trequest.onload = generateCubeFaceCallback( request, cubeImage );\n\
\t\t\t\trequest.onerror = onError;\n\
\n\
\t\t\t\tvar url = array[ i ];\n\
\n\
\t\t\t\trequest.open( 'GET', url, true );\n\
\t\t\t\trequest.responseType = \"arraybuffer\";\n\
\t\t\t\trequest.send( null );\n\
\n\
\t\t\t}\n\
\n\
\t\t// compressed cubemap texture stored in a single DDS file\n\
\n\
\t\t} else {\n\
\n\
\t\t\tvar url = array;\n\
\t\t\tvar request = new XMLHttpRequest();\n\
\n\
\t\t\trequest.onload = function( ) {\n\
\n\
\t\t\t\tvar buffer = request.response;\n\
\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\
\n\
\t\t\t\tif ( dds.isCubemap ) {\n\
\n\
\t\t\t\t\tvar faces = dds.mipmaps.length / dds.mipmapCount;\n\
\n\
\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\
\n\
\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\
\n\
\t\t\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\
\n\
\t\t\t\t\t\t\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\n\
\t\t\t\t\t\t\timages[ f ].format = dds.format;\n\
\t\t\t\t\t\t\timages[ f ].width = dds.width;\n\
\t\t\t\t\t\t\timages[ f ].height = dds.height;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\ttexture.format = dds.format;\n\
\t\t\t\t\ttexture.needsUpdate = true;\n\
\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\trequest.onerror = onError;\n\
\n\
\t\t\trequest.open( 'GET', url, true );\n\
\t\t\trequest.responseType = \"arraybuffer\";\n\
\t\t\trequest.send( null );\n\
\n\
\t\t}\n\
\n\
\t\treturn texture;\n\
\n\
\t},\n\
\n\
\tparseDDS: function ( buffer, loadMipmaps ) {\n\
\n\
\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\
\n\
\t\t// Adapted from @toji's DDS utils\n\
\t\t//\thttps://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\
\n\
\t\t// All values and structures referenced from:\n\
\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\
\n\
\t\tvar DDS_MAGIC = 0x20534444;\n\
\n\
\t\tvar DDSD_CAPS = 0x1,\n\
\t\t\tDDSD_HEIGHT = 0x2,\n\
\t\t\tDDSD_WIDTH = 0x4,\n\
\t\t\tDDSD_PITCH = 0x8,\n\
\t\t\tDDSD_PIXELFORMAT = 0x1000,\n\
\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\n\
\t\t\tDDSD_LINEARSIZE = 0x80000,\n\
\t\t\tDDSD_DEPTH = 0x800000;\n\
\n\
\t\tvar DDSCAPS_COMPLEX = 0x8,\n\
\t\t\tDDSCAPS_MIPMAP = 0x400000,\n\
\t\t\tDDSCAPS_TEXTURE = 0x1000;\n\
\n\
\t\tvar DDSCAPS2_CUBEMAP = 0x200,\n\
\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n\
\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n\
\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n\
\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n\
\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n\
\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n\
\t\t\tDDSCAPS2_VOLUME = 0x200000;\n\
\n\
\t\tvar DDPF_ALPHAPIXELS = 0x1,\n\
\t\t\tDDPF_ALPHA = 0x2,\n\
\t\t\tDDPF_FOURCC = 0x4,\n\
\t\t\tDDPF_RGB = 0x40,\n\
\t\t\tDDPF_YUV = 0x200,\n\
\t\t\tDDPF_LUMINANCE = 0x20000;\n\
\n\
\t\tfunction fourCCToInt32( value ) {\n\
\n\
\t\t\treturn value.charCodeAt(0) +\n\
\t\t\t\t(value.charCodeAt(1) << 8) +\n\
\t\t\t\t(value.charCodeAt(2) << 16) +\n\
\t\t\t\t(value.charCodeAt(3) << 24);\n\
\n\
\t\t}\n\
\n\
\t\tfunction int32ToFourCC( value ) {\n\
\n\
\t\t\treturn String.fromCharCode(\n\
\t\t\t\tvalue & 0xff,\n\
\t\t\t\t(value >> 8) & 0xff,\n\
\t\t\t\t(value >> 16) & 0xff,\n\
\t\t\t\t(value >> 24) & 0xff\n\
\t\t\t);\n\
\t\t}\n\
\n\
\t\tvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n\
\t\tvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n\
\t\tvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n\
\n\
\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\n\
\n\
\t\t// Offsets into the header array\n\
\n\
\t\tvar off_magic = 0;\n\
\n\
\t\tvar off_size = 1;\n\
\t\tvar off_flags = 2;\n\
\t\tvar off_height = 3;\n\
\t\tvar off_width = 4;\n\
\n\
\t\tvar off_mipmapCount = 7;\n\
\n\
\t\tvar off_pfFlags = 20;\n\
\t\tvar off_pfFourCC = 21;\n\
\n\
\t\tvar off_caps = 27;\n\
\t\tvar off_caps2 = 28;\n\
\t\tvar off_caps3 = 29;\n\
\t\tvar off_caps4 = 30;\n\
\n\
\t\t// Parse header\n\
\n\
\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\n\
\n\
\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\
\n\
\t\t\tconsole.error( \"ImageUtils.parseDDS(): Invalid magic number in DDS header\" );\n\
\t\t\treturn dds;\n\
\n\
\t\t}\n\
\n\
\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\n\
\n\
\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\" );\n\
\t\t\treturn dds;\n\
\n\
\t\t}\n\
\n\
\t\tvar blockBytes;\n\
\n\
\t\tvar fourCC = header[ off_pfFourCC ];\n\
\n\
\t\tswitch ( fourCC ) {\n\
\n\
\t\t\tcase FOURCC_DXT1:\n\
\n\
\t\t\t\tblockBytes = 8;\n\
\t\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\n\
\t\t\t\tbreak;\n\
\n\
\t\t\tcase FOURCC_DXT3:\n\
\n\
\t\t\t\tblockBytes = 16;\n\
\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\n\
\t\t\t\tbreak;\n\
\n\
\t\t\tcase FOURCC_DXT5:\n\
\n\
\t\t\t\tblockBytes = 16;\n\
\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\n\
\t\t\t\tbreak;\n\
\n\
\t\t\tdefault:\n\
\n\
\t\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported FourCC code: \", int32ToFourCC( fourCC ) );\n\
\t\t\t\treturn dds;\n\
\n\
\t\t}\n\
\n\
\t\tdds.mipmapCount = 1;\n\
\n\
\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\
\n\
\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\
\n\
\t\t}\n\
\n\
\t\t//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.\n\
\n\
\t\tdds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;\n\
\n\
\t\tdds.width = header[ off_width ];\n\
\t\tdds.height = header[ off_height ];\n\
\n\
\t\tvar dataOffset = header[ off_size ] + 4;\n\
\n\
\t\t// Extract mipmaps buffers\n\
\n\
\t\tvar width = dds.width;\n\
\t\tvar height = dds.height;\n\
\n\
\t\tvar faces = dds.isCubemap ? 6 : 1;\n\
\n\
\t\tfor ( var face = 0; face < faces; face ++ ) {\n\
\n\
\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\
\n\
\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\
\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\
\n\
\t\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\n\
\t\t\t\tdds.mipmaps.push( mipmap );\n\
\n\
\t\t\t\tdataOffset += dataLength;\n\
\n\
\t\t\t\twidth = Math.max( width * 0.5, 1 );\n\
\t\t\t\theight = Math.max( height * 0.5, 1 );\n\
\n\
\t\t\t}\n\
\n\
\t\t\twidth = dds.width;\n\
\t\t\theight = dds.height;\n\
\n\
\t\t}\n\
\n\
\t\treturn dds;\n\
\n\
\t},\n\
\n\
\tgetNormalMap: function ( image, depth ) {\n\
\n\
\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\n\
\n\
\t\tvar cross = function ( a, b ) {\n\
\n\
\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\n\
\n\
\t\t}\n\
\n\
\t\tvar subtract = function ( a, b ) {\n\
\n\
\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\n\
\n\
\t\t}\n\
\n\
\t\tvar normalize = function ( a ) {\n\
\n\
\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\n\
\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\n\
\n\
\t\t}\n\
\n\
\t\tdepth = depth | 1;\n\
\n\
\t\tvar width = image.width;\n\
\t\tvar height = image.height;\n\
\n\
\t\tvar canvas = document.createElement( 'canvas' );\n\
\t\tcanvas.width = width;\n\
\t\tcanvas.height = height;\n\
\n\
\t\tvar context = canvas.getContext( '2d' );\n\
\t\tcontext.drawImage( image, 0, 0 );\n\
\n\
\t\tvar data = context.getImageData( 0, 0, width, height ).data;\n\
\t\tvar imageData = context.createImageData( width, height );\n\
\t\tvar output = imageData.data;\n\
\n\
\t\tfor ( var x = 0; x < width; x ++ ) {\n\
\n\
\t\t\tfor ( var y = 0; y < height; y ++ ) {\n\
\n\
\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\n\
\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\n\
\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\n\
\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\n\
\n\
\t\t\t\tvar points = [];\n\
\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\n\
\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\n\
\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\n\
\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\n\
\t\t\t\tpoints.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\n\
\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\n\
\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\n\
\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\n\
\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\n\
\n\
\t\t\t\tvar normals = [];\n\
\t\t\t\tvar num_points = points.length;\n\
\n\
\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\n\
\n\
\t\t\t\t\tvar v1 = points[ i ];\n\
\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\n\
\t\t\t\t\tv1 = subtract( v1, origin );\n\
\t\t\t\t\tv2 = subtract( v2, origin );\n\
\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tvar normal = [ 0, 0, 0 ];\n\
\n\
\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\n\
\n\
\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\n\
\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\n\
\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tnormal[ 0 ] /= normals.length;\n\
\t\t\t\tnormal[ 1 ] /= normals.length;\n\
\t\t\t\tnormal[ 2 ] /= normals.length;\n\
\n\
\t\t\t\tvar idx = ( y * width + x ) * 4;\n\
\n\
\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\n\
\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\n\
\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\n\
\t\t\t\toutput[ idx + 3 ] = 255;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tcontext.putImageData( imageData, 0, 0 );\n\
\n\
\t\treturn canvas;\n\
\n\
\t},\n\
\n\
\tgenerateDataTexture: function ( width, height, color ) {\n\
\n\
\t\tvar size = width * height;\n\
\t\tvar data = new Uint8Array( 3 * size );\n\
\n\
\t\tvar r = Math.floor( color.r * 255 );\n\
\t\tvar g = Math.floor( color.g * 255 );\n\
\t\tvar b = Math.floor( color.b * 255 );\n\
\n\
\t\tfor ( var i = 0; i < size; i ++ ) {\n\
\n\
\t\t\tdata[ i * 3 ] \t  = r;\n\
\t\t\tdata[ i * 3 + 1 ] = g;\n\
\t\t\tdata[ i * 3 + 2 ] = b;\n\
\n\
\t\t}\n\
\n\
\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\n\
\t\ttexture.needsUpdate = true;\n\
\n\
\t\treturn texture;\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.SceneUtils = {\n\
\n\
\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\
\n\
\t\tvar group = new THREE.Object3D();\n\
\n\
\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\
\n\
\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\
\n\
\t\t}\n\
\n\
\t\treturn group;\n\
\n\
\t},\n\
\n\
\tdetach : function ( child, parent, scene ) {\n\
\n\
\t\tchild.applyMatrix( parent.matrixWorld );\n\
\t\tparent.remove( child );\n\
\t\tscene.add( child );\n\
\n\
\t},\n\
\n\
\tattach: function ( child, scene, parent ) {\n\
\n\
\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\
\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\
\t\tchild.applyMatrix( matrixWorldInverse );\n\
\n\
\t\tscene.remove( child );\n\
\t\tparent.add( child );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author zz85 / http://www.lab4games.net/zz85/blog\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * For Text operations in three.js (See TextGeometry)\n\
 *\n\
 * It uses techniques used in:\n\
 *\n\
 * \ttypeface.js and canvastext\n\
 * \t\tFor converting fonts and rendering with javascript\n\
 *\t\thttp://typeface.neocracy.org\n\
 *\n\
 *\tTriangulation ported from AS3\n\
 *\t\tSimple Polygon Triangulation\n\
 *\t\thttp://actionsnippet.com/?p=1462\n\
 *\n\
 * \tA Method to triangulate shapes with holes\n\
 *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\n\
 *\n\
 */\n\
\n\
THREE.FontUtils = {\n\
\n\
\tfaces : {},\n\
\n\
\t// Just for now. face[weight][style]\n\
\n\
\tface : \"helvetiker\",\n\
\tweight: \"normal\",\n\
\tstyle : \"normal\",\n\
\tsize : 150,\n\
\tdivisions : 10,\n\
\n\
\tgetFace : function() {\n\
\n\
\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\n\
\n\
\t},\n\
\n\
\tloadFace : function( data ) {\n\
\n\
\t\tvar family = data.familyName.toLowerCase();\n\
\n\
\t\tvar ThreeFont = this;\n\
\n\
\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\n\
\n\
\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\n\
\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\n\
\n\
\t\tvar face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\n\
\n\
\t\treturn data;\n\
\n\
\t},\n\
\n\
\tdrawText : function( text ) {\n\
\n\
\t\tvar characterPts = [], allPts = [];\n\
\n\
\t\t// RenderText\n\
\n\
\t\tvar i, p,\n\
\t\t\tface = this.getFace(),\n\
\t\t\tscale = this.size / face.resolution,\n\
\t\t\toffset = 0,\n\
\t\t\tchars = String( text ).split( '' ),\n\
\t\t\tlength = chars.length;\n\
\n\
\t\tvar fontPaths = [];\n\
\n\
\t\tfor ( i = 0; i < length; i ++ ) {\n\
\n\
\t\t\tvar path = new THREE.Path();\n\
\n\
\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\n\
\t\t\toffset += ret.offset;\n\
\n\
\t\t\tfontPaths.push( ret.path );\n\
\n\
\t\t}\n\
\n\
\t\t// get the width\n\
\n\
\t\tvar width = offset / 2;\n\
\t\t//\n\
\t\t// for ( p = 0; p < allPts.length; p++ ) {\n\
\t\t//\n\
\t\t// \tallPts[ p ].x -= width;\n\
\t\t//\n\
\t\t// }\n\
\n\
\t\t//var extract = this.extractPoints( allPts, characterPts );\n\
\t\t//extract.contour = allPts;\n\
\n\
\t\t//extract.paths = fontPaths;\n\
\t\t//extract.offset = width;\n\
\n\
\t\treturn { paths : fontPaths, offset : width };\n\
\n\
\t},\n\
\n\
\n\
\n\
\n\
\textractGlyphPoints : function( c, face, scale, offset, path ) {\n\
\n\
\t\tvar pts = [];\n\
\n\
\t\tvar i, i2, divisions,\n\
\t\t\toutline, action, length,\n\
\t\t\tscaleX, scaleY,\n\
\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\n\
\t\t\tlaste,\n\
\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\n\
\n\
\t\tif ( !glyph ) return;\n\
\n\
\t\tif ( glyph.o ) {\n\
\n\
\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\
\t\t\tlength = outline.length;\n\
\n\
\t\t\tscaleX = scale;\n\
\t\t\tscaleY = scale;\n\
\n\
\t\t\tfor ( i = 0; i < length; ) {\n\
\n\
\t\t\t\taction = outline[ i ++ ];\n\
\n\
\t\t\t\t//console.log( action );\n\
\n\
\t\t\t\tswitch( action ) {\n\
\n\
\t\t\t\tcase 'm':\n\
\n\
\t\t\t\t\t// Move To\n\
\n\
\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\n\
\t\t\t\t\ty = outline[ i++ ] * scaleY;\n\
\n\
\t\t\t\t\tpath.moveTo( x, y );\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tcase 'l':\n\
\n\
\t\t\t\t\t// Line To\n\
\n\
\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\n\
\t\t\t\t\ty = outline[ i++ ] * scaleY;\n\
\t\t\t\t\tpath.lineTo(x,y);\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\tcase 'q':\n\
\n\
\t\t\t\t\t// QuadraticCurveTo\n\
\n\
\t\t\t\t\tcpx  = outline[ i++ ] * scaleX + offset;\n\
\t\t\t\t\tcpy  = outline[ i++ ] * scaleY;\n\
\t\t\t\t\tcpx1 = outline[ i++ ] * scaleX + offset;\n\
\t\t\t\t\tcpy1 = outline[ i++ ] * scaleY;\n\
\n\
\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n\
\n\
\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\
\n\
\t\t\t\t\tif ( laste ) {\n\
\n\
\t\t\t\t\t\tcpx0 = laste.x;\n\
\t\t\t\t\t\tcpy0 = laste.y;\n\
\n\
\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\n\
\n\
\t\t\t\t\t\t\tvar t = i2 / divisions;\n\
\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\n\
\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\n\
\t\t\t\t\t  }\n\
\n\
\t\t\t\t  }\n\
\n\
\t\t\t\t  break;\n\
\n\
\t\t\t\tcase 'b':\n\
\n\
\t\t\t\t\t// Cubic Bezier Curve\n\
\n\
\t\t\t\t\tcpx  = outline[ i++ ] *  scaleX + offset;\n\
\t\t\t\t\tcpy  = outline[ i++ ] *  scaleY;\n\
\t\t\t\t\tcpx1 = outline[ i++ ] *  scaleX + offset;\n\
\t\t\t\t\tcpy1 = outline[ i++ ] * -scaleY;\n\
\t\t\t\t\tcpx2 = outline[ i++ ] *  scaleX + offset;\n\
\t\t\t\t\tcpy2 = outline[ i++ ] * -scaleY;\n\
\n\
\t\t\t\t\tpath.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );\n\
\n\
\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\
\n\
\t\t\t\t\tif ( laste ) {\n\
\n\
\t\t\t\t\t\tcpx0 = laste.x;\n\
\t\t\t\t\t\tcpy0 = laste.y;\n\
\n\
\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\n\
\n\
\t\t\t\t\t\t\tvar t = i2 / divisions;\n\
\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\n\
\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\t\t}\n\
\n\
\n\
\n\
\t\treturn { offset: glyph.ha*scale, path:path};\n\
\t}\n\
\n\
};\n\
\n\
\n\
THREE.FontUtils.generateShapes = function( text, parameters ) {\n\
\n\
\t// Parameters \n\
\n\
\tparameters = parameters || {};\n\
\n\
\tvar size = parameters.size !== undefined ? parameters.size : 100;\n\
\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;\n\
\n\
\tvar font = parameters.font !== undefined ? parameters.font : \"helvetiker\";\n\
\tvar weight = parameters.weight !== undefined ? parameters.weight : \"normal\";\n\
\tvar style = parameters.style !== undefined ? parameters.style : \"normal\";\n\
\n\
\tTHREE.FontUtils.size = size;\n\
\tTHREE.FontUtils.divisions = curveSegments;\n\
\n\
\tTHREE.FontUtils.face = font;\n\
\tTHREE.FontUtils.weight = weight;\n\
\tTHREE.FontUtils.style = style;\n\
\n\
\t// Get a Font data json object\n\
\n\
\tvar data = THREE.FontUtils.drawText( text );\n\
\n\
\tvar paths = data.paths;\n\
\tvar shapes = [];\n\
\n\
\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\
\n\
\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\
\n\
\t}\n\
\n\
\treturn shapes;\n\
\n\
};\n\
\n\
\n\
/**\n\
 * This code is a quick port of code written in C++ which was submitted to\n\
 * flipcode.com by John W. Ratcliff  // July 22, 2000\n\
 * See original code and more information here:\n\
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\
 *\n\
 * ported to actionscript by Zevan Rosser\n\
 * www.actionsnippet.com\n\
 *\n\
 * ported to javascript by Joshua Koo\n\
 * http://www.lab4games.net/zz85/blog\n\
 *\n\
 */\n\
\n\
\n\
( function( namespace ) {\n\
\n\
\tvar EPSILON = 0.0000000001;\n\
\n\
\t// takes in an contour array and returns\n\
\n\
\tvar process = function( contour, indices ) {\n\
\n\
\t\tvar n = contour.length;\n\
\n\
\t\tif ( n < 3 ) return null;\n\
\n\
\t\tvar result = [],\n\
\t\t\tverts = [],\n\
\t\t\tvertIndices = [];\n\
\n\
\t\t/* we want a counter-clockwise polygon in verts */\n\
\n\
\t\tvar u, v, w;\n\
\n\
\t\tif ( area( contour ) > 0.0 ) {\n\
\n\
\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = v;\n\
\n\
\t\t} else {\n\
\n\
\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;\n\
\n\
\t\t}\n\
\n\
\t\tvar nv = n;\n\
\n\
\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\
\n\
\t\tvar count = 2 * nv;   /* error detection */\n\
\n\
\t\tfor( v = nv - 1; nv > 2; ) {\n\
\n\
\t\t\t/* if we loop, it is probably a non-simple polygon */\n\
\n\
\t\t\tif ( ( count-- ) <= 0 ) {\n\
\n\
\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\
\n\
\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\
\t\t\t\t//return null;\n\
\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\
\t\t\t\tconsole.log( \"Warning, unable to triangulate polygon!\" );\n\
\n\
\t\t\t\tif ( indices ) return vertIndices;\n\
\t\t\t\treturn result;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\
\n\
\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\
\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\
\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\
\n\
\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\
\n\
\t\t\t\tvar a, b, c, s, t;\n\
\n\
\t\t\t\t/* true names of the vertices */\n\
\n\
\t\t\t\ta = verts[ u ];\n\
\t\t\t\tb = verts[ v ];\n\
\t\t\t\tc = verts[ w ];\n\
\n\
\t\t\t\t/* output Triangle */\n\
\n\
\t\t\t\tresult.push( [ contour[ a ],\n\
\t\t\t\t\tcontour[ b ],\n\
\t\t\t\t\tcontour[ c ] ] );\n\
\n\
\n\
\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\
\n\
\t\t\t\t/* remove v from the remaining polygon */\n\
\n\
\t\t\t\tfor( s = v, t = v + 1; t < nv; s++, t++ ) {\n\
\n\
\t\t\t\t\tverts[ s ] = verts[ t ];\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tnv--;\n\
\n\
\t\t\t\t/* reset error detection counter */\n\
\n\
\t\t\t\tcount = 2 * nv;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tif ( indices ) return vertIndices;\n\
\t\treturn result;\n\
\n\
\t};\n\
\n\
\t// calculate area of the contour polygon\n\
\n\
\tvar area = function ( contour ) {\n\
\n\
\t\tvar n = contour.length;\n\
\t\tvar a = 0.0;\n\
\n\
\t\tfor( var p = n - 1, q = 0; q < n; p = q++ ) {\n\
\n\
\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\
\n\
\t\t}\n\
\n\
\t\treturn a * 0.5;\n\
\n\
\t};\n\
\n\
\tvar snip = function ( contour, u, v, w, n, verts ) {\n\
\n\
\t\tvar p;\n\
\t\tvar ax, ay, bx, by;\n\
\t\tvar cx, cy, px, py;\n\
\n\
\t\tax = contour[ verts[ u ] ].x;\n\
\t\tay = contour[ verts[ u ] ].y;\n\
\n\
\t\tbx = contour[ verts[ v ] ].x;\n\
\t\tby = contour[ verts[ v ] ].y;\n\
\n\
\t\tcx = contour[ verts[ w ] ].x;\n\
\t\tcy = contour[ verts[ w ] ].y;\n\
\n\
\t\tif ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;\n\
\n\
\t\tvar aX, aY, bX, bY, cX, cY;\n\
\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\
\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\
\n\
\t\taX = cx - bx;  aY = cy - by;\n\
\t\tbX = ax - cx;  bY = ay - cy;\n\
\t\tcX = bx - ax;  cY = by - ay;\n\
\n\
\t\tfor ( p = 0; p < n; p++ ) {\n\
\n\
\t\t\tif( (p === u) || (p === v) || (p === w) ) continue;\n\
\n\
\t\t\tpx = contour[ verts[ p ] ].x\n\
\t\t\tpy = contour[ verts[ p ] ].y\n\
\n\
\t\t\tapx = px - ax;  apy = py - ay;\n\
\t\t\tbpx = px - bx;  bpy = py - by;\n\
\t\t\tcpx = px - cx;  cpy = py - cy;\n\
\n\
\t\t\t// see if p is inside triangle abc\n\
\n\
\t\t\taCROSSbp = aX*bpy - aY*bpx;\n\
\t\t\tcCROSSap = cX*apy - cY*apx;\n\
\t\t\tbCROSScp = bX*cpy - bY*cpx;\n\
\n\
\t\t\tif ( (aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON) ) return false;\n\
\n\
\t\t}\n\
\n\
\t\treturn true;\n\
\n\
\t};\n\
\n\
\n\
\tnamespace.Triangulate = process;\n\
\tnamespace.Triangulate.area = area;\n\
\n\
\treturn namespace;\n\
\n\
})(THREE.FontUtils);\n\
\n\
// To use the typeface.js face files, hook up the API\n\
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };\n\
THREE.typeface_js = self._typeface_js;\n\
\n\
/**\n\
 * @author zz85 / http://www.lab4games.net/zz85/blog\n\
 * Extensible curve object\n\
 *\n\
 * Some common of Curve methods\n\
 * .getPoint(t), getTangent(t)\n\
 * .getPointAt(u), getTagentAt(u)\n\
 * .getPoints(), .getSpacedPoints()\n\
 * .getLength()\n\
 * .updateArcLengths()\n\
 *\n\
 * This following classes subclasses THREE.Curve:\n\
 *\n\
 * -- 2d classes --\n\
 * THREE.LineCurve\n\
 * THREE.QuadraticBezierCurve\n\
 * THREE.CubicBezierCurve\n\
 * THREE.SplineCurve\n\
 * THREE.ArcCurve\n\
 * THREE.EllipseCurve\n\
 *\n\
 * -- 3d classes --\n\
 * THREE.LineCurve3\n\
 * THREE.QuadraticBezierCurve3\n\
 * THREE.CubicBezierCurve3\n\
 * THREE.SplineCurve3\n\
 * THREE.ClosedSplineCurve3\n\
 *\n\
 * A series of curves can be represented as a THREE.CurvePath\n\
 *\n\
 **/\n\
\n\
/**************************************************************\n\
 *\tAbstract Curve base class\n\
 **************************************************************/\n\
\n\
THREE.Curve = function () {\n\
\n\
};\n\
\n\
// Virtual base class method to overwrite and implement in subclasses\n\
//\t- t [0 .. 1]\n\
\n\
THREE.Curve.prototype.getPoint = function ( t ) {\n\
\n\
\tconsole.log( \"Warning, getPoint() not implemented!\" );\n\
\treturn null;\n\
\n\
};\n\
\n\
// Get point at relative position in curve according to arc length\n\
// - u [0 .. 1]\n\
\n\
THREE.Curve.prototype.getPointAt = function ( u ) {\n\
\n\
\tvar t = this.getUtoTmapping( u );\n\
\treturn this.getPoint( t );\n\
\n\
};\n\
\n\
// Get sequence of points using getPoint( t )\n\
\n\
THREE.Curve.prototype.getPoints = function ( divisions ) {\n\
\n\
\tif ( !divisions ) divisions = 5;\n\
\n\
\tvar d, pts = [];\n\
\n\
\tfor ( d = 0; d <= divisions; d ++ ) {\n\
\n\
\t\tpts.push( this.getPoint( d / divisions ) );\n\
\n\
\t}\n\
\n\
\treturn pts;\n\
\n\
};\n\
\n\
// Get sequence of points using getPointAt( u )\n\
\n\
THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\n\
\n\
\tif ( !divisions ) divisions = 5;\n\
\n\
\tvar d, pts = [];\n\
\n\
\tfor ( d = 0; d <= divisions; d ++ ) {\n\
\n\
\t\tpts.push( this.getPointAt( d / divisions ) );\n\
\n\
\t}\n\
\n\
\treturn pts;\n\
\n\
};\n\
\n\
// Get total curve arc length\n\
\n\
THREE.Curve.prototype.getLength = function () {\n\
\n\
\tvar lengths = this.getLengths();\n\
\treturn lengths[ lengths.length - 1 ];\n\
\n\
};\n\
\n\
// Get list of cumulative segment lengths\n\
\n\
THREE.Curve.prototype.getLengths = function ( divisions ) {\n\
\n\
\tif ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;\n\
\n\
\tif ( this.cacheArcLengths\n\
\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\n\
\t\t&& !this.needsUpdate) {\n\
\n\
\t\t//console.log( \"cached\", this.cacheArcLengths );\n\
\t\treturn this.cacheArcLengths;\n\
\n\
\t}\n\
\n\
\tthis.needsUpdate = false;\n\
\n\
\tvar cache = [];\n\
\tvar current, last = this.getPoint( 0 );\n\
\tvar p, sum = 0;\n\
\n\
\tcache.push( 0 );\n\
\n\
\tfor ( p = 1; p <= divisions; p ++ ) {\n\
\n\
\t\tcurrent = this.getPoint ( p / divisions );\n\
\t\tsum += current.distanceTo( last );\n\
\t\tcache.push( sum );\n\
\t\tlast = current;\n\
\n\
\t}\n\
\n\
\tthis.cacheArcLengths = cache;\n\
\n\
\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\
\n\
};\n\
\n\
\n\
THREE.Curve.prototype.updateArcLengths = function() {\n\
\tthis.needsUpdate = true;\n\
\tthis.getLengths();\n\
};\n\
\n\
// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\n\
\n\
THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\n\
\n\
\tvar arcLengths = this.getLengths();\n\
\n\
\tvar i = 0, il = arcLengths.length;\n\
\n\
\tvar targetArcLength; // The targeted u distance value to get\n\
\n\
\tif ( distance ) {\n\
\n\
\t\ttargetArcLength = distance;\n\
\n\
\t} else {\n\
\n\
\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\
\n\
\t}\n\
\n\
\t//var time = Date.now();\n\
\n\
\t// binary search for the index with largest value smaller than target u distance\n\
\n\
\tvar low = 0, high = il - 1, comparison;\n\
\n\
\twhile ( low <= high ) {\n\
\n\
\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\
\n\
\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\
\n\
\t\tif ( comparison < 0 ) {\n\
\n\
\t\t\tlow = i + 1;\n\
\t\t\tcontinue;\n\
\n\
\t\t} else if ( comparison > 0 ) {\n\
\n\
\t\t\thigh = i - 1;\n\
\t\t\tcontinue;\n\
\n\
\t\t} else {\n\
\n\
\t\t\thigh = i;\n\
\t\t\tbreak;\n\
\n\
\t\t\t// DONE\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\ti = high;\n\
\n\
\t//console.log('b' , i, low, high, Date.now()- time);\n\
\n\
\tif ( arcLengths[ i ] == targetArcLength ) {\n\
\n\
\t\tvar t = i / ( il - 1 );\n\
\t\treturn t;\n\
\n\
\t}\n\
\n\
\t// we could get finer grain at lengths, or use simple interpolatation between two points\n\
\n\
\tvar lengthBefore = arcLengths[ i ];\n\
    var lengthAfter = arcLengths[ i + 1 ];\n\
\n\
    var segmentLength = lengthAfter - lengthBefore;\n\
\n\
    // determine where we are between the 'before' and 'after' points\n\
\n\
    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\
\n\
    // add that fractional amount to t\n\
\n\
    var t = ( i + segmentFraction ) / ( il -1 );\n\
\n\
\treturn t;\n\
\n\
};\n\
\n\
// Returns a unit vector tangent at t\n\
// In case any sub curve does not implement its tangent derivation,\n\
// 2 points a small delta apart will be used to find its gradient\n\
// which seems to give a reasonable approximation\n\
\n\
THREE.Curve.prototype.getTangent = function( t ) {\n\
\n\
\tvar delta = 0.0001;\n\
\tvar t1 = t - delta;\n\
\tvar t2 = t + delta;\n\
\n\
\t// Capping in case of danger\n\
\n\
\tif ( t1 < 0 ) t1 = 0;\n\
\tif ( t2 > 1 ) t2 = 1;\n\
\n\
\tvar pt1 = this.getPoint( t1 );\n\
\tvar pt2 = this.getPoint( t2 );\n\
\n\
\tvar vec = pt2.clone().sub(pt1);\n\
\treturn vec.normalize();\n\
\n\
};\n\
\n\
\n\
THREE.Curve.prototype.getTangentAt = function ( u ) {\n\
\n\
\tvar t = this.getUtoTmapping( u );\n\
\treturn this.getTangent( t );\n\
\n\
};\n\
\n\
\n\
\n\
\n\
\n\
/**************************************************************\n\
 *\tUtils\n\
 **************************************************************/\n\
\n\
THREE.Curve.Utils = {\n\
\n\
\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\
\n\
\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\
\n\
\t},\n\
\n\
\t// Puay Bing, thanks for helping with this derivative!\n\
\n\
\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\n\
\n\
\t\treturn -3 * p0 * (1 - t) * (1 - t)  +\n\
\t\t\t3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +\n\
\t\t\t6 * t *  p2 * (1-t) - 3 * t * t * p2 +\n\
\t\t\t3 * t * t * p3;\n\
\t},\n\
\n\
\n\
\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\
\n\
\t\t// To check if my formulas are correct\n\
\n\
\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\n\
\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\n\
\t\tvar h01 = -6 * t * t + 6 * t; \t// − 2t3 + 3t2\n\
\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\n\
\n\
\t\treturn h00 + h10 + h01 + h11;\n\
\n\
\t},\n\
\n\
\t// Catmull-Rom\n\
\n\
\tinterpolate: function( p0, p1, p2, p3, t ) {\n\
\n\
\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\
\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\
\t\tvar t2 = t * t;\n\
\t\tvar t3 = t * t2;\n\
\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\
\n\
\t}\n\
\n\
};\n\
\n\
\n\
// TODO: Transformation for Curves?\n\
\n\
/**************************************************************\n\
 *\t3D Curves\n\
 **************************************************************/\n\
\n\
// A Factory method for creating new curve subclasses\n\
\n\
THREE.Curve.create = function ( constructor, getPointFunc ) {\n\
\n\
\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\
\tconstructor.prototype.getPoint = getPointFunc;\n\
\n\
\treturn constructor;\n\
\n\
};\n\
\n\
/**\n\
 * @author zz85 / http://www.lab4games.net/zz85/blog\n\
 *\n\
 **/\n\
\n\
/**************************************************************\n\
 *\tCurved Path - a curve path is simply a array of connected\n\
 *  curves, but retains the api of a curve\n\
 **************************************************************/\n\
\n\
THREE.CurvePath = function () {\n\
\n\
\tthis.curves = [];\n\
\tthis.bends = [];\n\
\t\n\
\tthis.autoClose = false; // Automatically closes the path\n\
};\n\
\n\
THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\n\
\n\
THREE.CurvePath.prototype.add = function ( curve ) {\n\
\n\
\tthis.curves.push( curve );\n\
\n\
};\n\
\n\
THREE.CurvePath.prototype.checkConnection = function() {\n\
\t// TODO\n\
\t// If the ending of curve is not connected to the starting\n\
\t// or the next curve, then, this is not a real path\n\
};\n\
\n\
THREE.CurvePath.prototype.closePath = function() {\n\
\t// TODO Test\n\
\t// and verify for vector3 (needs to implement equals)\n\
\t// Add a line curve if start and end of lines are not connected\n\
\tvar startPoint = this.curves[0].getPoint(0);\n\
\tvar endPoint = this.curves[this.curves.length-1].getPoint(1);\n\
\t\n\
\tif (!startPoint.equals(endPoint)) {\n\
\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\n\
\t}\n\
\t\n\
};\n\
\n\
// To get accurate point with reference to\n\
// entire path distance at time t,\n\
// following has to be done:\n\
\n\
// 1. Length of each sub path have to be known\n\
// 2. Locate and identify type of curve\n\
// 3. Get t for the curve\n\
// 4. Return curve.getPointAt(t')\n\
\n\
THREE.CurvePath.prototype.getPoint = function( t ) {\n\
\n\
\tvar d = t * this.getLength();\n\
\tvar curveLengths = this.getCurveLengths();\n\
\tvar i = 0, diff, curve;\n\
\n\
\t// To think about boundaries points.\n\
\n\
\twhile ( i < curveLengths.length ) {\n\
\n\
\t\tif ( curveLengths[ i ] >= d ) {\n\
\n\
\t\t\tdiff = curveLengths[ i ] - d;\n\
\t\t\tcurve = this.curves[ i ];\n\
\n\
\t\t\tvar u = 1 - diff / curve.getLength();\n\
\n\
\t\t\treturn curve.getPointAt( u );\n\
\n\
\t\t\tbreak;\n\
\t\t}\n\
\n\
\t\ti ++;\n\
\n\
\t}\n\
\n\
\treturn null;\n\
\n\
\t// loop where sum != 0, sum > d , sum+1 <d\n\
\n\
};\n\
\n\
/*\n\
THREE.CurvePath.prototype.getTangent = function( t ) {\n\
};*/\n\
\n\
\n\
// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\
// getPoint() depends on getLength\n\
\n\
THREE.CurvePath.prototype.getLength = function() {\n\
\n\
\tvar lens = this.getCurveLengths();\n\
\treturn lens[ lens.length - 1 ];\n\
\n\
};\n\
\n\
// Compute lengths and cache them\n\
// We cannot overwrite getLengths() because UtoT mapping uses it.\n\
\n\
THREE.CurvePath.prototype.getCurveLengths = function() {\n\
\n\
\t// We use cache values if curves and cache array are same length\n\
\n\
\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\n\
\n\
\t\treturn this.cacheLengths;\n\
\n\
\t};\n\
\n\
\t// Get length of subsurve\n\
\t// Push sums into cached array\n\
\n\
\tvar lengths = [], sums = 0;\n\
\tvar i, il = this.curves.length;\n\
\n\
\tfor ( i = 0; i < il; i ++ ) {\n\
\n\
\t\tsums += this.curves[ i ].getLength();\n\
\t\tlengths.push( sums );\n\
\n\
\t}\n\
\n\
\tthis.cacheLengths = lengths;\n\
\n\
\treturn lengths;\n\
\n\
};\n\
\n\
\n\
\n\
// Returns min and max coordinates, as well as centroid\n\
\n\
THREE.CurvePath.prototype.getBoundingBox = function () {\n\
\n\
\tvar points = this.getPoints();\n\
\n\
\tvar maxX, maxY, maxZ;\n\
\tvar minX, minY, minZ;\n\
\n\
\tmaxX = maxY = Number.NEGATIVE_INFINITY;\n\
\tminX = minY = Number.POSITIVE_INFINITY;\n\
\n\
\tvar p, i, il, sum;\n\
\n\
\tvar v3 = points[0] instanceof THREE.Vector3;\n\
\n\
\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\n\
\n\
\tfor ( i = 0, il = points.length; i < il; i ++ ) {\n\
\n\
\t\tp = points[ i ];\n\
\n\
\t\tif ( p.x > maxX ) maxX = p.x;\n\
\t\telse if ( p.x < minX ) minX = p.x;\n\
\n\
\t\tif ( p.y > maxY ) maxY = p.y;\n\
\t\telse if ( p.y < minY ) minY = p.y;\n\
\n\
\t\tif ( v3 ) {\n\
\n\
\t\t\tif ( p.z > maxZ ) maxZ = p.z;\n\
\t\t\telse if ( p.z < minZ ) minZ = p.z;\n\
\n\
\t\t}\n\
\n\
\t\tsum.add( p );\n\
\n\
\t}\n\
\n\
\tvar ret = {\n\
\n\
\t\tminX: minX,\n\
\t\tminY: minY,\n\
\t\tmaxX: maxX,\n\
\t\tmaxY: maxY,\n\
\t\tcentroid: sum.divideScalar( il )\n\
\n\
\t};\n\
\n\
\tif ( v3 ) {\n\
\n\
\t\tret.maxZ = maxZ;\n\
\t\tret.minZ = minZ;\n\
\n\
\t}\n\
\n\
\treturn ret;\n\
\n\
};\n\
\n\
/**************************************************************\n\
 *\tCreate Geometries Helpers\n\
 **************************************************************/\n\
\n\
/// Generate geometry from path points (for Line or ParticleSystem objects)\n\
\n\
THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\n\
\n\
\tvar pts = this.getPoints( divisions, true );\n\
\treturn this.createGeometry( pts );\n\
\n\
};\n\
\n\
// Generate geometry from equidistance sampling along the path\n\
\n\
THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\n\
\n\
\tvar pts = this.getSpacedPoints( divisions, true );\n\
\treturn this.createGeometry( pts );\n\
\n\
};\n\
\n\
THREE.CurvePath.prototype.createGeometry = function( points ) {\n\
\n\
\tvar geometry = new THREE.Geometry();\n\
\n\
\tfor ( var i = 0; i < points.length; i ++ ) {\n\
\n\
\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\n\
\n\
\t}\n\
\n\
\treturn geometry;\n\
\n\
};\n\
\n\
\n\
/**************************************************************\n\
 *\tBend / Wrap Helper Methods\n\
 **************************************************************/\n\
\n\
// Wrap path / Bend modifiers?\n\
\n\
THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\n\
\n\
\tthis.bends.push( bendpath );\n\
\n\
};\n\
\n\
THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\n\
\n\
\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\n\
\tvar i, il;\n\
\n\
\tif ( !bends ) {\n\
\n\
\t\tbends = this.bends;\n\
\n\
\t}\n\
\n\
\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\n\
\n\
\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\n\
\n\
\t}\n\
\n\
\treturn oldPts;\n\
\n\
};\n\
\n\
THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\n\
\n\
\tvar oldPts = this.getSpacedPoints( segments );\n\
\n\
\tvar i, il;\n\
\n\
\tif ( !bends ) {\n\
\n\
\t\tbends = this.bends;\n\
\n\
\t}\n\
\n\
\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\n\
\n\
\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\n\
\n\
\t}\n\
\n\
\treturn oldPts;\n\
\n\
};\n\
\n\
// This returns getPoints() bend/wrapped around the contour of a path.\n\
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\n\
\n\
THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\n\
\n\
\tvar bounds = this.getBoundingBox();\n\
\n\
\tvar i, il, p, oldX, oldY, xNorm;\n\
\n\
\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\n\
\n\
\t\tp = oldPts[ i ];\n\
\n\
\t\toldX = p.x;\n\
\t\toldY = p.y;\n\
\n\
\t\txNorm = oldX / bounds.maxX;\n\
\n\
\t\t// If using actual distance, for length > path, requires line extrusions\n\
\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\n\
\n\
\t\txNorm = path.getUtoTmapping( xNorm, oldX );\n\
\n\
\t\t// check for out of bounds?\n\
\n\
\t\tvar pathPt = path.getPoint( xNorm );\n\
\t\tvar normal = path.getNormalVector( xNorm ).multiplyScalar( oldY );\n\
\n\
\t\tp.x = pathPt.x + normal.x;\n\
\t\tp.y = pathPt.y + normal.y;\n\
\n\
\t}\n\
\n\
\treturn oldPts;\n\
\n\
};\n\
\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Gyroscope = function () {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
};\n\
\n\
THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {\n\
\n\
\tthis.matrixAutoUpdate && this.updateMatrix();\n\
\n\
\t// update matrixWorld\n\
\n\
\tif ( this.matrixWorldNeedsUpdate || force ) {\n\
\n\
\t\tif ( this.parent ) {\n\
\n\
\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\
\n\
\t\t\tthis.matrixWorld.decompose( this.translationWorld, this.quaternionWorld, this.scaleWorld );\n\
\t\t\tthis.matrix.decompose( this.translationObject, this.quaternionObject, this.scaleObject );\n\
\n\
\t\t\tthis.matrixWorld.compose( this.translationWorld, this.quaternionObject, this.scaleWorld );\n\
\n\
\n\
\t\t} else {\n\
\n\
\t\t\tthis.matrixWorld.copy( this.matrix );\n\
\n\
\t\t}\n\
\n\
\n\
\t\tthis.matrixWorldNeedsUpdate = false;\n\
\n\
\t\tforce = true;\n\
\n\
\t}\n\
\n\
\t// update children\n\
\n\
\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\
\n\
\t\tthis.children[ i ].updateMatrixWorld( force );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();\n\
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();\n\
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();\n\
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();\n\
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();\n\
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();\n\
\n\
\n\
/**\n\
 * @author zz85 / http://www.lab4games.net/zz85/blog\n\
 * Creates free form 2d path using series of points, lines or curves.\n\
 *\n\
 **/\n\
\n\
THREE.Path = function ( points ) {\n\
\n\
\tTHREE.CurvePath.call(this);\n\
\n\
\tthis.actions = [];\n\
\n\
\tif ( points ) {\n\
\n\
\t\tthis.fromPoints( points );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\n\
\n\
THREE.PathActions = {\n\
\n\
\tMOVE_TO: 'moveTo',\n\
\tLINE_TO: 'lineTo',\n\
\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\n\
\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\n\
\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\n\
\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\n\
\tELLIPSE: 'ellipse'\n\
};\n\
\n\
// TODO Clean up PATH API\n\
\n\
// Create path using straight lines to connect all points\n\
// - vectors: array of Vector2\n\
\n\
THREE.Path.prototype.fromPoints = function ( vectors ) {\n\
\n\
\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\
\n\
\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\n\
\n\
\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\n\
\n\
\t};\n\
\n\
};\n\
\n\
// startPath() endPath()?\n\
\n\
THREE.Path.prototype.moveTo = function ( x, y ) {\n\
\n\
\tvar args = Array.prototype.slice.call( arguments );\n\
\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\n\
\n\
};\n\
\n\
THREE.Path.prototype.lineTo = function ( x, y ) {\n\
\n\
\tvar args = Array.prototype.slice.call( arguments );\n\
\n\
\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\
\n\
\tvar x0 = lastargs[ lastargs.length - 2 ];\n\
\tvar y0 = lastargs[ lastargs.length - 1 ];\n\
\n\
\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\
\tthis.curves.push( curve );\n\
\n\
\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\n\
\n\
};\n\
\n\
THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\n\
\n\
\tvar args = Array.prototype.slice.call( arguments );\n\
\n\
\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\
\n\
\tvar x0 = lastargs[ lastargs.length - 2 ];\n\
\tvar y0 = lastargs[ lastargs.length - 1 ];\n\
\n\
\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\n\
\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\
\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\n\
\tthis.curves.push( curve );\n\
\n\
\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\n\
\n\
};\n\
\n\
THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\n\
\t\t\t\t\t\t\t\t\t\t\t   aCP2x, aCP2y,\n\
\t\t\t\t\t\t\t\t\t\t\t   aX, aY ) {\n\
\n\
\tvar args = Array.prototype.slice.call( arguments );\n\
\n\
\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\
\n\
\tvar x0 = lastargs[ lastargs.length - 2 ];\n\
\tvar y0 = lastargs[ lastargs.length - 1 ];\n\
\n\
\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\n\
\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\
\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\
\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\n\
\tthis.curves.push( curve );\n\
\n\
\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\n\
\n\
};\n\
\n\
THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\n\
\n\
\tvar args = Array.prototype.slice.call( arguments );\n\
\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\
\n\
\tvar x0 = lastargs[ lastargs.length - 2 ];\n\
\tvar y0 = lastargs[ lastargs.length - 1 ];\n\
//---\n\
\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\
\tArray.prototype.push.apply( npts, pts );\n\
\n\
\tvar curve = new THREE.SplineCurve( npts );\n\
\tthis.curves.push( curve );\n\
\n\
\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\n\
\n\
};\n\
\n\
// FUTURE: Change the API or follow canvas API?\n\
\n\
THREE.Path.prototype.arc = function ( aX, aY, aRadius,\n\
\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\
\n\
\tvar lastargs = this.actions[ this.actions.length - 1].args;\n\
\tvar x0 = lastargs[ lastargs.length - 2 ];\n\
\tvar y0 = lastargs[ lastargs.length - 1 ];\n\
\n\
\tthis.absarc(aX + x0, aY + y0, aRadius,\n\
\t\taStartAngle, aEndAngle, aClockwise );\n\
\n\
 };\n\
\n\
 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\n\
\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\
\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n\
 };\n\
\n\
THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\n\
\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\
\n\
\tvar lastargs = this.actions[ this.actions.length - 1].args;\n\
\tvar x0 = lastargs[ lastargs.length - 2 ];\n\
\tvar y0 = lastargs[ lastargs.length - 1 ];\n\
\n\
\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\n\
\t\taStartAngle, aEndAngle, aClockwise );\n\
\n\
 };\n\
\n\
\n\
THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\n\
\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\
\n\
\tvar args = Array.prototype.slice.call( arguments );\n\
\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\n\
\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\
\tthis.curves.push( curve );\n\
\n\
\tvar lastPoint = curve.getPoint(aClockwise ? 1 : 0);\n\
\targs.push(lastPoint.x);\n\
\targs.push(lastPoint.y);\n\
\n\
\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\n\
\n\
 };\n\
\n\
THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\n\
\n\
\tif ( ! divisions ) divisions = 40;\n\
\n\
\tvar points = [];\n\
\n\
\tfor ( var i = 0; i < divisions; i ++ ) {\n\
\n\
\t\tpoints.push( this.getPoint( i / divisions ) );\n\
\n\
\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\
\n\
\t}\n\
\n\
\t// if ( closedPath ) {\n\
\t//\n\
\t// \tpoints.push( points[ 0 ] );\n\
\t//\n\
\t// }\n\
\n\
\treturn points;\n\
\n\
};\n\
\n\
/* Return an array of vectors based on contour of the path */\n\
\n\
THREE.Path.prototype.getPoints = function( divisions, closedPath ) {\n\
\n\
\tif (this.useSpacedPoints) {\n\
\t\tconsole.log('tata');\n\
\t\treturn this.getSpacedPoints( divisions, closedPath );\n\
\t}\n\
\n\
\tdivisions = divisions || 12;\n\
\n\
\tvar points = [];\n\
\n\
\tvar i, il, item, action, args;\n\
\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\
\t\tlaste, j,\n\
\t\tt, tx, ty;\n\
\n\
\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\n\
\n\
\t\titem = this.actions[ i ];\n\
\n\
\t\taction = item.action;\n\
\t\targs = item.args;\n\
\n\
\t\tswitch( action ) {\n\
\n\
\t\tcase THREE.PathActions.MOVE_TO:\n\
\n\
\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\
\n\
\t\t\tbreak;\n\
\n\
\t\tcase THREE.PathActions.LINE_TO:\n\
\n\
\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\
\n\
\t\t\tbreak;\n\
\n\
\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\n\
\n\
\t\t\tcpx  = args[ 2 ];\n\
\t\t\tcpy  = args[ 3 ];\n\
\n\
\t\t\tcpx1 = args[ 0 ];\n\
\t\t\tcpy1 = args[ 1 ];\n\
\n\
\t\t\tif ( points.length > 0 ) {\n\
\n\
\t\t\t\tlaste = points[ points.length - 1 ];\n\
\n\
\t\t\t\tcpx0 = laste.x;\n\
\t\t\t\tcpy0 = laste.y;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\
\n\
\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\
\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\
\n\
\t\t\t}\n\
\n\
\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\n\
\n\
\t\t\t\tt = j / divisions;\n\
\n\
\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\n\
\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\n\
\n\
\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tbreak;\n\
\n\
\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\n\
\n\
\t\t\tcpx  = args[ 4 ];\n\
\t\t\tcpy  = args[ 5 ];\n\
\n\
\t\t\tcpx1 = args[ 0 ];\n\
\t\t\tcpy1 = args[ 1 ];\n\
\n\
\t\t\tcpx2 = args[ 2 ];\n\
\t\t\tcpy2 = args[ 3 ];\n\
\n\
\t\t\tif ( points.length > 0 ) {\n\
\n\
\t\t\t\tlaste = points[ points.length - 1 ];\n\
\n\
\t\t\t\tcpx0 = laste.x;\n\
\t\t\t\tcpy0 = laste.y;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\
\n\
\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\
\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\
\n\
\t\t\t}\n\
\n\
\n\
\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\n\
\n\
\t\t\t\tt = j / divisions;\n\
\n\
\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\n\
\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\n\
\n\
\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tbreak;\n\
\n\
\t\tcase THREE.PathActions.CSPLINE_THRU:\n\
\n\
\t\t\tlaste = this.actions[ i - 1 ].args;\n\
\n\
\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\
\t\t\tvar spts = [ last ];\n\
\n\
\t\t\tvar n = divisions * args[ 0 ].length;\n\
\n\
\t\t\tspts = spts.concat( args[ 0 ] );\n\
\n\
\t\t\tvar spline = new THREE.SplineCurve( spts );\n\
\n\
\t\t\tfor ( j = 1; j <= n; j ++ ) {\n\
\n\
\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tbreak;\n\
\n\
\t\tcase THREE.PathActions.ARC:\n\
\n\
\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\
\t\t\t\taRadius = args[ 2 ],\n\
\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\
\t\t\t\taClockwise = !!args[ 5 ];\n\
\n\
\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\
\t\t\tvar angle;\n\
\t\t\tvar tdivisions = divisions * 2;\n\
\n\
\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\n\
\n\
\t\t\t\tt = j / tdivisions;\n\
\n\
\t\t\t\tif ( ! aClockwise ) {\n\
\n\
\t\t\t\t\tt = 1 - t;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\
\n\
\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\
\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\
\n\
\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\
\n\
\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t//console.log(points);\n\
\n\
\t\t  break;\n\
\t\t  \n\
\t\tcase THREE.PathActions.ELLIPSE:\n\
\n\
\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\
\t\t\t\txRadius = args[ 2 ],\n\
\t\t\t\tyRadius = args[ 3 ],\n\
\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\
\t\t\t\taClockwise = !!args[ 6 ];\n\
\n\
\n\
\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\
\t\t\tvar angle;\n\
\t\t\tvar tdivisions = divisions * 2;\n\
\n\
\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\n\
\n\
\t\t\t\tt = j / tdivisions;\n\
\n\
\t\t\t\tif ( ! aClockwise ) {\n\
\n\
\t\t\t\t\tt = 1 - t;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\
\n\
\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\
\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\
\n\
\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\
\n\
\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t//console.log(points);\n\
\n\
\t\t  break;\n\
\n\
\t\t} // end switch\n\
\n\
\t}\n\
\n\
\n\
\n\
\t// Normalize to remove the closing point by default.\n\
\tvar lastPoint = points[ points.length - 1];\n\
\tvar EPSILON = 0.0000000001;\n\
\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\n\
\t\t\t Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\n\
\t\tpoints.splice( points.length - 1, 1);\n\
\tif ( closedPath ) {\n\
\n\
\t\tpoints.push( points[ 0 ] );\n\
\n\
\t}\n\
\n\
\treturn points;\n\
\n\
};\n\
\n\
// Breaks path into shapes\n\
\n\
THREE.Path.prototype.toShapes = function( isCCW ) {\n\
\n\
\tvar i, il, item, action, args;\n\
\n\
\tvar subPaths = [], lastPath = new THREE.Path();\n\
\n\
\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\n\
\n\
\t\titem = this.actions[ i ];\n\
\n\
\t\targs = item.args;\n\
\t\taction = item.action;\n\
\n\
\t\tif ( action == THREE.PathActions.MOVE_TO ) {\n\
\n\
\t\t\tif ( lastPath.actions.length != 0 ) {\n\
\n\
\t\t\t\tsubPaths.push( lastPath );\n\
\t\t\t\tlastPath = new THREE.Path();\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tlastPath[ action ].apply( lastPath, args );\n\
\n\
\t}\n\
\n\
\tif ( lastPath.actions.length != 0 ) {\n\
\n\
\t\tsubPaths.push( lastPath );\n\
\n\
\t}\n\
\n\
\t// console.log(subPaths);\n\
\n\
\tif ( subPaths.length == 0 ) return [];\n\
\n\
\tvar solid, tmpPath, tmpShape, shapes = [];\n\
\n\
\tif ( subPaths.length == 1) {\n\
\n\
\t\ttmpPath = subPaths[0];\n\
\t\ttmpShape = new THREE.Shape();\n\
\t\ttmpShape.actions = tmpPath.actions;\n\
\t\ttmpShape.curves = tmpPath.curves;\n\
\t\tshapes.push( tmpShape );\n\
\t\treturn shapes;\n\
\n\
\t}\n\
\n\
\tvar holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\n\
\tholesFirst = isCCW ? !holesFirst : holesFirst;\n\
\n\
\t// console.log(\"Holes first\", holesFirst);\n\
\n\
\tif ( holesFirst ) {\n\
\n\
\t\ttmpShape = new THREE.Shape();\n\
\n\
\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\n\
\n\
\t\t\ttmpPath = subPaths[ i ];\n\
\t\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );\n\
\t\t\tsolid = isCCW ? !solid : solid;\n\
\n\
\t\t\tif ( solid ) {\n\
\n\
\t\t\t\ttmpShape.actions = tmpPath.actions;\n\
\t\t\t\ttmpShape.curves = tmpPath.curves;\n\
\n\
\t\t\t\tshapes.push( tmpShape );\n\
\t\t\t\ttmpShape = new THREE.Shape();\n\
\n\
\t\t\t\t//console.log('cw', i);\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\ttmpShape.holes.push( tmpPath );\n\
\n\
\t\t\t\t//console.log('ccw', i);\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t} else {\n\
\n\
\t\t// Shapes first\n\
\t\ttmpShape = undefined;\n\
\n\
\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\n\
\n\
\t\t\ttmpPath = subPaths[ i ];\n\
\t\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );\n\
\t\t\tsolid = isCCW ? !solid : solid;\n\
\n\
\t\t\tif ( solid ) {\n\
\n\
\t\t\t\tif ( tmpShape ) shapes.push( tmpShape );\n\
\n\
\t\t\t\ttmpShape = new THREE.Shape();\n\
\t\t\t\ttmpShape.actions = tmpPath.actions;\n\
\t\t\t\ttmpShape.curves = tmpPath.curves;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\ttmpShape.holes.push( tmpPath );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tshapes.push( tmpShape );\n\
\n\
\t}\n\
\n\
\t//console.log(\"shape\", shapes);\n\
\n\
\treturn shapes;\n\
\n\
};\n\
\n\
/**\n\
 * @author zz85 / http://www.lab4games.net/zz85/blog\n\
 * Defines a 2d shape plane using paths.\n\
 **/\n\
\n\
// STEP 1 Create a path.\n\
// STEP 2 Turn path into shape.\n\
// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\
// STEP 3a - Extract points from each shape, turn to vertices\n\
// STEP 3b - Triangulate each shape, add faces.\n\
\n\
THREE.Shape = function () {\n\
\n\
\tTHREE.Path.apply( this, arguments );\n\
\tthis.holes = [];\n\
\n\
};\n\
\n\
THREE.Shape.prototype = Object.create( THREE.Path.prototype );\n\
\n\
// Convenience method to return ExtrudeGeometry\n\
\n\
THREE.Shape.prototype.extrude = function ( options ) {\n\
\n\
\tvar extruded = new THREE.ExtrudeGeometry( this, options );\n\
\treturn extruded;\n\
\n\
};\n\
\n\
// Convenience method to return ShapeGeometry\n\
\n\
THREE.Shape.prototype.makeGeometry = function ( options ) {\n\
\n\
\tvar geometry = new THREE.ShapeGeometry( this, options );\n\
\treturn geometry;\n\
\n\
};\n\
\n\
// Get points of holes\n\
\n\
THREE.Shape.prototype.getPointsHoles = function ( divisions ) {\n\
\n\
\tvar i, il = this.holes.length, holesPts = [];\n\
\n\
\tfor ( i = 0; i < il; i ++ ) {\n\
\n\
\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\n\
\n\
\t}\n\
\n\
\treturn holesPts;\n\
\n\
};\n\
\n\
// Get points of holes (spaced by regular distance)\n\
\n\
THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\n\
\n\
\tvar i, il = this.holes.length, holesPts = [];\n\
\n\
\tfor ( i = 0; i < il; i ++ ) {\n\
\n\
\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\n\
\n\
\t}\n\
\n\
\treturn holesPts;\n\
\n\
};\n\
\n\
\n\
// Get points of shape and holes (keypoints based on segments parameter)\n\
\n\
THREE.Shape.prototype.extractAllPoints = function ( divisions ) {\n\
\n\
\treturn {\n\
\n\
\t\tshape: this.getTransformedPoints( divisions ),\n\
\t\tholes: this.getPointsHoles( divisions )\n\
\n\
\t};\n\
\n\
};\n\
\n\
THREE.Shape.prototype.extractPoints = function ( divisions ) {\n\
\n\
\tif (this.useSpacedPoints) {\n\
\t\treturn this.extractAllSpacedPoints(divisions);\n\
\t}\n\
\n\
\treturn this.extractAllPoints(divisions);\n\
\n\
};\n\
\n\
//\n\
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\n\
//\n\
// \treturn {\n\
//\n\
// \t\tshape: this.transform( bend, divisions ),\n\
// \t\tholes: this.getPointsHoles( divisions, bend )\n\
//\n\
// \t};\n\
//\n\
// };\n\
\n\
// Get points of shape and holes (spaced by regular distance)\n\
\n\
THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\n\
\n\
\treturn {\n\
\n\
\t\tshape: this.getTransformedSpacedPoints( divisions ),\n\
\t\tholes: this.getSpacedPointsHoles( divisions )\n\
\n\
\t};\n\
\n\
};\n\
\n\
/**************************************************************\n\
 *\tUtils\n\
 **************************************************************/\n\
\n\
THREE.Shape.Utils = {\n\
\n\
\t/*\n\
\t\tcontour - array of vector2 for contour\n\
\t\tholes   - array of array of vector2\n\
\t*/\n\
\n\
\tremoveHoles: function ( contour, holes ) {\n\
\n\
\t\tvar shape = contour.concat(); // work on this shape\n\
\t\tvar allpoints = shape.concat();\n\
\n\
\t\t/* For each isolated shape, find the closest points and break to the hole to allow triangulation */\n\
\n\
\n\
\t\tvar prevShapeVert, nextShapeVert,\n\
\t\t\tprevHoleVert, nextHoleVert,\n\
\t\t\tholeIndex, shapeIndex,\n\
\t\t\tshapeId, shapeGroup,\n\
\t\t\th, h2,\n\
\t\t\thole, shortest, d,\n\
\t\t\tp, pts1, pts2,\n\
\t\t\ttmpShape1, tmpShape2,\n\
\t\t\ttmpHole1, tmpHole2,\n\
\t\t\tverts = [];\n\
\n\
\t\tfor ( h = 0; h < holes.length; h ++ ) {\n\
\n\
\t\t\thole = holes[ h ];\n\
\n\
\t\t\t/*\n\
\t\t\tshapeholes[ h ].concat(); // preserves original\n\
\t\t\tholes.push( hole );\n\
\t\t\t*/\n\
\n\
\t\t\tArray.prototype.push.apply( allpoints, hole );\n\
\n\
\t\t\tshortest = Number.POSITIVE_INFINITY;\n\
\n\
\n\
\t\t\t// Find the shortest pair of pts between shape and hole\n\
\n\
\t\t\t// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)\n\
\t\t\t// Using distanceToSquared() intead of distanceTo() should speed a little\n\
\t\t\t// since running square roots operations are reduced.\n\
\n\
\t\t\tfor ( h2 = 0; h2 < hole.length; h2 ++ ) {\n\
\n\
\t\t\t\tpts1 = hole[ h2 ];\n\
\t\t\t\tvar dist = [];\n\
\n\
\t\t\t\tfor ( p = 0; p < shape.length; p++ ) {\n\
\n\
\t\t\t\t\tpts2 = shape[ p ];\n\
\t\t\t\t\td = pts1.distanceToSquared( pts2 );\n\
\t\t\t\t\tdist.push( d );\n\
\n\
\t\t\t\t\tif ( d < shortest ) {\n\
\n\
\t\t\t\t\t\tshortest = d;\n\
\t\t\t\t\t\tholeIndex = h2;\n\
\t\t\t\t\t\tshapeIndex = p;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\t//console.log(\"shortest\", shortest, dist);\n\
\n\
\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\
\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\
\n\
\t\t\tvar areaapts = [\n\
\n\
\t\t\t\thole[ holeIndex ],\n\
\t\t\t\tshape[ shapeIndex ],\n\
\t\t\t\tshape[ prevShapeVert ]\n\
\n\
\t\t\t];\n\
\n\
\t\t\tvar areaa = THREE.FontUtils.Triangulate.area( areaapts );\n\
\n\
\t\t\tvar areabpts = [\n\
\n\
\t\t\t\thole[ holeIndex ],\n\
\t\t\t\thole[ prevHoleVert ],\n\
\t\t\t\tshape[ shapeIndex ]\n\
\n\
\t\t\t];\n\
\n\
\t\t\tvar areab = THREE.FontUtils.Triangulate.area( areabpts );\n\
\n\
\t\t\tvar shapeOffset = 1;\n\
\t\t\tvar holeOffset = -1;\n\
\n\
\t\t\tvar oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;\n\
\t\t\tshapeIndex += shapeOffset;\n\
\t\t\tholeIndex += holeOffset;\n\
\n\
\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\n\
\t\t\tshapeIndex %= shape.length;\n\
\n\
\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\n\
\t\t\tholeIndex %= hole.length;\n\
\n\
\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\
\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\
\n\
\t\t\tareaapts = [\n\
\n\
\t\t\t\thole[ holeIndex ],\n\
\t\t\t\tshape[ shapeIndex ],\n\
\t\t\t\tshape[ prevShapeVert ]\n\
\n\
\t\t\t];\n\
\n\
\t\t\tvar areaa2 = THREE.FontUtils.Triangulate.area( areaapts );\n\
\n\
\t\t\tareabpts = [\n\
\n\
\t\t\t\thole[ holeIndex ],\n\
\t\t\t\thole[ prevHoleVert ],\n\
\t\t\t\tshape[ shapeIndex ]\n\
\n\
\t\t\t];\n\
\n\
\t\t\tvar areab2 = THREE.FontUtils.Triangulate.area( areabpts );\n\
\t\t\t//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));\n\
\n\
\t\t\tif ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {\n\
\n\
\t\t\t\t// In case areas are not correct.\n\
\t\t\t\t//console.log(\"USE THIS\");\n\
\n\
\t\t\t\tshapeIndex = oldShapeIndex;\n\
\t\t\t\tholeIndex = oldHoleIndex ;\n\
\n\
\t\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\n\
\t\t\t\tshapeIndex %= shape.length;\n\
\n\
\t\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\n\
\t\t\t\tholeIndex %= hole.length;\n\
\n\
\t\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\
\t\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t//console.log(\"USE THAT \")\n\
\n\
\t\t\t}\n\
\n\
\t\t\ttmpShape1 = shape.slice( 0, shapeIndex );\n\
\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\
\t\t\ttmpHole1 = hole.slice( holeIndex );\n\
\t\t\ttmpHole2 = hole.slice( 0, holeIndex );\n\
\n\
\t\t\t// Should check orders here again?\n\
\n\
\t\t\tvar trianglea = [\n\
\n\
\t\t\t\thole[ holeIndex ],\n\
\t\t\t\tshape[ shapeIndex ],\n\
\t\t\t\tshape[ prevShapeVert ]\n\
\n\
\t\t\t];\n\
\n\
\t\t\tvar triangleb = [\n\
\n\
\t\t\t\thole[ holeIndex ] ,\n\
\t\t\t\thole[ prevHoleVert ],\n\
\t\t\t\tshape[ shapeIndex ]\n\
\n\
\t\t\t];\n\
\n\
\t\t\tverts.push( trianglea );\n\
\t\t\tverts.push( triangleb );\n\
\n\
\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\
\n\
\t\t}\n\
\n\
\t\treturn {\n\
\n\
\t\t\tshape:shape, \t\t/* shape with no holes */\n\
\t\t\tisolatedPts: verts, /* isolated faces */\n\
\t\t\tallpoints: allpoints\n\
\n\
\t\t}\n\
\n\
\n\
\t},\n\
\n\
\ttriangulateShape: function ( contour, holes ) {\n\
\n\
\t\tvar shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );\n\
\n\
\t\tvar shape = shapeWithoutHoles.shape,\n\
\t\t\tallpoints = shapeWithoutHoles.allpoints,\n\
\t\t\tisolatedPts = shapeWithoutHoles.isolatedPts;\n\
\n\
\t\tvar triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape\n\
\n\
\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\
\n\
\t\t//console.log( \"triangles\",triangles, triangles.length );\n\
\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\
\n\
\t\tvar i, il, f, face,\n\
\t\t\tkey, index,\n\
\t\t\tallPointsMap = {},\n\
\t\t\tisolatedPointsMap = {};\n\
\n\
\t\t// prepare all points map\n\
\n\
\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\
\n\
\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\
\n\
\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\
\n\
\t\t\t\tconsole.log( \"Duplicate point\", key );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tallPointsMap[ key ] = i;\n\
\n\
\t\t}\n\
\n\
\t\t// check all face vertices against all points map\n\
\n\
\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\
\n\
\t\t\tface = triangles[ i ];\n\
\n\
\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\
\n\
\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\
\n\
\t\t\t\tindex = allPointsMap[ key ];\n\
\n\
\t\t\t\tif ( index !== undefined ) {\n\
\n\
\t\t\t\t\tface[ f ] = index;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// check isolated points vertices against all points map\n\
\n\
\t\tfor ( i = 0, il = isolatedPts.length; i < il; i ++ ) {\n\
\n\
\t\t\tface = isolatedPts[ i ];\n\
\n\
\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\
\n\
\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\
\n\
\t\t\t\tindex = allPointsMap[ key ];\n\
\n\
\t\t\t\tif ( index !== undefined ) {\n\
\n\
\t\t\t\t\tface[ f ] = index;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treturn triangles.concat( isolatedPts );\n\
\n\
\t}, // end triangulate shapes\n\
\n\
\t/*\n\
\ttriangulate2 : function( pts, holes ) {\n\
\n\
\t\t// For use with Poly2Tri.js\n\
\n\
\t\tvar allpts = pts.concat();\n\
\t\tvar shape = [];\n\
\t\tfor (var p in pts) {\n\
\t\t\tshape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));\n\
\t\t}\n\
\n\
\t\tvar swctx = new js.poly2tri.SweepContext(shape);\n\
\n\
\t\tfor (var h in holes) {\n\
\t\t\tvar aHole = holes[h];\n\
\t\t\tvar newHole = []\n\
\t\t\tfor (i in aHole) {\n\
\t\t\t\tnewHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));\n\
\t\t\t\tallpts.push(aHole[i]);\n\
\t\t\t}\n\
\t\t\tswctx.AddHole(newHole);\n\
\t\t}\n\
\n\
\t\tvar find;\n\
\t\tvar findIndexForPt = function (pt) {\n\
\t\t\tfind = new THREE.Vector2(pt.x, pt.y);\n\
\t\t\tvar p;\n\
\t\t\tfor (p=0, pl = allpts.length; p<pl; p++) {\n\
\t\t\t\tif (allpts[p].equals(find)) return p;\n\
\t\t\t}\n\
\t\t\treturn -1;\n\
\t\t};\n\
\n\
\t\t// triangulate\n\
\t\tjs.poly2tri.sweep.Triangulate(swctx);\n\
\n\
\t\tvar triangles =  swctx.GetTriangles();\n\
\t\tvar tr ;\n\
\t\tvar facesPts = [];\n\
\t\tfor (var t in triangles) {\n\
\t\t\ttr =  triangles[t];\n\
\t\t\tfacesPts.push([\n\
\t\t\t\tfindIndexForPt(tr.GetPoint(0)),\n\
\t\t\t\tfindIndexForPt(tr.GetPoint(1)),\n\
\t\t\t\tfindIndexForPt(tr.GetPoint(2))\n\
\t\t\t\t\t]);\n\
\t\t}\n\
\n\
\n\
\t//\tconsole.log(facesPts);\n\
\t//\tconsole.log(\"triangles\", triangles.length, triangles);\n\
\n\
\t\t// Returns array of faces with 3 element each\n\
\treturn facesPts;\n\
\t},\n\
*/\n\
\n\
\tisClockWise: function ( pts ) {\n\
\n\
\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\n\
\n\
\t},\n\
\n\
\t// Bezier Curves formulas obtained from\n\
\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\
\n\
\t// Quad Bezier Functions\n\
\n\
\tb2p0: function ( t, p ) {\n\
\n\
\t\tvar k = 1 - t;\n\
\t\treturn k * k * p;\n\
\n\
\t},\n\
\n\
\tb2p1: function ( t, p ) {\n\
\n\
\t\treturn 2 * ( 1 - t ) * t * p;\n\
\n\
\t},\n\
\n\
\tb2p2: function ( t, p ) {\n\
\n\
\t\treturn t * t * p;\n\
\n\
\t},\n\
\n\
\tb2: function ( t, p0, p1, p2 ) {\n\
\n\
\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\n\
\n\
\t},\n\
\n\
\t// Cubic Bezier Functions\n\
\n\
\tb3p0: function ( t, p ) {\n\
\n\
\t\tvar k = 1 - t;\n\
\t\treturn k * k * k * p;\n\
\n\
\t},\n\
\n\
\tb3p1: function ( t, p ) {\n\
\n\
\t\tvar k = 1 - t;\n\
\t\treturn 3 * k * k * t * p;\n\
\n\
\t},\n\
\n\
\tb3p2: function ( t, p ) {\n\
\n\
\t\tvar k = 1 - t;\n\
\t\treturn 3 * k * t * t * p;\n\
\n\
\t},\n\
\n\
\tb3p3: function ( t, p ) {\n\
\n\
\t\treturn t * t * t * p;\n\
\n\
\t},\n\
\n\
\tb3: function ( t, p0, p1, p2, p3 ) {\n\
\n\
\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\n\
\n\
\t}\n\
\n\
};\n\
\n\
\n\
/**************************************************************\n\
 *\tLine\n\
 **************************************************************/\n\
\n\
THREE.LineCurve = function ( v1, v2 ) {\n\
\n\
\tthis.v1 = v1;\n\
\tthis.v2 = v2;\n\
\n\
};\n\
\n\
THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\n\
\n\
THREE.LineCurve.prototype.getPoint = function ( t ) {\n\
\n\
\tvar point = this.v2.clone().sub(this.v1);\n\
\tpoint.multiplyScalar( t ).add( this.v1 );\n\
\n\
\treturn point;\n\
\n\
};\n\
\n\
// Line curve is linear, so we can overwrite default getPointAt\n\
\n\
THREE.LineCurve.prototype.getPointAt = function ( u ) {\n\
\n\
\treturn this.getPoint( u );\n\
\n\
};\n\
\n\
THREE.LineCurve.prototype.getTangent = function( t ) {\n\
\n\
\tvar tangent = this.v2.clone().sub(this.v1);\n\
\n\
\treturn tangent.normalize();\n\
\n\
};\n\
/**************************************************************\n\
 *\tQuadratic Bezier curve\n\
 **************************************************************/\n\
\n\
\n\
THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\
\n\
\tthis.v0 = v0;\n\
\tthis.v1 = v1;\n\
\tthis.v2 = v2;\n\
\n\
};\n\
\n\
THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\
\n\
\n\
THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\
\n\
\tvar tx, ty;\n\
\n\
\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\n\
\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\n\
\n\
\treturn new THREE.Vector2( tx, ty );\n\
\n\
};\n\
\n\
\n\
THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\
\n\
\tvar tx, ty;\n\
\n\
\ttx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\n\
\tty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\n\
\n\
\t// returns unit vector\n\
\n\
\tvar tangent = new THREE.Vector2( tx, ty );\n\
\ttangent.normalize();\n\
\n\
\treturn tangent;\n\
\n\
};\n\
/**************************************************************\n\
 *\tCubic Bezier curve\n\
 **************************************************************/\n\
\n\
THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\
\n\
\tthis.v0 = v0;\n\
\tthis.v1 = v1;\n\
\tthis.v2 = v2;\n\
\tthis.v3 = v3;\n\
\n\
};\n\
\n\
THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\
\n\
THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\
\n\
\tvar tx, ty;\n\
\n\
\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\
\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\
\n\
\treturn new THREE.Vector2( tx, ty );\n\
\n\
};\n\
\n\
THREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\
\n\
\tvar tx, ty;\n\
\n\
\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\
\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\
\n\
\tvar tangent = new THREE.Vector2( tx, ty );\n\
\ttangent.normalize();\n\
\n\
\treturn tangent;\n\
\n\
};\n\
/**************************************************************\n\
 *\tSpline curve\n\
 **************************************************************/\n\
\n\
THREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\
\n\
\tthis.points = (points == undefined) ? [] : points;\n\
\n\
};\n\
\n\
THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\n\
\n\
THREE.SplineCurve.prototype.getPoint = function ( t ) {\n\
\n\
\tvar v = new THREE.Vector2();\n\
\tvar c = [];\n\
\tvar points = this.points, point, intPoint, weight;\n\
\tpoint = ( points.length - 1 ) * t;\n\
\n\
\tintPoint = Math.floor( point );\n\
\tweight = point - intPoint;\n\
\n\
\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\
\tc[ 1 ] = intPoint;\n\
\tc[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;\n\
\tc[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;\n\
\n\
\tv.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\n\
\tv.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\n\
\n\
\treturn v;\n\
\n\
};\n\
/**************************************************************\n\
 *\tEllipse curve\n\
 **************************************************************/\n\
\n\
THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius,\n\
\t\t\t\t\t\t\taStartAngle, aEndAngle,\n\
\t\t\t\t\t\t\taClockwise ) {\n\
\n\
\tthis.aX = aX;\n\
\tthis.aY = aY;\n\
\n\
\tthis.xRadius = xRadius;\n\
\tthis.yRadius = yRadius;\n\
\n\
\tthis.aStartAngle = aStartAngle;\n\
\tthis.aEndAngle = aEndAngle;\n\
\n\
\tthis.aClockwise = aClockwise;\n\
\n\
};\n\
\n\
THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\n\
\n\
THREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\
\n\
\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\
\n\
\tif ( !this.aClockwise ) {\n\
\n\
\t\tt = 1 - t;\n\
\n\
\t}\n\
\n\
\tvar angle = this.aStartAngle + t * deltaAngle;\n\
\n\
\tvar tx = this.aX + this.xRadius * Math.cos( angle );\n\
\tvar ty = this.aY + this.yRadius * Math.sin( angle );\n\
\n\
\treturn new THREE.Vector2( tx, ty );\n\
\n\
};\n\
/**************************************************************\n\
 *\tArc curve\n\
 **************************************************************/\n\
\n\
THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\
\n\
\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\
};\n\
\n\
THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\n\
/**************************************************************\n\
 *\tLine3D\n\
 **************************************************************/\n\
\n\
THREE.LineCurve3 = THREE.Curve.create(\n\
\n\
\tfunction ( v1, v2 ) {\n\
\n\
\t\tthis.v1 = v1;\n\
\t\tthis.v2 = v2;\n\
\n\
\t},\n\
\n\
\tfunction ( t ) {\n\
\n\
\t\tvar r = new THREE.Vector3();\n\
\n\
\n\
\t\tr.subVectors( this.v2, this.v1 ); // diff\n\
\t\tr.multiplyScalar( t );\n\
\t\tr.add( this.v1 );\n\
\n\
\t\treturn r;\n\
\n\
\t}\n\
\n\
);\n\
\n\
/**************************************************************\n\
 *\tQuadratic Bezier 3D curve\n\
 **************************************************************/\n\
\n\
THREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\
\n\
\tfunction ( v0, v1, v2 ) {\n\
\n\
\t\tthis.v0 = v0;\n\
\t\tthis.v1 = v1;\n\
\t\tthis.v2 = v2;\n\
\n\
\t},\n\
\n\
\tfunction ( t ) {\n\
\n\
\t\tvar tx, ty, tz;\n\
\n\
\t\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\n\
\t\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\n\
\t\ttz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\n\
\n\
\t\treturn new THREE.Vector3( tx, ty, tz );\n\
\n\
\t}\n\
\n\
);\n\
/**************************************************************\n\
 *\tCubic Bezier 3D curve\n\
 **************************************************************/\n\
\n\
THREE.CubicBezierCurve3 = THREE.Curve.create(\n\
\n\
\tfunction ( v0, v1, v2, v3 ) {\n\
\n\
\t\tthis.v0 = v0;\n\
\t\tthis.v1 = v1;\n\
\t\tthis.v2 = v2;\n\
\t\tthis.v3 = v3;\n\
\n\
\t},\n\
\n\
\tfunction ( t ) {\n\
\n\
\t\tvar tx, ty, tz;\n\
\n\
\t\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\
\t\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\
\t\ttz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\n\
\n\
\t\treturn new THREE.Vector3( tx, ty, tz );\n\
\n\
\t}\n\
\n\
);\n\
/**************************************************************\n\
 *\tSpline 3D curve\n\
 **************************************************************/\n\
\n\
\n\
THREE.SplineCurve3 = THREE.Curve.create(\n\
\n\
\tfunction ( points /* array of Vector3 */) {\n\
\n\
\t\tthis.points = (points == undefined) ? [] : points;\n\
\n\
\t},\n\
\n\
\tfunction ( t ) {\n\
\n\
\t\tvar v = new THREE.Vector3();\n\
\t\tvar c = [];\n\
\t\tvar points = this.points, point, intPoint, weight;\n\
\t\tpoint = ( points.length - 1 ) * t;\n\
\n\
\t\tintPoint = Math.floor( point );\n\
\t\tweight = point - intPoint;\n\
\n\
\t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\
\t\tc[ 1 ] = intPoint;\n\
\t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n\
\t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n\
\n\
\t\tvar pt0 = points[ c[0] ],\n\
\t\t\tpt1 = points[ c[1] ],\n\
\t\t\tpt2 = points[ c[2] ],\n\
\t\t\tpt3 = points[ c[3] ];\n\
\n\
\t\tv.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);\n\
\t\tv.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);\n\
\t\tv.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);\n\
\n\
\t\treturn v;\n\
\n\
\t}\n\
\n\
);\n\
\n\
\n\
// THREE.SplineCurve3.prototype.getTangent = function(t) {\n\
// \t\tvar v = new THREE.Vector3();\n\
// \t\tvar c = [];\n\
// \t\tvar points = this.points, point, intPoint, weight;\n\
// \t\tpoint = ( points.length - 1 ) * t;\n\
\n\
// \t\tintPoint = Math.floor( point );\n\
// \t\tweight = point - intPoint;\n\
\n\
// \t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\
// \t\tc[ 1 ] = intPoint;\n\
// \t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n\
// \t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n\
\n\
// \t\tvar pt0 = points[ c[0] ],\n\
// \t\t\tpt1 = points[ c[1] ],\n\
// \t\t\tpt2 = points[ c[2] ],\n\
// \t\t\tpt3 = points[ c[3] ];\n\
\n\
// \t// t = weight;\n\
// \tv.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );\n\
// \tv.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );\n\
// \tv.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );\n\
\n\
// \treturn v;\n\
\n\
// }\n\
/**************************************************************\n\
 *\tClosed Spline 3D curve\n\
 **************************************************************/\n\
\n\
\n\
THREE.ClosedSplineCurve3 = THREE.Curve.create(\n\
\n\
\tfunction ( points /* array of Vector3 */) {\n\
\n\
\t\tthis.points = (points == undefined) ? [] : points;\n\
\n\
\t},\n\
\n\
    function ( t ) {\n\
\n\
        var v = new THREE.Vector3();\n\
        var c = [];\n\
        var points = this.points, point, intPoint, weight;\n\
        point = ( points.length - 0 ) * t;\n\
            // This needs to be from 0-length +1\n\
\n\
        intPoint = Math.floor( point );\n\
        weight = point - intPoint;\n\
\n\
        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\
        c[ 0 ] = ( intPoint - 1 ) % points.length;\n\
        c[ 1 ] = ( intPoint ) % points.length;\n\
        c[ 2 ] = ( intPoint + 1 ) % points.length;\n\
        c[ 3 ] = ( intPoint + 2 ) % points.length;\n\
\n\
        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\n\
        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\n\
        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );\n\
\n\
        return v;\n\
\n\
    }\n\
\n\
);\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 */\n\
\n\
THREE.AnimationHandler = (function() {\n\
\n\
\tvar playing = [];\n\
\tvar library = {};\n\
\tvar that    = {};\n\
\n\
\n\
\t//--- update ---\n\
\n\
\tthat.update = function( deltaTimeMS ) {\n\
\n\
\t\tfor( var i = 0; i < playing.length; i ++ )\n\
\t\t\tplaying[ i ].update( deltaTimeMS );\n\
\n\
\t};\n\
\n\
\n\
\t//--- add ---\n\
\n\
\tthat.addToUpdate = function( animation ) {\n\
\n\
\t\tif ( playing.indexOf( animation ) === -1 )\n\
\t\t\tplaying.push( animation );\n\
\n\
\t};\n\
\n\
\n\
\t//--- remove ---\n\
\n\
\tthat.removeFromUpdate = function( animation ) {\n\
\n\
\t\tvar index = playing.indexOf( animation );\n\
\n\
\t\tif( index !== -1 )\n\
\t\t\tplaying.splice( index, 1 );\n\
\n\
\t};\n\
\n\
\n\
\t//--- add ---\n\
\n\
\tthat.add = function( data ) {\n\
\n\
\t\tif ( library[ data.name ] !== undefined )\n\
\t\t\tconsole.log( \"THREE.AnimationHandler.add: Warning! \" + data.name + \" already exists in library. Overwriting.\" );\n\
\n\
\t\tlibrary[ data.name ] = data;\n\
\t\tinitData( data );\n\
\n\
\t};\n\
\n\
\n\
\t//--- get ---\n\
\n\
\tthat.get = function( name ) {\n\
\n\
\t\tif ( typeof name === \"string\" ) {\n\
\n\
\t\t\tif ( library[ name ] ) {\n\
\n\
\t\t\t\treturn library[ name ];\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tconsole.log( \"THREE.AnimationHandler.get: Couldn't find animation \" + name );\n\
\t\t\t\treturn null;\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\t// todo: add simple tween library\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\t//--- parse ---\n\
\n\
\tthat.parse = function( root ) {\n\
\n\
\t\t// setup hierarchy\n\
\n\
\t\tvar hierarchy = [];\n\
\n\
\t\tif ( root instanceof THREE.SkinnedMesh ) {\n\
\n\
\t\t\tfor( var b = 0; b < root.bones.length; b++ ) {\n\
\n\
\t\t\t\thierarchy.push( root.bones[ b ] );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tparseRecurseHierarchy( root, hierarchy );\n\
\n\
\t\t}\n\
\n\
\t\treturn hierarchy;\n\
\n\
\t};\n\
\n\
\tvar parseRecurseHierarchy = function( root, hierarchy ) {\n\
\n\
\t\thierarchy.push( root );\n\
\n\
\t\tfor( var c = 0; c < root.children.length; c++ )\n\
\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\n\
\n\
\t}\n\
\n\
\n\
\t//--- init data ---\n\
\n\
\tvar initData = function( data ) {\n\
\n\
\t\tif( data.initialized === true )\n\
\t\t\treturn;\n\
\n\
\n\
\t\t// loop through all keys\n\
\n\
\t\tfor( var h = 0; h < data.hierarchy.length; h ++ ) {\n\
\n\
\t\t\tfor( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\
\n\
\t\t\t\t// remove minus times\n\
\n\
\t\t\t\tif( data.hierarchy[ h ].keys[ k ].time < 0 )\n\
\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].time = 0;\n\
\n\
\n\
\t\t\t\t// create quaternions\n\
\n\
\t\t\t\tif( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\n\
\t\t\t\t !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\n\
\n\
\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\n\
\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\n\
\t\t\t// prepare morph target keys\n\
\n\
\t\t\tif( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\n\
\n\
\t\t\t\t// get all used\n\
\n\
\t\t\t\tvar usedMorphTargets = {};\n\
\n\
\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\
\n\
\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\
\n\
\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\n\
\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = -1;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\n\
\n\
\n\
\t\t\t\t// set all used on all frames\n\
\n\
\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\
\n\
\t\t\t\t\tvar influences = {};\n\
\n\
\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\n\
\n\
\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\
\n\
\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\n\
\n\
\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\n\
\t\t\t\t\t\t\t\tbreak;\n\
\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\n\
\n\
\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\n\
\t\t\t// remove all keys that are on the same time\n\
\n\
\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\
\n\
\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\n\
\n\
\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\n\
\t\t\t\t\tk --;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\n\
\t\t\t// set index\n\
\n\
\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\
\n\
\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\n\
\t\t// JIT\n\
\n\
\t\tvar lengthInFrames = parseInt( data.length * data.fps, 10 );\n\
\n\
\t\tdata.JIT = {};\n\
\t\tdata.JIT.hierarchy = [];\n\
\n\
\t\tfor( var h = 0; h < data.hierarchy.length; h ++ )\n\
\t\t\tdata.JIT.hierarchy.push( new Array( lengthInFrames ) );\n\
\n\
\n\
\t\t// done\n\
\n\
\t\tdata.initialized = true;\n\
\n\
\t};\n\
\n\
\n\
\t// interpolation types\n\
\n\
\tthat.LINEAR = 0;\n\
\tthat.CATMULLROM = 1;\n\
\tthat.CATMULLROM_FORWARD = 2;\n\
\n\
\treturn that;\n\
\n\
}());\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.Animation = function ( root, name, interpolationType ) {\n\
\n\
\tthis.root = root;\n\
\tthis.data = THREE.AnimationHandler.get( name );\n\
\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\
\n\
\tthis.currentTime = 0;\n\
\tthis.timeScale = 1;\n\
\n\
\tthis.isPlaying = false;\n\
\tthis.isPaused = true;\n\
\tthis.loop = true;\n\
\n\
\tthis.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;\n\
\n\
\tthis.points = [];\n\
\tthis.target = new THREE.Vector3();\n\
\n\
};\n\
\n\
THREE.Animation.prototype.play = function ( loop, startTimeMS ) {\n\
\n\
\tif ( this.isPlaying === false ) {\n\
\n\
\t\tthis.isPlaying = true;\n\
\t\tthis.loop = loop !== undefined ? loop : true;\n\
\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n\
\n\
\t\t// reset key cache\n\
\n\
\t\tvar h, hl = this.hierarchy.length,\n\
\t\t\tobject;\n\
\n\
\t\tfor ( h = 0; h < hl; h ++ ) {\n\
\n\
\t\t\tobject = this.hierarchy[ h ];\n\
\n\
\t\t\tobject.matrixAutoUpdate = true;\n\
\n\
\t\t\tif ( object.animationCache === undefined ) {\n\
\n\
\t\t\t\tobject.animationCache = {};\n\
\t\t\t\tobject.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };\n\
\t\t\t\tobject.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };\n\
\t\t\t\tobject.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar prevKey = object.animationCache.prevKey;\n\
\t\t\tvar nextKey = object.animationCache.nextKey;\n\
\n\
\t\t\tprevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];\n\
\t\t\tprevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];\n\
\t\t\tprevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];\n\
\n\
\t\t\tnextKey.pos = this.getNextKeyWith( \"pos\", h, 1 );\n\
\t\t\tnextKey.rot = this.getNextKeyWith( \"rot\", h, 1 );\n\
\t\t\tnextKey.scl = this.getNextKeyWith( \"scl\", h, 1 );\n\
\n\
\t\t}\n\
\n\
\t\tthis.update( 0 );\n\
\n\
\t}\n\
\n\
\tthis.isPaused = false;\n\
\n\
\tTHREE.AnimationHandler.addToUpdate( this );\n\
\n\
};\n\
\n\
\n\
THREE.Animation.prototype.pause = function() {\n\
\n\
\tif ( this.isPaused === true ) {\n\
\n\
\t\tTHREE.AnimationHandler.addToUpdate( this );\n\
\n\
\t} else {\n\
\n\
\t\tTHREE.AnimationHandler.removeFromUpdate( this );\n\
\n\
\t}\n\
\n\
\tthis.isPaused = !this.isPaused;\n\
\n\
};\n\
\n\
\n\
THREE.Animation.prototype.stop = function() {\n\
\n\
\tthis.isPlaying = false;\n\
\tthis.isPaused  = false;\n\
\tTHREE.AnimationHandler.removeFromUpdate( this );\n\
\n\
};\n\
\n\
\n\
THREE.Animation.prototype.update = function ( deltaTimeMS ) {\n\
\n\
\t// early out\n\
\n\
\tif ( this.isPlaying === false ) return;\n\
\n\
\n\
\t// vars\n\
\n\
\tvar types = [ \"pos\", \"rot\", \"scl\" ];\n\
\tvar type;\n\
\tvar scale;\n\
\tvar vector;\n\
\tvar prevXYZ, nextXYZ;\n\
\tvar prevKey, nextKey;\n\
\tvar object;\n\
\tvar animationCache;\n\
\tvar frame;\n\
\tvar JIThierarchy = this.data.JIT.hierarchy;\n\
\tvar currentTime, unloopedCurrentTime;\n\
\tvar currentPoint, forwardPoint, angle;\n\
\n\
\n\
\tthis.currentTime += deltaTimeMS * this.timeScale;\n\
\n\
\tunloopedCurrentTime = this.currentTime;\n\
\tcurrentTime = this.currentTime = this.currentTime % this.data.length;\n\
\tframe = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\n\
\n\
\n\
\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\n\
\n\
\t\tobject = this.hierarchy[ h ];\n\
\t\tanimationCache = object.animationCache;\n\
\n\
\t\t// loop through pos/rot/scl\n\
\n\
\t\tfor ( var t = 0; t < 3; t ++ ) {\n\
\n\
\t\t\t// get keys\n\
\n\
\t\t\ttype    = types[ t ];\n\
\t\t\tprevKey = animationCache.prevKey[ type ];\n\
\t\t\tnextKey = animationCache.nextKey[ type ];\n\
\n\
\t\t\t// switch keys?\n\
\n\
\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\n\
\n\
\t\t\t\t// did we loop?\n\
\n\
\t\t\t\tif ( currentTime < unloopedCurrentTime ) {\n\
\n\
\t\t\t\t\tif ( this.loop ) {\n\
\n\
\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\n\
\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\n\
\n\
\t\t\t\t\t\twhile( nextKey.time < currentTime ) {\n\
\n\
\t\t\t\t\t\t\tprevKey = nextKey;\n\
\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\tthis.stop();\n\
\t\t\t\t\t\treturn;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tdo {\n\
\n\
\t\t\t\t\t\tprevKey = nextKey;\n\
\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\
\n\
\t\t\t\t\t} while( nextKey.time < currentTime )\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\n\
\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\n\
\n\
\t\t\t}\n\
\n\
\n\
\t\t\tobject.matrixAutoUpdate = true;\n\
\t\t\tobject.matrixWorldNeedsUpdate = true;\n\
\n\
\t\t\tscale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\n\
\t\t\tprevXYZ = prevKey[ type ];\n\
\t\t\tnextXYZ = nextKey[ type ];\n\
\n\
\n\
\t\t\t// check scale error\n\
\n\
\t\t\tif ( scale < 0 || scale > 1 ) {\n\
\n\
\t\t\t\tconsole.log( \"THREE.Animation.update: Warning! Scale out of bounds:\" + scale + \" on bone \" + h );\n\
\t\t\t\tscale = scale < 0 ? 0 : 1;\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// interpolate\n\
\n\
\t\t\tif ( type === \"pos\" ) {\n\
\n\
\t\t\t\tvector = object.position;\n\
\n\
\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\n\
\n\
\t\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\
\t\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\
\t\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\
\n\
\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\
\t\t\t\t\t\t    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\
\n\
\t\t\t\t\tthis.points[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\n\
\t\t\t\t\tthis.points[ 1 ] = prevXYZ;\n\
\t\t\t\t\tthis.points[ 2 ] = nextXYZ;\n\
\t\t\t\t\tthis.points[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\n\
\n\
\t\t\t\t\tscale = scale * 0.33 + 0.33;\n\
\n\
\t\t\t\t\tcurrentPoint = this.interpolateCatmullRom( this.points, scale );\n\
\n\
\t\t\t\t\tvector.x = currentPoint[ 0 ];\n\
\t\t\t\t\tvector.y = currentPoint[ 1 ];\n\
\t\t\t\t\tvector.z = currentPoint[ 2 ];\n\
\n\
\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\
\n\
\t\t\t\t\t\tforwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );\n\
\n\
\t\t\t\t\t\tthis.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\n\
\t\t\t\t\t\tthis.target.sub( vector );\n\
\t\t\t\t\t\tthis.target.y = 0;\n\
\t\t\t\t\t\tthis.target.normalize();\n\
\n\
\t\t\t\t\t\tangle = Math.atan2( this.target.x, this.target.z );\n\
\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else if ( type === \"rot\" ) {\n\
\n\
\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );\n\
\n\
\t\t\t} else if ( type === \"scl\" ) {\n\
\n\
\t\t\t\tvector = object.scale;\n\
\n\
\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\
\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\
\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
};\n\
\n\
// Catmull-Rom spline\n\
\n\
THREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {\n\
\n\
\tvar c = [], v3 = [],\n\
\tpoint, intPoint, weight, w2, w3,\n\
\tpa, pb, pc, pd;\n\
\n\
\tpoint = ( points.length - 1 ) * scale;\n\
\tintPoint = Math.floor( point );\n\
\tweight = point - intPoint;\n\
\n\
\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\
\tc[ 1 ] = intPoint;\n\
\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\n\
\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\n\
\n\
\tpa = points[ c[ 0 ] ];\n\
\tpb = points[ c[ 1 ] ];\n\
\tpc = points[ c[ 2 ] ];\n\
\tpd = points[ c[ 3 ] ];\n\
\n\
\tw2 = weight * weight;\n\
\tw3 = weight * w2;\n\
\n\
\tv3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\n\
\tv3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\n\
\tv3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\n\
\n\
\treturn v3;\n\
\n\
};\n\
\n\
THREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\n\
\n\
\tvar v0 = ( p2 - p0 ) * 0.5,\n\
\t\tv1 = ( p3 - p1 ) * 0.5;\n\
\n\
\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\
\n\
};\n\
\n\
\n\
\n\
// Get next key with\n\
\n\
THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {\n\
\n\
\tvar keys = this.data.hierarchy[ h ].keys;\n\
\n\
\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\
\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\
\n\
\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\n\
\n\
\t} else {\n\
\n\
\t\tkey = key % keys.length;\n\
\n\
\t}\n\
\n\
\tfor ( ; key < keys.length; key++ ) {\n\
\n\
\t\tif ( keys[ key ][ type ] !== undefined ) {\n\
\n\
\t\t\treturn keys[ key ];\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\treturn this.data.hierarchy[ h ].keys[ 0 ];\n\
\n\
};\n\
\n\
// Get previous key with\n\
\n\
THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {\n\
\n\
\tvar keys = this.data.hierarchy[ h ].keys;\n\
\n\
\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\
\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\
\n\
\t\tkey = key > 0 ? key : 0;\n\
\n\
\t} else {\n\
\n\
\t\tkey = key >= 0 ? key : key + keys.length;\n\
\n\
\t}\n\
\n\
\n\
\tfor ( ; key >= 0; key -- ) {\n\
\n\
\t\tif ( keys[ key ][ type ] !== undefined ) {\n\
\n\
\t\t\treturn keys[ key ];\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\n\
\n\
};\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author khang duong\n\
 * @author erik kitson\n\
 */\n\
\n\
THREE.KeyFrameAnimation = function( root, data, JITCompile ) {\n\
\n\
\tthis.root = root;\n\
\tthis.data = THREE.AnimationHandler.get( data );\n\
\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\
\tthis.currentTime = 0;\n\
\tthis.timeScale = 0.001;\n\
\tthis.isPlaying = false;\n\
\tthis.isPaused = true;\n\
\tthis.loop = true;\n\
\tthis.JITCompile = JITCompile !== undefined ? JITCompile : true;\n\
\n\
\t// initialize to first keyframes\n\
\n\
\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\
\n\
\t\tvar keys = this.data.hierarchy[h].keys,\n\
\t\t\tsids = this.data.hierarchy[h].sids,\n\
\t\t\tobj = this.hierarchy[h];\n\
\n\
\t\tif ( keys.length && sids ) {\n\
\n\
\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\n\
\n\
\t\t\t\tvar sid = sids[ s ],\n\
\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\n\
\n\
\t\t\t\tif ( next ) {\n\
\n\
\t\t\t\t\tnext.apply( sid );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tobj.matrixAutoUpdate = false;\n\
\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\
\t\t\tobj.matrixWorldNeedsUpdate = true;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
};\n\
\n\
// Play\n\
\n\
THREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {\n\
\n\
\tif( !this.isPlaying ) {\n\
\n\
\t\tthis.isPlaying = true;\n\
\t\tthis.loop = loop !== undefined ? loop : true;\n\
\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n\
\t\tthis.startTimeMs = startTimeMS;\n\
\t\tthis.startTime = 10000000;\n\
\t\tthis.endTime = -this.startTime;\n\
\n\
\n\
\t\t// reset key cache\n\
\n\
\t\tvar h, hl = this.hierarchy.length,\n\
\t\t\tobject,\n\
\t\t\tnode;\n\
\n\
\t\tfor ( h = 0; h < hl; h++ ) {\n\
\n\
\t\t\tobject = this.hierarchy[ h ];\n\
\t\t\tnode = this.data.hierarchy[ h ];\n\
\n\
\t\t\tif ( node.animationCache === undefined ) {\n\
\n\
\t\t\t\tnode.animationCache = {};\n\
\t\t\t\tnode.animationCache.prevKey = null;\n\
\t\t\t\tnode.animationCache.nextKey = null;\n\
\t\t\t\tnode.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tvar keys = this.data.hierarchy[h].keys;\n\
\n\
\t\t\tif (keys.length) {\n\
\n\
\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\n\
\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\n\
\n\
\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\n\
\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tthis.update( 0 );\n\
\n\
\t}\n\
\n\
\tthis.isPaused = false;\n\
\n\
\tTHREE.AnimationHandler.addToUpdate( this );\n\
\n\
};\n\
\n\
\n\
\n\
// Pause\n\
\n\
THREE.KeyFrameAnimation.prototype.pause = function() {\n\
\n\
\tif( this.isPaused ) {\n\
\n\
\t\tTHREE.AnimationHandler.addToUpdate( this );\n\
\n\
\t} else {\n\
\n\
\t\tTHREE.AnimationHandler.removeFromUpdate( this );\n\
\n\
\t}\n\
\n\
\tthis.isPaused = !this.isPaused;\n\
\n\
};\n\
\n\
\n\
// Stop\n\
\n\
THREE.KeyFrameAnimation.prototype.stop = function() {\n\
\n\
\tthis.isPlaying = false;\n\
\tthis.isPaused  = false;\n\
\tTHREE.AnimationHandler.removeFromUpdate( this );\n\
\n\
\n\
\t// reset JIT matrix and remove cache\n\
\n\
\tfor ( var h = 0; h < this.data.hierarchy.length; h++ ) {\n\
        \n\
        var obj = this.hierarchy[ h ];\n\
\t\tvar node = this.data.hierarchy[ h ];\n\
\n\
\t\tif ( node.animationCache !== undefined ) {\n\
\n\
\t\t\tvar original = node.animationCache.originalMatrix;\n\
\n\
\t\t\tif( obj instanceof THREE.Bone ) {\n\
\n\
\t\t\t\toriginal.copy( obj.skinMatrix );\n\
\t\t\t\tobj.skinMatrix = original;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\toriginal.copy( obj.matrix );\n\
\t\t\t\tobj.matrix = original;\n\
\n\
\t\t\t}\n\
\n\
\t\t\tdelete node.animationCache;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
};\n\
\n\
\n\
// Update\n\
\n\
THREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {\n\
\n\
\t// early out\n\
\n\
\tif( !this.isPlaying ) return;\n\
\n\
\n\
\t// vars\n\
\n\
\tvar prevKey, nextKey;\n\
\tvar object;\n\
\tvar node;\n\
\tvar frame;\n\
\tvar JIThierarchy = this.data.JIT.hierarchy;\n\
\tvar currentTime, unloopedCurrentTime;\n\
\tvar looped;\n\
\n\
\n\
\t// update\n\
\n\
\tthis.currentTime += deltaTimeMS * this.timeScale;\n\
\n\
\tunloopedCurrentTime = this.currentTime;\n\
\tcurrentTime         = this.currentTime = this.currentTime % this.data.length;\n\
\n\
\t// if looped around, the current time should be based on the startTime\n\
\tif ( currentTime < this.startTimeMs ) {\n\
\n\
\t\tcurrentTime = this.currentTime = this.startTimeMs + currentTime;\n\
\n\
\t}\n\
\n\
\tframe               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\n\
\tlooped \t\t\t\t= currentTime < unloopedCurrentTime;\n\
\n\
\tif ( looped && !this.loop ) {\n\
\n\
\t\t// Set the animation to the last keyframes and stop\n\
\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\
\n\
\t\t\tvar keys = this.data.hierarchy[h].keys,\n\
\t\t\t\tsids = this.data.hierarchy[h].sids,\n\
\t\t\t\tend = keys.length-1,\n\
\t\t\t\tobj = this.hierarchy[h];\n\
\n\
\t\t\tif ( keys.length ) {\n\
\n\
\t\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\n\
\n\
\t\t\t\t\tvar sid = sids[ s ],\n\
\t\t\t\t\t\tprev = this.getPrevKeyWith( sid, h, end );\n\
\n\
\t\t\t\t\tif ( prev ) {\n\
\t\t\t\t\t\tprev.apply( sid );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\
\t\t\t\tobj.matrixWorldNeedsUpdate = true;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tthis.stop();\n\
\t\treturn;\n\
\n\
\t}\n\
\n\
\t// check pre-infinity\n\
\tif ( currentTime < this.startTime ) {\n\
\n\
\t\treturn;\n\
\n\
\t}\n\
\n\
\t// update\n\
\n\
\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\
\n\
\t\tobject = this.hierarchy[ h ];\n\
\t\tnode = this.data.hierarchy[ h ];\n\
\n\
\t\tvar keys = node.keys,\n\
\t\t\tanimationCache = node.animationCache;\n\
\n\
\t\t// use JIT?\n\
\n\
\t\tif ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {\n\
\n\
\t\t\tif( object instanceof THREE.Bone ) {\n\
\n\
\t\t\t\tobject.skinMatrix = JIThierarchy[ h ][ frame ];\n\
\t\t\t\tobject.matrixWorldNeedsUpdate = false;\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tobject.matrix = JIThierarchy[ h ][ frame ];\n\
\t\t\t\tobject.matrixWorldNeedsUpdate = true;\n\
\n\
\t\t\t}\n\
\n\
\t\t// use interpolation\n\
\n\
\t\t} else if ( keys.length ) {\n\
\n\
\t\t\t// make sure so original matrix and not JIT matrix is set\n\
\n\
\t\t\tif ( this.JITCompile && animationCache ) {\n\
\n\
\t\t\t\tif( object instanceof THREE.Bone ) {\n\
\n\
\t\t\t\t\tobject.skinMatrix = animationCache.originalMatrix;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tobject.matrix = animationCache.originalMatrix;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\tprevKey = animationCache.prevKey;\n\
\t\t\tnextKey = animationCache.nextKey;\n\
\n\
\t\t\tif ( prevKey && nextKey ) {\n\
\n\
\t\t\t\t// switch keys?\n\
\n\
\t\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\n\
\n\
\t\t\t\t\t// did we loop?\n\
\n\
\t\t\t\t\tif ( looped && this.loop ) {\n\
\n\
\t\t\t\t\t\tprevKey = keys[ 0 ];\n\
\t\t\t\t\t\tnextKey = keys[ 1 ];\n\
\n\
\t\t\t\t\t\twhile ( nextKey.time < currentTime ) {\n\
\n\
\t\t\t\t\t\t\tprevKey = nextKey;\n\
\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t} else if ( !looped ) {\n\
\n\
\t\t\t\t\t\tvar lastIndex = keys.length - 1;\n\
\n\
\t\t\t\t\t\twhile ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {\n\
\n\
\t\t\t\t\t\t\tprevKey = nextKey;\n\
\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\
\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tanimationCache.prevKey = prevKey;\n\
\t\t\t\t\tanimationCache.nextKey = nextKey;\n\
\n\
\t\t\t\t}\n\
                if(nextKey.time >= currentTime)\n\
                    prevKey.interpolate( nextKey, currentTime );\n\
                else\n\
                    prevKey.interpolate( nextKey, nextKey.time);\n\
\n\
\t\t\t}\n\
\n\
\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\
\t\t\tobject.matrixWorldNeedsUpdate = true;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\t// update JIT?\n\
\n\
\tif ( this.JITCompile ) {\n\
\n\
\t\tif ( JIThierarchy[ 0 ][ frame ] === undefined ) {\n\
\n\
\t\t\tthis.hierarchy[ 0 ].updateMatrixWorld( true );\n\
\n\
\t\t\tfor ( var h = 0; h < this.hierarchy.length; h++ ) {\n\
\n\
\t\t\t\tif( this.hierarchy[ h ] instanceof THREE.Bone ) {\n\
\n\
\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
};\n\
\n\
// Get next key with\n\
\n\
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {\n\
\n\
\tvar keys = this.data.hierarchy[ h ].keys;\n\
\tkey = key % keys.length;\n\
\n\
\tfor ( ; key < keys.length; key++ ) {\n\
\n\
\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\
\n\
\t\t\treturn keys[ key ];\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\treturn keys[ 0 ];\n\
\n\
};\n\
\n\
// Get previous key with\n\
\n\
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {\n\
\n\
\tvar keys = this.data.hierarchy[ h ].keys;\n\
\tkey = key >= 0 ? key : key + keys.length;\n\
\n\
\tfor ( ; key >= 0; key-- ) {\n\
\n\
\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\
\n\
\t\t\treturn keys[ key ];\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\treturn keys[ keys.length - 1 ];\n\
\n\
};\n\
\n\
/**\n\
 * Camera for rendering cube maps\n\
 *\t- renders scene into axis-aligned cube\n\
 *\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.CubeCamera = function ( near, far, cubeResolution ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tvar fov = 90, aspect = 1;\n\
\n\
\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\
\tcameraPX.up.set( 0, -1, 0 );\n\
\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\
\tthis.add( cameraPX );\n\
\n\
\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\
\tcameraNX.up.set( 0, -1, 0 );\n\
\tcameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );\n\
\tthis.add( cameraNX );\n\
\n\
\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\
\tcameraPY.up.set( 0, 0, 1 );\n\
\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\
\tthis.add( cameraPY );\n\
\n\
\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\
\tcameraNY.up.set( 0, 0, -1 );\n\
\tcameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );\n\
\tthis.add( cameraNY );\n\
\n\
\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\
\tcameraPZ.up.set( 0, -1, 0 );\n\
\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\
\tthis.add( cameraPZ );\n\
\n\
\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\
\tcameraNZ.up.set( 0, -1, 0 );\n\
\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );\n\
\tthis.add( cameraNZ );\n\
\n\
\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\n\
\n\
\tthis.updateCubeMap = function ( renderer, scene ) {\n\
\n\
\t\tvar renderTarget = this.renderTarget;\n\
\t\tvar generateMipmaps = renderTarget.generateMipmaps;\n\
\n\
\t\trenderTarget.generateMipmaps = false;\n\
\n\
\t\trenderTarget.activeCubeFace = 0;\n\
\t\trenderer.render( scene, cameraPX, renderTarget );\n\
\n\
\t\trenderTarget.activeCubeFace = 1;\n\
\t\trenderer.render( scene, cameraNX, renderTarget );\n\
\n\
\t\trenderTarget.activeCubeFace = 2;\n\
\t\trenderer.render( scene, cameraPY, renderTarget );\n\
\n\
\t\trenderTarget.activeCubeFace = 3;\n\
\t\trenderer.render( scene, cameraNY, renderTarget );\n\
\n\
\t\trenderTarget.activeCubeFace = 4;\n\
\t\trenderer.render( scene, cameraPZ, renderTarget );\n\
\n\
\t\trenderTarget.generateMipmaps = generateMipmaps;\n\
\n\
\t\trenderTarget.activeCubeFace = 5;\n\
\t\trenderer.render( scene, cameraNZ, renderTarget );\n\
\n\
\t};\n\
\n\
};\n\
\n\
THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
/*\n\
 *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n\
 *\n\
 *\tA general perpose camera, for setting FOV, Lens Focal Length,\n\
 *\t\tand switching between perspective and orthographic views easily.\n\
 *\t\tUse this only if you do not wish to manage\n\
 *\t\tboth a Orthographic and Perspective Camera\n\
 *\n\
 */\n\
\n\
\n\
THREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {\n\
\n\
\tTHREE.Camera.call( this );\n\
\n\
\tthis.fov = fov;\n\
\n\
\tthis.left = -width / 2;\n\
\tthis.right = width / 2\n\
\tthis.top = height / 2;\n\
\tthis.bottom = -height / 2;\n\
\n\
\t// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\n\
\n\
\tthis.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, \torthoNear, orthoFar );\n\
\tthis.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );\n\
\n\
\tthis.zoom = 1;\n\
\n\
\tthis.toPerspective();\n\
\n\
\tvar aspect = width/height;\n\
\n\
};\n\
\n\
THREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );\n\
\n\
THREE.CombinedCamera.prototype.toPerspective = function () {\n\
\n\
\t// Switches to the Perspective Camera\n\
\n\
\tthis.near = this.cameraP.near;\n\
\tthis.far = this.cameraP.far;\n\
\n\
\tthis.cameraP.fov =  this.fov / this.zoom ;\n\
\n\
\tthis.cameraP.updateProjectionMatrix();\n\
\n\
\tthis.projectionMatrix = this.cameraP.projectionMatrix;\n\
\n\
\tthis.inPerspectiveMode = true;\n\
\tthis.inOrthographicMode = false;\n\
\n\
};\n\
\n\
THREE.CombinedCamera.prototype.toOrthographic = function () {\n\
\n\
\t// Switches to the Orthographic camera estimating viewport from Perspective\n\
\n\
\tvar fov = this.fov;\n\
\tvar aspect = this.cameraP.aspect;\n\
\tvar near = this.cameraP.near;\n\
\tvar far = this.cameraP.far;\n\
\n\
\t// The size that we set is the mid plane of the viewing frustum\n\
\n\
\tvar hyperfocus = ( near + far ) / 2;\n\
\n\
\tvar halfHeight = Math.tan( fov / 2 ) * hyperfocus;\n\
\tvar planeHeight = 2 * halfHeight;\n\
\tvar planeWidth = planeHeight * aspect;\n\
\tvar halfWidth = planeWidth / 2;\n\
\n\
\thalfHeight /= this.zoom;\n\
\thalfWidth /= this.zoom;\n\
\n\
\tthis.cameraO.left = -halfWidth;\n\
\tthis.cameraO.right = halfWidth;\n\
\tthis.cameraO.top = halfHeight;\n\
\tthis.cameraO.bottom = -halfHeight;\n\
\n\
\t// this.cameraO.left = -farHalfWidth;\n\
\t// this.cameraO.right = farHalfWidth;\n\
\t// this.cameraO.top = farHalfHeight;\n\
\t// this.cameraO.bottom = -farHalfHeight;\n\
\n\
\t// this.cameraO.left = this.left / this.zoom;\n\
\t// this.cameraO.right = this.right / this.zoom;\n\
\t// this.cameraO.top = this.top / this.zoom;\n\
\t// this.cameraO.bottom = this.bottom / this.zoom;\n\
\n\
\tthis.cameraO.updateProjectionMatrix();\n\
\n\
\tthis.near = this.cameraO.near;\n\
\tthis.far = this.cameraO.far;\n\
\tthis.projectionMatrix = this.cameraO.projectionMatrix;\n\
\n\
\tthis.inPerspectiveMode = false;\n\
\tthis.inOrthographicMode = true;\n\
\n\
};\n\
\n\
\n\
THREE.CombinedCamera.prototype.setSize = function( width, height ) {\n\
\n\
\tthis.cameraP.aspect = width / height;\n\
\tthis.left = -width / 2;\n\
\tthis.right = width / 2\n\
\tthis.top = height / 2;\n\
\tthis.bottom = -height / 2;\n\
\n\
};\n\
\n\
\n\
THREE.CombinedCamera.prototype.setFov = function( fov ) {\n\
\n\
\tthis.fov = fov;\n\
\n\
\tif ( this.inPerspectiveMode ) {\n\
\n\
\t\tthis.toPerspective();\n\
\n\
\t} else {\n\
\n\
\t\tthis.toOrthographic();\n\
\n\
\t}\n\
\n\
};\n\
\n\
// For mantaining similar API with PerspectiveCamera\n\
\n\
THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {\n\
\n\
\tif ( this.inPerspectiveMode ) {\n\
\n\
\t\tthis.toPerspective();\n\
\n\
\t} else {\n\
\n\
\t\tthis.toPerspective();\n\
\t\tthis.toOrthographic();\n\
\n\
\t}\n\
\n\
};\n\
\n\
/*\n\
* Uses Focal Length (in mm) to estimate and set FOV\n\
* 35mm (fullframe) camera is used if frame size is not specified;\n\
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n\
*/\n\
THREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {\n\
\n\
\tif ( frameHeight === undefined ) frameHeight = 24;\n\
\n\
\tvar fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\n\
\n\
\tthis.setFov( fov );\n\
\n\
\treturn fov;\n\
};\n\
\n\
\n\
THREE.CombinedCamera.prototype.setZoom = function( zoom ) {\n\
\n\
\tthis.zoom = zoom;\n\
\n\
\tif ( this.inPerspectiveMode ) {\n\
\n\
\t\tthis.toPerspective();\n\
\n\
\t} else {\n\
\n\
\t\tthis.toOrthographic();\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.CombinedCamera.prototype.toFrontView = function() {\n\
\n\
\tthis.rotation.x = 0;\n\
\tthis.rotation.y = 0;\n\
\tthis.rotation.z = 0;\n\
\n\
\t// should we be modifing the matrix instead?\n\
\n\
\tthis.rotationAutoUpdate = false;\n\
\n\
};\n\
\n\
THREE.CombinedCamera.prototype.toBackView = function() {\n\
\n\
\tthis.rotation.x = 0;\n\
\tthis.rotation.y = Math.PI;\n\
\tthis.rotation.z = 0;\n\
\tthis.rotationAutoUpdate = false;\n\
\n\
};\n\
\n\
THREE.CombinedCamera.prototype.toLeftView = function() {\n\
\n\
\tthis.rotation.x = 0;\n\
\tthis.rotation.y = - Math.PI / 2;\n\
\tthis.rotation.z = 0;\n\
\tthis.rotationAutoUpdate = false;\n\
\n\
};\n\
\n\
THREE.CombinedCamera.prototype.toRightView = function() {\n\
\n\
\tthis.rotation.x = 0;\n\
\tthis.rotation.y = Math.PI / 2;\n\
\tthis.rotation.z = 0;\n\
\tthis.rotationAutoUpdate = false;\n\
\n\
};\n\
\n\
THREE.CombinedCamera.prototype.toTopView = function() {\n\
\n\
\tthis.rotation.x = - Math.PI / 2;\n\
\tthis.rotation.y = 0;\n\
\tthis.rotation.z = 0;\n\
\tthis.rotationAutoUpdate = false;\n\
\n\
};\n\
\n\
THREE.CombinedCamera.prototype.toBottomView = function() {\n\
\n\
\tthis.rotation.x = Math.PI / 2;\n\
\tthis.rotation.y = 0;\n\
\tthis.rotation.z = 0;\n\
\tthis.rotationAutoUpdate = false;\n\
\n\
};\n\
\n\
\n\
/**\n\
 * @author hughes\n\
 */\n\
\n\
THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tradius = radius || 50;\n\
\n\
\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\
\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\
\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\
\n\
\tvar i, uvs = [],\n\
\tcenter = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\n\
\n\
\tthis.vertices.push(center);\n\
\tuvs.push( centerUV );\n\
\n\
\tfor ( i = 0; i <= segments; i ++ ) {\n\
\n\
\t\tvar vertex = new THREE.Vector3();\n\
\t\tvar segment = thetaStart + i / segments * thetaLength;\n\
\n\
\t\tvertex.x = radius * Math.cos( segment );\n\
\t\tvertex.y = radius * Math.sin( segment );\n\
\n\
\t\tthis.vertices.push( vertex );\n\
\t\tuvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );\n\
\n\
\t}\n\
\n\
\tvar n = new THREE.Vector3( 0, 0, 1 );\n\
\n\
\tfor ( i = 1; i <= segments; i ++ ) {\n\
\n\
\t\tvar v1 = i;\n\
\t\tvar v2 = i + 1 ;\n\
\t\tvar v3 = 0;\n\
\n\
\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n, n, n ] ) );\n\
\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ i ], uvs[ i + 1 ], centerUV ] );\n\
\n\
\t}\n\
\n\
\tthis.computeCentroids();\n\
\tthis.computeFaceNormals();\n\
\n\
\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\
\n\
};\n\
\n\
THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\
 */\n\
\n\
THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tvar scope = this;\n\
\n\
\tthis.width = width;\n\
\tthis.height = height;\n\
\tthis.depth = depth;\n\
\n\
\tthis.widthSegments = widthSegments || 1;\n\
\tthis.heightSegments = heightSegments || 1;\n\
\tthis.depthSegments = depthSegments || 1;\n\
\n\
\tvar width_half = this.width / 2;\n\
\tvar height_half = this.height / 2;\n\
\tvar depth_half = this.depth / 2;\n\
\n\
\tbuildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px\n\
\tbuildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx\n\
\tbuildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py\n\
\tbuildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny\n\
\tbuildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz\n\
\tbuildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz\n\
\n\
\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\n\
\n\
\t\tvar w, ix, iy,\n\
\t\tgridX = scope.widthSegments,\n\
\t\tgridY = scope.heightSegments,\n\
\t\twidth_half = width / 2,\n\
\t\theight_half = height / 2,\n\
\t\toffset = scope.vertices.length;\n\
\n\
\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\n\
\n\
\t\t\tw = 'z';\n\
\n\
\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\n\
\n\
\t\t\tw = 'y';\n\
\t\t\tgridY = scope.depthSegments;\n\
\n\
\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\n\
\n\
\t\t\tw = 'x';\n\
\t\t\tgridX = scope.depthSegments;\n\
\n\
\t\t}\n\
\n\
\t\tvar gridX1 = gridX + 1,\n\
\t\tgridY1 = gridY + 1,\n\
\t\tsegment_width = width / gridX,\n\
\t\tsegment_height = height / gridY,\n\
\t\tnormal = new THREE.Vector3();\n\
\n\
\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\n\
\n\
\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\
\n\
\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\
\n\
\t\t\t\tvar vector = new THREE.Vector3();\n\
\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\n\
\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\n\
\t\t\t\tvector[ w ] = depth;\n\
\n\
\t\t\t\tscope.vertices.push( vector );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tfor ( iy = 0; iy < gridY; iy++ ) {\n\
\n\
\t\t\tfor ( ix = 0; ix < gridX; ix++ ) {\n\
\n\
\t\t\t\tvar a = ix + gridX1 * iy;\n\
\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\
\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\
\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\
\n\
\t\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\n\
\t\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\n\
\t\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\n\
\t\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\n\
\n\
\t\t\t\tvar face = new THREE.Face3( a + offset, b + offset, d + offset );\n\
\t\t\t\tface.normal.copy( normal );\n\
\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\
\t\t\t\tface.materialIndex = materialIndex;\n\
\n\
\t\t\t\tscope.faces.push( face );\n\
\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\
\n\
\t\t\t\tface = new THREE.Face3( b + offset, c + offset, d + offset );\n\
\t\t\t\tface.normal.copy( normal );\n\
\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\
\t\t\t\tface.materialIndex = materialIndex;\n\
\n\
\t\t\t\tscope.faces.push( face );\n\
\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tthis.computeCentroids();\n\
\tthis.mergeVertices();\n\
\n\
};\n\
\n\
THREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tthis.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;\n\
\tthis.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\
\tthis.height = height = height !== undefined ? height : 100;\n\
\n\
\tthis.radialSegments = radialSegments = radialSegments || 8;\n\
\tthis.heightSegments = heightSegments = heightSegments || 1;\n\
\n\
\tthis.openEnded = openEnded = openEnded !== undefined ? openEnded : false;\n\
\n\
\tvar heightHalf = height / 2;\n\
\n\
\tvar x, y, vertices = [], uvs = [];\n\
\n\
\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\
\n\
\t\tvar verticesRow = [];\n\
\t\tvar uvsRow = [];\n\
\n\
\t\tvar v = y / heightSegments;\n\
\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\
\n\
\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\
\n\
\t\t\tvar u = x / radialSegments;\n\
\n\
\t\t\tvar vertex = new THREE.Vector3();\n\
\t\t\tvertex.x = radius * Math.sin( u * Math.PI * 2 );\n\
\t\t\tvertex.y = - v * height + heightHalf;\n\
\t\t\tvertex.z = radius * Math.cos( u * Math.PI * 2 );\n\
\n\
\t\t\tthis.vertices.push( vertex );\n\
\n\
\t\t\tverticesRow.push( this.vertices.length - 1 );\n\
\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\n\
\n\
\t\t}\n\
\n\
\t\tvertices.push( verticesRow );\n\
\t\tuvs.push( uvsRow );\n\
\n\
\t}\n\
\n\
\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\
\tvar na, nb;\n\
\n\
\tfor ( x = 0; x < radialSegments; x ++ ) {\n\
\n\
\t\tif ( radiusTop !== 0 ) {\n\
\n\
\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\n\
\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\n\
\n\
\t\t} else {\n\
\n\
\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\n\
\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\n\
\n\
\t\t}\n\
\n\
\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\n\
\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\n\
\n\
\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\
\n\
\t\t\tvar v1 = vertices[ y ][ x ];\n\
\t\t\tvar v2 = vertices[ y + 1 ][ x ];\n\
\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\n\
\t\t\tvar v4 = vertices[ y ][ x + 1 ];\n\
\n\
\t\t\tvar n1 = na.clone();\n\
\t\t\tvar n2 = na.clone();\n\
\t\t\tvar n3 = nb.clone();\n\
\t\t\tvar n4 = nb.clone();\n\
\n\
\t\t\tvar uv1 = uvs[ y ][ x ].clone();\n\
\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\n\
\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\n\
\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2, n3, n4 ] ) );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2, uv3, uv4 ] );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\t// top cap\n\
\n\
\tif ( openEnded === false && radiusTop > 0 ) {\n\
\n\
\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\n\
\n\
\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\
\n\
\t\t\tvar v1 = vertices[ 0 ][ x ];\n\
\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\n\
\t\t\tvar v3 = this.vertices.length - 1;\n\
\n\
\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\n\
\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\n\
\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\n\
\n\
\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\n\
\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\n\
\t\t\tvar uv3 = new THREE.Vector2( uv2.u, 0 );\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\t// bottom cap\n\
\n\
\tif ( openEnded === false && radiusBottom > 0 ) {\n\
\n\
\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\n\
\n\
\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\
\n\
\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\
\t\t\tvar v2 = vertices[ y ][ x ];\n\
\t\t\tvar v3 = this.vertices.length - 1;\n\
\n\
\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\n\
\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\n\
\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\n\
\n\
\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\n\
\t\t\tvar uv2 = uvs[ y ][ x ].clone();\n\
\t\t\tvar uv3 = new THREE.Vector2( uv2.u, 1 );\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tthis.computeCentroids();\n\
\tthis.computeFaceNormals();\n\
\n\
}\n\
\n\
THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author zz85 / http://www.lab4games.net/zz85/blog\n\
 *\n\
 * Creates extruded geometry from a path shape.\n\
 *\n\
 * parameters = {\n\
 *\n\
 *  size: <float>, // size of the text\n\
 *  height: <float>, // thickness to extrude text\n\
 *  curveSegments: <int>, // number of points on the curves\n\
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\n\
 *  amount: <int>, // Amount\n\
 *\n\
 *  bevelEnabled: <bool>, // turn on bevel\n\
 *  bevelThickness: <float>, // how deep into text bevel goes\n\
 *  bevelSize: <float>, // how far from text outline is bevel\n\
 *  bevelSegments: <int>, // number of bevel layers\n\
 *\n\
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n\
 *\n\
 *  material: <int> // material index for front and back faces\n\
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces\n\
 *  uvGenerator: <Object> // object that provides UV generator functions\n\
 *\n\
 * }\n\
 **/\n\
\n\
THREE.ExtrudeGeometry = function ( shapes, options ) {\n\
\n\
\tif ( typeof( shapes ) === \"undefined\" ) {\n\
\t\tshapes = [];\n\
\t\treturn;\n\
\t}\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tshapes = shapes instanceof Array ? shapes : [ shapes ];\n\
\n\
\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\n\
\n\
\tthis.addShapeList( shapes, options );\n\
\n\
\tthis.computeCentroids();\n\
\tthis.computeFaceNormals();\n\
\n\
\t// can't really use automatic vertex normals\n\
\t// as then front and back sides get smoothed too\n\
\t// should do separate smoothing just for sides\n\
\n\
\t//this.computeVertexNormals();\n\
\n\
\t//console.log( \"took\", ( Date.now() - startTime ) );\n\
\n\
};\n\
\n\
THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\
\tvar sl = shapes.length;\n\
\n\
\tfor ( var s = 0; s < sl; s ++ ) {\n\
\t\tvar shape = shapes[ s ];\n\
\t\tthis.addShape( shape, options );\n\
\t}\n\
};\n\
\n\
THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\
\n\
\tvar amount = options.amount !== undefined ? options.amount : 100;\n\
\n\
\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\
\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\
\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\
\n\
\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\
\n\
\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\
\n\
\tvar steps = options.steps !== undefined ? options.steps : 1;\n\
\n\
\tvar extrudePath = options.extrudePath;\n\
\tvar extrudePts, extrudeByPath = false;\n\
\n\
\tvar material = options.material;\n\
\tvar extrudeMaterial = options.extrudeMaterial;\n\
\n\
\t// Use default WorldUVGenerator if no UV generators are specified.\n\
\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\
\n\
\tvar shapebb = this.shapebb;\n\
\t//shapebb = shape.getBoundingBox();\n\
\n\
\n\
\n\
\tvar splineTube, binormal, normal, position2;\n\
\tif ( extrudePath ) {\n\
\n\
\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\
\n\
\t\textrudeByPath = true;\n\
\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\
\n\
\t\t// SETUP TNB variables\n\
\n\
\t\t// Reuse TNB from TubeGeomtry for now.\n\
\t\t// TODO1 - have a .isClosed in spline?\n\
\n\
\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\n\
\n\
\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\
\n\
\t\tbinormal = new THREE.Vector3();\n\
\t\tnormal = new THREE.Vector3();\n\
\t\tposition2 = new THREE.Vector3();\n\
\n\
\t}\n\
\n\
\t// Safeguards if bevels are not enabled\n\
\n\
\tif ( ! bevelEnabled ) {\n\
\n\
\t\tbevelSegments = 0;\n\
\t\tbevelThickness = 0;\n\
\t\tbevelSize = 0;\n\
\n\
\t}\n\
\n\
\t// Variables initalization\n\
\n\
\tvar ahole, h, hl; // looping of holes\n\
\tvar scope = this;\n\
\tvar bevelPoints = [];\n\
\n\
\tvar shapesOffset = this.vertices.length;\n\
\n\
\tvar shapePoints = shape.extractPoints( curveSegments );\n\
\n\
\tvar vertices = shapePoints.shape;\n\
\tvar holes = shapePoints.holes;\n\
\n\
\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;\n\
\n\
\tif ( reverse ) {\n\
\n\
\t\tvertices = vertices.reverse();\n\
\n\
\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\
\n\
\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\
\n\
\t\t\tahole = holes[ h ];\n\
\n\
\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\n\
\n\
\t\t\t\tholes[ h ] = ahole.reverse();\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\
\n\
\t}\n\
\n\
\n\
\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\n\
\n\
\t/* Vertices */\n\
\n\
\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\
\n\
\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\n\
\n\
\t\tahole = holes[ h ];\n\
\n\
\t\tvertices = vertices.concat( ahole );\n\
\n\
\t}\n\
\n\
\n\
\tfunction scalePt2 ( pt, vec, size ) {\n\
\n\
\t\tif ( !vec ) console.log( \"die\" );\n\
\n\
\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\
\n\
\t}\n\
\n\
\tvar b, bs, t, z,\n\
\t\tvert, vlen = vertices.length,\n\
\t\tface, flen = faces.length,\n\
\t\tcont, clen = contour.length;\n\
\n\
\n\
\t// Find directions for point movement\n\
\n\
\tvar RAD_TO_DEGREES = 180 / Math.PI;\n\
\n\
\n\
\tfunction getBevelVec( pt_i, pt_j, pt_k ) {\n\
\n\
\t\t// Algorithm 2\n\
\n\
\t\treturn getBevelVec2( pt_i, pt_j, pt_k );\n\
\n\
\t}\n\
\n\
\tfunction getBevelVec1( pt_i, pt_j, pt_k ) {\n\
\n\
\t\tvar anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );\n\
\t\tvar angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );\n\
\n\
\t\tif ( anglea > angleb ) {\n\
\n\
\t\t\tangleb += Math.PI * 2;\n\
\n\
\t\t}\n\
\n\
\t\tvar anglec = ( anglea + angleb ) / 2;\n\
\n\
\n\
\t\t//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);\n\
\n\
\t\tvar x = - Math.cos( anglec );\n\
\t\tvar y = - Math.sin( anglec );\n\
\n\
\t\tvar vec = new THREE.Vector2( x, y ); //.normalize();\n\
\n\
\t\treturn vec;\n\
\n\
\t}\n\
\n\
\tfunction getBevelVec2( pt_i, pt_j, pt_k ) {\n\
\n\
\t\tvar a = THREE.ExtrudeGeometry.__v1,\n\
\t\t\tb = THREE.ExtrudeGeometry.__v2,\n\
\t\t\tv_hat = THREE.ExtrudeGeometry.__v3,\n\
\t\t\tw_hat = THREE.ExtrudeGeometry.__v4,\n\
\t\t\tp = THREE.ExtrudeGeometry.__v5,\n\
\t\t\tq = THREE.ExtrudeGeometry.__v6,\n\
\t\t\tv, w,\n\
\t\t\tv_dot_w_hat, q_sub_p_dot_w_hat,\n\
\t\t\ts, intersection;\n\
\n\
\t\t// good reading for line-line intersection\n\
\t\t// http://sputsoft.com/blog/2010/03/line-line-intersection.html\n\
\n\
\t\t// define a as vector j->i\n\
\t\t// define b as vectot k->i\n\
\n\
\t\ta.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );\n\
\t\tb.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );\n\
\n\
\t\t// get unit vectors\n\
\n\
\t\tv = a.normalize();\n\
\t\tw = b.normalize();\n\
\n\
\t\t// normals from pt i\n\
\n\
\t\tv_hat.set( -v.y, v.x );\n\
\t\tw_hat.set( w.y, -w.x );\n\
\n\
\t\t// pts from i\n\
\n\
\t\tp.copy( pt_i ).add( v_hat );\n\
\t\tq.copy( pt_i ).add( w_hat );\n\
\n\
\t\tif ( p.equals( q ) ) {\n\
\n\
\t\t\t//console.log(\"Warning: lines are straight\");\n\
\t\t\treturn w_hat.clone();\n\
\n\
\t\t}\n\
\n\
\t\t// Points from j, k. helps prevents points cross overover most of the time\n\
\n\
\t\tp.copy( pt_j ).add( v_hat );\n\
\t\tq.copy( pt_k ).add( w_hat );\n\
\n\
\t\tv_dot_w_hat = v.dot( w_hat );\n\
\t\tq_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );\n\
\n\
\t\t// We should not reach these conditions\n\
\n\
\t\tif ( v_dot_w_hat === 0 ) {\n\
\n\
\t\t\tconsole.log( \"Either infinite or no solutions!\" );\n\
\n\
\t\t\tif ( q_sub_p_dot_w_hat === 0 ) {\n\
\n\
\t\t\t\tconsole.log( \"Its finite solutions.\" );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tconsole.log( \"Too bad, no solutions.\" );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\ts = q_sub_p_dot_w_hat / v_dot_w_hat;\n\
\n\
\t\tif ( s < 0 ) {\n\
\n\
\t\t\t// in case of emergecy, revert to algorithm 1.\n\
\n\
\t\t\treturn getBevelVec1( pt_i, pt_j, pt_k );\n\
\n\
\t\t}\n\
\n\
\t\tintersection = v.multiplyScalar( s ).add( p );\n\
\n\
\t\treturn intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly\n\
\n\
\t}\n\
\n\
\tvar contourMovements = [];\n\
\n\
\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\
\n\
\t\tif ( j === il ) j = 0;\n\
\t\tif ( k === il ) k = 0;\n\
\n\
\t\t//  (j)---(i)---(k)\n\
\t\t// console.log('i,j,k', i, j , k)\n\
\n\
\t\tvar pt_i = contour[ i ];\n\
\t\tvar pt_j = contour[ j ];\n\
\t\tvar pt_k = contour[ k ];\n\
\n\
\t\tcontourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\
\n\
\t}\n\
\n\
\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\
\n\
\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\
\n\
\t\tahole = holes[ h ];\n\
\n\
\t\toneHoleMovements = [];\n\
\n\
\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\
\n\
\t\t\tif ( j === il ) j = 0;\n\
\t\t\tif ( k === il ) k = 0;\n\
\n\
\t\t\t//  (j)---(i)---(k)\n\
\t\t\toneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\
\n\
\t\t}\n\
\n\
\t\tholesMovements.push( oneHoleMovements );\n\
\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\
\n\
\t}\n\
\n\
\n\
\t// Loop bevelSegments, 1 for the front, 1 for the back\n\
\n\
\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\
\t//for ( b = bevelSegments; b > 0; b -- ) {\n\
\n\
\t\tt = b / bevelSegments;\n\
\t\tz = bevelThickness * ( 1 - t );\n\
\n\
\t\t//z = bevelThickness * t;\n\
\t\tbs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved\n\
\t\t//bs = bevelSize * t ; // linear\n\
\n\
\t\t// contract shape\n\
\n\
\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\
\n\
\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\
\t\t\t//vert = scalePt( contour[ i ], contourCentroid, bs, false );\n\
\t\t\tv( vert.x, vert.y,  - z );\n\
\n\
\t\t}\n\
\n\
\t\t// expand holes\n\
\n\
\t\tfor ( h = 0, hl = holes.length; h < hl; h++ ) {\n\
\n\
\t\t\tahole = holes[ h ];\n\
\t\t\toneHoleMovements = holesMovements[ h ];\n\
\n\
\t\t\tfor ( i = 0, il = ahole.length; i < il; i++ ) {\n\
\n\
\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\
\t\t\t\t//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );\n\
\n\
\t\t\t\tv( vert.x, vert.y,  -z );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tbs = bevelSize;\n\
\n\
\t// Back facing vertices\n\
\n\
\tfor ( i = 0; i < vlen; i ++ ) {\n\
\n\
\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\
\n\
\t\tif ( !extrudeByPath ) {\n\
\n\
\t\t\tv( vert.x, vert.y, 0 );\n\
\n\
\t\t} else {\n\
\n\
\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\
\n\
\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\n\
\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\n\
\n\
\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\n\
\n\
\t\t\tv( position2.x, position2.y, position2.z );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\t// Add stepped vertices...\n\
\t// Including front facing vertices\n\
\n\
\tvar s;\n\
\n\
\tfor ( s = 1; s <= steps; s ++ ) {\n\
\n\
\t\tfor ( i = 0; i < vlen; i ++ ) {\n\
\n\
\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\
\n\
\t\t\tif ( !extrudeByPath ) {\n\
\n\
\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\
\n\
\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\n\
\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\n\
\n\
\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\n\
\n\
\t\t\t\tv( position2.x, position2.y, position2.z );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\n\
\t// Add bevel segments planes\n\
\n\
\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\
\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\
\n\
\t\tt = b / bevelSegments;\n\
\t\tz = bevelThickness * ( 1 - t );\n\
\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\
\t\tbs = bevelSize * Math.sin ( t * Math.PI/2 ) ;\n\
\n\
\t\t// contract shape\n\
\n\
\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\
\n\
\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\
\t\t\tv( vert.x, vert.y,  amount + z );\n\
\n\
\t\t}\n\
\n\
\t\t// expand holes\n\
\n\
\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\
\n\
\t\t\tahole = holes[ h ];\n\
\t\t\toneHoleMovements = holesMovements[ h ];\n\
\n\
\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\
\n\
\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\
\n\
\t\t\t\tif ( !extrudeByPath ) {\n\
\n\
\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\t/* Faces */\n\
\n\
\t// Top and bottom faces\n\
\n\
\tbuildLidFaces();\n\
\n\
\t// Sides faces\n\
\n\
\tbuildSideFaces();\n\
\n\
\n\
\t/////  Internal functions\n\
\n\
\tfunction buildLidFaces() {\n\
\n\
\t\tif ( bevelEnabled ) {\n\
\n\
\t\t\tvar layer = 0 ; // steps + 1\n\
\t\t\tvar offset = vlen * layer;\n\
\n\
\t\t\t// Bottom faces\n\
\n\
\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\
\n\
\t\t\t\tface = faces[ i ];\n\
\t\t\t\tf3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tlayer = steps + bevelSegments * 2;\n\
\t\t\toffset = vlen * layer;\n\
\n\
\t\t\t// Top faces\n\
\n\
\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\
\n\
\t\t\t\tface = faces[ i ];\n\
\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\t// Bottom faces\n\
\n\
\t\t\tfor ( i = 0; i < flen; i++ ) {\n\
\n\
\t\t\t\tface = faces[ i ];\n\
\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ], true );\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// Top faces\n\
\n\
\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\
\n\
\t\t\t\tface = faces[ i ];\n\
\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );\n\
\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t}\n\
\n\
\t// Create faces for the z-sides of the shape\n\
\n\
\tfunction buildSideFaces() {\n\
\n\
\t\tvar layeroffset = 0;\n\
\t\tsidewalls( contour, layeroffset );\n\
\t\tlayeroffset += contour.length;\n\
\n\
\t\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\n\
\n\
\t\t\tahole = holes[ h ];\n\
\t\t\tsidewalls( ahole, layeroffset );\n\
\n\
\t\t\t//, true\n\
\t\t\tlayeroffset += ahole.length;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfunction sidewalls( contour, layeroffset ) {\n\
\n\
\t\tvar j, k;\n\
\t\ti = contour.length;\n\
\n\
\t\twhile ( --i >= 0 ) {\n\
\n\
\t\t\tj = i;\n\
\t\t\tk = i - 1;\n\
\t\t\tif ( k < 0 ) k = contour.length - 1;\n\
\n\
\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\
\n\
\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\
\n\
\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\
\n\
\t\t\t\tvar slen1 = vlen * s;\n\
\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\
\n\
\t\t\t\tvar a = layeroffset + j + slen1,\n\
\t\t\t\t\tb = layeroffset + k + slen1,\n\
\t\t\t\t\tc = layeroffset + k + slen2,\n\
\t\t\t\t\td = layeroffset + j + slen2;\n\
\n\
\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\
\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t}\n\
\n\
\n\
\tfunction v( x, y, z ) {\n\
\n\
\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\
\n\
\t}\n\
\n\
\tfunction f3( a, b, c, isBottom ) {\n\
\n\
\t\ta += shapesOffset;\n\
\t\tb += shapesOffset;\n\
\t\tc += shapesOffset;\n\
\n\
\t\t// normal, color, material\n\
\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\
\n\
\t\tvar uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );\n\
\n\
 \t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\
\n\
\t}\n\
\n\
\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\
\n\
\t\ta += shapesOffset;\n\
\t\tb += shapesOffset;\n\
\t\tc += shapesOffset;\n\
\t\td += shapesOffset;\n\
\n\
 \t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );\n\
 \t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );\n\
\n\
 \t\tvar uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,\n\
 \t\t                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );\n\
\n\
 \t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\
 \t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.ExtrudeGeometry.WorldUVGenerator = {\n\
\n\
\tgenerateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\n\
\t\tvar ax = geometry.vertices[ indexA ].x,\n\
\t\t\tay = geometry.vertices[ indexA ].y,\n\
\n\
\t\t\tbx = geometry.vertices[ indexB ].x,\n\
\t\t\tby = geometry.vertices[ indexB ].y,\n\
\n\
\t\t\tcx = geometry.vertices[ indexC ].x,\n\
\t\t\tcy = geometry.vertices[ indexC ].y;\n\
\n\
\t\treturn [\n\
\t\t\tnew THREE.Vector2( ax, ay ),\n\
\t\t\tnew THREE.Vector2( bx, by ),\n\
\t\t\tnew THREE.Vector2( cx, cy )\n\
\t\t];\n\
\n\
\t},\n\
\n\
\tgenerateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\n\
\n\
\t\treturn this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );\n\
\n\
\t},\n\
\n\
\tgenerateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,\n\
\t                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,\n\
\t                              contourIndex1, contourIndex2 ) {\n\
\n\
\t\tvar ax = geometry.vertices[ indexA ].x,\n\
\t\t\tay = geometry.vertices[ indexA ].y,\n\
\t\t\taz = geometry.vertices[ indexA ].z,\n\
\n\
\t\t\tbx = geometry.vertices[ indexB ].x,\n\
\t\t\tby = geometry.vertices[ indexB ].y,\n\
\t\t\tbz = geometry.vertices[ indexB ].z,\n\
\n\
\t\t\tcx = geometry.vertices[ indexC ].x,\n\
\t\t\tcy = geometry.vertices[ indexC ].y,\n\
\t\t\tcz = geometry.vertices[ indexC ].z,\n\
\n\
\t\t\tdx = geometry.vertices[ indexD ].x,\n\
\t\t\tdy = geometry.vertices[ indexD ].y,\n\
\t\t\tdz = geometry.vertices[ indexD ].z;\n\
\n\
\t\tif ( Math.abs( ay - by ) < 0.01 ) {\n\
\t\t\treturn [\n\
\t\t\t\tnew THREE.Vector2( ax, 1 - az ),\n\
\t\t\t\tnew THREE.Vector2( bx, 1 - bz ),\n\
\t\t\t\tnew THREE.Vector2( cx, 1 - cz ),\n\
\t\t\t\tnew THREE.Vector2( dx, 1 - dz )\n\
\t\t\t];\n\
\t\t} else {\n\
\t\t\treturn [\n\
\t\t\t\tnew THREE.Vector2( ay, 1 - az ),\n\
\t\t\t\tnew THREE.Vector2( by, 1 - bz ),\n\
\t\t\t\tnew THREE.Vector2( cy, 1 - cz ),\n\
\t\t\t\tnew THREE.Vector2( dy, 1 - dz )\n\
\t\t\t];\n\
\t\t}\n\
\t}\n\
};\n\
\n\
THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();\n\
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();\n\
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();\n\
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();\n\
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();\n\
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();\n\
\n\
/**\n\
 * @author jonobr1 / http://jonobr1.com\n\
 *\n\
 * Creates a one-sided polygonal geometry from a path shape. Similar to\n\
 * ExtrudeGeometry.\n\
 *\n\
 * parameters = {\n\
 *\n\
 *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\
 *\n\
 *\tmaterial: <int> // material index for front and back faces\n\
 *\tuvGenerator: <Object> // object that provides UV generator functions\n\
 *\n\
 * }\n\
 **/\n\
\n\
THREE.ShapeGeometry = function ( shapes, options ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\n\
\n\
\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\n\
\n\
\tthis.addShapeList( shapes, options );\n\
\n\
\tthis.computeCentroids();\n\
\tthis.computeFaceNormals();\n\
\n\
};\n\
\n\
THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * Add an array of shapes to THREE.ShapeGeometry.\n\
 */\n\
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\
\n\
\tfor ( var i = 0, l = shapes.length; i < l; i++ ) {\n\
\n\
\t\tthis.addShape( shapes[ i ], options );\n\
\n\
\t}\n\
\n\
\treturn this;\n\
\n\
};\n\
\n\
/**\n\
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\
 */\n\
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\
\n\
\tif ( options === undefined ) options = {};\n\
\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\
\n\
\tvar material = options.material;\n\
\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\
\n\
\tvar shapebb = this.shapebb;\n\
\n\
\t//\n\
\n\
\tvar i, l, hole, s;\n\
\n\
\tvar shapesOffset = this.vertices.length;\n\
\tvar shapePoints = shape.extractPoints( curveSegments );\n\
\n\
\tvar vertices = shapePoints.shape;\n\
\tvar holes = shapePoints.holes;\n\
\n\
\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices );\n\
\n\
\tif ( reverse ) {\n\
\n\
\t\tvertices = vertices.reverse();\n\
\n\
\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\
\n\
\t\tfor ( i = 0, l = holes.length; i < l; i++ ) {\n\
\n\
\t\t\thole = holes[ i ];\n\
\n\
\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\n\
\n\
\t\t\t\tholes[ i ] = hole.reverse();\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\treverse = false;\n\
\n\
\t}\n\
\n\
\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\n\
\n\
\t// Vertices\n\
\n\
\tvar contour = vertices;\n\
\n\
\tfor ( i = 0, l = holes.length; i < l; i++ ) {\n\
\n\
\t\thole = holes[ i ];\n\
\t\tvertices = vertices.concat( hole );\n\
\n\
\t}\n\
\n\
\t//\n\
\n\
\tvar vert, vlen = vertices.length;\n\
\tvar face, flen = faces.length;\n\
\tvar cont, clen = contour.length;\n\
\n\
\tfor ( i = 0; i < vlen; i++ ) {\n\
\n\
\t\tvert = vertices[ i ];\n\
\n\
\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\
\n\
\t}\n\
\n\
\tfor ( i = 0; i < flen; i++ ) {\n\
\n\
\t\tface = faces[ i ];\n\
\n\
\t\tvar a = face[ 0 ] + shapesOffset;\n\
\t\tvar b = face[ 1 ] + shapesOffset;\n\
\t\tvar c = face[ 2 ] + shapesOffset;\n\
\n\
\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\
\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author astrodud / http://astrodud.isgreat.org/\n\
 * @author zz85 / https://github.com/zz85\n\
 * @author bhouston / http://exocortex.com\n\
 */\n\
\n\
// points - to create a closed torus, one must use a set of points \n\
//    like so: [ a, b, c, d, a ], see first is the same as last.\n\
// segments - the number of circumference segments to create\n\
// phiStart - the starting radian\n\
// phiLength - the radian (0 to 2*PI) range of the lathed section\n\
//    2*pi is a closed lathe, less than 2PI is a portion.\n\
THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tsegments = segments || 12;\n\
\tphiStart = phiStart || 0;\n\
\tphiLength = phiLength || 2 * Math.PI;\n\
\n\
\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\
\tvar inverseSegments = 1.0 / segments;\n\
\n\
\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\n\
\n\
\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\
\n\
\t\tvar c = Math.cos( phi ),\n\
\t\t\ts = Math.sin( phi );\n\
\n\
\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\n\
\n\
\t\t\tvar pt = points[ j ];\n\
\n\
\t\t\tvar vertex = new THREE.Vector3();\n\
\n\
\t\t\tvertex.x = c * pt.x - s * pt.y;\n\
\t\t\tvertex.y = s * pt.x + c * pt.y;\n\
\t\t\tvertex.z = pt.z;\n\
\n\
\t\t\tthis.vertices.push( vertex );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tvar np = points.length;\n\
\n\
\tfor ( var i = 0, il = segments; i < il; i ++ ) {\n\
\n\
\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\n\
\n\
\t\t\tvar base = j + np * i;\n\
\t\t\tvar a = base;\n\
\t\t\tvar b = base + np;\n\
\t\t\tvar c = base + 1 + np;\n\
\t\t\tvar d = base + 1;\n\
\n\
\t\t\tvar u0 = i * inverseSegments;\n\
\t\t\tvar v0 = j * inversePointLength;\n\
\t\t\tvar u1 = u0 + inverseSegments;\n\
\t\t\tvar v1 = v0 + inversePointLength;\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\
\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [\n\
\n\
\t\t\t\tnew THREE.Vector2( u0, v0 ),\n\
\t\t\t\tnew THREE.Vector2( u1, v0 ),\n\
\t\t\t\tnew THREE.Vector2( u0, v1 )\n\
\n\
\t\t\t] );\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\
\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [\n\
\n\
\t\t\t\tnew THREE.Vector2( u1, v0 ),\n\
\t\t\t\tnew THREE.Vector2( u1, v1 ),\n\
\t\t\t\tnew THREE.Vector2( u0, v1 )\n\
\n\
\t\t\t] );\n\
\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tthis.mergeVertices();\n\
\tthis.computeCentroids();\n\
\tthis.computeFaceNormals();\n\
\tthis.computeVertexNormals();\n\
\n\
};\n\
\n\
THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\
 */\n\
\n\
THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tthis.width = width;\n\
\tthis.height = height;\n\
\n\
\tthis.widthSegments = widthSegments || 1;\n\
\tthis.heightSegments = heightSegments || 1;\n\
\n\
\tvar ix, iz;\n\
\tvar width_half = width / 2;\n\
\tvar height_half = height / 2;\n\
\n\
\tvar gridX = this.widthSegments;\n\
\tvar gridZ = this.heightSegments;\n\
\n\
\tvar gridX1 = gridX + 1;\n\
\tvar gridZ1 = gridZ + 1;\n\
\n\
\tvar segment_width = this.width / gridX;\n\
\tvar segment_height = this.height / gridZ;\n\
\n\
\tvar normal = new THREE.Vector3( 0, 0, 1 );\n\
\n\
\tfor ( iz = 0; iz < gridZ1; iz ++ ) {\n\
\n\
\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\
\n\
\t\t\tvar x = ix * segment_width - width_half;\n\
\t\t\tvar y = iz * segment_height - height_half;\n\
\n\
\t\t\tthis.vertices.push( new THREE.Vector3( x, - y, 0 ) );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfor ( iz = 0; iz < gridZ; iz ++ ) {\n\
\n\
\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\
\n\
\t\t\tvar a = ix + gridX1 * iz;\n\
\t\t\tvar b = ix + gridX1 * ( iz + 1 );\n\
\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iz + 1 );\n\
\t\t\tvar d = ( ix + 1 ) + gridX1 * iz;\n\
\n\
\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iz / gridZ );\n\
\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ );\n\
\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ );\n\
\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ );\n\
\n\
\t\t\tvar face = new THREE.Face3( a, b, d );\n\
\t\t\tface.normal.copy( normal );\n\
\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\
\n\
\t\t\tthis.faces.push( face );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\
\n\
\t\t\tface = new THREE.Face3( b, c, d );\n\
\t\t\tface.normal.copy( normal );\n\
\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\
\n\
\t\t\tthis.faces.push( face );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tthis.computeCentroids();\n\
\n\
};\n\
\n\
THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author Kaleb Murphy\n\
 */\n\
\n\
THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tinnerRadius = innerRadius || 0;\n\
\touterRadius = outerRadius || 50;\n\
\n\
\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\
\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\
\n\
\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\
\tphiSegments = phiSegments !== undefined ? Math.max( 3, phiSegments ) : 8;\n\
\n\
\tvar i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\
\n\
\tfor ( i = 0; i <= phiSegments; i ++ ) { // concentric circles inside ring\n\
\n\
\t\tfor ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle\n\
\n\
\t\t\tvar vertex = new THREE.Vector3();\n\
\t\t\tvar segment = thetaStart + o / thetaSegments * thetaLength;\n\
\n\
\t\t\tvertex.x = radius * Math.cos( segment );\n\
\t\t\tvertex.y = radius * Math.sin( segment );\n\
\n\
\t\t\tthis.vertices.push( vertex );\n\
\t\t\tuvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, - ( vertex.y / radius + 1 ) / 2 + 1 ) );\n\
\t\t}\n\
\n\
\t\tradius += radiusStep;\n\
\n\
\t}\n\
\n\
\tvar n = new THREE.Vector3( 0, 0, 1 );\n\
\n\
\tfor ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring\n\
\n\
\t\tvar thetaSegment = i * thetaSegments;\n\
\n\
\t\tfor ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle\n\
\n\
\t\t\tvar segment = o + thetaSegment;\n\
\n\
\t\t\tvar v1 = segment + i;\n\
\t\t\tvar v2 = segment + thetaSegments + i;\n\
\t\t\tvar v3 = segment + thetaSegments + 1 + i;\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n, n, n ] ) );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ], uvs[ v2 ], uvs[ v3 ] ]);\n\
\n\
\t\t\tv1 = segment + i;\n\
\t\t\tv2 = segment + thetaSegments + 1 + i;\n\
\t\t\tv3 = segment + 1 + i;\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n, n, n ] ) );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ], uvs[ v2 ], uvs[ v3 ] ]);\n\
\n\
\t\t}\n\
\t}\n\
\n\
\tthis.computeCentroids();\n\
\tthis.computeFaceNormals();\n\
\n\
\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\
\n\
};\n\
\n\
THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tthis.radius = radius = radius || 50;\n\
\n\
\tthis.widthSegments = widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\
\tthis.heightSegments = heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\
\n\
\tthis.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;\n\
\tthis.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\
\n\
\tthis.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;\n\
\tthis.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\
\n\
\tvar x, y, vertices = [], uvs = [];\n\
\n\
\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\
\n\
\t\tvar verticesRow = [];\n\
\t\tvar uvsRow = [];\n\
\n\
\t\tfor ( x = 0; x <= widthSegments; x ++ ) {\n\
\n\
\t\t\tvar u = x / widthSegments;\n\
\t\t\tvar v = y / heightSegments;\n\
\n\
\t\t\tvar vertex = new THREE.Vector3();\n\
\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\
\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\
\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\
\n\
\t\t\tthis.vertices.push( vertex );\n\
\n\
\t\t\tverticesRow.push( this.vertices.length - 1 );\n\
\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\n\
\n\
\t\t}\n\
\n\
\t\tvertices.push( verticesRow );\n\
\t\tuvs.push( uvsRow );\n\
\n\
\t}\n\
\n\
\tfor ( y = 0; y < this.heightSegments; y ++ ) {\n\
\n\
\t\tfor ( x = 0; x < this.widthSegments; x ++ ) {\n\
\n\
\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\
\t\t\tvar v2 = vertices[ y ][ x ];\n\
\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\
\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\
\n\
\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\n\
\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\n\
\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\n\
\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\n\
\n\
\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\n\
\t\t\tvar uv2 = uvs[ y ][ x ].clone();\n\
\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\n\
\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\n\
\n\
\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {\n\
\n\
\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\n\
\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\n\
\n\
\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {\n\
\n\
\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\
\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\n\
\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\n\
\n\
\t\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2, n3, n4 ] ) );\n\
\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tthis.computeCentroids();\n\
\tthis.computeFaceNormals();\n\
\n\
\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\
\n\
};\n\
\n\
THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author zz85 / http://www.lab4games.net/zz85/blog\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 * For creating 3D text geometry in three.js\n\
 *\n\
 * Text = 3D Text\n\
 *\n\
 * parameters = {\n\
 *  size: \t\t\t<float>, \t// size of the text\n\
 *  height: \t\t<float>, \t// thickness to extrude text\n\
 *  curveSegments: \t<int>,\t\t// number of points on the curves\n\
 *\n\
 *  font: \t\t\t<string>,\t\t// font name\n\
 *  weight: \t\t<string>,\t\t// font weight (normal, bold)\n\
 *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\n\
 *\n\
 *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\n\
 *  bevelThickness: <float>, \t\t// how deep into text bevel goes\n\
 *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\n\
 *  }\n\
 *\n\
 */\n\
\n\
/*\tUsage Examples\n\
\n\
\t// TextGeometry wrapper\n\
\n\
\tvar text3d = new TextGeometry( text, options );\n\
\n\
\t// Complete manner\n\
\n\
\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\n\
\tvar text3d = new ExtrudeGeometry( textShapes, options );\n\
\n\
*/\n\
\n\
\n\
THREE.TextGeometry = function ( text, parameters ) {\n\
\n\
\tparameters = parameters || {};\n\
\n\
\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\n\
\n\
\t// translate parameters to ExtrudeGeometry API\n\
\n\
\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\
\n\
\t// defaults\n\
\n\
\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\
\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\
\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\
\n\
\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\n\
\n\
};\n\
\n\
THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\n\
\n\
/**\n\
 * @author oosmoxiecode\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\
 */\n\
\n\
THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tvar scope = this;\n\
\n\
\tthis.radius = radius || 100;\n\
\tthis.tube = tube || 40;\n\
\tthis.radialSegments = radialSegments || 8;\n\
\tthis.tubularSegments = tubularSegments || 6;\n\
\tthis.arc = arc || Math.PI * 2;\n\
\n\
\tvar center = new THREE.Vector3(), uvs = [], normals = [];\n\
\n\
\tfor ( var j = 0; j <= this.radialSegments; j ++ ) {\n\
\n\
\t\tfor ( var i = 0; i <= this.tubularSegments; i ++ ) {\n\
\n\
\t\t\tvar u = i / this.tubularSegments * this.arc;\n\
\t\t\tvar v = j / this.radialSegments * Math.PI * 2;\n\
\n\
\t\t\tcenter.x = this.radius * Math.cos( u );\n\
\t\t\tcenter.y = this.radius * Math.sin( u );\n\
\n\
\t\t\tvar vertex = new THREE.Vector3();\n\
\t\t\tvertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );\n\
\t\t\tvertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );\n\
\t\t\tvertex.z = this.tube * Math.sin( v );\n\
\n\
\t\t\tthis.vertices.push( vertex );\n\
\n\
\t\t\tuvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );\n\
\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\n\
\n\
\t\t}\n\
\t}\n\
\n\
\n\
\tfor ( var j = 1; j <= this.radialSegments; j ++ ) {\n\
\n\
\t\tfor ( var i = 1; i <= this.tubularSegments; i ++ ) {\n\
\n\
\t\t\tvar a = ( this.tubularSegments + 1 ) * j + i - 1;\n\
\t\t\tvar b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\
\t\t\tvar c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;\n\
\t\t\tvar d = ( this.tubularSegments + 1 ) * j + i;\n\
\n\
\t\t\tvar face = new THREE.Face3( a, b, d, [ normals[ a ], normals[ b ], normals[ d ] ] );\n\
\t\t\tface.normal.add( normals[ a ] );\n\
\t\t\tface.normal.add( normals[ b ] );\n\
\t\t\tface.normal.add( normals[ d ] );\n\
\t\t\tface.normal.normalize();\n\
\n\
\t\t\tthis.faces.push( face );\n\
\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\n\
\n\
\t\t\tface = new THREE.Face3( b, c, d, [ normals[ b ], normals[ c ], normals[ d ] ] );\n\
\t\t\tface.normal.add( normals[ b ] );\n\
\t\t\tface.normal.add( normals[ c ] );\n\
\t\t\tface.normal.add( normals[ d ] );\n\
\t\t\tface.normal.normalize();\n\
\n\
\t\t\tthis.faces.push( face );\n\
\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tthis.computeCentroids();\n\
\n\
};\n\
\n\
THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author oosmoxiecode\n\
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n\
 */\n\
\n\
THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tvar scope = this;\n\
\n\
\tthis.radius = radius || 100;\n\
\tthis.tube = tube || 40;\n\
\tthis.radialSegments = radialSegments || 64;\n\
\tthis.tubularSegments = tubularSegments || 8;\n\
\tthis.p = p || 2;\n\
\tthis.q = q || 3;\n\
\tthis.heightScale = heightScale || 1;\n\
\tthis.grid = new Array( this.radialSegments );\n\
\n\
\tvar tang = new THREE.Vector3();\n\
\tvar n = new THREE.Vector3();\n\
\tvar bitan = new THREE.Vector3();\n\
\n\
\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\n\
\n\
\t\tthis.grid[ i ] = new Array( this.tubularSegments );\n\
\t\tvar u = i / this.radialSegments * 2 * this.p * Math.PI;\n\
\t\tvar p1 = getPos( u, this.q, this.p, this.radius, this.heightScale );\n\
\t\tvar p2 = getPos( u + 0.01, this.q, this.p, this.radius, this.heightScale );\n\
\t\ttang.subVectors( p2, p1 );\n\
\t\tn.addVectors( p2, p1 );\n\
\n\
\t\tbitan.crossVectors( tang, n );\n\
\t\tn.crossVectors( bitan, tang );\n\
\t\tbitan.normalize();\n\
\t\tn.normalize();\n\
\n\
\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\n\
\n\
\t\t\tvar v = j / this.tubularSegments * 2 * Math.PI;\n\
\t\t\tvar cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\
\t\t\tvar cy = this.tube * Math.sin( v );\n\
\n\
\t\t\tvar pos = new THREE.Vector3();\n\
\t\t\tpos.x = p1.x + cx * n.x + cy * bitan.x;\n\
\t\t\tpos.y = p1.y + cx * n.y + cy * bitan.y;\n\
\t\t\tpos.z = p1.z + cx * n.z + cy * bitan.z;\n\
\n\
\t\t\tthis.grid[ i ][ j ] = scope.vertices.push( pos ) - 1;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\n\
\n\
\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\n\
\n\
\t\t\tvar ip = ( i + 1 ) % this.radialSegments;\n\
\t\t\tvar jp = ( j + 1 ) % this.tubularSegments;\n\
\n\
\t\t\tvar a = this.grid[ i ][ j ];\n\
\t\t\tvar b = this.grid[ ip ][ j ];\n\
\t\t\tvar c = this.grid[ ip ][ jp ];\n\
\t\t\tvar d = this.grid[ i ][ jp ];\n\
\n\
\t\t\tvar uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );\n\
\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );\n\
\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );\n\
\t\t\tvar uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\
\n\
\t\t}\n\
\t}\n\
\n\
\tthis.computeCentroids();\n\
\tthis.computeFaceNormals();\n\
\tthis.computeVertexNormals();\n\
\n\
\tfunction getPos( u, in_q, in_p, radius, heightScale ) {\n\
\n\
\t\tvar cu = Math.cos( u );\n\
\t\tvar su = Math.sin( u );\n\
\t\tvar quOverP = in_q / in_p * u;\n\
\t\tvar cs = Math.cos( quOverP );\n\
\n\
\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\n\
\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\n\
\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\n\
\n\
\t\treturn new THREE.Vector3( tx, ty, tz );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author WestLangley / https://github.com/WestLangley\n\
 * @author zz85 / https://github.com/zz85\n\
 * @author miningold / https://github.com/miningold\n\
 *\n\
 * Modified from the TorusKnotGeometry by @oosmoxiecode\n\
 *\n\
 * Creates a tube which extrudes along a 3d spline\n\
 *\n\
 * Uses parallel transport frames as described in\n\
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\
 */\n\
\n\
THREE.TubeGeometry = function( path, segments, radius, radialSegments, closed ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tthis.path = path;\n\
\tthis.segments = segments || 64;\n\
\tthis.radius = radius || 1;\n\
\tthis.radialSegments = radialSegments || 8;\n\
\tthis.closed = closed || false;\n\
\n\
\tthis.grid = [];\n\
\n\
\tvar scope = this,\n\
\n\
\t\ttangent,\n\
\t\tnormal,\n\
\t\tbinormal,\n\
\n\
\t\tnumpoints = this.segments + 1,\n\
\n\
\t\tx, y, z,\n\
\t\ttx, ty, tz,\n\
\t\tu, v,\n\
\n\
\t\tcx, cy,\n\
\t\tpos, pos2 = new THREE.Vector3(),\n\
\t\ti, j,\n\
\t\tip, jp,\n\
\t\ta, b, c, d,\n\
\t\tuva, uvb, uvc, uvd;\n\
\n\
\tvar frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),\n\
\t\ttangents = frames.tangents,\n\
\t\tnormals = frames.normals,\n\
\t\tbinormals = frames.binormals;\n\
\n\
\t// proxy internals\n\
\tthis.tangents = tangents;\n\
\tthis.normals = normals;\n\
\tthis.binormals = binormals;\n\
\n\
\tfunction vert( x, y, z ) {\n\
\n\
\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\
\n\
\t}\n\
\n\
\n\
\t// consruct the grid\n\
\n\
\tfor ( i = 0; i < numpoints; i++ ) {\n\
\n\
\t\tthis.grid[ i ] = [];\n\
\n\
\t\tu = i / ( numpoints - 1 );\n\
\n\
\t\tpos = path.getPointAt( u );\n\
\n\
\t\ttangent = tangents[ i ];\n\
\t\tnormal = normals[ i ];\n\
\t\tbinormal = binormals[ i ];\n\
\n\
\t\tfor ( j = 0; j < this.radialSegments; j++ ) {\n\
\n\
\t\t\tv = j / this.radialSegments * 2 * Math.PI;\n\
\n\
\t\t\tcx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\
\t\t\tcy = this.radius * Math.sin( v );\n\
\n\
\t\t\tpos2.copy( pos );\n\
\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\
\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\
\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\
\n\
\t\t\tthis.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\
\n\
\t\t}\n\
\t}\n\
\n\
\n\
\t// construct the mesh\n\
\n\
\tfor ( i = 0; i < this.segments; i++ ) {\n\
\n\
\t\tfor ( j = 0; j < this.radialSegments; j++ ) {\n\
\n\
\t\t\tip = ( this.closed ) ? (i + 1) % this.segments : i + 1;\n\
\t\t\tjp = (j + 1) % this.radialSegments;\n\
\n\
\t\t\ta = this.grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\
\t\t\tb = this.grid[ ip ][ j ];\n\
\t\t\tc = this.grid[ ip ][ jp ];\n\
\t\t\td = this.grid[ i ][ jp ];\n\
\n\
\t\t\tuva = new THREE.Vector2( i / this.segments, j / this.radialSegments );\n\
\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radialSegments );\n\
\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radialSegments );\n\
\t\t\tuvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radialSegments );\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\
\n\
\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\
\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\
\n\
\t\t}\n\
\t}\n\
\n\
\tthis.computeCentroids();\n\
\tthis.computeFaceNormals();\n\
\tthis.computeVertexNormals();\n\
\n\
};\n\
\n\
THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
\n\
// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\n\
THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {\n\
\n\
\tvar\ttangent = new THREE.Vector3(),\n\
\t\tnormal = new THREE.Vector3(),\n\
\t\tbinormal = new THREE.Vector3(),\n\
\n\
\t\ttangents = [],\n\
\t\tnormals = [],\n\
\t\tbinormals = [],\n\
\n\
\t\tvec = new THREE.Vector3(),\n\
\t\tmat = new THREE.Matrix4(),\n\
\n\
\t\tnumpoints = segments + 1,\n\
\t\ttheta,\n\
\t\tepsilon = 0.0001,\n\
\t\tsmallest,\n\
\n\
\t\ttx, ty, tz,\n\
\t\ti, u, v;\n\
\n\
\n\
\t// expose internals\n\
\tthis.tangents = tangents;\n\
\tthis.normals = normals;\n\
\tthis.binormals = binormals;\n\
\n\
\t// compute the tangent vectors for each segment on the path\n\
\n\
\tfor ( i = 0; i < numpoints; i++ ) {\n\
\n\
\t\tu = i / ( numpoints - 1 );\n\
\n\
\t\ttangents[ i ] = path.getTangentAt( u );\n\
\t\ttangents[ i ].normalize();\n\
\n\
\t}\n\
\n\
\tinitialNormal3();\n\
\n\
\tfunction initialNormal1(lastBinormal) {\n\
\t\t// fixed start binormal. Has dangers of 0 vectors\n\
\t\tnormals[ 0 ] = new THREE.Vector3();\n\
\t\tbinormals[ 0 ] = new THREE.Vector3();\n\
\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\
\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\
\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\
\t}\n\
\n\
\tfunction initialNormal2() {\n\
\n\
\t\t// This uses the Frenet-Serret formula for deriving binormal\n\
\t\tvar t2 = path.getTangentAt( epsilon );\n\
\n\
\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\
\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\
\n\
\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\
\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\
\n\
\t}\n\
\n\
\tfunction initialNormal3() {\n\
\t\t// select an initial normal vector perpenicular to the first tangent vector,\n\
\t\t// and in the direction of the smallest tangent xyz component\n\
\n\
\t\tnormals[ 0 ] = new THREE.Vector3();\n\
\t\tbinormals[ 0 ] = new THREE.Vector3();\n\
\t\tsmallest = Number.MAX_VALUE;\n\
\t\ttx = Math.abs( tangents[ 0 ].x );\n\
\t\tty = Math.abs( tangents[ 0 ].y );\n\
\t\ttz = Math.abs( tangents[ 0 ].z );\n\
\n\
\t\tif ( tx <= smallest ) {\n\
\t\t\tsmallest = tx;\n\
\t\t\tnormal.set( 1, 0, 0 );\n\
\t\t}\n\
\n\
\t\tif ( ty <= smallest ) {\n\
\t\t\tsmallest = ty;\n\
\t\t\tnormal.set( 0, 1, 0 );\n\
\t\t}\n\
\n\
\t\tif ( tz <= smallest ) {\n\
\t\t\tnormal.set( 0, 0, 1 );\n\
\t\t}\n\
\n\
\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\
\n\
\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\
\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\
\t}\n\
\n\
\n\
\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\
\n\
\tfor ( i = 1; i < numpoints; i++ ) {\n\
\n\
\t\tnormals[ i ] = normals[ i-1 ].clone();\n\
\n\
\t\tbinormals[ i ] = binormals[ i-1 ].clone();\n\
\n\
\t\tvec.crossVectors( tangents[ i-1 ], tangents[ i ] );\n\
\n\
\t\tif ( vec.length() > epsilon ) {\n\
\n\
\t\t\tvec.normalize();\n\
\n\
\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors\n\
\n\
\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\
\n\
\t\t}\n\
\n\
\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\
\n\
\t}\n\
\n\
\n\
\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\
\n\
\tif ( closed ) {\n\
\n\
\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), -1, 1 ) );\n\
\t\ttheta /= ( numpoints - 1 );\n\
\n\
\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {\n\
\n\
\t\t\ttheta = -theta;\n\
\n\
\t\t}\n\
\n\
\t\tfor ( i = 1; i < numpoints; i++ ) {\n\
\n\
\t\t\t// twist a little...\n\
\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\
\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\
\n\
\t\t}\n\
\n\
\t}\n\
};\n\
\n\
/**\n\
 * @author clockworkgeek / https://github.com/clockworkgeek\n\
 * @author timothypratley / https://github.com/timothypratley\n\
 * @author WestLangley / http://github.com/WestLangley\n\
*/\n\
\n\
THREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tradius = radius || 1;\n\
\tdetail = detail || 0;\n\
\n\
\tvar that = this;\n\
\n\
\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\
\n\
\t\tprepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );\n\
\n\
\t}\n\
\n\
\tvar midpoints = [], p = this.vertices;\n\
\n\
\tvar f = [];\n\
\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\
\n\
\t\tvar v1 = p[ faces[ i ][ 0 ] ];\n\
\t\tvar v2 = p[ faces[ i ][ 1 ] ];\n\
\t\tvar v3 = p[ faces[ i ][ 2 ] ];\n\
\n\
\t\tf[ i ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\
\n\
\t}\n\
\n\
\tfor ( var i = 0, l = f.length; i < l; i ++ ) {\n\
\n\
\t\tsubdivide(f[ i ], detail);\n\
\n\
\t}\n\
\n\
\n\
\t// Handle case when face straddles the seam\n\
\n\
\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\
\n\
\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\
\n\
\t\tvar x0 = uvs[ 0 ].x;\n\
\t\tvar x1 = uvs[ 1 ].x;\n\
\t\tvar x2 = uvs[ 2 ].x;\n\
\n\
\t\tvar max = Math.max( x0, Math.max( x1, x2 ) );\n\
\t\tvar min = Math.min( x0, Math.min( x1, x2 ) );\n\
\n\
\t\tif ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary\n\
\n\
\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\
\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\
\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\n\
\t// Apply radius\n\
\n\
\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\
\n\
\t\tthis.vertices[ i ].multiplyScalar( radius );\n\
\n\
\t}\n\
\n\
\n\
\t// Merge vertices\n\
\n\
\tthis.mergeVertices();\n\
\n\
\tthis.computeCentroids();\n\
\n\
\tthis.computeFaceNormals();\n\
\n\
\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\
\n\
\n\
\t// Project vector onto sphere's surface\n\
\n\
\tfunction prepare( vector ) {\n\
\n\
\t\tvar vertex = vector.normalize().clone();\n\
\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\
\n\
\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\
\n\
\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\
\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\
\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\
\n\
\t\treturn vertex;\n\
\n\
\t}\n\
\n\
\n\
\t// Approximate a curved face with recursively sub-divided triangles.\n\
\n\
\tfunction make( v1, v2, v3 ) {\n\
\n\
\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\
\t\tface.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\
\t\tthat.faces.push( face );\n\
\n\
\t\tvar azi = azimuth( face.centroid );\n\
\n\
\t\tthat.faceVertexUvs[ 0 ].push( [\n\
\t\t\tcorrectUV( v1.uv, v1, azi ),\n\
\t\t\tcorrectUV( v2.uv, v2, azi ),\n\
\t\t\tcorrectUV( v3.uv, v3, azi )\n\
\t\t] );\n\
\n\
\t}\n\
\n\
\n\
\t// Analytically subdivide a face to the required detail level.\n\
\n\
\tfunction subdivide(face, detail ) {\n\
\n\
\t\tvar cols = Math.pow(2, detail);\n\
\t\tvar cells = Math.pow(4, detail);\n\
\t\tvar a = prepare( that.vertices[ face.a ] );\n\
\t\tvar b = prepare( that.vertices[ face.b ] );\n\
\t\tvar c = prepare( that.vertices[ face.c ] );\n\
\t\tvar v = [];\n\
\n\
\t\t// Construct all of the vertices for this subdivision.\n\
\n\
\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\
\n\
\t\t\tv[ i ] = [];\n\
\n\
\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\
\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\
\t\t\tvar rows = cols - i;\n\
\n\
\t\t\tfor ( var j = 0; j <= rows; j ++) {\n\
\n\
\t\t\t\tif ( j == 0 && i == cols ) {\n\
\n\
\t\t\t\t\tv[ i ][ j ] = aj;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// Construct all of the faces.\n\
\n\
\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\
\n\
\t\t\tfor ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {\n\
\n\
\t\t\t\tvar k = Math.floor( j / 2 );\n\
\n\
\t\t\t\tif ( j % 2 == 0 ) {\n\
\n\
\t\t\t\t\tmake(\n\
\t\t\t\t\t\tv[ i ][ k + 1],\n\
\t\t\t\t\t\tv[ i + 1 ][ k ],\n\
\t\t\t\t\t\tv[ i ][ k ]\n\
\t\t\t\t\t);\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tmake(\n\
\t\t\t\t\t\tv[ i ][ k + 1 ],\n\
\t\t\t\t\t\tv[ i + 1][ k + 1],\n\
\t\t\t\t\t\tv[ i + 1 ][ k ]\n\
\t\t\t\t\t);\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\n\
\t// Angle around the Y axis, counter-clockwise when looking from above.\n\
\n\
\tfunction azimuth( vector ) {\n\
\n\
\t\treturn Math.atan2( vector.z, -vector.x );\n\
\n\
\t}\n\
\n\
\n\
\t// Angle above the XZ plane.\n\
\n\
\tfunction inclination( vector ) {\n\
\n\
\t\treturn Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\
\n\
\t}\n\
\n\
\n\
\t// Texture fixing helper. Spheres have some odd behaviours.\n\
\n\
\tfunction correctUV( uv, vector, azimuth ) {\n\
\n\
\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\
\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\
\t\treturn uv.clone();\n\
\n\
\t}\n\
\n\
\n\
};\n\
\n\
THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author timothypratley / https://github.com/timothypratley\n\
 */\n\
\n\
THREE.IcosahedronGeometry = function ( radius, detail ) {\n\
\n\
\tthis.radius = radius;\n\
\tthis.detail = detail;\n\
\n\
\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\
\n\
\tvar vertices = [\n\
\t\t[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],\n\
\t\t[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],\n\
\t\t[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]\n\
\t];\n\
\n\
\tvar faces = [\n\
\t\t[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],\n\
\t\t[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],\n\
\t\t[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],\n\
\t\t[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]\n\
\t];\n\
\n\
\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\
\n\
};\n\
\n\
THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author timothypratley / https://github.com/timothypratley\n\
 */\n\
\n\
THREE.OctahedronGeometry = function ( radius, detail ) {\n\
\n\
\tvar vertices = [\n\
\t\t[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]\n\
\t];\n\
\n\
\tvar faces = [\n\
\t\t[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]\n\
\t];\n\
\n\
\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\
};\n\
\n\
THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author timothypratley / https://github.com/timothypratley\n\
 */\n\
\n\
THREE.TetrahedronGeometry = function ( radius, detail ) {\n\
\n\
\tvar vertices = [\n\
\t\t[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]\n\
\t];\n\
\n\
\tvar faces = [\n\
\t\t[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]\n\
\t];\n\
\n\
\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\
\n\
};\n\
\n\
THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author zz85 / https://github.com/zz85\n\
 * Parametric Surfaces Geometry\n\
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\
 *\n\
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n\
 *\n\
 */\n\
\n\
THREE.ParametricGeometry = function ( func, slices, stacks ) {\n\
\n\
\tTHREE.Geometry.call( this );\n\
\n\
\tvar verts = this.vertices;\n\
\tvar faces = this.faces;\n\
\tvar uvs = this.faceVertexUvs[ 0 ];\n\
\n\
\tvar i, il, j, p;\n\
\tvar u, v;\n\
\n\
\tvar stackCount = stacks + 1;\n\
\tvar sliceCount = slices + 1;\n\
\n\
\tfor ( i = 0; i <= stacks; i ++ ) {\n\
\n\
\t\tv = i / stacks;\n\
\n\
\t\tfor ( j = 0; j <= slices; j ++ ) {\n\
\n\
\t\t\tu = j / slices;\n\
\n\
\t\t\tp = func( u, v );\n\
\t\t\tverts.push( p );\n\
\n\
\t\t}\n\
\t}\n\
\n\
\tvar a, b, c, d;\n\
\tvar uva, uvb, uvc, uvd;\n\
\n\
\tfor ( i = 0; i < stacks; i ++ ) {\n\
\n\
\t\tfor ( j = 0; j < slices; j ++ ) {\n\
\n\
\t\t\ta = i * sliceCount + j;\n\
\t\t\tb = i * sliceCount + j + 1;\n\
\t\t\tc = (i + 1) * sliceCount + j + 1;\n\
\t\t\td = (i + 1) * sliceCount + j;\n\
\n\
\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\
\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\
\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\
\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\
\n\
\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\
\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\
\n\
\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\
\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\t// console.log(this);\n\
\n\
\t// magic bullet\n\
\t// var diff = this.mergeVertices();\n\
\t// console.log('removed ', diff, ' vertices by merging');\n\
\n\
\tthis.computeCentroids();\n\
\tthis.computeFaceNormals();\n\
\tthis.computeVertexNormals();\n\
\n\
};\n\
\n\
THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\
\n\
/**\n\
 * @author sroucheray / http://sroucheray.org/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.AxisHelper = function ( size ) {\n\
\n\
\tsize = size || 1;\n\
\n\
\tvar geometry = new THREE.Geometry();\n\
\n\
\tgeometry.vertices.push(\n\
\t\tnew THREE.Vector3(), new THREE.Vector3( size, 0, 0 ),\n\
\t\tnew THREE.Vector3(), new THREE.Vector3( 0, size, 0 ),\n\
\t\tnew THREE.Vector3(), new THREE.Vector3( 0, 0, size )\n\
\t);\n\
\n\
\tgeometry.colors.push(\n\
\t\tnew THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),\n\
\t\tnew THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),\n\
\t\tnew THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )\n\
\t);\n\
\n\
\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\
\n\
\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\
\n\
};\n\
\n\
THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\n\
\n\
/**\n\
 * @author WestLangley / http://github.com/WestLangley\n\
 * @author zz85 / http://github.com/zz85\n\
 * @author bhouston / http://exocortex.com\n\
 *\n\
 * Creates an arrow for visualizing directions\n\
 *\n\
 * Parameters:\n\
 *  dir - Vector3\n\
 *  origin - Vector3\n\
 *  length - Number\n\
 *  hex - color in hex value\n\
 */\n\
\n\
THREE.ArrowHelper = function ( dir, origin, length, hex ) {\n\
\n\
\t// dir is assumed to be normalized\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tif ( hex === undefined ) hex = 0xffff00;\n\
\tif ( length === undefined ) length = 1;\n\
\n\
\tthis.position = origin;\n\
\n\
\tvar lineGeometry = new THREE.Geometry();\n\
\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );\n\
\tlineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );\n\
\n\
\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );\n\
\tthis.line.matrixAutoUpdate = false;\n\
\tthis.add( this.line );\n\
\n\
\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.05, 0.25, 5, 1 );\n\
\tconeGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0.875, 0 ) );\n\
\n\
\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );\n\
\tthis.cone.matrixAutoUpdate = false;\n\
\tthis.add( this.cone );\n\
\n\
\tthis.setDirection( dir );\n\
\tthis.setLength( length );\n\
\n\
};\n\
\n\
THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.ArrowHelper.prototype.setDirection = function () {\n\
\n\
\tvar axis = new THREE.Vector3();\n\
\tvar radians;\n\
\n\
\treturn function ( dir ) {\n\
\n\
\t\t// dir is assumed to be normalized\n\
\n\
\t\tif ( dir.y > 0.99999 ) {\n\
\n\
\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\
\n\
\t\t} else if ( dir.y < - 0.99999 ) {\n\
\n\
\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\
\n\
\t\t} else {\n\
\n\
\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\
\n\
\t\t\tradians = Math.acos( dir.y );\n\
\n\
\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
}();\n\
\n\
THREE.ArrowHelper.prototype.setLength = function ( length ) {\n\
\n\
\tthis.scale.set( length, length, length );\n\
\n\
};\n\
\n\
THREE.ArrowHelper.prototype.setColor = function ( hex ) {\n\
\n\
\tthis.line.material.color.setHex( hex );\n\
\tthis.cone.material.color.setHex( hex );\n\
\n\
};\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.BoxHelper = function ( object ) {\n\
\n\
\t//   5____4\n\
\t// 1/___0/|\n\
\t// | 6__|_7\n\
\t// 2/___3/\n\
\n\
\tvar vertices = [\n\
\t\tnew THREE.Vector3(   1,   1,   1 ),\n\
\t\tnew THREE.Vector3( - 1,   1,   1 ),\n\
\t\tnew THREE.Vector3( - 1, - 1,   1 ),\n\
\t\tnew THREE.Vector3(   1, - 1,   1 ),\n\
\n\
\t\tnew THREE.Vector3(   1,   1, - 1 ),\n\
\t\tnew THREE.Vector3( - 1,   1, - 1 ),\n\
\t\tnew THREE.Vector3( - 1, - 1, - 1 ),\n\
\t\tnew THREE.Vector3(   1, - 1, - 1 )\n\
\t];\n\
\n\
\tthis.vertices = vertices;\n\
\n\
\t// TODO: Wouldn't be nice if Line had .segments?\n\
\n\
\tvar geometry = new THREE.Geometry();\n\
\tgeometry.vertices.push(\n\
\t\tvertices[ 0 ], vertices[ 1 ],\n\
\t\tvertices[ 1 ], vertices[ 2 ],\n\
\t\tvertices[ 2 ], vertices[ 3 ],\n\
\t\tvertices[ 3 ], vertices[ 0 ],\n\
\n\
\t\tvertices[ 4 ], vertices[ 5 ],\n\
\t\tvertices[ 5 ], vertices[ 6 ],\n\
\t\tvertices[ 6 ], vertices[ 7 ],\n\
\t\tvertices[ 7 ], vertices[ 4 ],\n\
\n\
\t\tvertices[ 0 ], vertices[ 4 ],\n\
\t\tvertices[ 1 ], vertices[ 5 ],\n\
\t\tvertices[ 2 ], vertices[ 6 ],\n\
\t\tvertices[ 3 ], vertices[ 7 ]\n\
\t);\n\
\n\
\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );\n\
\n\
\tif ( object !== undefined ) {\n\
\n\
\t\tthis.update( object );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );\n\
\n\
THREE.BoxHelper.prototype.update = function ( object ) {\n\
\n\
\tvar geometry = object.geometry;\n\
\n\
\tif ( geometry.boundingBox === null ) {\n\
\n\
\t\tgeometry.computeBoundingBox();\n\
\n\
\t}\n\
\n\
\tvar min = geometry.boundingBox.min;\n\
\tvar max = geometry.boundingBox.max;\n\
\tvar vertices = this.vertices;\n\
\n\
\tvertices[ 0 ].set( max.x, max.y, max.z );\n\
\tvertices[ 1 ].set( min.x, max.y, max.z );\n\
\tvertices[ 2 ].set( min.x, min.y, max.z );\n\
\tvertices[ 3 ].set( max.x, min.y, max.z );\n\
\tvertices[ 4 ].set( max.x, max.y, min.z );\n\
\tvertices[ 5 ].set( min.x, max.y, min.z );\n\
\tvertices[ 6 ].set( min.x, min.y, min.z );\n\
\tvertices[ 7 ].set( max.x, min.y, min.z );\n\
\n\
\tthis.geometry.computeBoundingSphere();\n\
\tthis.geometry.verticesNeedUpdate = true;\n\
\n\
\tthis.matrixAutoUpdate = false;\n\
\tthis.matrixWorld = object.matrixWorld;\n\
\n\
};\n\
\n\
/**\n\
 * @author WestLangley / http://github.com/WestLangley\n\
 */\n\
\n\
// a helper to show the world-axis-aligned bounding box for an object\n\
\n\
THREE.BoundingBoxHelper = function ( object, hex ) {\n\
\n\
\tvar color = hex || 0x888888;\n\
\n\
\tthis.object = object;\n\
\n\
\tthis.box = new THREE.Box3();\n\
\n\
\tTHREE.Mesh.call( this, new THREE.CubeGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\
\n\
};\n\
\n\
THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\n\
\n\
THREE.BoundingBoxHelper.prototype.update = function () {\n\
\n\
\tthis.box.setFromObject( this.object );\n\
\n\
\tthis.box.size( this.scale );\n\
\n\
\tthis.box.center( this.position );\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 *\t- shows frustum, line of sight and up of the camera\n\
 *\t- suitable for fast updates\n\
 * \t- based on frustum visualization in lightgl.js shadowmap example\n\
 *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\
 */\n\
\n\
THREE.CameraHelper = function ( camera ) {\n\
\n\
\tvar geometry = new THREE.Geometry();\n\
\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\
\n\
\tvar pointMap = {};\n\
\n\
\t// colors\n\
\n\
\tvar hexFrustum = 0xffaa00;\n\
\tvar hexCone = 0xff0000;\n\
\tvar hexUp = 0x00aaff;\n\
\tvar hexTarget = 0xffffff;\n\
\tvar hexCross = 0x333333;\n\
\n\
\t// near\n\
\n\
\taddLine( \"n1\", \"n2\", hexFrustum );\n\
\taddLine( \"n2\", \"n4\", hexFrustum );\n\
\taddLine( \"n4\", \"n3\", hexFrustum );\n\
\taddLine( \"n3\", \"n1\", hexFrustum );\n\
\n\
\t// far\n\
\n\
\taddLine( \"f1\", \"f2\", hexFrustum );\n\
\taddLine( \"f2\", \"f4\", hexFrustum );\n\
\taddLine( \"f4\", \"f3\", hexFrustum );\n\
\taddLine( \"f3\", \"f1\", hexFrustum );\n\
\n\
\t// sides\n\
\n\
\taddLine( \"n1\", \"f1\", hexFrustum );\n\
\taddLine( \"n2\", \"f2\", hexFrustum );\n\
\taddLine( \"n3\", \"f3\", hexFrustum );\n\
\taddLine( \"n4\", \"f4\", hexFrustum );\n\
\n\
\t// cone\n\
\n\
\taddLine( \"p\", \"n1\", hexCone );\n\
\taddLine( \"p\", \"n2\", hexCone );\n\
\taddLine( \"p\", \"n3\", hexCone );\n\
\taddLine( \"p\", \"n4\", hexCone );\n\
\n\
\t// up\n\
\n\
\taddLine( \"u1\", \"u2\", hexUp );\n\
\taddLine( \"u2\", \"u3\", hexUp );\n\
\taddLine( \"u3\", \"u1\", hexUp );\n\
\n\
\t// target\n\
\n\
\taddLine( \"c\", \"t\", hexTarget );\n\
\taddLine( \"p\", \"c\", hexCross );\n\
\n\
\t// cross\n\
\n\
\taddLine( \"cn1\", \"cn2\", hexCross );\n\
\taddLine( \"cn3\", \"cn4\", hexCross );\n\
\n\
\taddLine( \"cf1\", \"cf2\", hexCross );\n\
\taddLine( \"cf3\", \"cf4\", hexCross );\n\
\n\
\tfunction addLine( a, b, hex ) {\n\
\n\
\t\taddPoint( a, hex );\n\
\t\taddPoint( b, hex );\n\
\n\
\t}\n\
\n\
\tfunction addPoint( id, hex ) {\n\
\n\
\t\tgeometry.vertices.push( new THREE.Vector3() );\n\
\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\
\n\
\t\tif ( pointMap[ id ] === undefined ) {\n\
\n\
\t\t\tpointMap[ id ] = [];\n\
\n\
\t\t}\n\
\n\
\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\
\n\
\t}\n\
\n\
\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\
\n\
\tthis.camera = camera;\n\
\tthis.matrixWorld = camera.matrixWorld;\n\
\tthis.matrixAutoUpdate = false;\n\
\n\
\tthis.pointMap = pointMap;\n\
\n\
\tthis.update();\n\
\n\
};\n\
\n\
THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\n\
\n\
THREE.CameraHelper.prototype.update = function () {\n\
\n\
\tvar vector = new THREE.Vector3();\n\
\tvar camera = new THREE.Camera();\n\
\tvar projector = new THREE.Projector();\n\
\n\
\treturn function () {\n\
\n\
\t\tvar scope = this;\n\
\n\
\t\tvar w = 1, h = 1;\n\
\n\
\t\t// we need just camera projection matrix\n\
\t\t// world matrix must be identity\n\
\n\
\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\
\n\
\t\t// center / target\n\
\n\
\t\tsetPoint( \"c\", 0, 0, -1 );\n\
\t\tsetPoint( \"t\", 0, 0,  1 );\n\
\n\
\t\t// near\n\
\n\
\t\tsetPoint( \"n1\", -w, -h, -1 );\n\
\t\tsetPoint( \"n2\",  w, -h, -1 );\n\
\t\tsetPoint( \"n3\", -w,  h, -1 );\n\
\t\tsetPoint( \"n4\",  w,  h, -1 );\n\
\n\
\t\t// far\n\
\n\
\t\tsetPoint( \"f1\", -w, -h, 1 );\n\
\t\tsetPoint( \"f2\",  w, -h, 1 );\n\
\t\tsetPoint( \"f3\", -w,  h, 1 );\n\
\t\tsetPoint( \"f4\",  w,  h, 1 );\n\
\n\
\t\t// up\n\
\n\
\t\tsetPoint( \"u1\",  w * 0.7, h * 1.1, -1 );\n\
\t\tsetPoint( \"u2\", -w * 0.7, h * 1.1, -1 );\n\
\t\tsetPoint( \"u3\",        0, h * 2,   -1 );\n\
\n\
\t\t// cross\n\
\n\
\t\tsetPoint( \"cf1\", -w,  0, 1 );\n\
\t\tsetPoint( \"cf2\",  w,  0, 1 );\n\
\t\tsetPoint( \"cf3\",  0, -h, 1 );\n\
\t\tsetPoint( \"cf4\",  0,  h, 1 );\n\
\n\
\t\tsetPoint( \"cn1\", -w,  0, -1 );\n\
\t\tsetPoint( \"cn2\",  w,  0, -1 );\n\
\t\tsetPoint( \"cn3\",  0, -h, -1 );\n\
\t\tsetPoint( \"cn4\",  0,  h, -1 );\n\
\n\
\t\tfunction setPoint( point, x, y, z ) {\n\
\n\
\t\t\tvector.set( x, y, z );\n\
\t\t\tprojector.unprojectVector( vector, camera );\n\
\n\
\t\t\tvar points = scope.pointMap[ point ];\n\
\n\
\t\t\tif ( points !== undefined ) {\n\
\n\
\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\
\n\
\t\t\t\t\tscope.geometry.vertices[ points[ i ] ].copy( vector );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tthis.geometry.verticesNeedUpdate = true;\n\
\n\
\t};\n\
\n\
}();\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.DirectionalLightHelper = function ( light, size ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.light = light;\n\
\tthis.light.updateMatrixWorld();\n\
\n\
\tthis.matrixWorld = light.matrixWorld;\n\
\tthis.matrixAutoUpdate = false;\n\
\n\
\tvar geometry = new THREE.PlaneGeometry( size, size );\n\
\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\
\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\
\n\
\tthis.lightPlane = new THREE.Mesh( geometry, material );\n\
\tthis.add( this.lightPlane );\n\
\n\
\tgeometry = new THREE.Geometry();\n\
\tgeometry.vertices.push( new THREE.Vector3() );\n\
\tgeometry.vertices.push( new THREE.Vector3() );\n\
\tgeometry.computeLineDistances();\n\
\n\
\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\n\
\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\
\n\
\tthis.targetLine = new THREE.Line( geometry, material );\n\
\tthis.add( this.targetLine );\n\
\n\
\tthis.update();\n\
\n\
};\n\
\n\
THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.DirectionalLightHelper.prototype.update = function () {\n\
\n\
\tvar vector = new THREE.Vector3();\n\
\n\
\treturn function () {\n\
\n\
\t\tvector.getPositionFromMatrix( this.light.matrixWorld ).negate();\n\
\n\
\t\tthis.lightPlane.lookAt( vector );\n\
\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\
\n\
\t\tthis.targetLine.geometry.vertices[ 1 ].copy( vector );\n\
\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\n\
\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\n\
\n\
\t}\n\
\n\
}();\n\
\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
*/\n\
\n\
THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\
\n\
\tthis.object = object;\n\
\n\
\tthis.size = size || 1;\n\
\n\
\tvar color = hex || 0xffff00;\n\
\n\
\tvar width = linewidth || 1;\n\
\n\
\tvar geometry = new THREE.Geometry();\n\
\n\
\tvar faces = this.object.geometry.faces;\n\
\n\
\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\
\n\
\t\tgeometry.vertices.push( new THREE.Vector3() );\n\
\t\tgeometry.vertices.push( new THREE.Vector3() );\n\
\n\
\t}\n\
\n\
\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\n\
\n\
\tthis.matrixAutoUpdate = false;\n\
\n\
\tthis.normalMatrix = new THREE.Matrix3();\n\
\n\
\tthis.update();\n\
\n\
};\n\
\n\
THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );\n\
\n\
THREE.FaceNormalsHelper.prototype.update = ( function ( object ) {\n\
\n\
\tvar v1 = new THREE.Vector3();\n\
\n\
\treturn function ( object ) {\n\
\n\
\t\tthis.object.updateMatrixWorld( true );\n\
\n\
\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\n\
\n\
\t\tvar vertices = this.geometry.vertices;\n\
\n\
\t\tvar faces = this.object.geometry.faces;\n\
\n\
\t\tvar worldMatrix = this.object.matrixWorld;\n\
\n\
\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\
\n\
\t\t\tvar face = faces[ i ];\n\
\n\
\t\t\tv1.copy( face.normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\n\
\n\
\t\t\tvar idx = 2 * i;\n\
\n\
\t\t\tvertices[ idx ].copy( face.centroid ).applyMatrix4( worldMatrix );\n\
\n\
\t\t\tvertices[ idx + 1 ].addVectors( vertices[ idx ], v1 );\n\
\n\
\t\t}\n\
\n\
\t\tthis.geometry.verticesNeedUpdate = true;\n\
\n\
\t\treturn this;\n\
\n\
\t}\n\
\n\
}());\n\
\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.GridHelper = function ( size, step ) {\n\
\n\
\tvar geometry = new THREE.Geometry();\n\
\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\
\n\
\tthis.color1 = new THREE.Color( 0x444444 );\n\
\tthis.color2 = new THREE.Color( 0x888888 );\n\
\n\
\tfor ( var i = - size; i <= size; i += step ) {\n\
\n\
\t\tgeometry.vertices.push(\n\
\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\n\
\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\n\
\t\t);\n\
\n\
\t\tvar color = i === 0 ? this.color1 : this.color2;\n\
\n\
\t\tgeometry.colors.push( color, color, color, color );\n\
\n\
\t}\n\
\n\
\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\
\n\
};\n\
\n\
THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );\n\
\n\
THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\n\
\n\
\tthis.color1.set( colorCenterLine );\n\
\tthis.color2.set( colorGrid );\n\
\n\
\tthis.geometry.colorsNeedUpdate = true;\n\
\n\
}\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.light = light;\n\
\tthis.light.updateMatrixWorld();\n\
\n\
\tthis.matrixWorld = light.matrixWorld;\n\
\tthis.matrixAutoUpdate = false;\n\
\n\
\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\
\n\
\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\
\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\n\
\n\
\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\
\n\
\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\
\n\
\t}\n\
\n\
\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\
\n\
\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\
\tthis.add( this.lightSphere );\n\
\n\
\tthis.update();\n\
\n\
};\n\
\n\
THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.HemisphereLightHelper.prototype.update = function () {\n\
\n\
\tvar vector = new THREE.Vector3();\n\
\n\
\treturn function () {\n\
\n\
\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\
\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\
\n\
\t\tthis.lightSphere.lookAt( vector.getPositionFromMatrix( this.light.matrixWorld ).negate() );\n\
\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\
\n\
\t}\n\
\n\
}();\n\
\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.PointLightHelper = function ( light, sphereSize ) {\n\
\n\
\tthis.light = light;\n\
\tthis.light.updateMatrixWorld();\n\
\n\
\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\
\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\
\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\
\n\
\tTHREE.Mesh.call( this, geometry, material );\n\
\n\
\tthis.matrixWorld = this.light.matrixWorld;\n\
\tthis.matrixAutoUpdate = false;\n\
\n\
\t/*\n\
\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\
\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\
\n\
\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\
\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\
\n\
\tvar d = light.distance;\n\
\n\
\tif ( d === 0.0 ) {\n\
\n\
\t\tthis.lightDistance.visible = false;\n\
\n\
\t} else {\n\
\n\
\t\tthis.lightDistance.scale.set( d, d, d );\n\
\n\
\t}\n\
\n\
\tthis.add( this.lightDistance );\n\
\t*/\n\
\n\
};\n\
\n\
THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\n\
\n\
THREE.PointLightHelper.prototype.update = function () {\n\
\n\
\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\
\n\
\t/*\n\
\tvar d = this.light.distance;\n\
\n\
\tif ( d === 0.0 ) {\n\
\n\
\t\tthis.lightDistance.visible = false;\n\
\n\
\t} else {\n\
\n\
\t\tthis.lightDistance.visible = true;\n\
\t\tthis.lightDistance.scale.set( d, d, d );\n\
\n\
\t}\n\
\t*/\n\
\n\
};\n\
\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
*/\n\
\n\
THREE.SpotLightHelper = function ( light ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.light = light;\n\
\tthis.light.updateMatrixWorld();\n\
\n\
\tthis.matrixWorld = light.matrixWorld;\n\
\tthis.matrixAutoUpdate = false;\n\
\n\
\tvar geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\n\
\n\
\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -0.5, 0 ) );\n\
\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\n\
\n\
\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\
\t\n\
\tthis.cone = new THREE.Mesh( geometry, material );\n\
\tthis.add( this.cone );\n\
\n\
\tthis.update();\n\
\n\
};\n\
\n\
THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
THREE.SpotLightHelper.prototype.update = function () {\n\
\n\
\tvar vector = new THREE.Vector3();\n\
\tvar vector2 = new THREE.Vector3();\n\
\n\
\treturn function () {\n\
\n\
\t\tvar coneLength = this.light.distance ? this.light.distance : 10000;\n\
\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\
\n\
\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\
\n\
\t\tvector.getPositionFromMatrix( this.light.matrixWorld );\n\
\t\tvector2.getPositionFromMatrix( this.light.target.matrixWorld );\n\
\n\
\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\
\n\
\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\
\n\
\t};\n\
\n\
}();\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
*/\n\
\n\
THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\
\n\
\tthis.object = object;\n\
\n\
\tthis.size = size || 1;\n\
\n\
\tvar color = hex || 0xff0000;\n\
\n\
\tvar width = linewidth || 1;\n\
\n\
\tvar geometry = new THREE.Geometry();\n\
\n\
\tvar vertices = object.geometry.vertices;\n\
\n\
\tvar faces = object.geometry.faces;\n\
\n\
\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\
\n\
\t\tvar face = faces[ i ];\n\
\n\
\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\
\n\
\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\
\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\n\
\n\
\tthis.matrixAutoUpdate = false;\n\
\n\
\tthis.normalMatrix = new THREE.Matrix3();\n\
\n\
\tthis.update();\n\
\n\
};\n\
\n\
THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );\n\
\n\
THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {\n\
\n\
\tvar v1 = new THREE.Vector3();\n\
\n\
\treturn function( object ) {\n\
\n\
\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\n\
\n\
\t\tthis.object.updateMatrixWorld( true );\n\
\n\
\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\n\
\n\
\t\tvar vertices = this.geometry.vertices;\n\
\n\
\t\tvar verts = this.object.geometry.vertices;\n\
\n\
\t\tvar faces = this.object.geometry.faces;\n\
\n\
\t\tvar worldMatrix = this.object.matrixWorld;\n\
\n\
\t\tvar idx = 0;\n\
\n\
\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\
\n\
\t\t\tvar face = faces[ i ];\n\
\n\
\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\tvar vertexId = face[ keys[ j ] ];\n\
\t\t\t\tvar vertex = verts[ vertexId ];\n\
\n\
\t\t\t\tvar normal = face.vertexNormals[ j ];\n\
\n\
\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\n\
\n\
\t\t\t\tv1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\n\
\n\
\t\t\t\tv1.add( vertices[ idx ] );\n\
\t\t\t\tidx = idx + 1;\n\
\n\
\t\t\t\tvertices[ idx ].copy( v1 );\n\
\t\t\t\tidx = idx + 1;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tthis.geometry.verticesNeedUpdate = true;\n\
\n\
\t\treturn this;\n\
\n\
\t}\n\
\n\
}());\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 * @author WestLangley / http://github.com/WestLangley\n\
*/\n\
\n\
THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {\n\
\n\
\tthis.object = object;\n\
\n\
\tthis.size = size || 1;\n\
\n\
\tvar color = hex || 0x0000ff;\n\
\n\
\tvar width = linewidth || 1;\n\
\n\
\tvar geometry = new THREE.Geometry();\n\
\n\
\tvar vertices = object.geometry.vertices;\n\
\n\
\tvar faces = object.geometry.faces;\n\
\n\
\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\
\n\
\t\tvar face = faces[ i ];\n\
\n\
\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\n\
\n\
\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\
\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\n\
\n\
\tthis.matrixAutoUpdate = false;\n\
\n\
\tthis.update();\n\
\n\
};\n\
\n\
THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );\n\
\n\
THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {\n\
\n\
\tvar v1 = new THREE.Vector3();\n\
\n\
\treturn function( object ) {\n\
\n\
\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\n\
\n\
\t\tthis.object.updateMatrixWorld( true );\n\
\n\
\t\tvar vertices = this.geometry.vertices;\n\
\n\
\t\tvar verts = this.object.geometry.vertices;\n\
\n\
\t\tvar faces = this.object.geometry.faces;\n\
\n\
\t\tvar worldMatrix = this.object.matrixWorld;\n\
\n\
\t\tvar idx = 0;\n\
\n\
\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\
\n\
\t\t\tvar face = faces[ i ];\n\
\n\
\t\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\tvar vertexId = face[ keys[ j ] ];\n\
\t\t\t\tvar vertex = verts[ vertexId ];\n\
\n\
\t\t\t\tvar tangent = face.vertexTangents[ j ];\n\
\n\
\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\n\
\n\
\t\t\t\tv1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );\n\
\n\
\t\t\t\tv1.add( vertices[ idx ] );\n\
\t\t\t\tidx = idx + 1;\n\
\n\
\t\t\t\tvertices[ idx ].copy( v1 );\n\
\t\t\t\tidx = idx + 1;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tthis.geometry.verticesNeedUpdate = true;\n\
\n\
\t\treturn this;\n\
\n\
\t}\n\
\n\
}());\n\
\n\
/**\n\
 * @author mrdoob / http://mrdoob.com/\n\
 */\n\
\n\
THREE.WireframeHelper = function ( object ) {\n\
\n\
\tvar edge = [ 0, 0 ], hash = {};\n\
\tvar sortFunction = function ( a, b ) { return a - b };\n\
\n\
\tvar keys = [ 'a', 'b', 'c', 'd' ];\n\
\tvar geometry = new THREE.Geometry();\n\
\n\
\tvar vertices = object.geometry.vertices;\n\
\tvar faces = object.geometry.faces;\n\
\n\
\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\
\n\
\t\tvar face = faces[ i ];\n\
\n\
\t\tfor ( var j = 0; j < 3; j ++ ) {\n\
\n\
\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\
\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\
\t\t\tedge.sort( sortFunction );\n\
\n\
\t\t\tvar key = edge.toString();\n\
\n\
\t\t\tif ( hash[ key ] === undefined ) {\n\
\n\
\t\t\t\tgeometry.vertices.push( vertices[ edge[ 0 ] ] );\n\
\t\t\t\tgeometry.vertices.push( vertices[ edge[ 1 ] ] );\n\
\n\
\t\t\t\thash[ key ] = true;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffffff } ), THREE.LinePieces );\n\
\n\
\tthis.matrixAutoUpdate = false;\n\
\tthis.matrixWorld = object.matrixWorld;\n\
\n\
};\n\
\n\
THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.ImmediateRenderObject = function () {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.render = function ( renderCallback ) { };\n\
\n\
};\n\
\n\
THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\
\n\
\tTHREE.Object3D.call( this );\n\
\n\
\tthis.lensFlares = [];\n\
\n\
\tthis.positionScreen = new THREE.Vector3();\n\
\tthis.customUpdateCallback = undefined;\n\
\n\
\tif( texture !== undefined ) {\n\
\n\
\t\tthis.add( texture, size, distance, blending, color );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\n\
\n\
\n\
/*\n\
 * Add: adds another flare\n\
 */\n\
\n\
THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\n\
\n\
\tif( size === undefined ) size = -1;\n\
\tif( distance === undefined ) distance = 0;\n\
\tif( opacity === undefined ) opacity = 1;\n\
\tif( color === undefined ) color = new THREE.Color( 0xffffff );\n\
\tif( blending === undefined ) blending = THREE.NormalBlending;\n\
\n\
\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\
\n\
\tthis.lensFlares.push( { texture: texture, \t\t\t// THREE.Texture\n\
\t\t                    size: size, \t\t\t\t// size in pixels (-1 = use texture.width)\n\
\t\t                    distance: distance, \t\t// distance (0-1) from light source (0=at light source)\n\
\t\t                    x: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\n\
\t\t                    scale: 1, \t\t\t\t\t// scale\n\
\t\t                    rotation: 1, \t\t\t\t// rotation\n\
\t\t                    opacity: opacity,\t\t\t// opacity\n\
\t\t\t\t\t\t\tcolor: color,\t\t\t\t// color\n\
\t\t                    blending: blending } );\t\t// blending\n\
\n\
};\n\
\n\
\n\
/*\n\
 * Update lens flares update positions on all flares based on the screen position\n\
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\
 */\n\
\n\
THREE.LensFlare.prototype.updateLensFlares = function () {\n\
\n\
\tvar f, fl = this.lensFlares.length;\n\
\tvar flare;\n\
\tvar vecX = -this.positionScreen.x * 2;\n\
\tvar vecY = -this.positionScreen.y * 2;\n\
\n\
\tfor( f = 0; f < fl; f ++ ) {\n\
\n\
\t\tflare = this.lensFlares[ f ];\n\
\n\
\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\
\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\
\n\
\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\
\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\
\n\
\t}\n\
\n\
};\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.MorphBlendMesh = function( geometry, material ) {\n\
\n\
\tTHREE.Mesh.call( this, geometry, material );\n\
\n\
\tthis.animationsMap = {};\n\
\tthis.animationsList = [];\n\
\n\
\t// prepare default animation\n\
\t// (all frames played together in 1 second)\n\
\n\
\tvar numFrames = this.geometry.morphTargets.length;\n\
\n\
\tvar name = \"__default\";\n\
\n\
\tvar startFrame = 0;\n\
\tvar endFrame = numFrames - 1;\n\
\n\
\tvar fps = numFrames / 1;\n\
\n\
\tthis.createAnimation( name, startFrame, endFrame, fps );\n\
\tthis.setAnimationWeight( name, 1 );\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\n\
\n\
THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\
\n\
\tvar animation = {\n\
\n\
\t\tstartFrame: start,\n\
\t\tendFrame: end,\n\
\n\
\t\tlength: end - start + 1,\n\
\n\
\t\tfps: fps,\n\
\t\tduration: ( end - start ) / fps,\n\
\n\
\t\tlastFrame: 0,\n\
\t\tcurrentFrame: 0,\n\
\n\
\t\tactive: false,\n\
\n\
\t\ttime: 0,\n\
\t\tdirection: 1,\n\
\t\tweight: 1,\n\
\n\
\t\tdirectionBackwards: false,\n\
\t\tmirroredLoop: false\n\
\n\
\t};\n\
\n\
\tthis.animationsMap[ name ] = animation;\n\
\tthis.animationsList.push( animation );\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\
\n\
\tvar pattern = /([a-z]+)(\\d+)/;\n\
\n\
\tvar firstAnimation, frameRanges = {};\n\
\n\
\tvar geometry = this.geometry;\n\
\n\
\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\
\n\
\t\tvar morph = geometry.morphTargets[ i ];\n\
\t\tvar chunks = morph.name.match( pattern );\n\
\n\
\t\tif ( chunks && chunks.length > 1 ) {\n\
\n\
\t\t\tvar name = chunks[ 1 ];\n\
\t\t\tvar num = chunks[ 2 ];\n\
\n\
\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };\n\
\n\
\t\t\tvar range = frameRanges[ name ];\n\
\n\
\t\t\tif ( i < range.start ) range.start = i;\n\
\t\t\tif ( i > range.end ) range.end = i;\n\
\n\
\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\
\n\
\t\t}\n\
\n\
\t}\n\
\n\
\tfor ( var name in frameRanges ) {\n\
\n\
\t\tvar range = frameRanges[ name ];\n\
\t\tthis.createAnimation( name, range.start, range.end, fps );\n\
\n\
\t}\n\
\n\
\tthis.firstAnimation = firstAnimation;\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\
\n\
\tvar animation = this.animationsMap[ name ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\tanimation.direction = 1;\n\
\t\tanimation.directionBackwards = false;\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\
\n\
\tvar animation = this.animationsMap[ name ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\tanimation.direction = -1;\n\
\t\tanimation.directionBackwards = true;\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\
\n\
\tvar animation = this.animationsMap[ name ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\tanimation.fps = fps;\n\
\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\
\n\
\tvar animation = this.animationsMap[ name ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\tanimation.duration = duration;\n\
\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\
\n\
\tvar animation = this.animationsMap[ name ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\tanimation.weight = weight;\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\
\n\
\tvar animation = this.animationsMap[ name ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\tanimation.time = time;\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\
\n\
\tvar time = 0;\n\
\n\
\tvar animation = this.animationsMap[ name ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\ttime = animation.time;\n\
\n\
\t}\n\
\n\
\treturn time;\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\
\n\
\tvar duration = -1;\n\
\n\
\tvar animation = this.animationsMap[ name ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\tduration = animation.duration;\n\
\n\
\t}\n\
\n\
\treturn duration;\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\
\n\
\tvar animation = this.animationsMap[ name ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\tanimation.time = 0;\n\
\t\tanimation.active = true;\n\
\n\
\t} else {\n\
\n\
\t\tconsole.warn( \"animation[\" + name + \"] undefined\" );\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\
\n\
\tvar animation = this.animationsMap[ name ];\n\
\n\
\tif ( animation ) {\n\
\n\
\t\tanimation.active = false;\n\
\n\
\t}\n\
\n\
};\n\
\n\
THREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\
\n\
\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\
\n\
\t\tvar animation = this.animationsList[ i ];\n\
\n\
\t\tif ( ! animation.active ) continue;\n\
\n\
\t\tvar frameTime = animation.duration / animation.length;\n\
\n\
\t\tanimation.time += animation.direction * delta;\n\
\n\
\t\tif ( animation.mirroredLoop ) {\n\
\n\
\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\
\n\
\t\t\t\tanimation.direction *= -1;\n\
\n\
\t\t\t\tif ( animation.time > animation.duration ) {\n\
\n\
\t\t\t\t\tanimation.time = animation.duration;\n\
\t\t\t\t\tanimation.directionBackwards = true;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( animation.time < 0 ) {\n\
\n\
\t\t\t\t\tanimation.time = 0;\n\
\t\t\t\t\tanimation.directionBackwards = false;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\tanimation.time = animation.time % animation.duration;\n\
\n\
\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\
\n\
\t\t}\n\
\n\
\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\
\t\tvar weight = animation.weight;\n\
\n\
\t\tif ( keyframe !== animation.currentFrame ) {\n\
\n\
\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\
\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\
\n\
\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\
\n\
\t\t\tanimation.lastFrame = animation.currentFrame;\n\
\t\t\tanimation.currentFrame = keyframe;\n\
\n\
\t\t}\n\
\n\
\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\
\n\
\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\
\n\
\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\
\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.LensFlarePlugin = function () {\n\
\n\
\tvar _gl, _renderer, _precision, _lensFlare = {};\n\
\n\
\tthis.init = function ( renderer ) {\n\
\n\
\t\t_gl = renderer.context;\n\
\t\t_renderer = renderer;\n\
\n\
\t\t_precision = renderer.getPrecision();\n\
\n\
\t\t_lensFlare.vertices = new Float32Array( 8 + 8 );\n\
\t\t_lensFlare.faces = new Uint16Array( 6 );\n\
\n\
\t\tvar i = 0;\n\
\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;\t// vertex\n\
\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;\t// uv... etc.\n\
\n\
\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;\n\
\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;\n\
\n\
\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\n\
\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\n\
\n\
\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;\n\
\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;\n\
\n\
\t\ti = 0;\n\
\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;\n\
\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;\n\
\n\
\t\t// buffers\n\
\n\
\t\t_lensFlare.vertexBuffer     = _gl.createBuffer();\n\
\t\t_lensFlare.elementBuffer    = _gl.createBuffer();\n\
\n\
\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\n\
\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );\n\
\n\
\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\n\
\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );\n\
\n\
\t\t// textures\n\
\n\
\t\t_lensFlare.tempTexture      = _gl.createTexture();\n\
\t\t_lensFlare.occlusionTexture = _gl.createTexture();\n\
\n\
\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\
\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );\n\
\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\
\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\
\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\n\
\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\n\
\n\
\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\n\
\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );\n\
\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\
\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\
\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\n\
\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\n\
\n\
\t\tif ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {\n\
\n\
\t\t\t_lensFlare.hasVertexTexture = false;\n\
\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlare\" ], _precision );\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_lensFlare.hasVertexTexture = true;\n\
\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlareVertexTexture\" ], _precision );\n\
\n\
\t\t}\n\
\n\
\t\t_lensFlare.attributes = {};\n\
\t\t_lensFlare.uniforms = {};\n\
\n\
\t\t_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, \"position\" );\n\
\t\t_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, \"uv\" );\n\
\n\
\t\t_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, \"renderType\" );\n\
\t\t_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, \"map\" );\n\
\t\t_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, \"occlusionMap\" );\n\
\t\t_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, \"opacity\" );\n\
\t\t_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, \"color\" );\n\
\t\t_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, \"scale\" );\n\
\t\t_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, \"rotation\" );\n\
\t\t_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, \"screenPosition\" );\n\
\n\
\t};\n\
\n\
\n\
\t/*\n\
\t * Render lens flares\n\
\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\
\t *         reads these back and calculates occlusion.\n\
\t *         Then _lensFlare.update_lensFlares() is called to re-position and\n\
\t *         update transparency of flares. Then they are rendered.\n\
\t *\n\
\t */\n\
\n\
\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\n\
\n\
\t\tvar flares = scene.__webglFlares,\n\
\t\t\tnFlares = flares.length;\n\
\n\
\t\tif ( ! nFlares ) return;\n\
\n\
\t\tvar tempPosition = new THREE.Vector3();\n\
\n\
\t\tvar invAspect = viewportHeight / viewportWidth,\n\
\t\t\thalfViewportWidth = viewportWidth * 0.5,\n\
\t\t\thalfViewportHeight = viewportHeight * 0.5;\n\
\n\
\t\tvar size = 16 / viewportHeight,\n\
\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\
\n\
\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\
\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\
\n\
\t\tvar uniforms = _lensFlare.uniforms,\n\
\t\t\tattributes = _lensFlare.attributes;\n\
\n\
\t\t// set _lensFlare program and reset blending\n\
\n\
\t\t_gl.useProgram( _lensFlare.program );\n\
\n\
\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );\n\
\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.uv );\n\
\n\
\t\t// loop through all lens flares to update their occlusion and positions\n\
\t\t// setup gl and common used attribs/unforms\n\
\n\
\t\t_gl.uniform1i( uniforms.occlusionMap, 0 );\n\
\t\t_gl.uniform1i( uniforms.map, 1 );\n\
\n\
\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\n\
\t\t_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );\n\
\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\n\
\n\
\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\n\
\n\
\t\t_gl.disable( _gl.CULL_FACE );\n\
\t\t_gl.depthMask( false );\n\
\n\
\t\tvar i, j, jl, flare, sprite;\n\
\n\
\t\tfor ( i = 0; i < nFlares; i ++ ) {\n\
\n\
\t\t\tsize = 16 / viewportHeight;\n\
\t\t\tscale.set( size * invAspect, size );\n\
\n\
\t\t\t// calc object screen position\n\
\n\
\t\t\tflare = flares[ i ];\n\
\n\
\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\n\
\n\
\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\
\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\
\n\
\t\t\t// setup arrays for gl programs\n\
\n\
\t\t\tscreenPosition.copy( tempPosition )\n\
\n\
\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\n\
\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\n\
\n\
\t\t\t// screen cull\n\
\n\
\t\t\tif ( _lensFlare.hasVertexTexture || (\n\
\t\t\t\tscreenPositionPixels.x > 0 &&\n\
\t\t\t\tscreenPositionPixels.x < viewportWidth &&\n\
\t\t\t\tscreenPositionPixels.y > 0 &&\n\
\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\n\
\n\
\t\t\t\t// save current RGB to temp texture\n\
\n\
\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\n\
\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\
\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\n\
\n\
\n\
\t\t\t\t// render pink quad\n\
\n\
\t\t\t\t_gl.uniform1i( uniforms.renderType, 0 );\n\
\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\n\
\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\
\n\
\t\t\t\t_gl.disable( _gl.BLEND );\n\
\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\
\n\
\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\
\n\
\n\
\t\t\t\t// copy result to occlusionMap\n\
\n\
\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 );\n\
\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\n\
\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\n\
\n\
\n\
\t\t\t\t// restore graphics\n\
\n\
\t\t\t\t_gl.uniform1i( uniforms.renderType, 1 );\n\
\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\
\n\
\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\n\
\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\
\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\
\n\
\n\
\t\t\t\t// update object positions\n\
\n\
\t\t\t\tflare.positionScreen.copy( screenPosition )\n\
\n\
\t\t\t\tif ( flare.customUpdateCallback ) {\n\
\n\
\t\t\t\t\tflare.customUpdateCallback( flare );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tflare.updateLensFlares();\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// render flares\n\
\n\
\t\t\t\t_gl.uniform1i( uniforms.renderType, 2 );\n\
\t\t\t\t_gl.enable( _gl.BLEND );\n\
\n\
\t\t\t\tfor ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\t\tsprite = flare.lensFlares[ j ];\n\
\n\
\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\
\n\
\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\
\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\
\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\
\n\
\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\n\
\n\
\t\t\t\t\t\tscale.x = size * invAspect;\n\
\t\t\t\t\t\tscale.y = size;\n\
\n\
\t\t\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\
\t\t\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\n\
\t\t\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\n\
\n\
\t\t\t\t\t\t_gl.uniform1f( uniforms.opacity, sprite.opacity );\n\
\t\t\t\t\t\t_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\
\n\
\t\t\t\t\t\t_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\
\t\t\t\t\t\t_renderer.setTexture( sprite.texture, 1 );\n\
\n\
\t\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// restore gl\n\
\n\
\t\t_gl.enable( _gl.CULL_FACE );\n\
\t\t_gl.enable( _gl.DEPTH_TEST );\n\
\t\t_gl.depthMask( true );\n\
\n\
\t};\n\
\n\
\tfunction createProgram ( shader, precision ) {\n\
\n\
\t\tvar program = _gl.createProgram();\n\
\n\
\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\
\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\n\
\n\
\t\tvar prefix = \"precision \" + precision + \" float;\\n\
\";\n\
\n\
\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\
\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\
\n\
\t\t_gl.compileShader( fragmentShader );\n\
\t\t_gl.compileShader( vertexShader );\n\
\n\
\t\t_gl.attachShader( program, fragmentShader );\n\
\t\t_gl.attachShader( program, vertexShader );\n\
\n\
\t\t_gl.linkProgram( program );\n\
\n\
\t\treturn program;\n\
\n\
\t};\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.ShadowMapPlugin = function () {\n\
\n\
\tvar _gl,\n\
\t_renderer,\n\
\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\n\
\n\
\t_frustum = new THREE.Frustum(),\n\
\t_projScreenMatrix = new THREE.Matrix4(),\n\
\n\
\t_min = new THREE.Vector3(),\n\
\t_max = new THREE.Vector3(),\n\
\n\
\t_matrixPosition = new THREE.Vector3();\n\
\n\
\tthis.init = function ( renderer ) {\n\
\n\
\t\t_gl = renderer.context;\n\
\t\t_renderer = renderer;\n\
\n\
\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\n\
\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\
\n\
\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n\
\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\n\
\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\n\
\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\n\
\n\
\t\t_depthMaterial._shadowPass = true;\n\
\t\t_depthMaterialMorph._shadowPass = true;\n\
\t\t_depthMaterialSkin._shadowPass = true;\n\
\t\t_depthMaterialMorphSkin._shadowPass = true;\n\
\n\
\t};\n\
\n\
\tthis.render = function ( scene, camera ) {\n\
\n\
\t\tif ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;\n\
\n\
\t\tthis.update( scene, camera );\n\
\n\
\t};\n\
\n\
\tthis.update = function ( scene, camera ) {\n\
\n\
\t\tvar i, il, j, jl, n,\n\
\n\
\t\tshadowMap, shadowMatrix, shadowCamera,\n\
\t\tprogram, buffer, material,\n\
\t\twebglObject, object, light,\n\
\t\trenderList,\n\
\n\
\t\tlights = [],\n\
\t\tk = 0,\n\
\n\
\t\tfog = null;\n\
\n\
\t\t// set GL state for depth map\n\
\n\
\t\t_gl.clearColor( 1, 1, 1, 1 );\n\
\t\t_gl.disable( _gl.BLEND );\n\
\n\
\t\t_gl.enable( _gl.CULL_FACE );\n\
\t\t_gl.frontFace( _gl.CCW );\n\
\n\
\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\n\
\n\
\t\t\t_gl.cullFace( _gl.FRONT );\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_gl.cullFace( _gl.BACK );\n\
\n\
\t\t}\n\
\n\
\t\t_renderer.setDepthTest( true );\n\
\n\
\t\t// preprocess lights\n\
\t\t// \t- skip lights that are not casting shadows\n\
\t\t//\t- create virtual lights for cascaded shadow maps\n\
\n\
\t\tfor ( i = 0, il = scene.__lights.length; i < il; i ++ ) {\n\
\n\
\t\t\tlight = scene.__lights[ i ];\n\
\n\
\t\t\tif ( ! light.castShadow ) continue;\n\
\n\
\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\n\
\n\
\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\n\
\n\
\t\t\t\t\tvar virtualLight;\n\
\n\
\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\n\
\n\
\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\n\
\t\t\t\t\t\tvirtualLight.originalCamera = camera;\n\
\n\
\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\n\
\t\t\t\t\t\tgyro.position = light.shadowCascadeOffset;\n\
\n\
\t\t\t\t\t\tgyro.add( virtualLight );\n\
\t\t\t\t\t\tgyro.add( virtualLight.target );\n\
\n\
\t\t\t\t\t\tcamera.add( gyro );\n\
\n\
\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\n\
\n\
\t\t\t\t\t\tconsole.log( \"Created virtualLight\", virtualLight );\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tupdateVirtualLight( light, n );\n\
\n\
\t\t\t\t\tlights[ k ] = virtualLight;\n\
\t\t\t\t\tk ++;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tlights[ k ] = light;\n\
\t\t\t\tk ++;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// render depth map\n\
\n\
\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\n\
\n\
\t\t\tlight = lights[ i ];\n\
\n\
\t\t\tif ( ! light.shadowMap ) {\n\
\n\
\t\t\t\tvar shadowFilter = THREE.LinearFilter;\n\
\n\
\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\n\
\n\
\t\t\t\t\tshadowFilter = THREE.NearestFilter;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\n\
\n\
\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\n\
\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\n\
\n\
\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( ! light.shadowCamera ) {\n\
\n\
\t\t\t\tif ( light instanceof THREE.SpotLight ) {\n\
\n\
\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\n\
\n\
\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\
\n\
\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tconsole.error( \"Unsupported light type for shadow\" );\n\
\t\t\t\t\tcontinue;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tscene.add( light.shadowCamera );\n\
\n\
\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\n\
\n\
\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\n\
\t\t\t\tlight.shadowCamera.add( light.cameraHelper );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\n\
\n\
\t\t\t\tupdateShadowCamera( camera, light );\n\
\n\
\t\t\t}\n\
\n\
\t\t\tshadowMap = light.shadowMap;\n\
\t\t\tshadowMatrix = light.shadowMatrix;\n\
\t\t\tshadowCamera = light.shadowCamera;\n\
\n\
\t\t\tshadowCamera.position.getPositionFromMatrix( light.matrixWorld );\n\
\t\t\t_matrixPosition.getPositionFromMatrix( light.target.matrixWorld );\n\
\t\t\tshadowCamera.lookAt( _matrixPosition );\n\
\t\t\tshadowCamera.updateMatrixWorld();\n\
\n\
\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\
\n\
\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\n\
\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\n\
\n\
\t\t\t// compute shadow matrix\n\
\n\
\t\t\tshadowMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\
\t\t\t\t\t\t\t  0.0, 0.5, 0.0, 0.5,\n\
\t\t\t\t\t\t\t  0.0, 0.0, 0.5, 0.5,\n\
\t\t\t\t\t\t\t  0.0, 0.0, 0.0, 1.0 );\n\
\n\
\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\
\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\
\n\
\t\t\t// update camera matrices and frustum\n\
\n\
\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\
\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\
\n\
\t\t\t// render shadow map\n\
\n\
\t\t\t_renderer.setRenderTarget( shadowMap );\n\
\t\t\t_renderer.clear();\n\
\n\
\t\t\t// set object matrices & frustum culling\n\
\n\
\t\t\trenderList = scene.__webglObjects;\n\
\n\
\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\twebglObject = renderList[ j ];\n\
\t\t\t\tobject = webglObject.object;\n\
\n\
\t\t\t\twebglObject.render = false;\n\
\n\
\t\t\t\tif ( object.visible && object.castShadow ) {\n\
\n\
\t\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\
\n\
\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\
\n\
\t\t\t\t\t\twebglObject.render = true;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// render regular objects\n\
\n\
\t\t\tvar objectMaterial, useMorphing, useSkinning;\n\
\n\
\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\twebglObject = renderList[ j ];\n\
\n\
\t\t\t\tif ( webglObject.render ) {\n\
\n\
\t\t\t\t\tobject = webglObject.object;\n\
\t\t\t\t\tbuffer = webglObject.buffer;\n\
\n\
\t\t\t\t\t// culling is overriden globally for all objects\n\
\t\t\t\t\t// while rendering depth map\n\
\n\
\t\t\t\t\t// need to deal with MeshFaceMaterial somehow\n\
\t\t\t\t\t// in that case just use the first of material.materials for now\n\
\t\t\t\t\t// (proper solution would require to break objects by materials\n\
\t\t\t\t\t//  similarly to regular rendering and then set corresponding\n\
\t\t\t\t\t//  depth materials per each chunk instead of just once per object)\n\
\n\
\t\t\t\t\tobjectMaterial = getObjectMaterial( object );\n\
\n\
\t\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n\
\t\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n\
\n\
\t\t\t\t\tif ( object.customDepthMaterial ) {\n\
\n\
\t\t\t\t\t\tmaterial = object.customDepthMaterial;\n\
\n\
\t\t\t\t\t} else if ( useSkinning ) {\n\
\n\
\t\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n\
\n\
\t\t\t\t\t} else if ( useMorphing ) {\n\
\n\
\t\t\t\t\t\tmaterial = _depthMaterialMorph;\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\tmaterial = _depthMaterial;\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\
\n\
\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );\n\
\n\
\t\t\t\t\t} else {\n\
\n\
\t\t\t\t\t\t_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );\n\
\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t\t// set matrices and render immediate objects\n\
\n\
\t\t\trenderList = scene.__webglObjectsImmediate;\n\
\n\
\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\
\n\
\t\t\t\twebglObject = renderList[ j ];\n\
\t\t\t\tobject = webglObject.object;\n\
\n\
\t\t\t\tif ( object.visible && object.castShadow ) {\n\
\n\
\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\
\n\
\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// restore GL state\n\
\n\
\t\tvar clearColor = _renderer.getClearColor(),\n\
\t\tclearAlpha = _renderer.getClearAlpha();\n\
\n\
\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\n\
\t\t_gl.enable( _gl.BLEND );\n\
\n\
\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\n\
\n\
\t\t\t_gl.cullFace( _gl.BACK );\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
\tfunction createVirtualLight( light, cascade ) {\n\
\n\
\t\tvar virtualLight = new THREE.DirectionalLight();\n\
\n\
\t\tvirtualLight.isVirtual = true;\n\
\n\
\t\tvirtualLight.onlyShadow = true;\n\
\t\tvirtualLight.castShadow = true;\n\
\n\
\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\n\
\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\n\
\n\
\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\n\
\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\n\
\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\n\
\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\n\
\n\
\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\n\
\n\
\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\n\
\n\
\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\n\
\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\n\
\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\n\
\n\
\t\tvirtualLight.pointsWorld = [];\n\
\t\tvirtualLight.pointsFrustum = [];\n\
\n\
\t\tvar pointsWorld = virtualLight.pointsWorld,\n\
\t\t\tpointsFrustum = virtualLight.pointsFrustum;\n\
\n\
\t\tfor ( var i = 0; i < 8; i ++ ) {\n\
\n\
\t\t\tpointsWorld[ i ] = new THREE.Vector3();\n\
\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\n\
\n\
\t\t}\n\
\n\
\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\n\
\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\n\
\n\
\t\tpointsFrustum[ 0 ].set( -1, -1, nearZ );\n\
\t\tpointsFrustum[ 1 ].set(  1, -1, nearZ );\n\
\t\tpointsFrustum[ 2 ].set( -1,  1, nearZ );\n\
\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\n\
\n\
\t\tpointsFrustum[ 4 ].set( -1, -1, farZ );\n\
\t\tpointsFrustum[ 5 ].set(  1, -1, farZ );\n\
\t\tpointsFrustum[ 6 ].set( -1,  1, farZ );\n\
\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\n\
\n\
\t\treturn virtualLight;\n\
\n\
\t}\n\
\n\
\t// Synchronize virtual light with the original light\n\
\n\
\tfunction updateVirtualLight( light, cascade ) {\n\
\n\
\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\n\
\n\
\t\tvirtualLight.position.copy( light.position );\n\
\t\tvirtualLight.target.position.copy( light.target.position );\n\
\t\tvirtualLight.lookAt( virtualLight.target );\n\
\n\
\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\n\
\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\n\
\n\
\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\n\
\n\
\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\n\
\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\n\
\n\
\t\tvar pointsFrustum = virtualLight.pointsFrustum;\n\
\n\
\t\tpointsFrustum[ 0 ].z = nearZ;\n\
\t\tpointsFrustum[ 1 ].z = nearZ;\n\
\t\tpointsFrustum[ 2 ].z = nearZ;\n\
\t\tpointsFrustum[ 3 ].z = nearZ;\n\
\n\
\t\tpointsFrustum[ 4 ].z = farZ;\n\
\t\tpointsFrustum[ 5 ].z = farZ;\n\
\t\tpointsFrustum[ 6 ].z = farZ;\n\
\t\tpointsFrustum[ 7 ].z = farZ;\n\
\n\
\t}\n\
\n\
\t// Fit shadow camera's ortho frustum to camera frustum\n\
\n\
\tfunction updateShadowCamera( camera, light ) {\n\
\n\
\t\tvar shadowCamera = light.shadowCamera,\n\
\t\t\tpointsFrustum = light.pointsFrustum,\n\
\t\t\tpointsWorld = light.pointsWorld;\n\
\n\
\t\t_min.set( Infinity, Infinity, Infinity );\n\
\t\t_max.set( -Infinity, -Infinity, -Infinity );\n\
\n\
\t\tfor ( var i = 0; i < 8; i ++ ) {\n\
\n\
\t\t\tvar p = pointsWorld[ i ];\n\
\n\
\t\t\tp.copy( pointsFrustum[ i ] );\n\
\t\t\tTHREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );\n\
\n\
\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\n\
\n\
\t\t\tif ( p.x < _min.x ) _min.x = p.x;\n\
\t\t\tif ( p.x > _max.x ) _max.x = p.x;\n\
\n\
\t\t\tif ( p.y < _min.y ) _min.y = p.y;\n\
\t\t\tif ( p.y > _max.y ) _max.y = p.y;\n\
\n\
\t\t\tif ( p.z < _min.z ) _min.z = p.z;\n\
\t\t\tif ( p.z > _max.z ) _max.z = p.z;\n\
\n\
\t\t}\n\
\n\
\t\tshadowCamera.left = _min.x;\n\
\t\tshadowCamera.right = _max.x;\n\
\t\tshadowCamera.top = _max.y;\n\
\t\tshadowCamera.bottom = _min.y;\n\
\n\
\t\t// can't really fit near/far\n\
\t\t//shadowCamera.near = _min.z;\n\
\t\t//shadowCamera.far = _max.z;\n\
\n\
\t\tshadowCamera.updateProjectionMatrix();\n\
\n\
\t}\n\
\n\
\t// For the moment just ignore objects that have multiple materials with different animation methods\n\
\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\n\
\n\
\tfunction getObjectMaterial( object ) {\n\
\n\
\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\
\t\t\t? object.material.materials[ 0 ]\n\
\t\t\t: object.material;\n\
\n\
\t};\n\
\n\
};\n\
\n\
THREE.ShadowMapPlugin.__projector = new THREE.Projector();\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.SpritePlugin = function () {\n\
\n\
\tvar _gl, _renderer, _precision, _sprite = {};\n\
\n\
\tthis.init = function ( renderer ) {\n\
\n\
\t\t_gl = renderer.context;\n\
\t\t_renderer = renderer;\n\
\n\
\t\t_precision = renderer.getPrecision();\n\
\n\
\t\t_sprite.vertices = new Float32Array( 8 + 8 );\n\
\t\t_sprite.faces    = new Uint16Array( 6 );\n\
\n\
\t\tvar i = 0;\n\
\n\
\t\t_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = -1;\t// vertex 0\n\
\t\t_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 0;\t// uv 0\n\
\n\
\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = -1;\t// vertex 1\n\
\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 0;\t// uv 1\n\
\n\
\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;\t// vertex 2\n\
\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;\t// uv 2\n\
\n\
\t\t_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = 1;\t// vertex 3\n\
\t\t_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 1;\t// uv 3\n\
\n\
\t\ti = 0;\n\
\n\
\t\t_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 1; _sprite.faces[ i++ ] = 2;\n\
\t\t_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 2; _sprite.faces[ i++ ] = 3;\n\
\n\
\t\t_sprite.vertexBuffer  = _gl.createBuffer();\n\
\t\t_sprite.elementBuffer = _gl.createBuffer();\n\
\n\
\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );\n\
\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW );\n\
\n\
\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );\n\
\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW );\n\
\n\
\t\t_sprite.program = createProgram( THREE.ShaderSprite[ \"sprite\" ], _precision );\n\
\n\
\t\t_sprite.attributes = {};\n\
\t\t_sprite.uniforms = {};\n\
\n\
\t\t_sprite.attributes.position           = _gl.getAttribLocation ( _sprite.program, \"position\" );\n\
\t\t_sprite.attributes.uv                 = _gl.getAttribLocation ( _sprite.program, \"uv\" );\n\
\n\
\t\t_sprite.uniforms.uvOffset             = _gl.getUniformLocation( _sprite.program, \"uvOffset\" );\n\
\t\t_sprite.uniforms.uvScale              = _gl.getUniformLocation( _sprite.program, \"uvScale\" );\n\
\n\
\t\t_sprite.uniforms.rotation             = _gl.getUniformLocation( _sprite.program, \"rotation\" );\n\
\t\t_sprite.uniforms.scale                = _gl.getUniformLocation( _sprite.program, \"scale\" );\n\
\t\t_sprite.uniforms.alignment            = _gl.getUniformLocation( _sprite.program, \"alignment\" );\n\
\n\
\t\t_sprite.uniforms.color                = _gl.getUniformLocation( _sprite.program, \"color\" );\n\
\t\t_sprite.uniforms.map                  = _gl.getUniformLocation( _sprite.program, \"map\" );\n\
\t\t_sprite.uniforms.opacity              = _gl.getUniformLocation( _sprite.program, \"opacity\" );\n\
\n\
\t\t_sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation( _sprite.program, \"useScreenCoordinates\" );\n\
\t\t_sprite.uniforms.sizeAttenuation   \t  = _gl.getUniformLocation( _sprite.program, \"sizeAttenuation\" );\n\
\t\t_sprite.uniforms.screenPosition    \t  = _gl.getUniformLocation( _sprite.program, \"screenPosition\" );\n\
\t\t_sprite.uniforms.modelViewMatrix      = _gl.getUniformLocation( _sprite.program, \"modelViewMatrix\" );\n\
\t\t_sprite.uniforms.projectionMatrix     = _gl.getUniformLocation( _sprite.program, \"projectionMatrix\" );\n\
\n\
\t\t_sprite.uniforms.fogType \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogType\" );\n\
\t\t_sprite.uniforms.fogDensity \t\t  = _gl.getUniformLocation( _sprite.program, \"fogDensity\" );\n\
\t\t_sprite.uniforms.fogNear \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogNear\" );\n\
\t\t_sprite.uniforms.fogFar \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogFar\" );\n\
\t\t_sprite.uniforms.fogColor \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogColor\" );\n\
\n\
\t\t_sprite.uniforms.alphaTest \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"alphaTest\" );\n\
\n\
\t};\n\
\n\
\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\n\
\n\
\t\tvar sprites = scene.__webglSprites,\n\
\t\t\tnSprites = sprites.length;\n\
\n\
\t\tif ( ! nSprites ) return;\n\
\n\
\t\tvar attributes = _sprite.attributes,\n\
\t\t\tuniforms = _sprite.uniforms;\n\
\n\
\t\tvar invAspect = viewportHeight / viewportWidth;\n\
\n\
\t\tvar halfViewportWidth = viewportWidth * 0.5,\n\
\t\t\thalfViewportHeight = viewportHeight * 0.5;\n\
\n\
\t\t// setup gl\n\
\n\
\t\t_gl.useProgram( _sprite.program );\n\
\n\
\t\t_gl.enableVertexAttribArray( attributes.position );\n\
\t\t_gl.enableVertexAttribArray( attributes.uv );\n\
\n\
\t\t_gl.disable( _gl.CULL_FACE );\n\
\t\t_gl.enable( _gl.BLEND );\n\
\n\
\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );\n\
\t\t_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );\n\
\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\n\
\n\
\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );\n\
\n\
\t\t_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\
\n\
\t\t_gl.activeTexture( _gl.TEXTURE0 );\n\
\t\t_gl.uniform1i( uniforms.map, 0 );\n\
\n\
\t\tvar oldFogType = 0;\n\
\t\tvar sceneFogType = 0;\n\
\t\tvar fog = scene.fog;\n\
\n\
\t\tif ( fog ) {\n\
\n\
\t\t\t_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\
\n\
\t\t\tif ( fog instanceof THREE.Fog ) {\n\
\n\
\t\t\t\t_gl.uniform1f( uniforms.fogNear, fog.near );\n\
\t\t\t\t_gl.uniform1f( uniforms.fogFar, fog.far );\n\
\n\
\t\t\t\t_gl.uniform1i( uniforms.fogType, 1 );\n\
\t\t\t\toldFogType = 1;\n\
\t\t\t\tsceneFogType = 1;\n\
\n\
\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\
\n\
\t\t\t\t_gl.uniform1f( uniforms.fogDensity, fog.density );\n\
\n\
\t\t\t\t_gl.uniform1i( uniforms.fogType, 2 );\n\
\t\t\t\toldFogType = 2;\n\
\t\t\t\tsceneFogType = 2;\n\
\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\n\
\t\t\t_gl.uniform1i( uniforms.fogType, 0 );\n\
\t\t\toldFogType = 0;\n\
\t\t\tsceneFogType = 0;\n\
\n\
\t\t}\n\
\n\
\n\
\t\t// update positions and sort\n\
\n\
\t\tvar i, sprite, material, screenPosition, size, fogType, scale = [];\n\
\n\
\t\tfor( i = 0; i < nSprites; i ++ ) {\n\
\n\
\t\t\tsprite = sprites[ i ];\n\
\t\t\tmaterial = sprite.material;\n\
\n\
\t\t\tif ( ! sprite.visible || material.opacity === 0 ) continue;\n\
\n\
\t\t\tif ( ! material.useScreenCoordinates ) {\n\
\n\
\t\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\
\t\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\n\
\n\
\t\t\t} else {\n\
\n\
\t\t\t\tsprite.z = - sprite.position.z;\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\tsprites.sort( painterSortStable );\n\
\n\
\t\t// render all sprites\n\
\n\
\t\tfor( i = 0; i < nSprites; i ++ ) {\n\
\n\
\t\t\tsprite = sprites[ i ];\n\
\t\t\tmaterial = sprite.material;\n\
\n\
\t\t\tif ( ! sprite.visible || material.opacity === 0 ) continue;\n\
\n\
\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\n\
\n\
\t\t\t\t_gl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\
\n\
\t\t\t\tif ( material.useScreenCoordinates === true ) {\n\
\n\
\t\t\t\t\t_gl.uniform1i( uniforms.useScreenCoordinates, 1 );\n\
\t\t\t\t\t_gl.uniform3f(\n\
\t\t\t\t\t\tuniforms.screenPosition,\n\
\t\t\t\t\t\t( ( sprite.position.x * _renderer.devicePixelRatio ) - halfViewportWidth  ) / halfViewportWidth,\n\
\t\t\t\t\t\t( halfViewportHeight - ( sprite.position.y * _renderer.devicePixelRatio ) ) / halfViewportHeight,\n\
\t\t\t\t\t\tMath.max( 0, Math.min( 1, sprite.position.z ) )\n\
\t\t\t\t\t);\n\
\n\
\t\t\t\t\tscale[ 0 ] = _renderer.devicePixelRatio;\n\
\t\t\t\t\tscale[ 1 ] = _renderer.devicePixelRatio;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t_gl.uniform1i( uniforms.useScreenCoordinates, 0 );\n\
\t\t\t\t\t_gl.uniform1i( uniforms.sizeAttenuation, material.sizeAttenuation ? 1 : 0 );\n\
\t\t\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\n\
\n\
\t\t\t\t\tscale[ 0 ] = 1;\n\
\t\t\t\t\tscale[ 1 ] = 1;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( scene.fog && material.fog ) {\n\
\n\
\t\t\t\t\tfogType = sceneFogType;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tfogType = 0;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( oldFogType !== fogType ) {\n\
\n\
\t\t\t\t\t_gl.uniform1i( uniforms.fogType, fogType );\n\
\t\t\t\t\toldFogType = fogType;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tsize = 1 / ( material.scaleByViewport ? viewportHeight : 1 );\n\
\n\
\t\t\t\tscale[ 0 ] *= size * invAspect * sprite.scale.x\n\
\t\t\t\tscale[ 1 ] *= size * sprite.scale.y;\n\
\n\
\t\t\t\t_gl.uniform2f( uniforms.uvScale, material.uvScale.x, material.uvScale.y );\n\
\t\t\t\t_gl.uniform2f( uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y );\n\
\t\t\t\t_gl.uniform2f( uniforms.alignment, material.alignment.x, material.alignment.y );\n\
\n\
\t\t\t\t_gl.uniform1f( uniforms.opacity, material.opacity );\n\
\t\t\t\t_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\
\n\
\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\n\
\t\t\t\t_gl.uniform2fv( uniforms.scale, scale );\n\
\n\
\t\t\t\t_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\
\t\t\t\t_renderer.setDepthTest( material.depthTest );\n\
\t\t\t\t_renderer.setDepthWrite( material.depthWrite );\n\
\t\t\t\t_renderer.setTexture( material.map, 0 );\n\
\n\
\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// restore gl\n\
\n\
\t\t_gl.enable( _gl.CULL_FACE );\n\
\n\
\t};\n\
\n\
\tfunction createProgram ( shader, precision ) {\n\
\n\
\t\tvar program = _gl.createProgram();\n\
\n\
\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\
\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\n\
\n\
\t\tvar prefix = \"precision \" + precision + \" float;\\n\
\";\n\
\n\
\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\
\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\
\n\
\t\t_gl.compileShader( fragmentShader );\n\
\t\t_gl.compileShader( vertexShader );\n\
\n\
\t\t_gl.attachShader( program, fragmentShader );\n\
\t\t_gl.attachShader( program, vertexShader );\n\
\n\
\t\t_gl.linkProgram( program );\n\
\n\
\t\treturn program;\n\
\n\
\t};\n\
\n\
\tfunction painterSortStable ( a, b ) {\n\
\n\
\t\tif ( a.z !== b.z ) {\n\
\n\
\t\t\treturn b.z - a.z;\n\
\n\
\t\t} else {\n\
\n\
\t\t\treturn b.id - a.id;\n\
\n\
\t\t}\n\
\n\
\t};\n\
\n\
};\n\
\n\
/**\n\
 * @author alteredq / http://alteredqualia.com/\n\
 */\n\
\n\
THREE.DepthPassPlugin = function () {\n\
\n\
\tthis.enabled = false;\n\
\tthis.renderTarget = null;\n\
\n\
\tvar _gl,\n\
\t_renderer,\n\
\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\n\
\n\
\t_frustum = new THREE.Frustum(),\n\
\t_projScreenMatrix = new THREE.Matrix4();\n\
\n\
\tthis.init = function ( renderer ) {\n\
\n\
\t\t_gl = renderer.context;\n\
\t\t_renderer = renderer;\n\
\n\
\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\n\
\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\
\n\
\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n\
\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\n\
\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\n\
\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\n\
\n\
\t\t_depthMaterial._shadowPass = true;\n\
\t\t_depthMaterialMorph._shadowPass = true;\n\
\t\t_depthMaterialSkin._shadowPass = true;\n\
\t\t_depthMaterialMorphSkin._shadowPass = true;\n\
\n\
\t};\n\
\n\
\tthis.render = function ( scene, camera ) {\n\
\n\
\t\tif ( ! this.enabled ) return;\n\
\n\
\t\tthis.update( scene, camera );\n\
\n\
\t};\n\
\n\
\tthis.update = function ( scene, camera ) {\n\
\n\
\t\tvar i, il, j, jl, n,\n\
\n\
\t\tprogram, buffer, material,\n\
\t\twebglObject, object, light,\n\
\t\trenderList,\n\
\n\
\t\tfog = null;\n\
\n\
\t\t// set GL state for depth map\n\
\n\
\t\t_gl.clearColor( 1, 1, 1, 1 );\n\
\t\t_gl.disable( _gl.BLEND );\n\
\n\
\t\t_renderer.setDepthTest( true );\n\
\n\
\t\t// update scene\n\
\n\
\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\
\n\
\t\t// update camera matrices and frustum\n\
\n\
\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\
\n\
\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\
\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\
\n\
\t\t// render depth map\n\
\n\
\t\t_renderer.setRenderTarget( this.renderTarget );\n\
\t\t_renderer.clear();\n\
\n\
\t\t// set object matrices & frustum culling\n\
\n\
\t\trenderList = scene.__webglObjects;\n\
\n\
\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\
\n\
\t\t\twebglObject = renderList[ j ];\n\
\t\t\tobject = webglObject.object;\n\
\n\
\t\t\twebglObject.render = false;\n\
\n\
\t\t\tif ( object.visible ) {\n\
\n\
\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\
\n\
\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\
\n\
\t\t\t\t\twebglObject.render = true;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// render regular objects\n\
\n\
\t\tvar objectMaterial, useMorphing, useSkinning;\n\
\n\
\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\
\n\
\t\t\twebglObject = renderList[ j ];\n\
\n\
\t\t\tif ( webglObject.render ) {\n\
\n\
\t\t\t\tobject = webglObject.object;\n\
\t\t\t\tbuffer = webglObject.buffer;\n\
\n\
\t\t\t\t// todo: create proper depth material for particles\n\
\n\
\t\t\t\tif ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;\n\
\n\
\t\t\t\tobjectMaterial = getObjectMaterial( object );\n\
\n\
\t\t\t\tif ( objectMaterial ) _renderer.setMaterialFaces( object.material );\n\
\n\
\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n\
\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n\
\n\
\t\t\t\tif ( object.customDepthMaterial ) {\n\
\n\
\t\t\t\t\tmaterial = object.customDepthMaterial;\n\
\n\
\t\t\t\t} else if ( useSkinning ) {\n\
\n\
\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n\
\n\
\t\t\t\t} else if ( useMorphing ) {\n\
\n\
\t\t\t\t\tmaterial = _depthMaterialMorph;\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\tmaterial = _depthMaterial;\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\
\n\
\t\t\t\t\t_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );\n\
\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );\n\
\n\
\t\t\t\t}\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// set matrices and render immediate objects\n\
\n\
\t\trenderList = scene.__webglObjectsImmediate;\n\
\n\
\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\
\n\
\t\t\twebglObject = renderList[ j ];\n\
\t\t\tobject = webglObject.object;\n\
\n\
\t\t\tif ( object.visible ) {\n\
\n\
\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\
\n\
\t\t\t\t_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );\n\
\n\
\t\t\t}\n\
\n\
\t\t}\n\
\n\
\t\t// restore GL state\n\
\n\
\t\tvar clearColor = _renderer.getClearColor(),\n\
\t\tclearAlpha = _renderer.getClearAlpha();\n\
\n\
\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\n\
\t\t_gl.enable( _gl.BLEND );\n\
\n\
\t};\n\
\n\
\t// For the moment just ignore objects that have multiple materials with different animation methods\n\
\t// Only the first material will be taken into account for deciding which depth material to use\n\
\n\
\tfunction getObjectMaterial( object ) {\n\
\n\
\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\
\t\t\t? object.material.materials[ 0 ]\n\
\t\t\t: object.material;\n\
\n\
\t};\n\
\n\
};\n\
\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 */\n\
\n\
THREE.ShaderFlares = {\n\
\n\
\t'lensFlareVertexTexture': {\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"uniform lowp int renderType;\",\n\
\n\
\t\t\t\"uniform vec3 screenPosition;\",\n\
\t\t\t\"uniform vec2 scale;\",\n\
\t\t\t\"uniform float rotation;\",\n\
\n\
\t\t\t\"uniform sampler2D occlusionMap;\",\n\
\n\
\t\t\t\"attribute vec2 position;\",\n\
\t\t\t\"attribute vec2 uv;\",\n\
\n\
\t\t\t\"varying vec2 vUV;\",\n\
\t\t\t\"varying float vVisibility;\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"vUV = uv;\",\n\
\n\
\t\t\t\t\"vec2 pos = position;\",\n\
\n\
\t\t\t\t\"if( renderType == 2 ) {\",\n\
\n\
\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\
\n\
\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\
\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\
\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\
\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\
\n\
\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\
\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join( \"\\n\
\" ),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform lowp int renderType;\",\n\
\n\
\t\t\t\"uniform sampler2D map;\",\n\
\t\t\t\"uniform float opacity;\",\n\
\t\t\t\"uniform vec3 color;\",\n\
\n\
\t\t\t\"varying vec2 vUV;\",\n\
\t\t\t\"varying float vVisibility;\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t// pink square\n\
\n\
\t\t\t\t\"if( renderType == 0 ) {\",\n\
\n\
\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\
\n\
\t\t\t\t// restore\n\
\n\
\t\t\t\t\"} else if( renderType == 1 ) {\",\n\
\n\
\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\
\n\
\t\t\t\t// flare\n\
\n\
\t\t\t\t\"} else {\",\n\
\n\
\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\
\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\
\t\t\t\t\t\"gl_FragColor = texture;\",\n\
\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\"}\"\n\
\t\t].join( \"\\n\
\" )\n\
\n\
\t},\n\
\n\
\n\
\t'lensFlare': {\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"uniform lowp int renderType;\",\n\
\n\
\t\t\t\"uniform vec3 screenPosition;\",\n\
\t\t\t\"uniform vec2 scale;\",\n\
\t\t\t\"uniform float rotation;\",\n\
\n\
\t\t\t\"attribute vec2 position;\",\n\
\t\t\t\"attribute vec2 uv;\",\n\
\n\
\t\t\t\"varying vec2 vUV;\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"vUV = uv;\",\n\
\n\
\t\t\t\t\"vec2 pos = position;\",\n\
\n\
\t\t\t\t\"if( renderType == 2 ) {\",\n\
\n\
\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\
\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join( \"\\n\
\" ),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"precision mediump float;\",\n\
\n\
\t\t\t\"uniform lowp int renderType;\",\n\
\n\
\t\t\t\"uniform sampler2D map;\",\n\
\t\t\t\"uniform sampler2D occlusionMap;\",\n\
\t\t\t\"uniform float opacity;\",\n\
\t\t\t\"uniform vec3 color;\",\n\
\n\
\t\t\t\"varying vec2 vUV;\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t// pink square\n\
\n\
\t\t\t\t\"if( renderType == 0 ) {\",\n\
\n\
\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\n\
\n\
\t\t\t\t// restore\n\
\n\
\t\t\t\t\"} else if( renderType == 1 ) {\",\n\
\n\
\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\
\n\
\t\t\t\t// flare\n\
\n\
\t\t\t\t\"} else {\",\n\
\n\
\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\n\
\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\n\
\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\n\
\n\
\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\
\t\t\t\t\t\"texture.a *= opacity * visibility;\",\n\
\t\t\t\t\t\"gl_FragColor = texture;\",\n\
\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join( \"\\n\
\" )\n\
\n\
\t}\n\
\n\
};\n\
\n\
/**\n\
 * @author mikael emtinger / http://gomo.se/\n\
 * @author alteredq / http://alteredqualia.com/\n\
 *\n\
 */\n\
\n\
THREE.ShaderSprite = {\n\
\n\
\t'sprite': {\n\
\n\
\t\tvertexShader: [\n\
\n\
\t\t\t\"uniform int useScreenCoordinates;\",\n\
\t\t\t\"uniform int sizeAttenuation;\",\n\
\t\t\t\"uniform vec3 screenPosition;\",\n\
\t\t\t\"uniform mat4 modelViewMatrix;\",\n\
\t\t\t\"uniform mat4 projectionMatrix;\",\n\
\t\t\t\"uniform float rotation;\",\n\
\t\t\t\"uniform vec2 scale;\",\n\
\t\t\t\"uniform vec2 alignment;\",\n\
\t\t\t\"uniform vec2 uvOffset;\",\n\
\t\t\t\"uniform vec2 uvScale;\",\n\
\n\
\t\t\t\"attribute vec2 position;\",\n\
\t\t\t\"attribute vec2 uv;\",\n\
\n\
\t\t\t\"varying vec2 vUV;\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"vUV = uvOffset + uv * uvScale;\",\n\
\n\
\t\t\t\t\"vec2 alignedPosition = position + alignment;\",\n\
\n\
\t\t\t\t\"vec2 rotatedPosition;\",\n\
\t\t\t\t\"rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;\",\n\
\t\t\t\t\"rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;\",\n\
\n\
\t\t\t\t\"vec4 finalPosition;\",\n\
\n\
\t\t\t\t\"if( useScreenCoordinates != 0 ) {\",\n\
\n\
\t\t\t\t\t\"finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );\",\n\
\n\
\t\t\t\t\"} else {\",\n\
\n\
\t\t\t\t\t\"finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\",\n\
\t\t\t\t\t\"finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\"gl_Position = finalPosition;\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join( \"\\n\
\" ),\n\
\n\
\t\tfragmentShader: [\n\
\n\
\t\t\t\"uniform vec3 color;\",\n\
\t\t\t\"uniform sampler2D map;\",\n\
\t\t\t\"uniform float opacity;\",\n\
\n\
\t\t\t\"uniform int fogType;\",\n\
\t\t\t\"uniform vec3 fogColor;\",\n\
\t\t\t\"uniform float fogDensity;\",\n\
\t\t\t\"uniform float fogNear;\",\n\
\t\t\t\"uniform float fogFar;\",\n\
\t\t\t\"uniform float alphaTest;\",\n\
\n\
\t\t\t\"varying vec2 vUV;\",\n\
\n\
\t\t\t\"void main() {\",\n\
\n\
\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\
\n\
\t\t\t\t\"if ( texture.a < alphaTest ) discard;\",\n\
\n\
\t\t\t\t\"gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\",\n\
\n\
\t\t\t\t\"if ( fogType > 0 ) {\",\n\
\n\
\t\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\
\t\t\t\t\t\"float fogFactor = 0.0;\",\n\
\n\
\t\t\t\t\t\"if ( fogType == 1 ) {\",\n\
\n\
\t\t\t\t\t\t\"fogFactor = smoothstep( fogNear, fogFar, depth );\",\n\
\n\
\t\t\t\t\t\"} else {\",\n\
\n\
\t\t\t\t\t\t\"const float LOG2 = 1.442695;\",\n\
\t\t\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\n\
\t\t\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\n\
\n\
\t\t\t\t\t\"}\",\n\
\n\
\t\t\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\n\
\n\
\t\t\t\t\"}\",\n\
\n\
\t\t\t\"}\"\n\
\n\
\t\t].join( \"\\n\
\" )\n\
\n\
\t}\n\
\n\
};\n\
//@ sourceURL=cvdlab-three/index.js"
));
require.register("cvdlab-three-detector/index.js", Function("exports, require, module",
"exports.canvas = !!window.CanvasRenderingContext2D,\n\
\n\
exports.webgl = (function () { \n\
  try { \n\
    return !!window.WebGLRenderingContext && !!document.createElement('canvas').getContext('experimental-webgl'); \n\
  } catch(e) { \n\
    return false; \n\
  } \n\
})();\n\
\n\
exports.workers = !! window.Worker;\n\
\n\
exports.fileapi = window.File && window.FileReader && window.FileList && window.Blob;\n\
\n\
exports.getWebGLErrorMessage = function () {\n\
  var domElement = document.createElement('div');\n\
\n\
  domElement.style.fontFamily = 'monospace';\n\
  domElement.style.fontSize = '13px';\n\
  domElement.style.textAlign = 'center';\n\
  domElement.style.background = '#eee';\n\
  domElement.style.color = '#000';\n\
  domElement.style.padding = '1em';\n\
  domElement.style.width = '475px';\n\
  domElement.style.margin = '5em auto 0';\n\
\n\
  if (! this.webgl) {\n\
\n\
    domElement.innerHTML = window.WebGLRenderingContext ? [\n\
      'Your graphics card does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\">WebGL</a>.<br />',\n\
      'Find out how to get it <a href=\"http://get.webgl.org/\">here</a>.'\n\
    ].join('\\n\
') : [\n\
      'Your browser does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\">WebGL</a>.<br/>',\n\
      'Find out how to get it <a href=\"http://get.webgl.org/\">here</a>.'\n\
    ].join('\\n\
');\n\
\n\
  }\n\
\n\
  return domElement;\n\
\n\
};\n\
\n\
exports.addGetWebGLMessage = function (parameters) {\n\
  var parent, id, domElement;\n\
\n\
  parameters = parameters || {};\n\
\n\
  parent = parameters.parent !== undefined ? parameters.parent : document.body;\n\
  id = parameters.id !== undefined ? parameters.id : 'oldie';\n\
\n\
  domElement = Detector.getWebGLErrorMessage();\n\
  domElement.id = id;\n\
\n\
  parent.appendChild(domElement);\n\
\n\
};\n\
//@ sourceURL=cvdlab-three-detector/index.js"
));
require.register("cvdlab-three-stats/index.js", Function("exports, require, module",
"exports.Stats = function () {\n\
  var h, a, n = 0,\n\
    o = 0,\n\
    i = Date.now(),\n\
    u = i,\n\
    p = i,\n\
    l = 0,\n\
    q = 1E3,\n\
    r = 0,\n\
    e, j, f, b = [\n\
      [16, 16, 48],\n\
      [0, 255, 255]\n\
    ],\n\
    m = 0,\n\
    s = 1E3,\n\
    t = 0,\n\
    d, k, g, c = [\n\
      [16, 48, 16],\n\
      [0, 255, 0]\n\
    ];\n\
  h = document.createElement(\"div\");\n\
  h.style.cursor = \"pointer\";\n\
  h.style.width = \"80px\";\n\
  h.style.opacity = \"0.9\";\n\
  h.style.zIndex = \"10001\";\n\
  h.addEventListener(\"mousedown\", function (a) {\n\
    a.preventDefault();\n\
    n = (n + 1) % 2;\n\
    n == 0 ? (e.style.display = \"block\", d.style.display = \"none\") : (e.style.display = \"none\", d.style.display = \"block\")\n\
  }, !1);\n\
  e = document.createElement(\"div\");\n\
  e.style.textAlign =\n\
    \"left\";\n\
  e.style.lineHeight = \"1.2em\";\n\
  e.style.backgroundColor = \"rgb(\" + Math.floor(b[0][0] / 2) + \",\" + Math.floor(b[0][1] / 2) + \",\" + Math.floor(b[0][2] / 2) + \")\";\n\
  e.style.padding = \"0 0 3px 3px\";\n\
  h.appendChild(e);\n\
  j = document.createElement(\"div\");\n\
  j.style.fontFamily = \"Helvetica, Arial, sans-serif\";\n\
  j.style.fontSize = \"9px\";\n\
  j.style.color = \"rgb(\" + b[1][0] + \",\" + b[1][1] + \",\" + b[1][2] + \")\";\n\
  j.style.fontWeight = \"bold\";\n\
  j.innerHTML = \"FPS\";\n\
  e.appendChild(j);\n\
  f = document.createElement(\"div\");\n\
  f.style.position = \"relative\";\n\
  f.style.width = \"74px\";\n\
  f.style.height =\n\
    \"30px\";\n\
  f.style.backgroundColor = \"rgb(\" + b[1][0] + \",\" + b[1][1] + \",\" + b[1][2] + \")\";\n\
  for (e.appendChild(f); f.children.length < 74;) a = document.createElement(\"span\"), a.style.width = \"1px\", a.style.height = \"30px\", a.style.cssFloat = \"left\", a.style.backgroundColor = \"rgb(\" + b[0][0] + \",\" + b[0][1] + \",\" + b[0][2] + \")\", f.appendChild(a);\n\
  d = document.createElement(\"div\");\n\
  d.style.textAlign = \"left\";\n\
  d.style.lineHeight = \"1.2em\";\n\
  d.style.backgroundColor = \"rgb(\" + Math.floor(c[0][0] / 2) + \",\" + Math.floor(c[0][1] / 2) + \",\" + Math.floor(c[0][2] / 2) + \")\";\n\
  d.style.padding =\n\
    \"0 0 3px 3px\";\n\
  d.style.display = \"none\";\n\
  h.appendChild(d);\n\
  k = document.createElement(\"div\");\n\
  k.style.fontFamily = \"Helvetica, Arial, sans-serif\";\n\
  k.style.fontSize = \"9px\";\n\
  k.style.color = \"rgb(\" + c[1][0] + \",\" + c[1][1] + \",\" + c[1][2] + \")\";\n\
  k.style.fontWeight = \"bold\";\n\
  k.innerHTML = \"MS\";\n\
  d.appendChild(k);\n\
  g = document.createElement(\"div\");\n\
  g.style.position = \"relative\";\n\
  g.style.width = \"74px\";\n\
  g.style.height = \"30px\";\n\
  g.style.backgroundColor = \"rgb(\" + c[1][0] + \",\" + c[1][1] + \",\" + c[1][2] + \")\";\n\
  for (d.appendChild(g); g.children.length < 74;) a = document.createElement(\"span\"),\n\
  a.style.width = \"1px\", a.style.height = Math.random() * 30 + \"px\", a.style.cssFloat = \"left\", a.style.backgroundColor = \"rgb(\" + c[0][0] + \",\" + c[0][1] + \",\" + c[0][2] + \")\", g.appendChild(a);\n\
  return {\n\
    domElement: h,\n\
    update: function () {\n\
      i = Date.now();\n\
      m = i - u;\n\
      s = Math.min(s, m);\n\
      t = Math.max(t, m);\n\
      k.textContent = m + \" MS (\" + s + \"-\" + t + \")\";\n\
      var a = Math.min(30, 30 - m / 200 * 30);\n\
      g.appendChild(g.firstChild).style.height = a + \"px\";\n\
      u = i;\n\
      o++;\n\
      if (i > p + 1E3) l = Math.round(o * 1E3 / (i - p)), q = Math.min(q, l), r = Math.max(r, l), j.textContent = l + \" FPS (\" + q + \"-\" + r + \")\", a = Math.min(30, 30 - l / 100 * 30), f.appendChild(f.firstChild).style.height = a + \"px\", p = i, o = 0\n\
    }\n\
  }\n\
};//@ sourceURL=cvdlab-three-stats/index.js"
));
require.register("cvdlab-three-trackball/index.js", Function("exports, require, module",
"var THREE = require('three');\n\
\n\
module.exports = function (object, scene, domElement) {\n\
\n\
  steady = object;\n\
\n\
  var _this = this;\n\
  var scene;\n\
  var STATE = { NONE : -1, ROTATE : 0, ZOOM : 1, PAN : 2 };\n\
  var keys = {\n\
    r: 82,\n\
    c: 67,\n\
    v: 86,\n\
    bar: 32,\n\
    axis: {\n\
      x: 88,\n\
      y: 89,\n\
      z: 90\n\
    },\n\
    arrows: {\n\
      left: 37,\n\
      up: 38,\n\
      right: 39,\n\
      down: 40\n\
    }\n\
  };\n\
  var boundingRadius = 10;\n\
  var resetPosition = object.position.clone();\n\
  var resetMatrix = object.matrix.clone();\n\
  var resetUp = new THREE.Vector3(0,0,1);\n\
  var light = new THREE.SpotLight(0xcccccc);\n\
\n\
  light.position = object.position.clone();\n\
  light.matrix = object.matrix.clone();\n\
  scene.root.add(light);\n\
\n\
  this.object = object;\n\
  this.domElement = (domElement !== undefined) ? domElement : document;\n\
\n\
  var input = this.input = document.createElement('input');\n\
  input.setAttribute('id', 'three-trackball-input');\n\
  input.setAttribute('type', 'text');\n\
  input.setAttribute('autofocus', 'autofocus');\n\
  input.style.position = 'absolute';\n\
  input.style.width = '0px';\n\
  input.style.left = '-1000px';\n\
  domElement.appendChild(input);\n\
\n\
  // API\n\
\n\
  this.enabled = true;\n\
\n\
  this.screen = { width: window.innerWidth, height: window.innerHeight, offsetLeft: 0, offsetTop: 0 };\n\
  this.radius = (this.screen.width + this.screen.height) / 4;\n\
\n\
  this.rotateSpeed = 1.0;\n\
  this.zoomSpeed = 1.8;\n\
  this.panSpeed = 0.1;\n\
\n\
  this.noRotate = false;\n\
  this.noZoom = false;\n\
  this.noPan = false;\n\
\n\
  // this.staticMoving = false;\n\
  this.dynamicDampingFactor = 0.1;\n\
\n\
  this.minDistance = 0;\n\
  this.maxDistance = Infinity;\n\
\n\
  // internals\n\
\n\
  this.target = new THREE.Vector3(0, 0, 0);\n\
\n\
  var _keyPressed = false,\n\
  _state = STATE.NONE,\n\
\n\
  _eye = new THREE.Vector3(),\n\
\n\
  _rotateStart = new THREE.Vector3(),\n\
  _rotateEnd = new THREE.Vector3(),\n\
\n\
  _zoom = 0\n\
\n\
  _pan = new THREE.Vector2();\n\
\n\
\n\
  // methods\n\
\n\
  this.handleEvent = function (event) {\n\
    if (typeof this[ event.type ] == 'function') {\n\
      this[ event.type ](event);\n\
    }\n\
  };\n\
\n\
  this.getMouseOnScreen = function(clientX, clientY) {\n\
    return new THREE.Vector2(\n\
      (clientX - _this.screen.offsetLeft) / _this.radius * 0.5,\n\
      (clientY - _this.screen.offsetTop) / _this.radius * 0.5\n\
   );\n\
  };\n\
\n\
  this.getMouseProjectionOnBall = function(clientX, clientY) {\n\
    var mouseOnBall = new THREE.Vector3(\n\
      (clientX - _this.screen.width * 0.5 - _this.screen.offsetLeft) / _this.radius,\n\
      (_this.screen.height * 0.5 + _this.screen.offsetTop - clientY) / _this.radius,\n\
      0.0\n\
   );\n\
\n\
    var length = mouseOnBall.length();\n\
\n\
    if (length > 1.0) {\n\
      mouseOnBall.normalize();\n\
    } else {\n\
      mouseOnBall.z = Math.sqrt(1.0 - length * length);\n\
    }\n\
    _eye.copy(_this.object.position).subSelf(_this.target);\n\
\n\
    var projection = _this.object.up.clone().setLength(mouseOnBall.y);\n\
    projection.addSelf(_this.object.up.clone().crossSelf(_eye).setLength(mouseOnBall.x));\n\
    projection.addSelf(_eye.setLength(mouseOnBall.z));\n\
\n\
    return projection;\n\
  };\n\
\n\
  this.rotateCamera = function() {\n\
    var angle = Math.acos(_rotateStart.dot(_rotateEnd) / _rotateStart.length() / _rotateEnd.length());\n\
\n\
    if (angle) {\n\
      var axis = (new THREE.Vector3()).cross(_rotateStart, _rotateEnd).normalize();\n\
      var quaternion = new THREE.Quaternion();\n\
      angle *= _this.rotateSpeed;\n\
      quaternion.setFromAxisAngle(axis, -angle);\n\
      quaternion.multiplyVector3(_eye);\n\
      quaternion.multiplyVector3(_this.object.up);\n\
      quaternion.multiplyVector3(_rotateEnd);\n\
\n\
      if (_this.staticMoving) {\n\
        _rotateStart = _rotateEnd;\n\
      } else {\n\
        quaternion.setFromAxisAngle(axis, angle * (_this.dynamicDampingFactor - 1.0));\n\
        quaternion.multiplyVector3(_rotateStart);\n\
      }\n\
    }\n\
  };\n\
\n\
  this.zoomCamera = function() {\n\
    var factor = 1.0 + _zoom * _this.zoomSpeed;\n\
\n\
    if (factor !== 1.0 && factor > 0.0) {\n\
      _eye.multiplyScalar(factor);\n\
    }\n\
\n\
    _zoom = 0;\n\
  };\n\
\n\
  this.panCamera = function() {\n\
    if (_pan.lengthSq()) {\n\
      _pan.multiplyScalar(_eye.length() * _this.panSpeed);\n\
\n\
      var pan = _eye.clone().crossSelf(_this.object.up).setLength(_pan.x);\n\
      pan.addSelf(_this.object.up.clone().setLength(_pan.y));\n\
\n\
      _this.object.position.addSelf(pan);\n\
      _this.target.addSelf(pan);\n\
\n\
      light.position.addSelf(pan);\n\
\n\
      _pan = new THREE.Vector3();\n\
    }\n\
  };\n\
\n\
  this.checkDistances = function() {\n\
    if (!_this.noZoom || !_this.noPan) {\n\
      if (_this.object.position.lengthSq() > _this.maxDistance * _this.maxDistance) {\n\
        _this.object.position.setLength(_this.maxDistance);\n\
      }\n\
      if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {\n\
        _this.object.position.add(_this.target, _eye.setLength(_this.minDistance));\n\
      }\n\
    }\n\
  };\n\
\n\
  this.update = function() {\n\
    _eye.copy(_this.object.position).subSelf(_this.target);\n\
\n\
    if (!_this.noRotate) {\n\
      _this.rotateCamera();\n\
    }\n\
\n\
    if (!_this.noZoom) {\n\
      _this.zoomCamera();\n\
    }\n\
\n\
    if (!_this.noPan) {\n\
      _this.panCamera();\n\
    }\n\
\n\
    _this.object.position.add(_this.target, _eye);\n\
    light.position.copy(_this.object.position);\n\
    _this.checkDistances();\n\
    _this.object.lookAt(_this.target);\n\
    light.matrix.copy(_this.object.matrix);\n\
  };\n\
\n\
  this.resetCamera = function() {\n\
    console.log('Resetting camera...');\n\
    _state = STATE.NONE;\n\
    _this.object.position = resetPosition.clone();\n\
    light.position = resetPosition.clone();\n\
    _this.object.up = resetUp.clone();\n\
    _this.object.matrix = resetMatrix.clone();\n\
    light.matrix = resetMatrix.clone();\n\
    _this.object.rotation.setEulerFromRotationMatrix(_this.object.matrix);\n\
    light.rotation.setEulerFromRotationMatrix(light.matrix);\n\
\n\
    _this.target = new THREE.Vector3();\n\
    _eye = new THREE.Vector3();\n\
    _rotateStart = new THREE.Vector3();\n\
    _rotateEnd = new THREE.Vector3();\n\
    _zoom = 0;\n\
    _pan = new THREE.Vector2();\n\
  };\n\
\n\
  this.placeCamera = function(vector, target, up) {\n\
    console.log('Placing camera...');\n\
    _state = STATE.NONE;\n\
    _this.object.position = vector || _this.object.position\n\
    light.position = _this.object.position.clone();\n\
    _this.object.up = up || _this.object.up || new THREE.Vector3();\n\
    target && _this.object.lookAt(target);\n\
    target && light.lookAt(target);\n\
\n\
    _this.target = target;\n\
    _eye = new THREE.Vector3();\n\
    _rotateStart = new THREE.Vector3();\n\
    _rotateEnd = new THREE.Vector3();\n\
    _zoom = 0;\n\
    _pan = new THREE.Vector2();\n\
  };\n\
\n\
  this.useCentroid = function() {\n\
    var centroid = scene.getCentroid();\n\
    _this.placeCamera(undefined, centroid);\n\
  };\n\
\n\
  this.viewAll = function() {\n\
    var centroid = scene.getCentroid();\n\
    var boundingRadius = scene.getBoundingRadius();\n\
    var vector = (new THREE.Vector3(0,0, boundingRadius)).addSelf(resetPosition);\n\
\n\
    _this.placeCamera(vector, centroid);\n\
  };\n\
\n\
  // listeners\n\
\n\
  function keydown(event) {\n\
    var keyCode = event.keyCode;\n\
    var shiftKey = event.shiftKey;\n\
    var bigStep = +shiftKey*boundingRadius/2 + 1;\n\
\n\
    if (! _this.enabled) return;\n\
    if (_state !== STATE.NONE) {\n\
      return;\n\
    }\n\
\n\
    if (keyCode === keys.r) {\n\
      _this.resetCamera();\n\
    } else if (keyCode === keys.c) {\n\
      _this.useCentroid();\n\
    } else if (keyCode === keys.v) {\n\
     _this.viewAll();\n\
    } else if (keyCode === keys.axis.x) {\n\
      boundingRadius = scene.getBoundingRadius();\n\
      _this.placeCamera(new THREE.Vector3(1.8*boundingRadius, 0, 0), new THREE.Vector3(), new THREE.Vector3(0,0,1));\n\
    } else if (keyCode === keys.axis.y) {\n\
      boundingRadius = scene.getBoundingRadius();\n\
      _this.placeCamera(new THREE.Vector3(0, 1.8*boundingRadius, 0), new THREE.Vector3(), new THREE.Vector3(0,0,1));\n\
    } else if (keyCode === keys.axis.z) {\n\
      boundingRadius = scene.getBoundingRadius();\n\
      _this.placeCamera(new THREE.Vector3(0, 0, 1.8*boundingRadius), new THREE.Vector3(), new THREE.Vector3(0,1,0));\n\
    } else if (keyCode === keys.arrows.left && !_this.noPan) {\n\
      _state = STATE.PAN;\n\
      _pan = new THREE.Vector3(0.1 * bigStep,0,0);\n\
    } else if (keyCode === keys.arrows.up && !_this.noPan) {\n\
      _state = STATE.PAN;\n\
      _pan = new THREE.Vector3(0,0.1 * bigStep,0);\n\
    } else if (keyCode === keys.arrows.right && !_this.noPan) {\n\
      _state = STATE.PAN;\n\
      _pan = new THREE.Vector3(-0.1 * bigStep,0,0);\n\
    } else if (keyCode === keys.arrows.down  && !_this.noPan) {\n\
      _state = STATE.PAN;\n\
      _pan = new THREE.Vector3(0,-0.1 * bigStep,0);\n\
    }\n\
  };\n\
\n\
  function keyup(event) {\n\
    if (! _this.enabled) return;\n\
    if (_state !== STATE.NONE) {\n\
      _state = STATE.NONE;\n\
    }\n\
  };\n\
\n\
  function mousedown(event) {\n\
\n\
    if (! _this.enabled) return;\n\
\n\
    event.preventDefault();\n\
    // event.stopPropagation();\n\
\n\
    if (_state === STATE.NONE) {\n\
      _state = event.button;\n\
      if (_state === STATE.ROTATE && !_this.noRotate) {\n\
        _rotateStart = _rotateEnd = _this.getMouseProjectionOnBall(event.clientX, event.clientY);\n\
      } else if (_state === STATE.ZOOM && !_this.noZoom) {\n\
        _zoomStart = _zoomEnd = _this.getMouseOnScreen(event.clientX, event.clientY);\n\
      } else if (!this.noPan) {\n\
        _panStart = _panEnd = _this.getMouseOnScreen(event.clientX, event.clientY);\n\
      }\n\
    }\n\
  };\n\
\n\
  function mousemove(event) {\n\
\n\
    if (! _this.enabled) return;\n\
\n\
    if (_keyPressed) {\n\
      _rotateStart = _rotateEnd = _this.getMouseProjectionOnBall(event.clientX, event.clientY);\n\
      _zoomStart = _zoomEnd = _this.getMouseOnScreen(event.clientX, event.clientY);\n\
      _panStart = _panEnd = _this.getMouseOnScreen(event.clientX, event.clientY);\n\
\n\
      _keyPressed = false;\n\
    }\n\
\n\
    if (_state === STATE.NONE) {\n\
\n\
      return;\n\
\n\
    } else if (_state === STATE.ROTATE && !_this.noRotate) {\n\
      _rotateEnd = _this.getMouseProjectionOnBall(event.clientX, event.clientY);\n\
    } else if (_state === STATE.ZOOM && !_this.noZoom) {\n\
      _zoomEnd = _this.getMouseOnScreen(event.clientX, event.clientY);\n\
    } else if (_state === STATE.PAN && !_this.noPan) {\n\
      _panEnd = _this.getMouseOnScreen(event.clientX, event.clientY);\n\
    }\n\
\n\
  };\n\
\n\
  function mouseup (event) {\n\
\n\
    if (! _this.enabled) return;\n\
\n\
    event.preventDefault();\n\
    // event.stopPropagation();\n\
\n\
    _state = STATE.NONE;\n\
\n\
  };\n\
\n\
  function wheelZoomCamera (event) {\n\
    _zoom = event.wheelDeltaY / 10000;\n\
  }\n\
\n\
  function preventDefault (event) {\n\
    event.preventDefault();\n\
  }\n\
\n\
  function click (event) {\n\
    input.focus();\n\
  }\n\
\n\
  this.domElement.addEventListener('contextmenu', preventDefault, false);\n\
\n\
  this.domElement.addEventListener('mousemove', mousemove, false);\n\
  this.domElement.addEventListener('mousedown', mousedown, false);\n\
  this.domElement.addEventListener('mouseup', mouseup, false);\n\
\n\
  this.domElement.addEventListener('mousewheel', wheelZoomCamera, false);\n\
  this.domElement.addEventListener('click', click, false);\n\
\n\
  input.addEventListener('keydown', keydown, false);\n\
  input.addEventListener('keyup', keyup, false);\n\
\n\
  this.resetCamera();\n\
\n\
};//@ sourceURL=cvdlab-three-trackball/index.js"
));

require.register("cvdlab-plasm/index.js", Function("exports, require, module",
"/* !\n\
 * plasm\n\
 * JavaScript Programming Language for Solid Modeling\n\
 * Copyright (c) 2012 Enrico Marino and Federico Spini\n\
 * MIT License\n\
 */\n\
\n\
/**\n\
 * Library dependencies.\n\
 */\n\
\n\
var THREE = require('three');\n\
var detector = require('three-detector');\n\
var Stats = require('three-stats');\n\
var Trackball = require('three-trackball');\n\
var simplexn = require('simplexn');\n\
\n\
var toString = {}.toString;\n\
var max = Math.max;\n\
var min = Math.min;\n\
var abs = Math.abs;\n\
\n\
/**\n\
 * Library namespace\n\
 */\n\
\n\
var plasm = exports;\n\
\n\
/**\n\
 * Library version.\n\
 */\n\
\n\
plasm.version = '0.3.0';\n\
\n\
\n\
/*\n\
 * @intro Create the plasm viewer.\n\
 * @param {Element} container\n\
 * @param {Element} inspector\n\
 * @api public\n\
 */\n\
\n\
var Plasm = plasm.Viewer = function (container, inspector) {\n\
  if (!(this instanceof plasm.Viewer)) {\n\
    return new plasm.Viewer(container);\n\
  }\n\
\n\
  if (typeof container === 'string') {\n\
    container = document.getElementById(container);\n\
  }\n\
  if (container === null || container === undefined) {\n\
    container = document.createElement('div');\n\
    container.setAttribute('id', 'plasm');\n\
    document.body.appendChild(container);\n\
  }\n\
  if (typeof inspector === 'string') {\n\
    inspector = document.getElementById(inspector);\n\
  }\n\
\n\
  var scene = this.scene = new plasm.Scene();\n\
\n\
  var camera = this.camera = new plasm.Camera();\n\
  scene.add(camera);\n\
\n\
  var controls = this.controls = new plasm.Controls(camera, scene, {container: container});\n\
\n\
  var light = this.light = new THREE.AmbientLight(0x303030);\n\
  scene.root.add(light);\n\
\n\
  var axes = plasm.geometries.axes();\n\
  axes.draw(this);\n\
\n\
  var engine = detector.webgl ? THREE.WebGLRenderer : THREE.CanvasRenderer;\n\
  var renderer = this.renderer = new engine({ antialias: true });\n\
  renderer.setClearColorHex(0xefefef, 1);\n\
  resize();\n\
\n\
  this.container = container;\n\
  this.container.appendChild(this.renderer.domElement);\n\
\n\
  if (inspector) {\n\
    var stats = this.stats = new Stats();\n\
    inspector.appendChild(stats.domElement);\n\
  }\n\
\n\
  function animate () {\n\
    requestAnimationFrame(animate);\n\
    controls.update();\n\
    renderer.render(scene.root, camera.optics);\n\
    if (inspector) stats.update();\n\
  }\n\
\n\
  function resize () {\n\
    var width = container.clientWidth;\n\
    var height = container.clientHeight;\n\
    if (height === 0) { height = document.documentElement.clientHeight; }\n\
    \n\
    camera.optics.aspect = width / height;\n\
    camera.optics.updateProjectionMatrix();\n\
    renderer.setSize(width, height);\n\
  }\n\
\n\
  window.addEventListener('resize', resize, false);\n\
\n\
  console.log('Plasm.js');\n\
\n\
  animate();\n\
\n\
};\n\
\n\
/**\n\
 * Create a scene.\n\
 *\n\
 * @return {plasm.Scene} scene\n\
 * @api public\n\
 */\n\
\n\
plasm.Scene = function () {\n\
  this.root = new THREE.Scene();\n\
};\n\
\n\
/**\n\
 * Add object to the scene.\n\
 *\n\
 * @param {plasm.Model}\n\
 * @return {plasm.Scene} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Scene.prototype.add = function (object) {\n\
  if (object instanceof plasm.Camera) {\n\
    this.root.add(object.optics);\n\
    return this;\n\
  }\n\
  if (object instanceof plasm.Model) {\n\
    this.root.add(object.mesh);\n\
    return this;\n\
  }\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Remove object from the scene.\n\
 *\n\
 * @param {plasm.Model}\n\
 * @return {plasm.Scene} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Scene.prototype.remove = function (object) {\n\
  if (object instanceof plasm.Camera) {\n\
    this.root.remove(object.optics);\n\
    return this;\n\
  }\n\
  if (object instanceof plasm.Model) {\n\
    this.root.remove(object.mesh);\n\
    return this;\n\
  }\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Return scene bounding sphere's radius.\n\
 *\n\
 * @return {Number} boundingRadius\n\
 * @api public\n\
 */\n\
\n\
plasm.Scene.prototype.getBoundingRadius = function () {\n\
  var radius = 0;\n\
  var geometry;\n\
  var position;\n\
  var maxPos;\n\
\n\
  this.root.traverse(function (obj) {\n\
    if (obj instanceof THREE.Object3D && obj.geometry && obj.geometry.vertices.length) {\n\
      \n\
      geometry = obj.geometry;\n\
      geometry.computeBoundingSphere();\n\
      position = obj.position;\n\
      maxPos = max(abs(position.x), abs(position.y), abs(position.z));\n\
      radius = max(radius, geometry.boundingSphere.radius + maxPos);\n\
    }\n\
  });\n\
\n\
  return radius;\n\
};\n\
\n\
/**\n\
 * Return centroid of the scene.\n\
 *\n\
 * @return {THREE.Vector3} centroid\n\
 * @api public\n\
 */\n\
\n\
plasm.Scene.prototype.getCentroid = function () {\n\
  var centroid = new THREE.Vector3();\n\
  var geometry;\n\
  var position;\n\
  var bbox;\n\
  var p = { \n\
      max: new THREE.Vector3()\n\
    , min: new THREE.Vector3() \n\
  };\n\
  \n\
  this.root.traverse(function (obj) {\n\
    if (obj instanceof THREE.Object3D && obj.geometry && obj.geometry.vertices.length) {\n\
\n\
      geometry = obj.geometry;\n\
      geometry.computeBoundingBox();\n\
      bbox = geometry.boundingBox;\n\
      p.max.x = max(p.max.x, bbox.max.x);\n\
      p.max.y = max(p.max.y, bbox.max.y);\n\
      p.max.z = max(p.max.z, bbox.max.z);\n\
      p.min.x = min(p.min.x, bbox.min.x);\n\
      p.min.y = min(p.min.y, bbox.min.y);\n\
      p.min.z = min(p.min.z, bbox.min.z);\n\
    }\n\
  });\n\
\n\
  return centroid.add(p.max, p.min).divideScalar(2);\n\
};\n\
\n\
/**\n\
 * Create a camera.\n\
 *\n\
 * @param {Object} options options\n\
 * @param {Number} [options.fov = 60] field of view\n\
 * @param {Number} [options.aspect = 1] aspect\n\
 * @param {Number} [options.near = 1] near\n\
 * @param {Number} [options.far = 10000] far\n\
 * @return {plasm.Camera} camera\n\
 * @api public\n\
 */\n\
\n\
plasm.Camera = function (options) {\n\
  if (!(this instanceof plasm.Camera)) {\n\
    return new plasm.Camera(options);\n\
  }\n\
\n\
  var options = options || {};\n\
  var fovy = options.fovy || 60;\n\
  var aspect = options.aspect || window.innerWidth / window.innerHeight;\n\
  var near = options.near || 0.1;\n\
  var far = options.far || 10000;\n\
  var optics;\n\
  var controls;\n\
\n\
  optics = new THREE.PerspectiveCamera(fovy, aspect, near, far);\n\
  optics.fovy = fovy;\n\
  optics.aspect = aspect;\n\
  optics.near = near;\n\
  optics.far = far;\n\
  optics.position.x = 5;\n\
  optics.position.y = 5;\n\
  optics.position.z = 5;\n\
\n\
  this.optics = optics;\n\
};\n\
\n\
/**\n\
 * Create camera controls.\n\
 *\n\
 * @param {plasm.Camera} camera camera to control\n\
 * @param {Object} options options\n\
 * @param {Number} [options.rotateSpeed = 5.0] rotate speed\n\
 * @param {Number} [options.panSpeed = 0.8] pan speed\n\
 * @param {Boolean} [options.noZoom = false] no zoom flag\n\
 * @param {Boolean} [options.noPan = false] no pan flag\n\
 * @param {Boolean} [options.staticMoving = true] static moving flag\n\
 * @param {Number} [options.dynamicDampingFactor = 0.3] dynamic damping factor\n\
 * @param {Array} [options.keys = [65, 83, 68]] control keys\n\
 * @return {plasm.Controls} controls\n\
 * @api public\n\
 */\n\
\n\
plasm.Controls = function (camera, scene, options) {\n\
  if (!(this instanceof plasm.Controls)) {\n\
    return new plasm.Controls(camera, scene, options);\n\
  }\n\
\n\
  var options = options || {};\n\
  var controls;\n\
\n\
  controls = new Trackball(camera.optics, scene, options.container);\n\
  controls.rotateSpeed = options.rotateSpeed || 5.0;\n\
  controls.zoomSpeed = options.zoomSpeed || 1.2;\n\
  controls.panSpeed = options.panSpeed || 0.8;\n\
  controls.noZoom = options.noZoom || false;\n\
  controls.noPan = options.noPan || false;\n\
  controls.dynamicDampingFactor = options.dynamicDampingFactor || 0.1;\n\
\n\
  this.controls = controls;\n\
};\n\
\n\
/**\n\
 * Update.\n\
 *\n\
 * @return {plasm.Controls} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Controls.prototype.update = function () {\n\
  this.controls.update();\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Materials\n\
 */\n\
\n\
plasm.materials = {};\n\
\n\
plasm.materials.PointMaterial = function () {\n\
  return new THREE.ParticleBasicMaterial({ \n\
    color: 0x000000,\n\
    size: 0.2\n\
  });\n\
};\n\
\n\
plasm.materials.LineMaterial = function () {\n\
  return new THREE.LineBasicMaterial({\n\
      color: 0x292929\n\
    , opacity: 1\n\
    , linewidth: 2\n\
  });\n\
};\n\
\n\
plasm.materials.MeshMaterial = function () {\n\
  return new THREE.MeshLambertMaterial({\n\
      color: 0xD7D7D7,\n\
      wireframe: detector !== undefined ? !detector.webgl : false,\n\
      shading: THREE.FlatShading,\n\
      vertexColors: THREE.FaceColors\n\
    });\n\
};\n\
\n\
plasm.materials.cloneColor = function (materialFrom, materialTo) {\n\
  var color = materialFrom.color;\n\
  materialTo.color.setRGB(color.r, color.g, color.b);\n\
  materialTo.opacity = materialFrom.opacity !== undefined ? materialFrom.opacity : 1;\n\
  materialTo.transparent = materialFrom.transparent !== undefined ? materialFrom.transparent : false;\n\
}\n\
\n\
/**\n\
 * parse\n\
 * parse a Model or Struct JSON or string data\n\
 *\n\
 * @param {Object|String} json\n\
 * @param {plasm.Viewer} viewer\n\
 * @return {plasm.Model|plasm.Struct} model\n\
 */\n\
\n\
plasm.parse = function (data, viewer) {\n\
  if (viewer === undefined) {\n\
    throw new Error('VIEWER is mandatory to parse data');\n\
  }\n\
\n\
  var json = typeof data === \"string\" ? JSON.parse(data) : data;\n\
  \n\
  if ('models' in json && 'structs' in json) {\n\
    return plasm.Struct.fromJSON(json, viewer);\n\
  } else {\n\
    return plasm.Model.fromJSON(json, viewer);\n\
  }\n\
};\n\
\n\
plasm.DRAW_SINGLE_SIDE = false;\n\
\n\
/**\n\
 * Create the model of the given simplicial complex \n\
 * and add it to the scene of the given viewer.\n\
 *\n\
 * @param {simplexn.SimplicialComplex} complex\n\
 * @param {plasm.Viewer} viewer\n\
 * @return {plasm.Model} model\n\
 * @api public\n\
 */\n\
\n\
plasm.Model = function (complex, viewer) {\n\
  if (!(this instanceof plasm.Model)) {\n\
    return new plasm.Model(complex, viewer);\n\
  }\n\
\n\
  var complex = complex || new simplexn.SimplicialComplex();\n\
  var pointset = complex.pointset;\n\
  var topology = complex.topology;\n\
  var dim = topology.dim;\n\
  var cells, n_cells, i_cell;\n\
  var v1, v2, v3; \n\
\n\
  var geometry = new THREE.Geometry();\n\
  var material;\n\
  var mesh;\n\
\n\
  if (dim <= 0) {\n\
    cells = topology.cells0d();\n\
    n_cells = cells.length;\n\
\n\
    for (i_cell = 0; i_cell < n_cells; i_cell += 1) {\n\
      v1 = pointset.get(cells[i_cell]);\n\
      geometry.vertices.push(new THREE.Vector3(v1[0] || 0, v1[1] || 0, v1[2] || 0));\n\
    }\n\
\n\
    material = new plasm.materials.PointMaterial();\n\
    mesh = new THREE.ParticleSystem(geometry, material);\n\
  }\n\
\n\
  if (dim === 1) {\n\
    cells = topology.complexes[1];\n\
    n_cells = cells.length;\n\
\n\
    for (i_cell = 0; i_cell < n_cells; i_cell += 2) {\n\
      v1 = pointset.get(cells[i_cell + 0]);\n\
      v2 = pointset.get(cells[i_cell + 1]);\n\
      geometry.vertices.push(new THREE.Vector3(v1[0], v1[1], v1[2]));\n\
      geometry.vertices.push(new THREE.Vector3(v2[0], v2[1], v2[2]));\n\
    }\n\
\n\
    material = new plasm.materials.LineMaterial();\n\
    mesh = new THREE.Line(geometry, material, THREE.LinePieces);\n\
  }\n\
\n\
  if (dim >= 2) {\n\
    cells = topology.complexes[2];\n\
    n_cells = cells.length;\n\
\n\
    pointset.forEach(function (v) {\n\
      geometry.vertices.push(new THREE.Vector3(v[0] || 0, v[1] || 0, v[2] || 0));\n\
    });\n\
  \n\
    for (i_cell = 0; i_cell < n_cells; i_cell += 3) {\n\
      geometry.faces.push(new THREE.Face3(\n\
        cells[i_cell + 0], cells[i_cell + 1], cells[i_cell + 2]\n\
      ));\n\
      if (! plasm.DRAW_SINGLE_SIDE) {\n\
        geometry.faces.push(new THREE.Face3(\n\
        cells[i_cell + 2], cells[i_cell + 1], cells[i_cell + 0]\n\
      ));\n\
      }\n\
    }\n\
\n\
    geometry.computeCentroids();\n\
    geometry.mergeVertices();\n\
    geometry.computeFaceNormals();\n\
\n\
    material = new plasm.materials.MeshMaterial();\n\
    mesh = new THREE.Mesh(geometry, material);\n\
  }\n\
\n\
  this.complex = complex;\n\
  this.geometry = geometry;\n\
  this.geometry.dynamic = true;\n\
  this.material = material;\n\
  this.material.side = plasm.DRAW_SINGLE_SIDE ? THREE.FrontSide : THREE.DoubleSide;\n\
  this.mesh = mesh;\n\
  this.mesh.matrixAutoUpdate = true;\n\
  this.viewer = viewer;\n\
};\n\
\n\
/**\n\
 * Clone\n\
 * \n\
 * @return {plasm.Clone} clone\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.clone = function () {\n\
  var model =  new plasm.Model(this.complex.clone(), this.viewer);\n\
  plasm.materials.cloneColor(this.material, model.material);\n\
\n\
  return model;\n\
};\n\
\n\
/**\n\
 * toJSON\n\
 * return a JSON of Model data\n\
 * \n\
 * @return {Object} model\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.toJSON = function () {\n\
  var json = {};\n\
  var material = this.material;\n\
  var color = material.color;\n\
\n\
  json.complex = this.complex.toJSON();\n\
  json.color = new Array(4);\n\
  json.color[0] = color.r;\n\
  json.color[1] = color.g;\n\
  json.color[2] = color.b;\n\
  json.color[3] = material.opacity;\n\
\n\
  return json;\n\
};\n\
\n\
/**\n\
 * fromJSON\n\
 * instantiate a model from a serialized model\n\
 *\n\
 * @param {Object|String} json\n\
 * @param {plasm.Viewer} viewer\n\
 * @return {plasm.Model} model\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.fromJSON = function (json, viewer) {\n\
  var json = typeof json === \"string\" ? JSON.parse(json) : json;\n\
  var complex = simplexn.SimplicialComplex.fromJSON(json.complex);\n\
  var model = new plasm.Model(complex, viewer);\n\
\n\
  model.color(json.color);\n\
\n\
  return model;\n\
};\n\
\n\
/**\n\
 * Draw.\n\
 *\n\
 * @return {plasm.Mode} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.draw = function (viewer) {\n\
  if (this.mesh.parent !== viewer.scene) {\n\
    viewer.scene.add(this);\n\
  }\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Remove this model from the scene.\n\
 *\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.erase = function (viewer) {\n\
  viewer.scene.remove(this);\n\
  this.complex = null;\n\
  this.geometry = null;\n\
  this.mesh = null;\n\
};\n\
\n\
/**\n\
 * Show.\n\
 *\n\
 * @return {plasm.Mode} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.show = function () {\n\
  this.mesh.visible = true;\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Hide.\n\
 *\n\
 * @return {plasm.Mode} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.hide = function () {\n\
  this.mesh.visible = false;\n\
  \n\
  return this;\n\
};\n\
\n\
/**\n\
 * Cancel `this` object from graph of the scene.\n\
 *\n\
 * @return {plasm.Model} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.cancel = function () {\n\
  this.mesh.parent.remove(this.mesh);\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Translate.\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Array|Float32Array} values\n\
 * @return {plasm.Model} this for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.translate = function (dims, values) {\n\
  var v = [];\n\
  this.complex.translate(dims, values);\n\
\n\
  if (this.complex.rn <= 3) {\n\
    dims.forEach(function (dim, i) {\n\
      v[dim] = values[i];\n\
    });\n\
    this.mesh.position.addSelf({ x: v[0] || 0, y: v[1] || 0, z: v[2] || 0 });\n\
    this.geometry.__dirtyVertices = true;\n\
  }\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Rotate.\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Number|Array|Uint32Array} angle\n\
 * @return {plasm.Model} this for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.rotate = function (dims, angle) {\n\
  var v = [];\n\
  var axis = 3 - (dims[0] + dims[1]);\n\
  var angle = angle[0] || angle;\n\
\n\
  this.complex.rotate(dims, angle);\n\
\n\
  if (this.complex.rn <= 3) {\n\
    v[axis] = angle;\n\
    this.mesh.rotation.addSelf({x: v[0] || 0, y: v[1] || 0, z: v[2] || 0 });\n\
    this.geometry.__dirtyVertices = true;\n\
  }\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Scale.\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Array|Float32Array} values\n\
 * @return {plasm.Model} this for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.scale = function (dims, values) {\n\
  var v = [];\n\
  this.complex.scale(dims, values);\n\
\n\
  if (this.complex.rn <= 3) {\n\
    dims.forEach(function (dim, i) {\n\
      v[dim] = values[i];\n\
    });\n\
    this.mesh.scale.multiplySelf({ x: v[0] || 1, y: v[1] || 1, z: v[2] || 1 });\n\
    this.geometry.__dirtyVertices = true;\n\
  }\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Map.\n\
 * \n\
 * Map the vertices of this model by the mapping function.\n\
 *\n\
 * @example\n\
 *\n\
 *   domain([[0,1]],[0,2*Math.PI])\n\
 *     .map(function (v) { return [Math.sin(v[0]), Math.cos(v[1])]; })\n\
 *     .draw();\n\
 *\n\
 * @example\n\
 *\n\
 *   domain([[0,1]],[0,2*Math.PI])\n\
 *     .map([\n\
 *        function (v) { return Math.sin(v[0]); }, \n\
 *        function (v) { return Math.cos(v[1]); }\n\
 *      ])\n\
 *     .draw();\n\
 *\n\
 *\n\
 * @param {Function | Array} mapping\n\
 * @return {plasm.Model} a new mapped model\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.map = function (mapping, merge) {\n\
  if (mapping instanceof Array) {\n\
    return this.map(function (v) {\n\
      return mapping.map(function (f) {\n\
        return f(v);\n\
      });\n\
    }, merge);\n\
  }\n\
\n\
  var complex = this.complex.clone().map(mapping, merge);\n\
  var model = new plasm.Model(complex, this.viewer);\n\
\n\
  return model;\n\
};\n\
\n\
/**\n\
 * Color.\n\
 *\n\
 * @param {Array} rgba rgba\n\
 * @param {Number} [rgba[0] = 0] r\n\
 * @param {Number} [rgba[1] = 0] g\n\
 * @param {Number} [rgba[2] = 0] b\n\
 * @param {Number} [rgba[3] = 1] a\n\
 * @return {plasm.Object} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.color = function (rgba) {\n\
  var a = rgba[3];\n\
\n\
  this.material.color.setRGB(rgba[0] || 0, rgba[1] || 0, rgba[2] || 0);\n\
  \n\
  if (a < 1) {\n\
    this.material.opacity = a;\n\
    this.material.transparent = true;\n\
  }\n\
  \n\
  return this;\n\
};\n\
\n\
/**\n\
 * boundary\n\
 * \n\
 * @return {plasm.Model} boundary\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.boundary = function () {\n\
  var complex = this.complex.clone().boundary();\n\
  var boundary = new plasm.Model(complex, this.viewer);\n\
  plasm.materials.cloneColor(this.material, boundary.material);\n\
\n\
  return boundary;\n\
};\n\
\n\
/**\n\
 * skeleton\n\
 * \n\
 * @param {Number} dim\n\
 * @return {plasm.Model} skeleton\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.skeleton = function (dim) {\n\
  var complex = this.complex.clone().skeleton(dim);\n\
  var skeleton = new plasm.Model(complex, this.viewer);\n\
  plasm.materials.cloneColor(this.material, skeleton.material);\n\
\n\
  return skeleton;\n\
};\n\
\n\
/**\n\
 * extrude\n\
 * \n\
 * @param {Array|Float32Array} hlist which must be made by positive numbers \n\
 *   or by an alternation of positive and negative numbers\n\
 * @return {plasm.Model} extrusion\n\
 * @api private\n\
 */\n\
\n\
plasm.Model.prototype.extrude = function (hlist) {\n\
  var complex = this.complex.clone().extrude(hlist);\n\
  var extrusion = new plasm.Model(complex, this.viewer);\n\
  plasm.materials.cloneColor(this.material, extrusion.material);\n\
\n\
  return extrusion;\n\
};\n\
\n\
/**\n\
 * explode\n\
 *\n\
 * @param {Array|Float32Array} values\n\
 * @return {plasm.Model} explosion\n\
 * @api public\n\
 */\n\
\n\
plasm.Model.prototype.explode = function (values) {\n\
  var complex = this.complex.clone().explode(values);\n\
  var explosion = new plasm.Model(complex, this.viewer);\n\
  plasm.materials.cloneColor(this.material, explosion.material);\n\
\n\
  return explosion;\n\
};\n\
\n\
/**\n\
 * prod\n\
 * At the moment it's customed and tested only for following cases:\n\
 * - 1-rn x 1-rn\n\
 * - 1-rn x 2-rn\n\
 * - 2-rn x 1-rn\n\
 * \n\
 * @param {plasm.Model} model\n\
 * @return {plasm.Model} result of the product operation\n\
 * @api private\n\
 */\n\
\n\
plasm.Model.prototype._prod = function (model) {\n\
  var complex = this.complex.clone().prod(model.complex);\n\
  var result = new plasm.Model(complex, this.viewer);\n\
  plasm.materials.cloneColor(this.material, result.material);\n\
\n\
  return result;\n\
};\n\
\n\
plasm.Model.prototype.prod1x1 = function (model) {\n\
  if (this.complex.rn !== 1 || model.complex.rn !== 1) throw 'Dimesion error.';\n\
\n\
  return this._prod(model);\n\
};\n\
\n\
plasm.Model.prototype.prod1x2 = function (model) {\n\
  if (this.complex.rn !== 1 || model.complex.rn !== 2) throw 'Dimesion error.';\n\
\n\
  return this._prod(model);\n\
};\n\
\n\
plasm.Model.prototype.prod2x1 = function (model) {\n\
  if (this.complex.rn !== 2 || model.complex.rn !== 1) throw 'Dimesion error.';\n\
\n\
  return this._prod(model);\n\
};\n\
\n\
/**\n\
 * Struct\n\
 *\n\
 * @param {items} complex\n\
 * @param {plasm.Viewer} viewer\n\
 * @return {plasm.Struct} struct\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct = function (items) {\n\
  if (!(this instanceof plasm.Struct)) {\n\
    return new plasm.Struct(items);\n\
  }\n\
  \n\
  var items = items || [];\n\
  var structs = [];\n\
  var models = [];\n\
  var model;\n\
\n\
  items.forEach(function (item) {\n\
    model = item.clone();\n\
    if (model instanceof plasm.Model) {\n\
      models.push(model);\n\
    } else if (model instanceof plasm.Struct) {\n\
      structs.push(model);\n\
    }\n\
  });\n\
\n\
  this.structs = structs;\n\
  this.models = models;\n\
};\n\
\n\
/**\n\
 * Clone\n\
 * \n\
 * @return {plasm.Struct} clone\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.clone = function () {\n\
  var cloned = new plasm.Struct();\n\
  var models = [];\n\
  var structs = [];\n\
\n\
  this.models.forEach(function (model) {\n\
    models.push(model.clone());\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    structs.push(struct.clone());\n\
  });\n\
\n\
  cloned.models = models;\n\
  cloned.structs = structs;\n\
\n\
  return cloned;\n\
};\n\
\n\
/**\n\
 * toJSON\n\
 * return a JSON of Struct data\n\
 * \n\
 * @return {Object} model\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.toJSON = function () {\n\
  var json = {};\n\
  var models = [];\n\
  var structs = [];\n\
\n\
  this.models.forEach(function (model) {\n\
    models.push(model.toJSON());\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    structs.push(struct.toJSON());\n\
  });\n\
\n\
  json.models = models;\n\
  json.structs = structs;\n\
\n\
  return json;\n\
};\n\
\n\
/**\n\
 * fromJSON\n\
 * instantiate a struct from a Struct JSON\n\
 *\n\
 * @param {Object|String} json\n\
 * @param {plasm.Viewer} viewer\n\
 * @return {plasm.Struct} struct\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.fromJSON = function (json, viewer) {\n\
  var json = typeof json === \"string\" ? JSON.parse(json) : json;\n\
  var models = json.models;\n\
  var structs = json.structs;\n\
  var newStruct = new plasm.Struct();\n\
\n\
  models.forEach(function (model) {\n\
    newStruct.addNoClone(plasm.Model.fromJSON(model, viewer));\n\
  });\n\
\n\
  structs.forEach(function (struct) {\n\
    newStruct.addNoClone(plasm.Struct.fromJSON(struct, viewer));\n\
  });\n\
\n\
  json.models = models;\n\
  json.structs = structs;\n\
\n\
  return newStruct;\n\
};\n\
\n\
/**\n\
 * Draw.\n\
 *\n\
 * @return {plasm.Struct} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.draw = function (viewer) {\n\
  this.models.forEach(function (model) {\n\
    model.draw(viewer);\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.draw(viewer);\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Cancel.\n\
 *\n\
 * @return {plasm.Struct} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.cancel = function () {\n\
  this.models.forEach(function (model) {\n\
    model.cancel();\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.cancel();\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Remove this model from the scene.\n\
 *\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.erase = function () {\n\
  this.viewer.scene.remove(this);\n\
  this.structs = null;\n\
  this.models = null;\n\
};\n\
\n\
/**\n\
 * Show.\n\
 *\n\
 * @return {plasm.Struct} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.show = function () {\n\
  this.models.forEach(function (model) {\n\
    model.show();\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.show();\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Hide.\n\
 *\n\
 * @return {plasm.Struct} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.hide = function () {\n\
  this.models.forEach(function (model) {\n\
    model.hide();\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.hide();\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Add `item` to this plasm.Struct.\n\
 *\n\
 * @param {plasm.Model|plasm.Struct} item\n\
 * @return {plasm.Struct} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.add = function (item) {\n\
  if (this === item) return this;\n\
  var model = item.clone();\n\
  if (model instanceof plasm.Model) {\n\
    this.models.push(model);\n\
  } else if (model instanceof plasm.Struct) {\n\
    this.structs.push(model);\n\
  }\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Add `item` to this plasm.Struct without cloning it.\n\
 *\n\
 * @param {plasm.Model|plasm.Struct} item\n\
 * @return {plasm.Struct} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.addNoClone = function (item) {\n\
  if (this === item) return this;\n\
  var model = item;\n\
  if (model instanceof plasm.Model) {\n\
    this.models.push(model);\n\
  } else if (model instanceof plasm.Struct) {\n\
    this.structs.push(model);\n\
  }\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Remove `item` from this model.\n\
 *\n\
 * @param {plasm.Model|plasm.Struct} item\n\
 * @return {plasm.Struct} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.remove = function (item) {\n\
  if (this === item) return this;\n\
  var index;\n\
  var array;\n\
\n\
  if (item instanceof plasm.Model) {\n\
    array = this.models;\n\
  } else if (item instanceof Struct) {\n\
    array = this.structs;\n\
  }\n\
  index = array.indexOf(item);\n\
  if (index > 0) {\n\
    array.splice(index, 1);\n\
    item.remove();\n\
  }\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Translate.\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Array|Float32Array} values\n\
 * @return {plasm.Struct} this for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.translate = function (dims, values) {\n\
  this.models.forEach(function (model) {\n\
    model.translate(dims, values);\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.translate(dims, values);\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Rotate.\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Number|Array|Uint32Array} angle\n\
 * @return {plasm.Struct} this for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.rotate = function (dims, angle) {\n\
  this.models.forEach(function (model) {\n\
    model.rotate(dims, angle);\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.rotate(dims, angle);\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Scale.\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @param {Array|Float32Array} values\n\
 * @return {plasm.Struct} this for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.scale = function (dims, values) {\n\
  this.models.forEach(function (model) {\n\
    model.scale(dims, values);\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.scale(dims, values);\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Color.\n\
 *\n\
 * @param {Array} rgba rgba\n\
 * @param {Number} [rgba[0] = 0] r\n\
 * @param {Number} [rgba[1] = 0] g\n\
 * @param {Number} [rgba[2] = 0] b\n\
 * @param {Number} [rgba[3] = 1] a\n\
 * @return {plasm.Struct} for chaining\n\
 * @api public\n\
 */\n\
\n\
plasm.Struct.prototype.color = function (rgba) {\n\
  this.models.forEach(function (model) {\n\
    model.color(rgba);\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.color(rgba);\n\
  });\n\
\n\
  return this;\n\
};\n\
\n\
/**\n\
 * Extrude.\n\
 *\n\
 * @param {Array|Float32Array} hlist which must be made by positive numbers \n\
 *   or by an alternation of positive and negative numbers\n\
 * @return {plasm.Struct} extrusion\n\
 * @api private\n\
 */\n\
\n\
plasm.Struct.prototype.extrude = function (hlist) {\n\
  var struct = new plasm.Struct;\n\
\n\
  this.models.forEach(function (model) {\n\
    struct.models.push(model.extrude(hlist));\n\
  });\n\
\n\
  this.structs.forEach(function (struct) {\n\
    struct.structs.push(struct.extrude(hlist));\n\
  });\n\
\n\
  return struct;\n\
};\n\
\n\
plasm.geometries = {};\n\
\n\
/**\n\
 * SimplicialComplex\n\
 * \n\
 * @param {Array|Float32Array} points\n\
 * @param {Array|Uint32Array} complexes\n\
 * @return {plasm.Model} simplicial complex\n\
 * @api public\n\
 */\n\
\n\
plasm.SimplicialComplex = function (points, complex) {\n\
  var complex = new simplexn.SimplicialComplex(points, complex);\n\
  var model = new plasm.Model(complex, this);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * geometries\n\
 */\n\
\n\
/**\n\
 * simplex\n\
 * \n\
 * @param {number} d\n\
 * @return {plasm.Model} a simplex\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.simplex = function (d) {\n\
  var complex = new simplexn.geometries.simplex(d);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * polyline\n\
 * \n\
 * @param {Array} points\n\
 * @return {simplexn.SimplicialComplex} a polyline\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.polyline = function (points) {\n\
  var complex = simplexn.geometries.polyline(points);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * polypoint\n\
 * \n\
 * @param {Array} points\n\
 * @return {simplexn.SimplicialComplex} a polypoint\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.polypoint = function (points) {\n\
  var complex = simplexn.geometries.polypoint(points);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * axes\n\
 * \n\
 * @param {dim} points\n\
 * @faces {Array|Uint32Array} complexes\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.axes = function () {\n\
  var axeX = new simplexn.SimplicialComplex([[0,0,0],[1,0,0]],[[0,1]]);\n\
  var axeY = new simplexn.SimplicialComplex([[0,0,0],[0,1,0]],[[0,1]]);\n\
  var axeZ = new simplexn.SimplicialComplex([[0,0,0],[0,0,1]],[[0,1]]);\n\
  var modelX = (new plasm.Model(axeX)).color([1,0,0]);\n\
  var modelY = (new plasm.Model(axeY)).color([0,1,0]);\n\
  var modelZ = (new plasm.Model(axeZ)).color([0,0,1]);\n\
  var axes = new plasm.Struct([modelX,modelY,modelZ]);\n\
\n\
  return axes;\n\
};\n\
\n\
/**\n\
 * simplexGrid\n\
 * \n\
 * @param {Array} quotesList is a list of hlist made by positive numbers \n\
 * or made by an alternation of positive and negative numbers\n\
 * @return {plasm.Model} a grid of simplexes\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.simplexGrid = function (quotesList) {\n\
  var complex = new simplexn.geometries.simplexGrid(quotesList);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * cuboid\n\
 * \n\
 * @param {Array} sides\n\
 * @return {plasm.Model} a cuboidal simplicial complex\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.cuboid = function (sides) {\n\
  var complex = new simplexn.geometries.cuboid(sides);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * intervals\n\
 *\n\
 * @param {Array} values\n\
 * @return {plasm.Model} intervals\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.intervals = function (tip, n) {\n\
  var complex = new simplexn.geometries.intervals(tip, n);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * domain\n\
 *\n\
 * @param {Array} ends\n\
 * @param {Array} ns\n\
 * @return {plasm.Model} domain\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.domain = function (tips, ns) {\n\
  var domain = new simplexn.geometries.domain(tips, ns);\n\
  var model = new plasm.Model(domain);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * cube\n\
 * \n\
 * @param {Number} dim\n\
 * @return {plasm.Model} a dim-dimendional cube\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.cube = function (d) {\n\
  var complex = new simplexn.geometries.cube(d);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * circle\n\
 * \n\
 * @param {Number} [radius=1]\n\
 * @param {Number} [n=32] \n\
 * @return {plasm.Model} a circle\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.circle = function (radius, n) {\n\
  var complex = new simplexn.geometries.circle(radius, n);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * disk\n\
 * \n\
 * @param {Number} [radius=1]\n\
 * @param {Number} [n=32]\n\
 * @param {Number} [m=1] \n\
 * @return {plasm.Model} a disk\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.disk = function (radius, n, m) {\n\
  var complex = new simplexn.geometries.disk(radius, n, m);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * cylinderSurface\n\
 * Produces a cylindrical surface of radius r and heigth h.\n\
 * \n\
 * @param {Number} [r=1]\n\
 * @param {Number} [h=1]\n\
 * @param {Number} [n=16]\n\
 * @param {Number} [m=2] \n\
 * @return {plasm.Model} a cylindrical surface\n\
 * @api public\n\
 */\n\
 \n\
plasm.geometries.cylinderSurface = function (r, h, n, m) {\n\
  var complex = new simplexn.geometries.cylinderSurface(r, h, n, m);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * torusSurface\n\
 *\n\
 * produces a toroidal surface of radiuses r,R \n\
 * approximated with n x m x 2 triangles\n\
 *\n\
 * @param {Number} [r_min=1] r_min\n\
 * @param {Number} [r_max=3] r_max\n\
 * @param {Number} [n=12] n\n\
 * @param {Number} [m=8] m\n\
 * @return {plasm.Model} a torus surface\n\
 */\n\
\n\
plasm.geometries.torusSurface = function (r_min, r_max, n, m) {\n\
  var complex = new simplexn.geometries.torusSurface(r_min, r_max, n, m);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * torusSolid\n\
 *\n\
 * produces a toroidal surface of radiuses r,R \n\
 * approximated with n x m x 2 triangles\n\
 *\n\
 * @param {Number} [r=1] r_min\n\
 * @param {Number} [R=3] r_max\n\
 * @param {Number} [n=12] n\n\
 * @param {Number} [m=8] m\n\
 * @param {Number} [p=8] p\n\
 * @return {plasm.Model} a torus solid\n\
 */\n\
\n\
plasm.geometries.torusSolid = function (r_min, r_max, n, m, p) {\n\
  var r_min = r_min || 1;\n\
  var r_max = r_max || 3;\n\
  var n = n || 12;\n\
  var m = m || 8;\n\
  var p = p || 8;\n\
  var complex = new simplexn.geometries.torusSolid(r_min, r_max, n, m, p);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * triangleStrip\n\
 * \n\
 * @param {Array} points\n\
 * @return {plasm.Model} triangle strip\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.triangleStrip = function (points) {\n\
  var complex = new simplexn.geometries.triangleStrip(points);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * triangleFan\n\
 * \n\
 * @param {Array} points\n\
 * @return {plasm.Model} triangle strip\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.triangleFan = function (points) {\n\
  var complex = new simplexn.geometries.triangleFan(points);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * helix\n\
 * \n\
 * @param {Number} [r=1] r\n\
 * @param {Number} [pitch=1] pitch\n\
 * @param {Number} [n=24] n\n\
 * @param {Number} [turns=1] turns\n\
 * @return {plasm.Model} helix\n\
 * @api public   \n\
 */\n\
\n\
plasm.geometries.helix = function (r, pitch, n, turns) {\n\
  var complex = new simplexn.geometries.helix(r, pitch, n, turns);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
\n\
/**\n\
 * triangleDomain\n\
 * \n\
 * @param {Number} n\n\
 * @param {Array} points\n\
 * @return {plasm.Model} triangleDomain\n\
 * @api public\n\
 */\n\
\n\
plasm.geometries.triangleDomain = function (n, points) {\n\
  var complex = new simplexn.geometries.triangleDomain(n, points);\n\
  var model = new plasm.Model(complex);\n\
  return model;\n\
};\n\
//@ sourceURL=cvdlab-plasm/index.js"
));
require.register("enricomarino-globalize/index.js", Function("exports, require, module",
"/**\n\
 * globalize\n\
 * globalize component\n\
 * \n\
 * @copyright 2013 Enrico Marino\n\
 * @license MIT\n\
 */\n\
\n\
/**\n\
 * Expose `gloabalize`\n\
 */\n\
\n\
module.exports = globalize;\n\
\n\
/**\n\
 * global\n\
 */\n\
\n\
var global = window || exports; \n\
\n\
/** \n\
 * globalize\n\
 * globalize the properties of `obj`\n\
 * \n\
 * @param {Object} obj properties to globalize\n\
 * @api public\n\
 */\n\
\n\
function globalize (obj) {\n\
  for (var property in obj) {\n\
    global[property] = obj[property]\n\
  }\n\
}\n\
//@ sourceURL=enricomarino-globalize/index.js"
));
require.register("cvdlab-plasm-fun/index.js", Function("exports, require, module",
"/**!\n\
 * plasm-fun\n\
 * functional plasm\n\
 * \n\
 * @copyright 2013 Enrico Marino and Federico Spini\n\
 * @license MIT\n\
 */\n\
\n\
/**\n\
 * Library dependencies.\n\
 */\n\
\n\
var f = require('f');\n\
var plasm = require('plasm');\n\
var globalize = require('globalize');\n\
\n\
/**\n\
 * Expose `fun`\n\
 */\n\
\n\
module.exports = fun;\n\
\n\
/**\n\
 * fun\n\
 * \n\
 * @return {Function} fun\n\
 * @api public\n\
 */\n\
\n\
function fun (id) {\n\
  for (var p in f) {\n\
    fun[p.toUpperCase()] = f[p];\n\
  }\n\
  fun.plasm = plasm;\n\
  fun.viewer = plasm.Viewer(id);\n\
  return fun;\n\
}\n\
\n\
/**\n\
 * globalize\n\
 * Globalize fun functions\n\
 * \n\
 * @return {function} fun\n\
 * @api public\n\
 */\n\
\n\
fun.globalize = function () {\n\
  globalize(fun);\n\
  return fun;\n\
};\n\
\n\
/**\n\
 * DRAW\n\
 * \n\
 * @param {plasm.Model|plasm.Struct} object to draw\n\
 * @api public\n\
 */\n\
\n\
fun.DRAW = function (object) {\n\
  if (!(object instanceof plasm.Model) &&\n\
      !(object instanceof plasm.Struct)) {\n\
    return;\n\
  }\n\
\n\
  object.draw(fun.viewer);\n\
\n\
  return object;\n\
};\n\
\n\
/**\n\
 * CANCEL\n\
 * \n\
 * @param {plasm.Model|plasm.Struct} object\n\
 * @return {plasm.Model|plasm.Struct} object\n\
 * @api public\n\
 */\n\
\n\
fun.CANCEL = function (object) {\n\
  if (!(object instanceof plasm.Model) &&\n\
      !(object instanceof plasm.Struct)) {\n\
    return;\n\
  }\n\
\n\
  return object.cancel();\n\
};\n\
\n\
/**\n\
 * K\n\
 * \n\
 * @param {Object} an object to be stored and returned\n\
 * @return {Function}\n\
 *   @return {Object} the Object passed as first parameter\n\
 * @api public\n\
 */\n\
\n\
var K = \n\
fun.K = function (constObject) {\n\
  return function () {\n\
    return constObject;\n\
  };\n\
};\n\
\n\
/**\n\
 * R\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @return {Function}\n\
 *   @param {Number|Array|Uint32Array} angle\n\
 *   @return {Function}\n\
 *      @param {plasm.Model|plasm.Struct} object\n\
 *      @return {plasm.Model|plasm.Struct} rotated clone of object\n\
 * @api public\n\
 */\n\
\n\
var R = \n\
fun.R = \n\
fun.ROTATE = function (dims) {\n\
  return function (angle) {\n\
    return function (object) {\n\
      return object.clone().rotate(dims, angle);\n\
    };\n\
  };\n\
};\n\
\n\
/**\n\
 * S\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @return {Function}\n\
 *   @param {Number} values\n\
 *   @return {Function}\n\
 *      @param {plasm.Model|plasm.Struct} object\n\
 *      @return {plasm.Model|plasm.Struct} scaled clone of object\n\
 * @api public\n\
 */\n\
\n\
var S = \n\
fun.S = \n\
fun.SCALE = function (dims) {\n\
  return function (values) {\n\
    return function (object) {\n\
      return object.clone().scale(dims, values);\n\
    };\n\
  };\n\
};\n\
\n\
/**\n\
 * T\n\
 * \n\
 * @param {Array|Uint32Array} dims\n\
 * @return {Function}\n\
 *   @param {Number} values\n\
 *   @return {Function}\n\
 *      @param {plasm.Model|plasm.Struct} model\n\
 *      @return {plasm.Model|plasm.Struct} translated clone of object\n\
 * @api public\n\
 */\n\
\n\
var T =\n\
fun.T =\n\
fun.TRANSLATE = function (dims) {\n\
  return function (values) {\n\
    return function (object) {\n\
     return object.clone().translate(dims, values);\n\
    };\n\
  };\n\
};\n\
\n\
/**\n\
 * STRUCT\n\
 * \n\
 * @param {Array} items\n\
 * @return {plasm.Model}\n\
 * @api public\n\
 */\n\
\n\
fun.STRUCT = function (items) {\n\
  var transformations = function (o) {return o;};\n\
  var objects = [];\n\
  // var temp = [];\n\
\n\
  items.forEach(function (item) {\n\
    if (!(item instanceof plasm.Model) && \n\
        !(item instanceof plasm.Struct)) {\n\
      transformations = COMP2([transformations, item]);\n\
    } else {\n\
    //  temp.push(APPLY([transformations, item]).clone());\n\
      objects.push(APPLY([transformations, item]));\n\
    }\n\
  });\n\
\n\
//  return new plasm.Struct(objects, temp);\n\
    return new plasm.Struct(objects);\n\
};\n\
\n\
/**\n\
 * Map.\n\
 * \n\
 * Map `domain` by `mapping` function.\n\
 *\n\
 * @example\n\
 *\n\
 *   var domain = DOMAIN([[0,1]],[0,2*PI]);\n\
 *   var mapping = function (v) { return [SIN(v[0]), COS(v[1])]; });\n\
 *   var model = MAP(mapping)(domain);\n\
 *   DRAW(model);\n\
 *\n\
 * @example\n\
 *\n\
 *   var domain = DOMAIN([[0,1]],[0,2*PI]);\n\
 *   var mapping = [\n\
 *         function (v) { return SIN(v[0]); }, \n\
 *         function (v) { return COS(v[1]); }\n\
 *       ]);\n\
 *   var model = MAP(mapping)(domain)\n\
 *   DRAW(model);\n\
 * \n\
 * @param {Function} mapping\n\
 * @return {Function}\n\
 *   @param {plasm.Model} domain\n\
 *   @return {plasm.Model}\n\
 * @api public\n\
 */\n\
\n\
fun.MAP = function (mapping) {\n\
  return function (domain) {\n\
    return domain.map(mapping);\n\
  };\n\
};\n\
\n\
/**\n\
 * extrude\n\
 * \n\
 * @param {Array|Float32Array} hlist a list of positive numbers \n\
 *   or an alternation of positive and negative numbers\n\
 * @return {Function}\n\
 *   @param {plasm.Model|plasm.Struct} object to extrude\n\
 *   @return {plasm.Model|plasm.Struct} extrusion\n\
 * @api private\n\
 */\n\
\n\
var EXTRUDE =\n\
fun.EXTRUDE = function (hlist) {\n\
  return function (object) {\n\
    return object.extrude(hlist);\n\
  };\n\
};\n\
\n\
/**\n\
 * EXPLODE\n\
 *\n\
 * @param {Array|Float32Array} values\n\
 * @return {Function}\n\
 *    @param {plasm.Model} model\n\
 *    @return {plasm.Model} exploded clone of model\n\
 * @api public\n\
 */\n\
\n\
var EXPLODE =\n\
fun.EXPLODE = function (values) {\n\
  return function (model) {\n\
    return model.explode(values);\n\
  };\n\
};\n\
\n\
/**\n\
 * SKELETON\n\
 * \n\
 * @param {Number} dim\n\
 * @return {Function}\n\
 *   @param {plasm.Model} model\n\
 *   @return {plasm.Model} skeleton\n\
 * @api public\n\
 */\n\
\n\
var SKELETON = \n\
fun.SKELETON = function (dim) {\n\
  return function (model) {\n\
    return model.skeleton(dim);\n\
  };\n\
};\n\
\n\
/**\n\
 * BOUNDARY\n\
 * \n\
 * @param {plasm.Model} model\n\
 * @return {plasm.Model} boundary\n\
 * @api public\n\
 */\n\
\n\
var BOUNDARY = \n\
fun.BOUNDARY = function (model) {\n\
  return model.boundary();\n\
};\n\
\n\
/**\n\
 * COLOR\n\
 *\n\
 * Color.\n\
 *\n\
 * @param {Array} rgb rgb\n\
 * @param {Number} [rgb[0] = 0] r\n\
 * @param {Number} [rgb[1] = 0] g\n\
 * @param {Number} [rgb[2] = 0] b\n\
 * @param {Number} [rgb[3] = 1] a\n\
 * @return {Function}\n\
 *   @param {plasm.Model | plasm.Struct} object\n\
 *   @return {plasm.Model | plasm.Struct} colored object\n\
 * @api public\n\
 */\n\
\n\
var COLOR =\n\
fun.COLOR = function (rgba) {\n\
  return function (object) {\n\
    return object.clone().color(rgba);\n\
  };\n\
};\n\
\n\
/**\n\
 * SHOW\n\
 *\n\
 * @param {plasm.Model | plasm.Struct} model to show\n\
 * @return {plasm.Model | plasm.Struct} model\n\
 * @api public\n\
 */\n\
\n\
var SHOW = \n\
fun.SHOW = function (object) {\n\
  object.show();\n\
};\n\
\n\
/**\n\
 * HIDE\n\
 *\n\
 * @return {plasm.Model | plasm.Struct} for chaining\n\
 * @api public\n\
 */\n\
\n\
var HIDE = \n\
fun.HIDE = function (object) {\n\
  object.hide();\n\
};\n\
\n\
/**\n\
 * SIMPLICIAL_COMPLEX\n\
 * \n\
 * @param {Array|Float32Array} points\n\
 * @return {Function}\n\
 *   @param {Array|Uint32Array} cells\n\
 *   @return {plasm.Model} simplicial cells\n\
 * @api public\n\
 */\n\
\n\
var SIMPLICIAL_COMPLEX = \n\
fun.SIMPLICIAL_COMPLEX = function (points) {\n\
  return function (cells) {\n\
    return plasm.SimplicialComplex(points, cells);\n\
  };\n\
};\n\
\n\
/**\n\
 * SIMPLEX\n\
 * \n\
 * @param {number} d\n\
 * @return {plasm.Model} a simplex\n\
 * @api public\n\
 */\n\
\n\
var SIMPLEX =\n\
fun.SIMPLEX = function (d) {\n\
  return plasm.geometries.simplex(d);\n\
};\n\
\n\
/**\n\
 * POLYLINE\n\
 * \n\
 * @param {Array} points\n\
 * @return {plasm.Model} a polyline\n\
 * @api public\n\
 */\n\
\n\
var POLYLINE = \n\
fun.POLYLINE = function (points) {\n\
  return plasm.geometries.polyline(points);\n\
};\n\
\n\
/**\n\
 * POLYPOINT\n\
 * \n\
 * @param {Array} points\n\
 * @return {plasm.Model} a polypoint\n\
 * @api public\n\
 */\n\
\n\
var POLYPOINT =\n\
fun.POLYPOINT = function (points) {\n\
  return plasm.geometries.polypoint(points);\n\
};\n\
\n\
/**\n\
 * SIMPLEX_GRID\n\
 * \n\
 * @param {Array} quotesList is a list of hlist made by positive numbers \n\
 * or made by an alternation of positive and negative numbers\n\
 * @return {plasm.Model} a grid of simplexes\n\
 * @api public\n\
 */\n\
\n\
var SIMPLEX_GRID = \n\
fun.SIMPLEX_GRID = function (quotes) {\n\
  return plasm.geometries.simplexGrid(quotes);\n\
};\n\
\n\
/**\n\
 * CUBE\n\
 * \n\
 * @param {Number} dim\n\
 * @return {plasm.Model} a dim-dimendional cube\n\
 * @api public\n\
 */\n\
\n\
var CUBE = \n\
fun.CUBE = function (d) {\n\
  return plasm.geometries.cube(d);\n\
};\n\
\n\
/**\n\
 * CUBOID\n\
 * \n\
 * @param {Array} sides\n\
 * @return {plasm.Model} a cuboidal simplicial complex\n\
 * @api public\n\
 */\n\
\n\
var CUBOID =\n\
fun.CUBOID = function (sides) {\n\
  return plasm.geometries.cuboid(sides);\n\
};\n\
\n\
/**\n\
 * INTERVALS\n\
 *\n\
 * @param {Number} tip\n\
 * @return {Function}\n\
 *   @param {Number} n\n\
 *   @return {plasm.Model} intervals\n\
 * @api public\n\
 */\n\
\n\
var INTERVALS = \n\
fun.INTERVALS = function (tip) {\n\
  return function (n) {\n\
    return plasm.geometries.intervals(tip, n);\n\
  };\n\
};\n\
\n\
/**\n\
 * DOMAIN\n\
 *\n\
 * @param {Array} ends\n\
 * @return {Function}\n\
 *   @param {Number} ns\n\
 *   @return {plasm.Model} domain\n\
 * @return {plasm.Model} domain\n\
 * @api public\n\
 */\n\
\n\
var DOMAIN = \n\
fun.DOMAIN = function (ends) {\n\
  return function (ns) {\n\
    return plasm.geometries.domain(ends, ns);\n\
  };\n\
};\n\
\n\
/**\n\
 * PROD\n\
 * cartesian products\n\
 *\n\
 * @param {Array} array\n\
 * @param {plasm.Model} [array[0]] model1\n\
 * @param {plasm.Model} [array[1]] model2\n\
 * @return {plasm.Model} result\n\
 */\n\
\n\
var PROD1x1 = \n\
fun.PROD1x1 = function (array) {\n\
  return array[0].prod1x1(array[1]);\n\
};\n\
\n\
var PROD1x2 = \n\
fun.PROD1x2 = function (array) {\n\
  return array[0].prod1x2(array[1]);\n\
};\n\
\n\
var PROD2x1 = \n\
fun.PROD2x1 = function (array) {\n\
  return array[0].prod2x1(array[1]);\n\
};  \n\
\n\
/**\n\
 * CIRCLE\n\
 * \n\
 * @param {Number} r radius\n\
 * @return {Function}\n\
 *   @param {Number} n subdivisions\n\
 *   @return {plasm.Model} a circle\n\
 * @api public\n\
 */\n\
\n\
var CIRCLE = \n\
fun.CIRCLE = function (r) {\n\
  var r = r || 1;\n\
  return function (n) {\n\
    return plasm.geometries.circle(r, n);\n\
  };\n\
};\n\
\n\
/**\n\
 * DISK\n\
 * \n\
 * @param {Number} r radius\n\
 * @return {Function}\n\
 *   @param {Array} divs subdivisions\n\
 *   @param {Number} [divs[0]] slices\n\
 *   @param {Number} [divs[1]] stacks\n\
 *   @return {plasm.Model} a disk\n\
 * @api public\n\
 */\n\
\n\
var DISK = \n\
fun.DISK = function (r) {\n\
  var r = r || 1;\n\
  return function (divs) {\n\
    var divs = divs || [];\n\
    var slices = divs[0] || 24;\n\
    var stacks = divs[1] || 3;\n\
    return plasm.geometries.disk(r, slices, stacks);\n\
  };\n\
};\n\
\n\
/**\n\
 * CYLSURFACE\n\
 * \n\
 * @param {Array} dims\n\
 * @param {Number} [dims[0]=1] radius\n\
 * @param {Number} [dims[1]=1] height\n\
 * @return {Function}\n\
 *   @param {Array} divs\n\
 *   @param {Number} [divs[0]=16] slices\n\
 *   @param {Number} [divs[1]=2]  stacks\n\
 *   @return {plasm.Model} a cylindrical surface\n\
 * @api public\n\
 */\n\
\n\
var CYL_SURFACE = \n\
fun.CYL_SURFACE = function (dims) {\n\
  var dims = dims || [];\n\
  var r = dims[0] || 1;\n\
  var h = dims[1] || 1;\n\
  return function (divs) {\n\
    var divs = divs || [];\n\
    var slices = divs[0] || 12;\n\
    var stacks = divs[1] || 8;\n\
    return plasm.geometries.cylinderSurface(r, h, slices, stacks);\n\
  };\n\
};\n\
\n\
/**\n\
 * TORUS_SURFACE\n\
 * \n\
 * @param {Array} dims\n\
 * @param {Number} [dims[0]=0.1] r min\n\
 * @param {Number} [dims[1]=0.9] r max\n\
 * @return {Function}\n\
 *   @param {Array} divs\n\
 *   @param {Number} [divs[0]=12] slices\n\
 *   @param {Number} [divs[1]=8]  stacks\n\
 *   @return {plasm.Model} a torus surface\n\
 * @api public\n\
 */\n\
\n\
var TORUS_SURFACE = \n\
fun.TORUS_SURFACE = function (dims) {\n\
  var dims = dims || [];\n\
  var r_min = dims[0] || 1.0;\n\
  var r_max = dims[1] || 1.9;\n\
  return function (divs) {\n\
    var divs = divs || [];\n\
    var n = divs[0] || 12;\n\
    var m = divs[1] || 12;\n\
    return plasm.geometries.torusSurface(r_min, r_max, n, m);\n\
  };\n\
};\n\
\n\
/**\n\
 * TORUS_SOLID\n\
 * \n\
 * @param {Array} dims\n\
 * @param {Number} [dims[0]=0.1] r min\n\
 * @param {Number} [dims[1]=0.9] r max\n\
 * @return {Function}\n\
 *   @param {Array} divs\n\
 *   @param {Number} [divs[0]=12] n\n\
 *   @param {Number} [divs[1]=8]  m\n\
 *   @param {Number} [divs[1]=8]  p\n\
 *   @return {plasm.Model} a torus surface\n\
 * @api public\n\
 */\n\
\n\
var TORUS_SOLID = \n\
fun.TORUS_SOLID = function (dims) {\n\
  var dims = dims || [];\n\
  var r_min = dims[0] || 0.1;\n\
  var r_max = dims[1] || 0.9;\n\
  return function (divs) {\n\
    var divs = divs || [];\n\
    var n = divs[0] || 12;\n\
    var m = divs[1] || 8;\n\
    var q = divs[2] || 8;\n\
    return plasm.geometries.torusSolid(r_min, r_max, n, m, q);\n\
  };\n\
};\n\
\n\
/**\n\
 * TRIANGLE_STRIP\n\
 * \n\
 * @param {Array} points\n\
 * @return {plasm.Model} triangle strip\n\
 * @api public\n\
 */\n\
\n\
var TRIANGLE_STRIP = \n\
fun.TRIANGLE_STRIP = function (points) {\n\
  return plasm.geometries.triangleStrip(points);\n\
};\n\
\n\
/**\n\
 * TRIANGLEFAN\n\
 * \n\
 * @param {Array} points\n\
 * @return {plasm.Model} triangle strip\n\
 * @api public\n\
 */\n\
\n\
var TRIANGLE_FAN = \n\
fun.TRIANGLE_FAN = function (points) {\n\
  return plasm.geometries.triangleFan(points);\n\
};\n\
\n\
/**\n\
 * HELIX\n\
 * \n\
 * @param {Number} [r=1] r\n\
 * @param {Number} [pitch=1] pitch\n\
 * @param {Number} [n=24] n\n\
 * @param {Number} [turns=1] turns\n\
 * @return {plasm.Model} helix\n\
 * @api public   \n\
 */\n\
\n\
var HELIX = \n\
fun.HELIX = function (r, pitch, n, turns) {\n\
  return plasm.geometries.helix(r, pitch, n, turns);\n\
};\n\
\n\
/**\n\
 * CUBIC_HERMITE\n\
 * \n\
 * @param {Function} sel\n\
 * @return {Function}\n\
 *   @param {Array} args\n\
 *   @return {Function}\n\
 *     @param {Array} point\n\
 *     @return {Funciton}\n\
 * @api public\n\
 */\n\
\n\
var CUBIC_HERMITE = \n\
fun.CUBIC_HERMITE = function (sel) {\n\
  return function (args) {\n\
    var p1Fn = args[0];\n\
    var p2Fn = args[1];\n\
    var s1Fn = args[2];\n\
    var s2Fn = args[3];\n\
\n\
    return function (point) {\n\
      var u = sel(point);\n\
      var u2 = u * u;\n\
      var u3 = u2 * u;\n\
\n\
      var p1 = p1Fn instanceof Function ? p1Fn(point) : p1Fn;\n\
      var p2 = p2Fn instanceof Function ? p2Fn(point) : p2Fn;\n\
      var s1 = s1Fn instanceof Function ? s1Fn(point) : s1Fn;\n\
      var s2 = s2Fn instanceof Function ? s2Fn(point) : s2Fn;\n\
\n\
      var rn = p1.length;\n\
      var mapped = new Array(rn);\n\
      var i;\n\
\n\
      for (i = 0; i < rn; i += 1) {\n\
        mapped[i] = (2*u3-3*u2+1)*p1[i] + (-2*u3+3*u2)*p2[i]+(u3-2*u2+u)*s1[i]+(u3-u2)*s2[i];\n\
      }\n\
\n\
      return mapped;\n\
    };\n\
  };\n\
};\n\
\n\
/**\n\
 * BEZIER\n\
 * \n\
 * @param {Function} sel\n\
 * @return {Function}\n\
 *   @param {Array} args\n\
 *   @return {Function}\n\
 *     @param {Array} point\n\
 *     @return {Funciton}\n\
 * @api public\n\
 */\n\
\n\
var BEZIER = \n\
fun.BEZIER = function (sel) {  \n\
  return function (args) {\n\
    var n = args.length - 1;\n\
    var controldataFn = args;\n\
\n\
    return function (point) {\n\
      var t = sel(point);\n\
      var controldata = new Array(n+1);\n\
      var mapped;\n\
      var rn;\n\
      var weight;\n\
      var crtldata;\n\
      var i, k;\n\
\n\
      for (i = 0; i <= n; i += 1) {\n\
        crtldata = controldataFn[i];\n\
        controldata[i] = crtldata instanceof Function ? crtldata(point) : crtldata;\n\
      }\n\
\n\
      rn = controldata[0].length;\n\
      mapped = new Array(rn);\n\
\n\
      for (i = 0; i < rn; i += 1) {\n\
        mapped[i] = 0.0;\n\
      }\n\
\n\
      for (i = 0; i <= n; i += 1) {\n\
        weight = CHOOSE([n,i]) * POW([1-t,n-i]) * POW([t,i]);\n\
        for (k = 0; k < rn; k += 1) {\n\
          mapped[k] += weight * controldata[i][k];\n\
        }\n\
      }\n\
      \n\
      return mapped;\n\
    };\n\
  };\n\
};\n\
\n\
/**\n\
 * CUBIC_UBSPLINE\n\
 * \n\
 * @param {Function} domain\n\
 * @return {Function}\n\
 *   @param {Array} args\n\
 * @api public\n\
 */\n\
\n\
var CUBIC_UBSPLINE = \n\
fun.CUBIC_UBSPLINE = function (domain) {\n\
  return function (args) {\n\
    var q1Fn = args[0];\n\
    var q2Fn = args[1];\n\
    var q3Fn = args[2];\n\
    var q4Fn = args[3];\n\
\n\
    return MAP(function (point) {\n\
      var u = S0(point);\n\
      var u2 = u * u;\n\
      var u3 = u2 * u;\n\
      var rn;\n\
      var mapped;\n\
      var i;\n\
\n\
      var q1 = q1Fn instanceof Function ? q1Fn(point) : q1Fn;\n\
      var q2 = q2Fn instanceof Function ? q2Fn(point) : q2Fn;\n\
      var q3 = q3Fn instanceof Function ? q3Fn(point) : q3Fn;\n\
      var q4 = q4Fn instanceof Function ? q4Fn(point) : q4Fn;\n\
\n\
      rn = q1.length;\n\
      mapped = new Array(rn);\n\
\n\
      for (i = 0; i < rn; i +=1) {\n\
        mapped[i] = (1.0/6.0) * ( (-u3+3*u2-3*u+1)*q1[i] + (3*u3-6*u2+4)*q2[i]+ (-3*u3+3*u2+3*u+1)*q3[i] + (u3)*q4[i]);\n\
      }\n\
\n\
      return mapped;\n\
    })(domain);\n\
  };\n\
};\n\
\n\
/**\n\
 * CUBIC_CARDINAL\n\
 * \n\
 * @param {Function} domain\n\
 * @param {Number} [h=1]\n\
 * @return {Function}\n\
 *   @param {Array} args\n\
 * @api public\n\
 */\n\
\n\
var CUBIC_CARDINAL =\n\
fun.CUBIC_CARDINAL = function (domain, h) {\n\
  var h = h !== undefined ? h : 1;\n\
\n\
  return function (args) {\n\
    var q1Fn = args[0];\n\
    var q2Fn = args[1];\n\
    var q3Fn = args[2];\n\
    var q4Fn = args[3];\n\
\n\
    return MAP(function (point) {\n\
      var u = S0(point);\n\
      var u2 = u * u;\n\
      var u3 = u2 * u;\n\
      var rn;\n\
      var mapped;\n\
      var i;\n\
\n\
      var q1 = q1Fn instanceof Function ? q1Fn(point) : q1Fn;\n\
      var q2 = q2Fn instanceof Function ? q2Fn(point) : q2Fn;\n\
      var q3 = q3Fn instanceof Function ? q3Fn(point) : q3Fn;\n\
      var q4 = q4Fn instanceof Function ? q4Fn(point) : q4Fn;\n\
\n\
      rn = q1.length;\n\
      mapped = new Array(rn);\n\
\n\
      for (i = 0; i < rn; i +=1) {\n\
        mapped[i] = (-h*u3+2*h*u2-h*u)*q1[i] +((2-h)*u3+(h-3)*u2+1)*q2[i] + ((h-2)*u3+(3-2*h)*u2+h*u)*q3[i] + (h*u3-h*u2)*q4[i];\n\
      }\n\
\n\
      return mapped;\n\
    })(domain);\n\
  };\n\
};\n\
\n\
/**\n\
 * SPLINE\n\
 * \n\
 * @param {Function} curve\n\
 * @return {Function}\n\
 *   @param {Array} points\n\
 *   @return {plasm.Struct}\n\
 * @api public\n\
 */\n\
\n\
var SPLINE =\n\
fun.SPLINE = function (curve) {\n\
  return function (points) {\n\
    var segments = [];\n\
    var length = points.length;\n\
    var tip = length -4 + 1;\n\
    var slice;\n\
    var i;\n\
\n\
    for (i = 0; i < tip; i += 1) {\n\
      slice = points.slice(i,i+4);\n\
      segments.push(curve(slice));\n\
    }\n\
      \n\
    return STRUCT(segments);\n\
  };\n\
};\n\
\n\
/**\n\
 * DE_BOORD\n\
 * Cox and De Boord coefficients \n\
 *\n\
 * @api private\n\
 */\n\
 \n\
var DE_BOORD = \n\
fun.DE_BOORD = function (T, i, k, t, n) {\n\
  var tmin = T[k-1];\n\
  var tmax = T[n+1];\n\
  var ret, num1, div1, num2, div2;\n\
\n\
  // DE_BOORDi1(t)\n\
  if (k === 1) { \n\
    if ((t >= T[i] && t < T[i+1]) || \n\
        (t === tmax && t >= T[i] && t <= T[i+1])) {\n\
      return 1;\n\
    } else {\n\
      return 0;\n\
    }\n\
  }\n\
\n\
  // DE_BOORDik(t)\n\
  ret = 0;\n\
  num1 = t-T[i];\n\
  div1 = T[i+k-1]-T[i];\n\
  \n\
  if (div1 !== 0) {\n\
    ret += (num1/div1) * DE_BOORD(T,i,k-1,t,n);\n\
  }\n\
\n\
  num2 = T[i+k]-t;\n\
  div2 = T[i+k]-T[i+1];\n\
  \n\
  if (div2 !== 0) {\n\
    ret += (num2/div2) * DE_BOORD(T,i+1,k-1,t,n);\n\
  }\n\
\n\
  return ret;\n\
};\n\
\n\
/**\n\
 * BSPLINE\n\
 * \n\
 * @param {Number} degree\n\
 * @return {Function}\n\
 *   @param {Array} knots\n\
 *   @return {Function}\n\
 *     @param {Array} controls\n\
 *     @return {Funciton}\n\
 * @api public\n\
 */\n\
\n\
var BSPLINE =\n\
fun.BSPLINE = function (degree) {\n\
  return function (knots) {\n\
    return function (controls) {\n\
      var n = controls.length - 1;\n\
      var m = knots.length -1;\n\
      var k = degree + 1;\n\
\n\
      // see http://www.na.iac.cnr.it/~bdv/cagd/spline/B-spline/bspline-curve.html\n\
      if (knots.length !== (n+k+1)) {\n\
        throw \"Invalid point/knots/degree for bspline!\";\n\
      }\n\
\n\
      return function (point) {\n\
        var t = point[0];\n\
        var points = new Array(n);\n\
        var rn;\n\
        var control;\n\
        var mapped;\n\
        var coeff;\n\
        var i, j;\n\
\n\
        for (i = 0; i <= n; i += 1) {\n\
          control = controls[i];\n\
          points[i] = control instanceof Function ? control(point) : control;\n\
        }\n\
\n\
        rn = points[0].length;\n\
        mapped = new Array(rn);\n\
\n\
        for (i = 0; i < rn; i += 1) {\n\
          mapped[i] = 0.0;\n\
        }\n\
\n\
        for (i = 0; i <= n; i += 1) {\n\
          coeff = DE_BOORD(knots,i,k,t,n);\n\
          for (j = 0; j < rn; j += 1) {\n\
            mapped[j] += points[i][j] * coeff;\n\
          }\n\
        }\n\
\n\
        return mapped;\n\
      };\n\
    };\n\
  };\n\
};\n\
\n\
/**\n\
 * NUBSPLINE\n\
 * \n\
 * @param {Number} degree\n\
 * @param {Number} [totpoints=80]\n\
 * @return {Function}\n\
 *   @param {Array} knots\n\
 *   @return {Function}\n\
 *     @param {Array} point\n\
 *     @return {plasm.Model}\n\
 * @api public\n\
 */\n\
\n\
var NUBSPLINE =\n\
fun.NUBSPLINE = function (degree, totpoints) {\n\
  var totpoints = totpoints !== undefined ? totpoints : 80;\n\
  \n\
  return function (knots) {\n\
    return function (points) {\n\
      var m = knots.length;\n\
      var tmin = SMALLEST(knots);\n\
      var tmax = BIGGEST(knots);\n\
      var tsiz = tmax - tmin;\n\
      var size = totpoints - 1;\n\
      var v = new Array(size + 1);\n\
      var domain;\n\
      var i;\n\
\n\
      v[0] = -tmin;\n\
      for (i = 1; i <= size; i += 1) {\n\
        v[i] = tsiz / size;\n\
      }\n\
\n\
      domain = SIMPLEX_GRID([v]);\n\
      \n\
      return MAP(BSPLINE(degree)(knots)(points))(domain);\n\
    };\n\
  };\n\
};\n\
\n\
/**\n\
 * NUBS\n\
 * \n\
 * @parm {Function} sel\n\
 * @return {Function}\n\
 *   @param {Number} degree\n\
 *   @return {Function}\n\
 *     @param {Array} knots\n\
 *     @return {Function}\n\
 *       @param {Array} controls\n\
 *       @return {Funciton}\n\
 * @api public\n\
 */\n\
\n\
var NUBS =\n\
fun.NUBS = function (sel) {\n\
  return function (degree) {\n\
    return function (knots) {\n\
      return function (controls) {\n\
        var n = controls.length - 1;\n\
        var knotsLength = knots.length;\n\
        var k = degree + 1;\n\
\n\
        // see http://www.na.iac.cnr.it/~bdv/cagd/spline/B-spline/bspline-curve.html\n\
        if (knots.length !== (n+k+1)) {\n\
          throw \"Invalid point/knots/degree for bspline!\";\n\
        }\n\
\n\
        return function (point) {\n\
          var t = sel(point);\n\
          var points = new Array(n);\n\
          var kmin = SMALLEST(knots);\n\
          var kmax = BIGGEST(knots);\n\
          var ksize = kmax - kmin;\n\
          var mappedKnots = new Array(knotsLength);\n\
          var rn;\n\
          var control;\n\
          var mapped;\n\
          var coeff;\n\
          var i, j;\n\
\n\
          mappedKnots = knots.map(function (knot) {\n\
            return (knot - kmin) / ksize;\n\
          });\n\
\n\
          for (i = 0; i <= n; i += 1) {\n\
            control = controls[i];\n\
            points[i] = control instanceof Function ? control(point) : control;\n\
          }\n\
\n\
          rn = points[0].length;\n\
          mapped = new Array(rn);\n\
\n\
          for (i = 0; i < rn; i += 1) {\n\
            mapped[i] = 0.0;\n\
          } \n\
\n\
          for (i = 0; i <= n; i += 1) {\n\
            coeff = DE_BOORD(mappedKnots,i,k,t,n);\n\
            for (j = 0; j < rn; j += 1) {\n\
              mapped[j] += points[i][j] * coeff;\n\
            }\n\
          }\n\
\n\
          return mapped;\n\
        };\n\
      };\n\
    };\n\
  };\n\
};\n\
\n\
/**\n\
 * RATIONAL_BSPLINE\n\
 * \n\
 * @param {Number} degree\n\
 * @return {Function}\n\
 *   @param {Array} knots\n\
 *   @return {Function}\n\
 *     @param {Array} controls\n\
 *     @return {Funciton}\n\
 * @api public\n\
 */\n\
\n\
var RATIONAL_BSPLINE =\n\
fun.RATIONAL_BSPLINE = function (degree) {\n\
  return function (knots) {\n\
    return function (controls) {\n\
      var bspline = BSPLINE(degree)(knots)(controls);\n\
\n\
      return function (point) {\n\
        var mapped = bspline(point);\n\
        var last = mapped.slice(-1)[0];\n\
\n\
        // rationalize (== divide for the last value)\n\
        if (last !== 0) {\n\
          mapped = mapped.map(function (item) {\n\
            return item / last;\n\
          });\n\
        }\n\
        \n\
        return mapped.slice(0,-1);\n\
      };\n\
    };\n\
  };\n\
};\n\
\n\
/**\n\
 * NURBSPLINE\n\
 * \n\
 * @param {Number} degree\n\
 * @param {Number} [totpoints=80]\n\
 * @return {Function}\n\
 *   @param {Array} knots\n\
 *   @return {Function}\n\
 *     @param {Array} points\n\
 *     @return {plasm.Model}\n\
 * @api public\n\
 */\n\
\n\
var NURBSPLINE =\n\
fun.NURBSPLINE = function (degree, totpoints) {\n\
  var totpoints = totpoints !== undefined ? totpoints : 80;\n\
\n\
  return function (knots) {\n\
    return function (points) {\n\
      var m = knots.length;\n\
      var tmin = SMALLEST(knots);\n\
      var tmax = BIGGEST(knots);\n\
      var tsiz = tmax - tmin;\n\
      var size = totpoints - 1;\n\
      var v = new Array(size + 1);\n\
      var domain;\n\
      var i;\n\
\n\
      v[0] = -tmin;\n\
      for (i = 1; i <= size; i += 1) {\n\
        v[i] = tsiz / size;\n\
      }\n\
\n\
      domain = SIMPLEX_GRID([v]);\n\
      \n\
      return MAP(RATIONAL_BSPLINE(degree)(knots)(points))(domain);\n\
    };\n\
  };\n\
};\n\
\n\
/**\n\
 * ROTATIONAL_SURFACE\n\
 * \n\
 * @example\n\
 *   var domain = DOMAIN([[0,1],[0,2*PI]])([20,20]);\n\
 *   var profile = BEZIER(S0)([[0,0,0],[3,0,3],[3,0,5],[0,0,7]]);\n\
 *   var mapping = ROTATIONAL_SURFACE(profile);\n\
 *   var surface = MAP(mapping)(domain);\n\
 *\n\
 * @param {Function} profile mapping\n\
 * @return {Function}\n\
 *   @param {Array|Float32Array} point point to map\n\
 *   @return {Array|Float32Array) point mapped\n\
 * @api public\n\
 */\n\
\n\
var ROTATIONAL_SURFACE =\n\
fun.ROTATIONAL_SURFACE = function (profile) {\n\
  return function (point) {\n\
    var u = point[0];\n\
    var v = point[1];\n\
    var p = profile(point);\n\
    var f = p[0];\n\
    var h = p[1];\n\
    var g = p[2];\n\
    var ret = [f * COS(v), f * SIN(v), g];\n\
    return ret;\n\
  };\n\
};\n\
\n\
/**\n\
 * COONS_PATCH\n\
 * \n\
 * @param {Function} args\n\
 * @return {Function}\n\
 *   @param {Array} point\n\
 *   @return {Funciton}\n\
 * @api public\n\
 */\n\
\n\
var COONS_PATCH = \n\
fun.COONS_PATCH = function (args) {\n\
  var su0Fn = args[0];\n\
  var su1Fn = args[1];\n\
  var s0vFn = args[2];\n\
  var s1vFn = args[3];\n\
\n\
  return function (point) {\n\
    var u = point[0];\n\
    var v = point[1];\n\
\n\
    var s00 = su0Fn([0,0]);\n\
    var s01 = s0vFn([0,1]);\n\
    var s10 = su0Fn([1,0]);\n\
    var s11 = s1vFn([1,1]);\n\
\n\
    var su0 = su0Fn(point);\n\
    var su1 = su1Fn(point);\n\
    var s0v = s0vFn(point);\n\
    var s1v = s1vFn(point);\n\
    \n\
    var rn = su0.length;\n\
    var mapped = new Array(rn);\n\
    \n\
    var i;\n\
  \n\
    for (i = 0; i < rn; i += 1) { mapped[i] = (1-u)*s0v[i] + u*s1v[i] + (1-v)*su0[i] + v*su1[i] - (1-u)*(1-v)*s00[i] - (1-u)*v*s01[i] - u*(1-v)*s10[i] - u*v*s11[i];} \n\
    \n\
    return mapped;\n\
  };\n\
};\n\
\n\
/**\n\
 * PROFILEPROD_SURFACE\n\
 * \n\
 * @example\n\
 * var dom1D = INTERVALS(1)(32);\n\
 * var Su0 = BEZIER(S0)([[0,0,0],[2,0,0],[0,0,4],[1,0,5]]);\n\
 * var curve0 = MAP(Su0)(dom1D);\n\
 * DRAW(COLOR([0,0,1])(curve0));\n\
 *\n\
 * var Su1 = BEZIER(S1)([[0,0,0],[3,-0.5,0],[3,3.5,0],[0,3,0]]);\n\
 * var Su1Draw = BEZIER(S0)([[0,0,0],[3,-0.5,0],[3,3.5,0],[0,3,0]]);\n\
 * var curve1 = MAP(Su1Draw)(dom1D);\n\
 * DRAW(COLOR([1,0,1])(curve1));\n\
 *\n\
 * var dom2D = PROD1x1([INTERVALS(1)(16),INTERVALS(1)(16)]); // DOMAIN([[0,1],[0,1]])([20,20]);\n\
 * var out = MAP(PROFILEPROD_SURFACE([Su0,Su1]))(dom2D);\n\
 * DRAW(out); \n\
 *\n\
 * @param {Array|Function} profile and section curves\n\
 * @return {Function}\n\
 *   @param {Array|Float32Array} point point to map\n\
 *   @return {Array|Float32Array) point mapped\n\
 * @api public\n\
 */\n\
\n\
var PROFILEPROD_SURFACE =\n\
fun.PROFILEPROD_SURFACE = function (profiles) {\n\
  var alfaProfile = profiles[0];\n\
  var betaSection = profiles[1];\n\
  return function (point) {\n\
  // Profilo di ALFA\n\
    var pAlfa = alfaProfile(point);\n\
  // Sezione di BETA\n\
  var sBeta = betaSection(point);\n\
  // Punti profilo ALFA\n\
    var xA = pAlfa[0];\n\
    var zA = pAlfa[2];\n\
  // Punti sezione BETA\n\
    var xB = sBeta[0];\n\
    var yB = sBeta[1];\n\
  // Return\n\
    var ret = [xA * xB, xA * yB, zA];\n\
    return ret;\n\
  };\n\
};\n\
\n\
/**\n\
 * RULED_SURFACE\n\
 * \n\
 * @example\n\
 * var dom2D = T([0,1])([-1,-1])( PROD1x1([INTERVALS(2)(10),INTERVALS(2)(10)]) );\n\
 * var fun1 = function(pt) { return [ pt[0], pt[0], 0 ]; };\n\
 * var fun2 = function(pt) { return [ 1, -1, pt[0] ]; };\n\
 * var out = MAP(RULED_SURFACE([fun1,fun2]))(dom2D);\n\
 * DRAW(out); \n\
 *\n\
 *\n\
 * @param {Array|Function} an array of function that can map a single point\n\
 * @return {Function}\n\
 *   @param {Array|Float32Array} point point to map\n\
 *   @return {Array|Float32Array) point mapped\n\
 * @api public\n\
 */\n\
\n\
var RULED_SURFACE =\n\
fun.RULED_SURFACE = function (arrayFuns) {\n\
  var alfaFun = arrayFuns[0];\n\
  var betaFun = arrayFuns[1];\n\
  return function (point) {\n\
    var v = point[1];\n\
    // Generate ALFA points\n\
      var pAlfa = alfaFun(point);\n\
    // Generate BETA points\n\
    var sBeta = betaFun(point);\n\
    // Return\n\
      var ret = [];\n\
    pAlfa.forEach(function(item,index) { ret.push( pAlfa[index] + v*sBeta[index] ); } );\n\
      return ret;\n\
  };\n\
};\n\
\n\
/**\n\
 * CONICAL_SURFACE\n\
 * \n\
 * @example\n\
 * var domain = PROD1x1([INTERVALS(1)(20),INTERVALS(1)(6)]);\n\
 * var apex = [0,0,1];\n\
 * var funProfile = BEZIER(S0)([[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0]]);\n\
 * var out = MAP(CONICAL_SURFACE(apex)(funProfile))(domain);\n\
 * DRAW(out); \n\
 *\n\
 *\n\
 * @param {Array} the cone's vertex (apex)\n\
 * @return {Function} \n\
 *    @param {Function} profile mapping\n\
 *    @return {Array|Float32Array} point mapped\n\
 * @api public\n\
 */\n\
\n\
var CONICAL_SURFACE =\n\
fun.CONICAL_SURFACE = function (apex) {\n\
  return function(profile) {\n\
    var apexFun = K(apex);\n\
    var profileDiff = function(apexData, profileFunction) {\n\
      return function(point) {\n\
        var newPoint = [];\n\
        var profilePt = profileFunction(point);\n\
        profilePt.forEach(function(item,index) { \n\
          newPoint.push( profilePt[index] - apexData[index] ); \n\
        });\n\
        return newPoint;\n\
      };\n\
    };\n\
\n\
    return RULED_SURFACE([apexFun, profileDiff(apex,profile)]);\n\
  };\n\
};  \n\
\n\
/**\n\
 * CYLINDRICAL_SURFACE\n\
 * \n\
 * @example\n\
 * var domain = PROD1x1([INTERVALS(1)(20),INTERVALS(1)(6)]);\n\
 * var ncpVector = [0,0,1];\n\
 * var funProfile = BEZIER(S0)([[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0]]);\n\
 * var out = MAP(CYLINDRICAL_SURFACE(funProfile)(ncpVector))(domain);\n\
 * DRAW(out); \n\
 *\n\
 *\n\
 * @param {Function} profile mapping\n\
 * @return {Function} \n\
 *    @param {Array} non complanar vector to the curve in the profile mapping\n\
 *    @return {Array|Float32Array} point mapped\n\
 * @api public\n\
 */\n\
\n\
var CYLINDRICAL_SURFACE = \n\
fun.CYLINDRICAL_SURFACE = function (profile) {\n\
  return function(vector) {\n\
    return RULED_SURFACE([ profile, CONS(AA(K)(vector)) ]);\n\
  };\n\
};  \n\
\n\
/**\n\
 * TRIANGLE_DOMAIN\n\
 * @param {Number} n\n\
 * @param {Array} points\n\
 * @return {plasm.Model} triangle domain\n\
 * @api public\n\
 */\n\
\n\
var TRIANGLE_DOMAIN = \n\
fun.TRIANGLE_DOMAIN = function (n, points) {\n\
  return plasm.geometries.triangleDomain(n, points);\n\
};\n\
\n\
/**\n\
 * TRIANGULAR_COONS_PATCH\n\
 * \n\
 * @param {Array|Function} three profile curves\n\
 * @return {Function}\n\
 *   @param {Array|Float32Array} point point to map\n\
 *   @return {Array|Float32Array) point mapped\n\
 * @api public\n\
 */\n\
\n\
var TRIANGULAR_COONS_PATCH = \n\
fun.TRIANGULAR_COONS_PATCH = function (args) {\n\
  var ab0Fn = args[0];\n\
  var bc1Fn = args[1];\n\
  var ca0Fn = args[2];\n\
\n\
  return function (point) {\n\
    var u = point[0];\n\
    var v = point[1];\n\
    var w = point[2];\n\
\n\
    var Sab0 = ab0Fn instanceof Function ? ab0Fn(point) : ab0Fn;\n\
    var Sbc1 = bc1Fn instanceof Function ? bc1Fn(point) : bc1Fn;\n\
    var Sca0 = ca0Fn instanceof Function ? ca0Fn(point) : ca0Fn;\n\
\n\
    var rn = Sab0.length;\n\
    var mapped = new Array(rn);\n\
    \n\
    var i, r, s, t;\n\
  \n\
    if (u === 1) {ur = 0} else {ur = u * v / (v + w)};\n\
    if (v === 1) {vs = 0} else {vs = v * w / (w + u)};\n\
    if (w === 1) {wt = 0} else {wt = w * u / (v + u)};\n\
    \n\
    for (i = 0; i < rn; i += 1) {mapped[i] =  u * Sab0[i] + ur * (Sca0[i] - Sab0[i]) + v * Sca0[i] + vs * (Sbc1[i] - Sca0[i]) + w * Sbc1[i] + wt * (Sab0[i] - Sbc1[i]);};\n\
\n\
    return mapped;\n\
\n\
  };\n\
};\n\
\n\
/**\n\
* INTERP_P2P (interpolation point to point)\n\
* INTERP_P2C (interpolation point to curve)\n\
* INTERP_P2S (interpolation point to surface)\n\
* INTERP_C2C (interpolation curve to curve)\n\
* INTERP_C2S (interpolation curve to surface)\n\
* INTERP_S2S (interpolation surface to surface)\n\
*\n\
* @param {Function} sel\n\
* @return {Function}\n\
* @param {Array} args\n\
* @return {Function}\n\
* @param {Array} point\n\
* @return {Function}\n\
* @api public\n\
*\n\
*/\n\
  \n\
var INTERP_P2P = \n\
fun.INTERP_P2P = function (sel) {\n\
    return function (args) {\n\
        var P1 = args[0];\n\
        var P2 = args[1];\n\
\n\
        return function (point) {\n\
            var u = sel(point);\n\
\n\
      var mapped = new Array(3);\n\
var i;\n\
for (i = 0; i < 3; i += 1) { mapped[i] = P1[i] + u * (P2[i] - P1[i]);}\n\
return mapped;\n\
        };\n\
    };\n\
};\n\
\n\
var INTERP_P2C = \n\
fun.INTERP_P2C = function (sel) {\n\
    return function (args) {\n\
        var P1 = args[0];\n\
        var C1 = args[1];\n\
\n\
        return function (point) {\n\
            var v = sel(point);\n\
            var C1u = C1(point);\n\
\n\
var mapped = new Array(3);\n\
var i;\n\
for (i = 0; i < 3; i += 1) { mapped[i] = P1[i] + v * (C1u[i] - P1[i]);}\n\
return mapped;\n\
        };\n\
    };\n\
};\n\
\n\
var INTERP_P2S = \n\
fun.INTERP_P2S = function (sel) {\n\
    return function (args) {\n\
        var P1 = args[0];\n\
        var S1 = args[1];\n\
\n\
        return function (point) {\n\
            var z = sel(point);\n\
            var S1uv = S1(point);\n\
\n\
      var mapped = new Array(3);\n\
var i;\n\
for (i = 0; i < 3; i += 1) { mapped[i] = P1[i] + z * (S1uv[i] - P1[i]);}\n\
return mapped;\n\
        };\n\
    };\n\
};\n\
\n\
var INTERP_C2C = \n\
fun.INTERP_C2C = function (sel) {\n\
    return function (args) {\n\
        var C1 = args[0];\n\
        var C2 = args[1];\n\
\n\
        return function (point) {\n\
            var v = sel(point);\n\
            var C1u = C1(point);\n\
            var C2u = C2(point);\n\
\n\
var mapped = new Array(3);\n\
var i;\n\
for (i = 0; i < 3; i += 1) { mapped[i] = C2u[i] + v * (C1u[i] - C2u[i]);}\n\
return mapped;\n\
        };\n\
    };\n\
};\n\
\n\
var INTERP_C2S = \n\
fun.INTERP_C2S = function (sel) {\n\
    return function (args) {\n\
        var C1 = args[0];\n\
        var S1 = args[1];\n\
\n\
        return function (point) {\n\
            var z = sel(point);\n\
            var C1u = C1(point);\n\
            var S1uv = S1(point);\n\
\n\
var mapped = new Array(3);\n\
var i;\n\
for (i = 0; i < 3; i += 1) { mapped[i] = C1u[i] + z * (S1uv[i] - C1u[i]);}\n\
return mapped;\n\
        };\n\
    };\n\
};\n\
\n\
var INTERP_S2S = \n\
fun.INTERP_S2S = function (sel) {\n\
    return function (args) {\n\
        var S1 = args[0];\n\
        var S2 = args[1];\n\
\n\
        return function (point) {\n\
            var z = sel(point);\n\
            var S1uv = S1(point);\n\
            var S2uv = S2(point);\n\
\n\
var mapped = new Array(3);\n\
var i;\n\
for (i = 0; i < 3; i += 1) { mapped[i] = S1uv[i] + z * (S2uv[i] - S1uv[i]);}\n\
return mapped;\n\
        };\n\
    };\n\
};\n\
//@ sourceURL=cvdlab-plasm-fun/index.js"
));
require.register("component-jquery/index.js", Function("exports, require, module",
"/*!\n\
 * jQuery JavaScript Library v1.9.1\n\
 * http://jquery.com/\n\
 *\n\
 * Includes Sizzle.js\n\
 * http://sizzlejs.com/\n\
 *\n\
 * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors\n\
 * Released under the MIT license\n\
 * http://jquery.org/license\n\
 *\n\
 * Date: 2013-2-4\n\
 */\n\
(function( window, undefined ) {\n\
\n\
// Can't do this because several apps including ASP.NET trace\n\
// the stack via arguments.caller.callee and Firefox dies if\n\
// you try to trace through \"use strict\" call chains. (#13335)\n\
// Support: Firefox 18+\n\
//\"use strict\";\n\
var\n\
\t// The deferred used on DOM ready\n\
\treadyList,\n\
\n\
\t// A central reference to the root jQuery(document)\n\
\trootjQuery,\n\
\n\
\t// Support: IE<9\n\
\t// For `typeof node.method` instead of `node.method !== undefined`\n\
\tcore_strundefined = typeof undefined,\n\
\n\
\t// Use the correct document accordingly with window argument (sandbox)\n\
\tdocument = window.document,\n\
\tlocation = window.location,\n\
\n\
\t// Map over jQuery in case of overwrite\n\
\t_jQuery = window.jQuery,\n\
\n\
\t// Map over the $ in case of overwrite\n\
\t_$ = window.$,\n\
\n\
\t// [[Class]] -> type pairs\n\
\tclass2type = {},\n\
\n\
\t// List of deleted data cache ids, so we can reuse them\n\
\tcore_deletedIds = [],\n\
\n\
\tcore_version = \"1.9.1\",\n\
\n\
\t// Save a reference to some core methods\n\
\tcore_concat = core_deletedIds.concat,\n\
\tcore_push = core_deletedIds.push,\n\
\tcore_slice = core_deletedIds.slice,\n\
\tcore_indexOf = core_deletedIds.indexOf,\n\
\tcore_toString = class2type.toString,\n\
\tcore_hasOwn = class2type.hasOwnProperty,\n\
\tcore_trim = core_version.trim,\n\
\n\
\t// Define a local copy of jQuery\n\
\tjQuery = function( selector, context ) {\n\
\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\
\t\treturn new jQuery.fn.init( selector, context, rootjQuery );\n\
\t},\n\
\n\
\t// Used for matching numbers\n\
\tcore_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n\
\n\
\t// Used for splitting on whitespace\n\
\tcore_rnotwhite = /\\S+/g,\n\
\n\
\t// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)\n\
\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\
\n\
\t// A simple way to check for HTML strings\n\
\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\
\t// Strict HTML recognition (#11290: must start with <)\n\
\trquickExpr = /^(?:(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\
\n\
\t// Match a standalone tag\n\
\trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n\
\n\
\t// JSON RegExp\n\
\trvalidchars = /^[\\],:{}\\s]*$/,\n\
\trvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n\
\trvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,\n\
\trvalidtokens = /\"[^\"\\\\\\r\\n\
]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,\n\
\n\
\t// Matches dashed string for camelizing\n\
\trmsPrefix = /^-ms-/,\n\
\trdashAlpha = /-([\\da-z])/gi,\n\
\n\
\t// Used by jQuery.camelCase as callback to replace()\n\
\tfcamelCase = function( all, letter ) {\n\
\t\treturn letter.toUpperCase();\n\
\t},\n\
\n\
\t// The ready event handler\n\
\tcompleted = function( event ) {\n\
\n\
\t\t// readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\
\t\tif ( document.addEventListener || event.type === \"load\" || document.readyState === \"complete\" ) {\n\
\t\t\tdetach();\n\
\t\t\tjQuery.ready();\n\
\t\t}\n\
\t},\n\
\t// Clean-up method for dom ready events\n\
\tdetach = function() {\n\
\t\tif ( document.addEventListener ) {\n\
\t\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\
\t\t\twindow.removeEventListener( \"load\", completed, false );\n\
\n\
\t\t} else {\n\
\t\t\tdocument.detachEvent( \"onreadystatechange\", completed );\n\
\t\t\twindow.detachEvent( \"onload\", completed );\n\
\t\t}\n\
\t};\n\
\n\
jQuery.fn = jQuery.prototype = {\n\
\t// The current version of jQuery being used\n\
\tjquery: core_version,\n\
\n\
\tconstructor: jQuery,\n\
\tinit: function( selector, context, rootjQuery ) {\n\
\t\tvar match, elem;\n\
\n\
\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\
\t\tif ( !selector ) {\n\
\t\t\treturn this;\n\
\t\t}\n\
\n\
\t\t// Handle HTML strings\n\
\t\tif ( typeof selector === \"string\" ) {\n\
\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\
\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\
\t\t\t\tmatch = [ null, selector, null ];\n\
\n\
\t\t\t} else {\n\
\t\t\t\tmatch = rquickExpr.exec( selector );\n\
\t\t\t}\n\
\n\
\t\t\t// Match html or make sure no context is specified for #id\n\
\t\t\tif ( match && (match[1] || !context) ) {\n\
\n\
\t\t\t\t// HANDLE: $(html) -> $(array)\n\
\t\t\t\tif ( match[1] ) {\n\
\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\
\n\
\t\t\t\t\t// scripts is true for back-compat\n\
\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\
\t\t\t\t\t\tmatch[1],\n\
\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\
\t\t\t\t\t\ttrue\n\
\t\t\t\t\t) );\n\
\n\
\t\t\t\t\t// HANDLE: $(html, props)\n\
\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\
\t\t\t\t\t\tfor ( match in context ) {\n\
\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\
\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\
\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\
\n\
\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\
\t\t\t\t\t\t\t} else {\n\
\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\treturn this;\n\
\n\
\t\t\t\t// HANDLE: $(#id)\n\
\t\t\t\t} else {\n\
\t\t\t\t\telem = document.getElementById( match[2] );\n\
\n\
\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\
\t\t\t\t\t// nodes that are no longer in the document #6963\n\
\t\t\t\t\tif ( elem && elem.parentNode ) {\n\
\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\
\t\t\t\t\t\t// by name instead of ID\n\
\t\t\t\t\t\tif ( elem.id !== match[2] ) {\n\
\t\t\t\t\t\t\treturn rootjQuery.find( selector );\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\
\t\t\t\t\t\tthis.length = 1;\n\
\t\t\t\t\t\tthis[0] = elem;\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tthis.context = document;\n\
\t\t\t\t\tthis.selector = selector;\n\
\t\t\t\t\treturn this;\n\
\t\t\t\t}\n\
\n\
\t\t\t// HANDLE: $(expr, $(...))\n\
\t\t\t} else if ( !context || context.jquery ) {\n\
\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\
\n\
\t\t\t// HANDLE: $(expr, context)\n\
\t\t\t// (which is just equivalent to: $(context).find(expr)\n\
\t\t\t} else {\n\
\t\t\t\treturn this.constructor( context ).find( selector );\n\
\t\t\t}\n\
\n\
\t\t// HANDLE: $(DOMElement)\n\
\t\t} else if ( selector.nodeType ) {\n\
\t\t\tthis.context = this[0] = selector;\n\
\t\t\tthis.length = 1;\n\
\t\t\treturn this;\n\
\n\
\t\t// HANDLE: $(function)\n\
\t\t// Shortcut for document ready\n\
\t\t} else if ( jQuery.isFunction( selector ) ) {\n\
\t\t\treturn rootjQuery.ready( selector );\n\
\t\t}\n\
\n\
\t\tif ( selector.selector !== undefined ) {\n\
\t\t\tthis.selector = selector.selector;\n\
\t\t\tthis.context = selector.context;\n\
\t\t}\n\
\n\
\t\treturn jQuery.makeArray( selector, this );\n\
\t},\n\
\n\
\t// Start with an empty selector\n\
\tselector: \"\",\n\
\n\
\t// The default length of a jQuery object is 0\n\
\tlength: 0,\n\
\n\
\t// The number of elements contained in the matched element set\n\
\tsize: function() {\n\
\t\treturn this.length;\n\
\t},\n\
\n\
\ttoArray: function() {\n\
\t\treturn core_slice.call( this );\n\
\t},\n\
\n\
\t// Get the Nth element in the matched element set OR\n\
\t// Get the whole matched element set as a clean array\n\
\tget: function( num ) {\n\
\t\treturn num == null ?\n\
\n\
\t\t\t// Return a 'clean' array\n\
\t\t\tthis.toArray() :\n\
\n\
\t\t\t// Return just the object\n\
\t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\n\
\t},\n\
\n\
\t// Take an array of elements and push it onto the stack\n\
\t// (returning the new matched element set)\n\
\tpushStack: function( elems ) {\n\
\n\
\t\t// Build a new jQuery matched element set\n\
\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\
\n\
\t\t// Add the old object onto the stack (as a reference)\n\
\t\tret.prevObject = this;\n\
\t\tret.context = this.context;\n\
\n\
\t\t// Return the newly-formed element set\n\
\t\treturn ret;\n\
\t},\n\
\n\
\t// Execute a callback for every element in the matched set.\n\
\t// (You can seed the arguments with an array of args, but this is\n\
\t// only used internally.)\n\
\teach: function( callback, args ) {\n\
\t\treturn jQuery.each( this, callback, args );\n\
\t},\n\
\n\
\tready: function( fn ) {\n\
\t\t// Add the callback\n\
\t\tjQuery.ready.promise().done( fn );\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\tslice: function() {\n\
\t\treturn this.pushStack( core_slice.apply( this, arguments ) );\n\
\t},\n\
\n\
\tfirst: function() {\n\
\t\treturn this.eq( 0 );\n\
\t},\n\
\n\
\tlast: function() {\n\
\t\treturn this.eq( -1 );\n\
\t},\n\
\n\
\teq: function( i ) {\n\
\t\tvar len = this.length,\n\
\t\t\tj = +i + ( i < 0 ? len : 0 );\n\
\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\
\t},\n\
\n\
\tmap: function( callback ) {\n\
\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\
\t\t\treturn callback.call( elem, i, elem );\n\
\t\t}));\n\
\t},\n\
\n\
\tend: function() {\n\
\t\treturn this.prevObject || this.constructor(null);\n\
\t},\n\
\n\
\t// For internal use only.\n\
\t// Behaves like an Array's method, not like a jQuery method.\n\
\tpush: core_push,\n\
\tsort: [].sort,\n\
\tsplice: [].splice\n\
};\n\
\n\
// Give the init function the jQuery prototype for later instantiation\n\
jQuery.fn.init.prototype = jQuery.fn;\n\
\n\
jQuery.extend = jQuery.fn.extend = function() {\n\
\tvar src, copyIsArray, copy, name, options, clone,\n\
\t\ttarget = arguments[0] || {},\n\
\t\ti = 1,\n\
\t\tlength = arguments.length,\n\
\t\tdeep = false;\n\
\n\
\t// Handle a deep copy situation\n\
\tif ( typeof target === \"boolean\" ) {\n\
\t\tdeep = target;\n\
\t\ttarget = arguments[1] || {};\n\
\t\t// skip the boolean and the target\n\
\t\ti = 2;\n\
\t}\n\
\n\
\t// Handle case when target is a string or something (possible in deep copy)\n\
\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\
\t\ttarget = {};\n\
\t}\n\
\n\
\t// extend jQuery itself if only one argument is passed\n\
\tif ( length === i ) {\n\
\t\ttarget = this;\n\
\t\t--i;\n\
\t}\n\
\n\
\tfor ( ; i < length; i++ ) {\n\
\t\t// Only deal with non-null/undefined values\n\
\t\tif ( (options = arguments[ i ]) != null ) {\n\
\t\t\t// Extend the base object\n\
\t\t\tfor ( name in options ) {\n\
\t\t\t\tsrc = target[ name ];\n\
\t\t\t\tcopy = options[ name ];\n\
\n\
\t\t\t\t// Prevent never-ending loop\n\
\t\t\t\tif ( target === copy ) {\n\
\t\t\t\t\tcontinue;\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// Recurse if we're merging plain objects or arrays\n\
\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\
\t\t\t\t\tif ( copyIsArray ) {\n\
\t\t\t\t\t\tcopyIsArray = false;\n\
\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\
\n\
\t\t\t\t\t} else {\n\
\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Never move original objects, clone them\n\
\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\
\n\
\t\t\t\t// Don't bring in undefined values\n\
\t\t\t\t} else if ( copy !== undefined ) {\n\
\t\t\t\t\ttarget[ name ] = copy;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\t// Return the modified object\n\
\treturn target;\n\
};\n\
\n\
jQuery.extend({\n\
\tnoConflict: function( deep ) {\n\
\t\tif ( window.$ === jQuery ) {\n\
\t\t\twindow.$ = _$;\n\
\t\t}\n\
\n\
\t\tif ( deep && window.jQuery === jQuery ) {\n\
\t\t\twindow.jQuery = _jQuery;\n\
\t\t}\n\
\n\
\t\treturn jQuery;\n\
\t},\n\
\n\
\t// Is the DOM ready to be used? Set to true once it occurs.\n\
\tisReady: false,\n\
\n\
\t// A counter to track how many items to wait for before\n\
\t// the ready event fires. See #6781\n\
\treadyWait: 1,\n\
\n\
\t// Hold (or release) the ready event\n\
\tholdReady: function( hold ) {\n\
\t\tif ( hold ) {\n\
\t\t\tjQuery.readyWait++;\n\
\t\t} else {\n\
\t\t\tjQuery.ready( true );\n\
\t\t}\n\
\t},\n\
\n\
\t// Handle when the DOM is ready\n\
\tready: function( wait ) {\n\
\n\
\t\t// Abort if there are pending holds or we're already ready\n\
\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\
\t\tif ( !document.body ) {\n\
\t\t\treturn setTimeout( jQuery.ready );\n\
\t\t}\n\
\n\
\t\t// Remember that the DOM is ready\n\
\t\tjQuery.isReady = true;\n\
\n\
\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\
\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\t// If there are functions bound, to execute\n\
\t\treadyList.resolveWith( document, [ jQuery ] );\n\
\n\
\t\t// Trigger any bound ready events\n\
\t\tif ( jQuery.fn.trigger ) {\n\
\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\n\
\t\t}\n\
\t},\n\
\n\
\t// See test/unit/core.js for details concerning isFunction.\n\
\t// Since version 1.3, DOM methods and functions like alert\n\
\t// aren't supported. They return false on IE (#2968).\n\
\tisFunction: function( obj ) {\n\
\t\treturn jQuery.type(obj) === \"function\";\n\
\t},\n\
\n\
\tisArray: Array.isArray || function( obj ) {\n\
\t\treturn jQuery.type(obj) === \"array\";\n\
\t},\n\
\n\
\tisWindow: function( obj ) {\n\
\t\treturn obj != null && obj == obj.window;\n\
\t},\n\
\n\
\tisNumeric: function( obj ) {\n\
\t\treturn !isNaN( parseFloat(obj) ) && isFinite( obj );\n\
\t},\n\
\n\
\ttype: function( obj ) {\n\
\t\tif ( obj == null ) {\n\
\t\t\treturn String( obj );\n\
\t\t}\n\
\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\
\t\t\tclass2type[ core_toString.call(obj) ] || \"object\" :\n\
\t\t\ttypeof obj;\n\
\t},\n\
\n\
\tisPlainObject: function( obj ) {\n\
\t\t// Must be an Object.\n\
\t\t// Because of IE, we also have to check the presence of the constructor property.\n\
\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\
\t\tif ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\
\t\t\treturn false;\n\
\t\t}\n\
\n\
\t\ttry {\n\
\t\t\t// Not own constructor property must be Object\n\
\t\t\tif ( obj.constructor &&\n\
\t\t\t\t!core_hasOwn.call(obj, \"constructor\") &&\n\
\t\t\t\t!core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n\
\t\t\t\treturn false;\n\
\t\t\t}\n\
\t\t} catch ( e ) {\n\
\t\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n\
\t\t\treturn false;\n\
\t\t}\n\
\n\
\t\t// Own properties are enumerated firstly, so to speed up,\n\
\t\t// if last one is own, then all properties are own.\n\
\n\
\t\tvar key;\n\
\t\tfor ( key in obj ) {}\n\
\n\
\t\treturn key === undefined || core_hasOwn.call( obj, key );\n\
\t},\n\
\n\
\tisEmptyObject: function( obj ) {\n\
\t\tvar name;\n\
\t\tfor ( name in obj ) {\n\
\t\t\treturn false;\n\
\t\t}\n\
\t\treturn true;\n\
\t},\n\
\n\
\terror: function( msg ) {\n\
\t\tthrow new Error( msg );\n\
\t},\n\
\n\
\t// data: string of html\n\
\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\
\t// keepScripts (optional): If true, will include scripts passed in the html string\n\
\tparseHTML: function( data, context, keepScripts ) {\n\
\t\tif ( !data || typeof data !== \"string\" ) {\n\
\t\t\treturn null;\n\
\t\t}\n\
\t\tif ( typeof context === \"boolean\" ) {\n\
\t\t\tkeepScripts = context;\n\
\t\t\tcontext = false;\n\
\t\t}\n\
\t\tcontext = context || document;\n\
\n\
\t\tvar parsed = rsingleTag.exec( data ),\n\
\t\t\tscripts = !keepScripts && [];\n\
\n\
\t\t// Single tag\n\
\t\tif ( parsed ) {\n\
\t\t\treturn [ context.createElement( parsed[1] ) ];\n\
\t\t}\n\
\n\
\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\
\t\tif ( scripts ) {\n\
\t\t\tjQuery( scripts ).remove();\n\
\t\t}\n\
\t\treturn jQuery.merge( [], parsed.childNodes );\n\
\t},\n\
\n\
\tparseJSON: function( data ) {\n\
\t\t// Attempt to parse using the native JSON parser first\n\
\t\tif ( window.JSON && window.JSON.parse ) {\n\
\t\t\treturn window.JSON.parse( data );\n\
\t\t}\n\
\n\
\t\tif ( data === null ) {\n\
\t\t\treturn data;\n\
\t\t}\n\
\n\
\t\tif ( typeof data === \"string\" ) {\n\
\n\
\t\t\t// Make sure leading/trailing whitespace is removed (IE can't handle it)\n\
\t\t\tdata = jQuery.trim( data );\n\
\n\
\t\t\tif ( data ) {\n\
\t\t\t\t// Make sure the incoming data is actual JSON\n\
\t\t\t\t// Logic borrowed from http://json.org/json2.js\n\
\t\t\t\tif ( rvalidchars.test( data.replace( rvalidescape, \"@\" )\n\
\t\t\t\t\t.replace( rvalidtokens, \"]\" )\n\
\t\t\t\t\t.replace( rvalidbraces, \"\")) ) {\n\
\n\
\t\t\t\t\treturn ( new Function( \"return \" + data ) )();\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\tjQuery.error( \"Invalid JSON: \" + data );\n\
\t},\n\
\n\
\t// Cross-browser xml parsing\n\
\tparseXML: function( data ) {\n\
\t\tvar xml, tmp;\n\
\t\tif ( !data || typeof data !== \"string\" ) {\n\
\t\t\treturn null;\n\
\t\t}\n\
\t\ttry {\n\
\t\t\tif ( window.DOMParser ) { // Standard\n\
\t\t\t\ttmp = new DOMParser();\n\
\t\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\n\
\t\t\t} else { // IE\n\
\t\t\t\txml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n\
\t\t\t\txml.async = \"false\";\n\
\t\t\t\txml.loadXML( data );\n\
\t\t\t}\n\
\t\t} catch( e ) {\n\
\t\t\txml = undefined;\n\
\t\t}\n\
\t\tif ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\
\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\
\t\t}\n\
\t\treturn xml;\n\
\t},\n\
\n\
\tnoop: function() {},\n\
\n\
\t// Evaluates a script in a global context\n\
\t// Workarounds based on findings by Jim Driscoll\n\
\t// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n\
\tglobalEval: function( data ) {\n\
\t\tif ( data && jQuery.trim( data ) ) {\n\
\t\t\t// We use execScript on Internet Explorer\n\
\t\t\t// We use an anonymous function so that context is window\n\
\t\t\t// rather than jQuery in Firefox\n\
\t\t\t( window.execScript || function( data ) {\n\
\t\t\t\twindow[ \"eval\" ].call( window, data );\n\
\t\t\t} )( data );\n\
\t\t}\n\
\t},\n\
\n\
\t// Convert dashed to camelCase; used by the css and data modules\n\
\t// Microsoft forgot to hump their vendor prefix (#9572)\n\
\tcamelCase: function( string ) {\n\
\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\
\t},\n\
\n\
\tnodeName: function( elem, name ) {\n\
\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\
\t},\n\
\n\
\t// args is for internal usage only\n\
\teach: function( obj, callback, args ) {\n\
\t\tvar value,\n\
\t\t\ti = 0,\n\
\t\t\tlength = obj.length,\n\
\t\t\tisArray = isArraylike( obj );\n\
\n\
\t\tif ( args ) {\n\
\t\t\tif ( isArray ) {\n\
\t\t\t\tfor ( ; i < length; i++ ) {\n\
\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\
\n\
\t\t\t\t\tif ( value === false ) {\n\
\t\t\t\t\t\tbreak;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t} else {\n\
\t\t\t\tfor ( i in obj ) {\n\
\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\
\n\
\t\t\t\t\tif ( value === false ) {\n\
\t\t\t\t\t\tbreak;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t// A special, fast, case for the most common use of each\n\
\t\t} else {\n\
\t\t\tif ( isArray ) {\n\
\t\t\t\tfor ( ; i < length; i++ ) {\n\
\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\
\n\
\t\t\t\t\tif ( value === false ) {\n\
\t\t\t\t\t\tbreak;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t} else {\n\
\t\t\t\tfor ( i in obj ) {\n\
\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\
\n\
\t\t\t\t\tif ( value === false ) {\n\
\t\t\t\t\t\tbreak;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn obj;\n\
\t},\n\
\n\
\t// Use native String.trim function wherever possible\n\
\ttrim: core_trim && !core_trim.call(\"\\uFEFF\\xA0\") ?\n\
\t\tfunction( text ) {\n\
\t\t\treturn text == null ?\n\
\t\t\t\t\"\" :\n\
\t\t\t\tcore_trim.call( text );\n\
\t\t} :\n\
\n\
\t\t// Otherwise use our own trimming functionality\n\
\t\tfunction( text ) {\n\
\t\t\treturn text == null ?\n\
\t\t\t\t\"\" :\n\
\t\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\
\t\t},\n\
\n\
\t// results is for internal usage only\n\
\tmakeArray: function( arr, results ) {\n\
\t\tvar ret = results || [];\n\
\n\
\t\tif ( arr != null ) {\n\
\t\t\tif ( isArraylike( Object(arr) ) ) {\n\
\t\t\t\tjQuery.merge( ret,\n\
\t\t\t\t\ttypeof arr === \"string\" ?\n\
\t\t\t\t\t[ arr ] : arr\n\
\t\t\t\t);\n\
\t\t\t} else {\n\
\t\t\t\tcore_push.call( ret, arr );\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn ret;\n\
\t},\n\
\n\
\tinArray: function( elem, arr, i ) {\n\
\t\tvar len;\n\
\n\
\t\tif ( arr ) {\n\
\t\t\tif ( core_indexOf ) {\n\
\t\t\t\treturn core_indexOf.call( arr, elem, i );\n\
\t\t\t}\n\
\n\
\t\t\tlen = arr.length;\n\
\t\t\ti = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\
\n\
\t\t\tfor ( ; i < len; i++ ) {\n\
\t\t\t\t// Skip accessing in sparse arrays\n\
\t\t\t\tif ( i in arr && arr[ i ] === elem ) {\n\
\t\t\t\t\treturn i;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn -1;\n\
\t},\n\
\n\
\tmerge: function( first, second ) {\n\
\t\tvar l = second.length,\n\
\t\t\ti = first.length,\n\
\t\t\tj = 0;\n\
\n\
\t\tif ( typeof l === \"number\" ) {\n\
\t\t\tfor ( ; j < l; j++ ) {\n\
\t\t\t\tfirst[ i++ ] = second[ j ];\n\
\t\t\t}\n\
\t\t} else {\n\
\t\t\twhile ( second[j] !== undefined ) {\n\
\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\tfirst.length = i;\n\
\n\
\t\treturn first;\n\
\t},\n\
\n\
\tgrep: function( elems, callback, inv ) {\n\
\t\tvar retVal,\n\
\t\t\tret = [],\n\
\t\t\ti = 0,\n\
\t\t\tlength = elems.length;\n\
\t\tinv = !!inv;\n\
\n\
\t\t// Go through the array, only saving the items\n\
\t\t// that pass the validator function\n\
\t\tfor ( ; i < length; i++ ) {\n\
\t\t\tretVal = !!callback( elems[ i ], i );\n\
\t\t\tif ( inv !== retVal ) {\n\
\t\t\t\tret.push( elems[ i ] );\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn ret;\n\
\t},\n\
\n\
\t// arg is for internal usage only\n\
\tmap: function( elems, callback, arg ) {\n\
\t\tvar value,\n\
\t\t\ti = 0,\n\
\t\t\tlength = elems.length,\n\
\t\t\tisArray = isArraylike( elems ),\n\
\t\t\tret = [];\n\
\n\
\t\t// Go through the array, translating each of the items to their\n\
\t\tif ( isArray ) {\n\
\t\t\tfor ( ; i < length; i++ ) {\n\
\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\
\n\
\t\t\t\tif ( value != null ) {\n\
\t\t\t\t\tret[ ret.length ] = value;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t// Go through every key on the object,\n\
\t\t} else {\n\
\t\t\tfor ( i in elems ) {\n\
\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\
\n\
\t\t\t\tif ( value != null ) {\n\
\t\t\t\t\tret[ ret.length ] = value;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Flatten any nested arrays\n\
\t\treturn core_concat.apply( [], ret );\n\
\t},\n\
\n\
\t// A global GUID counter for objects\n\
\tguid: 1,\n\
\n\
\t// Bind a function to a context, optionally partially applying any\n\
\t// arguments.\n\
\tproxy: function( fn, context ) {\n\
\t\tvar args, proxy, tmp;\n\
\n\
\t\tif ( typeof context === \"string\" ) {\n\
\t\t\ttmp = fn[ context ];\n\
\t\t\tcontext = fn;\n\
\t\t\tfn = tmp;\n\
\t\t}\n\
\n\
\t\t// Quick check to determine if target is callable, in the spec\n\
\t\t// this throws a TypeError, but we will just return undefined.\n\
\t\tif ( !jQuery.isFunction( fn ) ) {\n\
\t\t\treturn undefined;\n\
\t\t}\n\
\n\
\t\t// Simulated bind\n\
\t\targs = core_slice.call( arguments, 2 );\n\
\t\tproxy = function() {\n\
\t\t\treturn fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );\n\
\t\t};\n\
\n\
\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\
\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\
\n\
\t\treturn proxy;\n\
\t},\n\
\n\
\t// Multifunctional method to get and set values of a collection\n\
\t// The value/s can optionally be executed if it's a function\n\
\taccess: function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\
\t\tvar i = 0,\n\
\t\t\tlength = elems.length,\n\
\t\t\tbulk = key == null;\n\
\n\
\t\t// Sets many values\n\
\t\tif ( jQuery.type( key ) === \"object\" ) {\n\
\t\t\tchainable = true;\n\
\t\t\tfor ( i in key ) {\n\
\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\
\t\t\t}\n\
\n\
\t\t// Sets one value\n\
\t\t} else if ( value !== undefined ) {\n\
\t\t\tchainable = true;\n\
\n\
\t\t\tif ( !jQuery.isFunction( value ) ) {\n\
\t\t\t\traw = true;\n\
\t\t\t}\n\
\n\
\t\t\tif ( bulk ) {\n\
\t\t\t\t// Bulk operations run against the entire set\n\
\t\t\t\tif ( raw ) {\n\
\t\t\t\t\tfn.call( elems, value );\n\
\t\t\t\t\tfn = null;\n\
\n\
\t\t\t\t// ...except when executing function values\n\
\t\t\t\t} else {\n\
\t\t\t\t\tbulk = fn;\n\
\t\t\t\t\tfn = function( elem, key, value ) {\n\
\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\
\t\t\t\t\t};\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\tif ( fn ) {\n\
\t\t\t\tfor ( ; i < length; i++ ) {\n\
\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn chainable ?\n\
\t\t\telems :\n\
\n\
\t\t\t// Gets\n\
\t\t\tbulk ?\n\
\t\t\t\tfn.call( elems ) :\n\
\t\t\t\tlength ? fn( elems[0], key ) : emptyGet;\n\
\t},\n\
\n\
\tnow: function() {\n\
\t\treturn ( new Date() ).getTime();\n\
\t}\n\
});\n\
\n\
jQuery.ready.promise = function( obj ) {\n\
\tif ( !readyList ) {\n\
\n\
\t\treadyList = jQuery.Deferred();\n\
\n\
\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\
\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\
\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\
\t\tif ( document.readyState === \"complete\" ) {\n\
\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\
\t\t\tsetTimeout( jQuery.ready );\n\
\n\
\t\t// Standards-based browsers support DOMContentLoaded\n\
\t\t} else if ( document.addEventListener ) {\n\
\t\t\t// Use the handy event callback\n\
\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\
\n\
\t\t\t// A fallback to window.onload, that will always work\n\
\t\t\twindow.addEventListener( \"load\", completed, false );\n\
\n\
\t\t// If IE event model is used\n\
\t\t} else {\n\
\t\t\t// Ensure firing before onload, maybe late but safe also for iframes\n\
\t\t\tdocument.attachEvent( \"onreadystatechange\", completed );\n\
\n\
\t\t\t// A fallback to window.onload, that will always work\n\
\t\t\twindow.attachEvent( \"onload\", completed );\n\
\n\
\t\t\t// If IE and not a frame\n\
\t\t\t// continually check to see if the document is ready\n\
\t\t\tvar top = false;\n\
\n\
\t\t\ttry {\n\
\t\t\t\ttop = window.frameElement == null && document.documentElement;\n\
\t\t\t} catch(e) {}\n\
\n\
\t\t\tif ( top && top.doScroll ) {\n\
\t\t\t\t(function doScrollCheck() {\n\
\t\t\t\t\tif ( !jQuery.isReady ) {\n\
\n\
\t\t\t\t\t\ttry {\n\
\t\t\t\t\t\t\t// Use the trick by Diego Perini\n\
\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\
\t\t\t\t\t\t\ttop.doScroll(\"left\");\n\
\t\t\t\t\t\t} catch(e) {\n\
\t\t\t\t\t\t\treturn setTimeout( doScrollCheck, 50 );\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t// detach all dom ready events\n\
\t\t\t\t\t\tdetach();\n\
\n\
\t\t\t\t\t\t// and execute any waiting functions\n\
\t\t\t\t\t\tjQuery.ready();\n\
\t\t\t\t\t}\n\
\t\t\t\t})();\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\treturn readyList.promise( obj );\n\
};\n\
\n\
// Populate the class2type map\n\
jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\
\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n\
});\n\
\n\
function isArraylike( obj ) {\n\
\tvar length = obj.length,\n\
\t\ttype = jQuery.type( obj );\n\
\n\
\tif ( jQuery.isWindow( obj ) ) {\n\
\t\treturn false;\n\
\t}\n\
\n\
\tif ( obj.nodeType === 1 && length ) {\n\
\t\treturn true;\n\
\t}\n\
\n\
\treturn type === \"array\" || type !== \"function\" &&\n\
\t\t( length === 0 ||\n\
\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\n\
}\n\
\n\
// All jQuery objects should point back to these\n\
rootjQuery = jQuery(document);\n\
// String to Object options format cache\n\
var optionsCache = {};\n\
\n\
// Convert String-formatted options into Object-formatted ones and store in cache\n\
function createOptions( options ) {\n\
\tvar object = optionsCache[ options ] = {};\n\
\tjQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\n\
\t\tobject[ flag ] = true;\n\
\t});\n\
\treturn object;\n\
}\n\
\n\
/*\n\
 * Create a callback list using the following parameters:\n\
 *\n\
 *\toptions: an optional list of space-separated options that will change how\n\
 *\t\t\tthe callback list behaves or a more traditional option object\n\
 *\n\
 * By default a callback list will act like an event callback list and can be\n\
 * \"fired\" multiple times.\n\
 *\n\
 * Possible options:\n\
 *\n\
 *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n\
 *\n\
 *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n\
 *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n\
 *\t\t\t\t\tvalues (like a Deferred)\n\
 *\n\
 *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n\
 *\n\
 *\tstopOnFalse:\tinterrupt callings when a callback returns false\n\
 *\n\
 */\n\
jQuery.Callbacks = function( options ) {\n\
\n\
\t// Convert options from String-formatted to Object-formatted if needed\n\
\t// (we check in cache first)\n\
\toptions = typeof options === \"string\" ?\n\
\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\
\t\tjQuery.extend( {}, options );\n\
\n\
\tvar // Flag to know if list is currently firing\n\
\t\tfiring,\n\
\t\t// Last fire value (for non-forgettable lists)\n\
\t\tmemory,\n\
\t\t// Flag to know if list was already fired\n\
\t\tfired,\n\
\t\t// End of the loop when firing\n\
\t\tfiringLength,\n\
\t\t// Index of currently firing callback (modified by remove if needed)\n\
\t\tfiringIndex,\n\
\t\t// First callback to fire (used internally by add and fireWith)\n\
\t\tfiringStart,\n\
\t\t// Actual callback list\n\
\t\tlist = [],\n\
\t\t// Stack of fire calls for repeatable lists\n\
\t\tstack = !options.once && [],\n\
\t\t// Fire callbacks\n\
\t\tfire = function( data ) {\n\
\t\t\tmemory = options.memory && data;\n\
\t\t\tfired = true;\n\
\t\t\tfiringIndex = firingStart || 0;\n\
\t\t\tfiringStart = 0;\n\
\t\t\tfiringLength = list.length;\n\
\t\t\tfiring = true;\n\
\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\
\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\
\t\t\t\t\tmemory = false; // To prevent further calls using add\n\
\t\t\t\t\tbreak;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t\tfiring = false;\n\
\t\t\tif ( list ) {\n\
\t\t\t\tif ( stack ) {\n\
\t\t\t\t\tif ( stack.length ) {\n\
\t\t\t\t\t\tfire( stack.shift() );\n\
\t\t\t\t\t}\n\
\t\t\t\t} else if ( memory ) {\n\
\t\t\t\t\tlist = [];\n\
\t\t\t\t} else {\n\
\t\t\t\t\tself.disable();\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t},\n\
\t\t// Actual Callbacks object\n\
\t\tself = {\n\
\t\t\t// Add a callback or a collection of callbacks to the list\n\
\t\t\tadd: function() {\n\
\t\t\t\tif ( list ) {\n\
\t\t\t\t\t// First, we save the current length\n\
\t\t\t\t\tvar start = list.length;\n\
\t\t\t\t\t(function add( args ) {\n\
\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\
\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\
\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\
\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\
\t\t\t\t\t\t\t\t\tlist.push( arg );\n\
\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\
\t\t\t\t\t\t\t\t// Inspect recursively\n\
\t\t\t\t\t\t\t\tadd( arg );\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t});\n\
\t\t\t\t\t})( arguments );\n\
\t\t\t\t\t// Do we need to add the callbacks to the\n\
\t\t\t\t\t// current firing batch?\n\
\t\t\t\t\tif ( firing ) {\n\
\t\t\t\t\t\tfiringLength = list.length;\n\
\t\t\t\t\t// With memory, if we're not firing then\n\
\t\t\t\t\t// we should call right away\n\
\t\t\t\t\t} else if ( memory ) {\n\
\t\t\t\t\t\tfiringStart = start;\n\
\t\t\t\t\t\tfire( memory );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t\treturn this;\n\
\t\t\t},\n\
\t\t\t// Remove a callback from the list\n\
\t\t\tremove: function() {\n\
\t\t\t\tif ( list ) {\n\
\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\
\t\t\t\t\t\tvar index;\n\
\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\
\t\t\t\t\t\t\tlist.splice( index, 1 );\n\
\t\t\t\t\t\t\t// Handle firing indexes\n\
\t\t\t\t\t\t\tif ( firing ) {\n\
\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\
\t\t\t\t\t\t\t\t\tfiringLength--;\n\
\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\
\t\t\t\t\t\t\t\t\tfiringIndex--;\n\
\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t});\n\
\t\t\t\t}\n\
\t\t\t\treturn this;\n\
\t\t\t},\n\
\t\t\t// Check if a given callback is in the list.\n\
\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\
\t\t\thas: function( fn ) {\n\
\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\
\t\t\t},\n\
\t\t\t// Remove all callbacks from the list\n\
\t\t\tempty: function() {\n\
\t\t\t\tlist = [];\n\
\t\t\t\treturn this;\n\
\t\t\t},\n\
\t\t\t// Have the list do nothing anymore\n\
\t\t\tdisable: function() {\n\
\t\t\t\tlist = stack = memory = undefined;\n\
\t\t\t\treturn this;\n\
\t\t\t},\n\
\t\t\t// Is it disabled?\n\
\t\t\tdisabled: function() {\n\
\t\t\t\treturn !list;\n\
\t\t\t},\n\
\t\t\t// Lock the list in its current state\n\
\t\t\tlock: function() {\n\
\t\t\t\tstack = undefined;\n\
\t\t\t\tif ( !memory ) {\n\
\t\t\t\t\tself.disable();\n\
\t\t\t\t}\n\
\t\t\t\treturn this;\n\
\t\t\t},\n\
\t\t\t// Is it locked?\n\
\t\t\tlocked: function() {\n\
\t\t\t\treturn !stack;\n\
\t\t\t},\n\
\t\t\t// Call all callbacks with the given context and arguments\n\
\t\t\tfireWith: function( context, args ) {\n\
\t\t\t\targs = args || [];\n\
\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\
\t\t\t\tif ( list && ( !fired || stack ) ) {\n\
\t\t\t\t\tif ( firing ) {\n\
\t\t\t\t\t\tstack.push( args );\n\
\t\t\t\t\t} else {\n\
\t\t\t\t\t\tfire( args );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t\treturn this;\n\
\t\t\t},\n\
\t\t\t// Call all the callbacks with the given arguments\n\
\t\t\tfire: function() {\n\
\t\t\t\tself.fireWith( this, arguments );\n\
\t\t\t\treturn this;\n\
\t\t\t},\n\
\t\t\t// To know if the callbacks have already been called at least once\n\
\t\t\tfired: function() {\n\
\t\t\t\treturn !!fired;\n\
\t\t\t}\n\
\t\t};\n\
\n\
\treturn self;\n\
};\n\
jQuery.extend({\n\
\n\
\tDeferred: function( func ) {\n\
\t\tvar tuples = [\n\
\t\t\t\t// action, add listener, listener list, final state\n\
\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\
\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\
\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\
\t\t\t],\n\
\t\t\tstate = \"pending\",\n\
\t\t\tpromise = {\n\
\t\t\t\tstate: function() {\n\
\t\t\t\t\treturn state;\n\
\t\t\t\t},\n\
\t\t\t\talways: function() {\n\
\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\
\t\t\t\t\treturn this;\n\
\t\t\t\t},\n\
\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\
\t\t\t\t\tvar fns = arguments;\n\
\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\
\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\
\t\t\t\t\t\t\tvar action = tuple[ 0 ],\n\
\t\t\t\t\t\t\t\tfn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\
\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\
\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\
\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\
\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\
\t\t\t\t\t\t\t\t\treturned.promise()\n\
\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\
\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\
\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\
\t\t\t\t\t\t\t\t} else {\n\
\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\
\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t});\n\
\t\t\t\t\t\t});\n\
\t\t\t\t\t\tfns = null;\n\
\t\t\t\t\t}).promise();\n\
\t\t\t\t},\n\
\t\t\t\t// Get a promise for this deferred\n\
\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\
\t\t\t\tpromise: function( obj ) {\n\
\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\
\t\t\t\t}\n\
\t\t\t},\n\
\t\t\tdeferred = {};\n\
\n\
\t\t// Keep pipe for back-compat\n\
\t\tpromise.pipe = promise.then;\n\
\n\
\t\t// Add list-specific methods\n\
\t\tjQuery.each( tuples, function( i, tuple ) {\n\
\t\t\tvar list = tuple[ 2 ],\n\
\t\t\t\tstateString = tuple[ 3 ];\n\
\n\
\t\t\t// promise[ done | fail | progress ] = list.add\n\
\t\t\tpromise[ tuple[1] ] = list.add;\n\
\n\
\t\t\t// Handle state\n\
\t\t\tif ( stateString ) {\n\
\t\t\t\tlist.add(function() {\n\
\t\t\t\t\t// state = [ resolved | rejected ]\n\
\t\t\t\t\tstate = stateString;\n\
\n\
\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\
\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\
\t\t\t}\n\
\n\
\t\t\t// deferred[ resolve | reject | notify ]\n\
\t\t\tdeferred[ tuple[0] ] = function() {\n\
\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\
\t\t\t\treturn this;\n\
\t\t\t};\n\
\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\
\t\t});\n\
\n\
\t\t// Make the deferred a promise\n\
\t\tpromise.promise( deferred );\n\
\n\
\t\t// Call given func if any\n\
\t\tif ( func ) {\n\
\t\t\tfunc.call( deferred, deferred );\n\
\t\t}\n\
\n\
\t\t// All done!\n\
\t\treturn deferred;\n\
\t},\n\
\n\
\t// Deferred helper\n\
\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\
\t\tvar i = 0,\n\
\t\t\tresolveValues = core_slice.call( arguments ),\n\
\t\t\tlength = resolveValues.length,\n\
\n\
\t\t\t// the count of uncompleted subordinates\n\
\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\
\n\
\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\
\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\
\n\
\t\t\t// Update function for both resolve and progress values\n\
\t\t\tupdateFunc = function( i, contexts, values ) {\n\
\t\t\t\treturn function( value ) {\n\
\t\t\t\t\tcontexts[ i ] = this;\n\
\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n\
\t\t\t\t\tif( values === progressValues ) {\n\
\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\
\t\t\t\t\t} else if ( !( --remaining ) ) {\n\
\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\
\t\t\t\t\t}\n\
\t\t\t\t};\n\
\t\t\t},\n\
\n\
\t\t\tprogressValues, progressContexts, resolveContexts;\n\
\n\
\t\t// add listeners to Deferred subordinates; treat others as resolved\n\
\t\tif ( length > 1 ) {\n\
\t\t\tprogressValues = new Array( length );\n\
\t\t\tprogressContexts = new Array( length );\n\
\t\t\tresolveContexts = new Array( length );\n\
\t\t\tfor ( ; i < length; i++ ) {\n\
\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\
\t\t\t\t\tresolveValues[ i ].promise()\n\
\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\
\t\t\t\t\t\t.fail( deferred.reject )\n\
\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\
\t\t\t\t} else {\n\
\t\t\t\t\t--remaining;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// if we're not waiting on anything, resolve the master\n\
\t\tif ( !remaining ) {\n\
\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\
\t\t}\n\
\n\
\t\treturn deferred.promise();\n\
\t}\n\
});\n\
jQuery.support = (function() {\n\
\n\
\tvar support, all, a,\n\
\t\tinput, select, fragment,\n\
\t\topt, eventName, isSupported, i,\n\
\t\tdiv = document.createElement(\"div\");\n\
\n\
\t// Setup\n\
\tdiv.setAttribute( \"className\", \"t\" );\n\
\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\
\n\
\t// Support tests won't run in some limited or non-browser environments\n\
\tall = div.getElementsByTagName(\"*\");\n\
\ta = div.getElementsByTagName(\"a\")[ 0 ];\n\
\tif ( !all || !a || !all.length ) {\n\
\t\treturn {};\n\
\t}\n\
\n\
\t// First batch of tests\n\
\tselect = document.createElement(\"select\");\n\
\topt = select.appendChild( document.createElement(\"option\") );\n\
\tinput = div.getElementsByTagName(\"input\")[ 0 ];\n\
\n\
\ta.style.cssText = \"top:1px;float:left;opacity:.5\";\n\
\tsupport = {\n\
\t\t// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\
\t\tgetSetAttribute: div.className !== \"t\",\n\
\n\
\t\t// IE strips leading whitespace when .innerHTML is used\n\
\t\tleadingWhitespace: div.firstChild.nodeType === 3,\n\
\n\
\t\t// Make sure that tbody elements aren't automatically inserted\n\
\t\t// IE will insert them into empty tables\n\
\t\ttbody: !div.getElementsByTagName(\"tbody\").length,\n\
\n\
\t\t// Make sure that link elements get serialized correctly by innerHTML\n\
\t\t// This requires a wrapper element in IE\n\
\t\thtmlSerialize: !!div.getElementsByTagName(\"link\").length,\n\
\n\
\t\t// Get the style information from getAttribute\n\
\t\t// (IE uses .cssText instead)\n\
\t\tstyle: /top/.test( a.getAttribute(\"style\") ),\n\
\n\
\t\t// Make sure that URLs aren't manipulated\n\
\t\t// (IE normalizes it by default)\n\
\t\threfNormalized: a.getAttribute(\"href\") === \"/a\",\n\
\n\
\t\t// Make sure that element opacity exists\n\
\t\t// (IE uses filter instead)\n\
\t\t// Use a regex to work around a WebKit issue. See #5145\n\
\t\topacity: /^0.5/.test( a.style.opacity ),\n\
\n\
\t\t// Verify style float existence\n\
\t\t// (IE uses styleFloat instead of cssFloat)\n\
\t\tcssFloat: !!a.style.cssFloat,\n\
\n\
\t\t// Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n\
\t\tcheckOn: !!input.value,\n\
\n\
\t\t// Make sure that a selected-by-default option has a working selected property.\n\
\t\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\
\t\toptSelected: opt.selected,\n\
\n\
\t\t// Tests for enctype support on a form (#6743)\n\
\t\tenctype: !!document.createElement(\"form\").enctype,\n\
\n\
\t\t// Makes sure cloning an html5 element does not cause problems\n\
\t\t// Where outerHTML is undefined, this still works\n\
\t\thtml5Clone: document.createElement(\"nav\").cloneNode( true ).outerHTML !== \"<:nav></:nav>\",\n\
\n\
\t\t// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode\n\
\t\tboxModel: document.compatMode === \"CSS1Compat\",\n\
\n\
\t\t// Will be defined later\n\
\t\tdeleteExpando: true,\n\
\t\tnoCloneEvent: true,\n\
\t\tinlineBlockNeedsLayout: false,\n\
\t\tshrinkWrapBlocks: false,\n\
\t\treliableMarginRight: true,\n\
\t\tboxSizingReliable: true,\n\
\t\tpixelPosition: false\n\
\t};\n\
\n\
\t// Make sure checked status is properly cloned\n\
\tinput.checked = true;\n\
\tsupport.noCloneChecked = input.cloneNode( true ).checked;\n\
\n\
\t// Make sure that the options inside disabled selects aren't marked as disabled\n\
\t// (WebKit marks them as disabled)\n\
\tselect.disabled = true;\n\
\tsupport.optDisabled = !opt.disabled;\n\
\n\
\t// Support: IE<9\n\
\ttry {\n\
\t\tdelete div.test;\n\
\t} catch( e ) {\n\
\t\tsupport.deleteExpando = false;\n\
\t}\n\
\n\
\t// Check if we can trust getAttribute(\"value\")\n\
\tinput = document.createElement(\"input\");\n\
\tinput.setAttribute( \"value\", \"\" );\n\
\tsupport.input = input.getAttribute( \"value\" ) === \"\";\n\
\n\
\t// Check if an input maintains its value after becoming a radio\n\
\tinput.value = \"t\";\n\
\tinput.setAttribute( \"type\", \"radio\" );\n\
\tsupport.radioValue = input.value === \"t\";\n\
\n\
\t// #11217 - WebKit loses check when the name is after the checked attribute\n\
\tinput.setAttribute( \"checked\", \"t\" );\n\
\tinput.setAttribute( \"name\", \"t\" );\n\
\n\
\tfragment = document.createDocumentFragment();\n\
\tfragment.appendChild( input );\n\
\n\
\t// Check if a disconnected checkbox will retain its checked\n\
\t// value of true after appended to the DOM (IE6/7)\n\
\tsupport.appendChecked = input.checked;\n\
\n\
\t// WebKit doesn't clone checked state correctly in fragments\n\
\tsupport.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\
\n\
\t// Support: IE<9\n\
\t// Opera does not clone events (and typeof div.attachEvent === undefined).\n\
\t// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n\
\tif ( div.attachEvent ) {\n\
\t\tdiv.attachEvent( \"onclick\", function() {\n\
\t\t\tsupport.noCloneEvent = false;\n\
\t\t});\n\
\n\
\t\tdiv.cloneNode( true ).click();\n\
\t}\n\
\n\
\t// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)\n\
\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php\n\
\tfor ( i in { submit: true, change: true, focusin: true }) {\n\
\t\tdiv.setAttribute( eventName = \"on\" + i, \"t\" );\n\
\n\
\t\tsupport[ i + \"Bubbles\" ] = eventName in window || div.attributes[ eventName ].expando === false;\n\
\t}\n\
\n\
\tdiv.style.backgroundClip = \"content-box\";\n\
\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\
\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\
\n\
\t// Run tests that need a body at doc ready\n\
\tjQuery(function() {\n\
\t\tvar container, marginDiv, tds,\n\
\t\t\tdivReset = \"padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;\",\n\
\t\t\tbody = document.getElementsByTagName(\"body\")[0];\n\
\n\
\t\tif ( !body ) {\n\
\t\t\t// Return for frameset docs that don't have a body\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\tcontainer = document.createElement(\"div\");\n\
\t\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\n\
\n\
\t\tbody.appendChild( container ).appendChild( div );\n\
\n\
\t\t// Support: IE8\n\
\t\t// Check if table cells still have offsetWidth/Height when they are set\n\
\t\t// to display:none and there are still other visible table cells in a\n\
\t\t// table row; if so, offsetWidth/Height are not reliable for use when\n\
\t\t// determining if an element has been hidden directly using\n\
\t\t// display:none (it is still safe to use offsets if a parent element is\n\
\t\t// hidden; don safety goggles and see bug #4512 for more information).\n\
\t\tdiv.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n\
\t\ttds = div.getElementsByTagName(\"td\");\n\
\t\ttds[ 0 ].style.cssText = \"padding:0;margin:0;border:0;display:none\";\n\
\t\tisSupported = ( tds[ 0 ].offsetHeight === 0 );\n\
\n\
\t\ttds[ 0 ].style.display = \"\";\n\
\t\ttds[ 1 ].style.display = \"none\";\n\
\n\
\t\t// Support: IE8\n\
\t\t// Check if empty table cells still have offsetWidth/Height\n\
\t\tsupport.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );\n\
\n\
\t\t// Check box-sizing and margin behavior\n\
\t\tdiv.innerHTML = \"\";\n\
\t\tdiv.style.cssText = \"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\";\n\
\t\tsupport.boxSizing = ( div.offsetWidth === 4 );\n\
\t\tsupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );\n\
\n\
\t\t// Use window.getComputedStyle because jsdom on node.js will break without it.\n\
\t\tif ( window.getComputedStyle ) {\n\
\t\t\tsupport.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n\
\t\t\tsupport.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\
\n\
\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\
\t\t\t// gets computed margin-right based on width of container. (#3333)\n\
\t\t\t// Fails in WebKit before Feb 2011 nightlies\n\
\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\
\t\t\tmarginDiv = div.appendChild( document.createElement(\"div\") );\n\
\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\n\
\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\
\t\t\tdiv.style.width = \"1px\";\n\
\n\
\t\t\tsupport.reliableMarginRight =\n\
\t\t\t\t!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\n\
\t\t}\n\
\n\
\t\tif ( typeof div.style.zoom !== core_strundefined ) {\n\
\t\t\t// Support: IE<8\n\
\t\t\t// Check if natively block-level elements act like inline-block\n\
\t\t\t// elements when setting their display to 'inline' and giving\n\
\t\t\t// them layout\n\
\t\t\tdiv.innerHTML = \"\";\n\
\t\t\tdiv.style.cssText = divReset + \"width:1px;padding:1px;display:inline;zoom:1\";\n\
\t\t\tsupport.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );\n\
\n\
\t\t\t// Support: IE6\n\
\t\t\t// Check if elements with layout shrink-wrap their children\n\
\t\t\tdiv.style.display = \"block\";\n\
\t\t\tdiv.innerHTML = \"<div></div>\";\n\
\t\t\tdiv.firstChild.style.width = \"5px\";\n\
\t\t\tsupport.shrinkWrapBlocks = ( div.offsetWidth !== 3 );\n\
\n\
\t\t\tif ( support.inlineBlockNeedsLayout ) {\n\
\t\t\t\t// Prevent IE 6 from affecting layout for positioned elements #11048\n\
\t\t\t\t// Prevent IE from shrinking the body in IE 7 mode #12869\n\
\t\t\t\t// Support: IE<8\n\
\t\t\t\tbody.style.zoom = 1;\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\tbody.removeChild( container );\n\
\n\
\t\t// Null elements to avoid leaks in IE\n\
\t\tcontainer = div = tds = marginDiv = null;\n\
\t});\n\
\n\
\t// Null elements to avoid leaks in IE\n\
\tall = select = fragment = opt = a = input = null;\n\
\n\
\treturn support;\n\
})();\n\
\n\
var rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n\
\trmultiDash = /([A-Z])/g;\n\
\n\
function internalData( elem, name, data, pvt /* Internal Use Only */ ){\n\
\tif ( !jQuery.acceptData( elem ) ) {\n\
\t\treturn;\n\
\t}\n\
\n\
\tvar thisCache, ret,\n\
\t\tinternalKey = jQuery.expando,\n\
\t\tgetByName = typeof name === \"string\",\n\
\n\
\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n\
\t\t// can't GC object references properly across the DOM-JS boundary\n\
\t\tisNode = elem.nodeType,\n\
\n\
\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n\
\t\t// attached directly to the object so GC can occur automatically\n\
\t\tcache = isNode ? jQuery.cache : elem,\n\
\n\
\t\t// Only defining an ID for JS objects if its cache already exists allows\n\
\t\t// the code to shortcut on the same path as a DOM node with no cache\n\
\t\tid = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\
\n\
\t// Avoid doing any more work than we need to when trying to get data on an\n\
\t// object that has no data at all\n\
\tif ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {\n\
\t\treturn;\n\
\t}\n\
\n\
\tif ( !id ) {\n\
\t\t// Only DOM nodes need a new unique ID for each element since their data\n\
\t\t// ends up in the global cache\n\
\t\tif ( isNode ) {\n\
\t\t\telem[ internalKey ] = id = core_deletedIds.pop() || jQuery.guid++;\n\
\t\t} else {\n\
\t\t\tid = internalKey;\n\
\t\t}\n\
\t}\n\
\n\
\tif ( !cache[ id ] ) {\n\
\t\tcache[ id ] = {};\n\
\n\
\t\t// Avoids exposing jQuery metadata on plain JS objects when the object\n\
\t\t// is serialized using JSON.stringify\n\
\t\tif ( !isNode ) {\n\
\t\t\tcache[ id ].toJSON = jQuery.noop;\n\
\t\t}\n\
\t}\n\
\n\
\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\
\t// shallow copied over onto the existing cache\n\
\tif ( typeof name === \"object\" || typeof name === \"function\" ) {\n\
\t\tif ( pvt ) {\n\
\t\t\tcache[ id ] = jQuery.extend( cache[ id ], name );\n\
\t\t} else {\n\
\t\t\tcache[ id ].data = jQuery.extend( cache[ id ].data, name );\n\
\t\t}\n\
\t}\n\
\n\
\tthisCache = cache[ id ];\n\
\n\
\t// jQuery data() is stored in a separate object inside the object's internal data\n\
\t// cache in order to avoid key collisions between internal data and user-defined\n\
\t// data.\n\
\tif ( !pvt ) {\n\
\t\tif ( !thisCache.data ) {\n\
\t\t\tthisCache.data = {};\n\
\t\t}\n\
\n\
\t\tthisCache = thisCache.data;\n\
\t}\n\
\n\
\tif ( data !== undefined ) {\n\
\t\tthisCache[ jQuery.camelCase( name ) ] = data;\n\
\t}\n\
\n\
\t// Check for both converted-to-camel and non-converted data property names\n\
\t// If a data property was specified\n\
\tif ( getByName ) {\n\
\n\
\t\t// First Try to find as-is property data\n\
\t\tret = thisCache[ name ];\n\
\n\
\t\t// Test for null|undefined property data\n\
\t\tif ( ret == null ) {\n\
\n\
\t\t\t// Try to find the camelCased property\n\
\t\t\tret = thisCache[ jQuery.camelCase( name ) ];\n\
\t\t}\n\
\t} else {\n\
\t\tret = thisCache;\n\
\t}\n\
\n\
\treturn ret;\n\
}\n\
\n\
function internalRemoveData( elem, name, pvt ) {\n\
\tif ( !jQuery.acceptData( elem ) ) {\n\
\t\treturn;\n\
\t}\n\
\n\
\tvar i, l, thisCache,\n\
\t\tisNode = elem.nodeType,\n\
\n\
\t\t// See jQuery.data for more information\n\
\t\tcache = isNode ? jQuery.cache : elem,\n\
\t\tid = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\
\n\
\t// If there is already no cache entry for this object, there is no\n\
\t// purpose in continuing\n\
\tif ( !cache[ id ] ) {\n\
\t\treturn;\n\
\t}\n\
\n\
\tif ( name ) {\n\
\n\
\t\tthisCache = pvt ? cache[ id ] : cache[ id ].data;\n\
\n\
\t\tif ( thisCache ) {\n\
\n\
\t\t\t// Support array or space separated string names for data keys\n\
\t\t\tif ( !jQuery.isArray( name ) ) {\n\
\n\
\t\t\t\t// try the string as a key before any manipulation\n\
\t\t\t\tif ( name in thisCache ) {\n\
\t\t\t\t\tname = [ name ];\n\
\t\t\t\t} else {\n\
\n\
\t\t\t\t\t// split the camel cased version by spaces unless a key with the spaces exists\n\
\t\t\t\t\tname = jQuery.camelCase( name );\n\
\t\t\t\t\tif ( name in thisCache ) {\n\
\t\t\t\t\t\tname = [ name ];\n\
\t\t\t\t\t} else {\n\
\t\t\t\t\t\tname = name.split(\" \");\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t} else {\n\
\t\t\t\t// If \"name\" is an array of keys...\n\
\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\
\t\t\t\t// keys will be converted to camelCase.\n\
\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\
\t\t\t\t// both plain key and camelCase key. #12786\n\
\t\t\t\t// This will only penalize the array argument path.\n\
\t\t\t\tname = name.concat( jQuery.map( name, jQuery.camelCase ) );\n\
\t\t\t}\n\
\n\
\t\t\tfor ( i = 0, l = name.length; i < l; i++ ) {\n\
\t\t\t\tdelete thisCache[ name[i] ];\n\
\t\t\t}\n\
\n\
\t\t\t// If there is no data left in the cache, we want to continue\n\
\t\t\t// and let the cache object itself get destroyed\n\
\t\t\tif ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {\n\
\t\t\t\treturn;\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\t// See jQuery.data for more information\n\
\tif ( !pvt ) {\n\
\t\tdelete cache[ id ].data;\n\
\n\
\t\t// Don't destroy the parent cache unless the internal data object\n\
\t\t// had been the only thing left in it\n\
\t\tif ( !isEmptyDataObject( cache[ id ] ) ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\t}\n\
\n\
\t// Destroy the cache\n\
\tif ( isNode ) {\n\
\t\tjQuery.cleanData( [ elem ], true );\n\
\n\
\t// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n\
\t} else if ( jQuery.support.deleteExpando || cache != cache.window ) {\n\
\t\tdelete cache[ id ];\n\
\n\
\t// When all else fails, null\n\
\t} else {\n\
\t\tcache[ id ] = null;\n\
\t}\n\
}\n\
\n\
jQuery.extend({\n\
\tcache: {},\n\
\n\
\t// Unique for each copy of jQuery on the page\n\
\t// Non-digits removed to match rinlinejQuery\n\
\texpando: \"jQuery\" + ( core_version + Math.random() ).replace( /\\D/g, \"\" ),\n\
\n\
\t// The following elements throw uncatchable exceptions if you\n\
\t// attempt to add expando properties to them.\n\
\tnoData: {\n\
\t\t\"embed\": true,\n\
\t\t// Ban all objects except for Flash (which handle expandos)\n\
\t\t\"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n\
\t\t\"applet\": true\n\
\t},\n\
\n\
\thasData: function( elem ) {\n\
\t\telem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n\
\t\treturn !!elem && !isEmptyDataObject( elem );\n\
\t},\n\
\n\
\tdata: function( elem, name, data ) {\n\
\t\treturn internalData( elem, name, data );\n\
\t},\n\
\n\
\tremoveData: function( elem, name ) {\n\
\t\treturn internalRemoveData( elem, name );\n\
\t},\n\
\n\
\t// For internal use only.\n\
\t_data: function( elem, name, data ) {\n\
\t\treturn internalData( elem, name, data, true );\n\
\t},\n\
\n\
\t_removeData: function( elem, name ) {\n\
\t\treturn internalRemoveData( elem, name, true );\n\
\t},\n\
\n\
\t// A method for determining if a DOM node can handle the data expando\n\
\tacceptData: function( elem ) {\n\
\t\t// Do not set data on non-element because it will not be cleared (#8335).\n\
\t\tif ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {\n\
\t\t\treturn false;\n\
\t\t}\n\
\n\
\t\tvar noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];\n\
\n\
\t\t// nodes accept data unless otherwise specified; rejection can be conditional\n\
\t\treturn !noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n\
\t}\n\
});\n\
\n\
jQuery.fn.extend({\n\
\tdata: function( key, value ) {\n\
\t\tvar attrs, name,\n\
\t\t\telem = this[0],\n\
\t\t\ti = 0,\n\
\t\t\tdata = null;\n\
\n\
\t\t// Gets all values\n\
\t\tif ( key === undefined ) {\n\
\t\t\tif ( this.length ) {\n\
\t\t\t\tdata = jQuery.data( elem );\n\
\n\
\t\t\t\tif ( elem.nodeType === 1 && !jQuery._data( elem, \"parsedAttrs\" ) ) {\n\
\t\t\t\t\tattrs = elem.attributes;\n\
\t\t\t\t\tfor ( ; i < attrs.length; i++ ) {\n\
\t\t\t\t\t\tname = attrs[i].name;\n\
\n\
\t\t\t\t\t\tif ( !name.indexOf( \"data-\" ) ) {\n\
\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\
\n\
\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t\tjQuery._data( elem, \"parsedAttrs\", true );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\treturn data;\n\
\t\t}\n\
\n\
\t\t// Sets multiple values\n\
\t\tif ( typeof key === \"object\" ) {\n\
\t\t\treturn this.each(function() {\n\
\t\t\t\tjQuery.data( this, key );\n\
\t\t\t});\n\
\t\t}\n\
\n\
\t\treturn jQuery.access( this, function( value ) {\n\
\n\
\t\t\tif ( value === undefined ) {\n\
\t\t\t\t// Try to fetch any internally stored data first\n\
\t\t\t\treturn elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;\n\
\t\t\t}\n\
\n\
\t\t\tthis.each(function() {\n\
\t\t\t\tjQuery.data( this, key, value );\n\
\t\t\t});\n\
\t\t}, null, value, arguments.length > 1, null, true );\n\
\t},\n\
\n\
\tremoveData: function( key ) {\n\
\t\treturn this.each(function() {\n\
\t\t\tjQuery.removeData( this, key );\n\
\t\t});\n\
\t}\n\
});\n\
\n\
function dataAttr( elem, key, data ) {\n\
\t// If nothing was found internally, try to fetch any\n\
\t// data from the HTML5 data-* attribute\n\
\tif ( data === undefined && elem.nodeType === 1 ) {\n\
\n\
\t\tvar name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\
\n\
\t\tdata = elem.getAttribute( name );\n\
\n\
\t\tif ( typeof data === \"string\" ) {\n\
\t\t\ttry {\n\
\t\t\t\tdata = data === \"true\" ? true :\n\
\t\t\t\t\tdata === \"false\" ? false :\n\
\t\t\t\t\tdata === \"null\" ? null :\n\
\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\
\t\t\t\t\t+data + \"\" === data ? +data :\n\
\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\
\t\t\t\t\t\tdata;\n\
\t\t\t} catch( e ) {}\n\
\n\
\t\t\t// Make sure we set the data so it isn't changed later\n\
\t\t\tjQuery.data( elem, key, data );\n\
\n\
\t\t} else {\n\
\t\t\tdata = undefined;\n\
\t\t}\n\
\t}\n\
\n\
\treturn data;\n\
}\n\
\n\
// checks a cache object for emptiness\n\
function isEmptyDataObject( obj ) {\n\
\tvar name;\n\
\tfor ( name in obj ) {\n\
\n\
\t\t// if the public data object is empty, the private is still empty\n\
\t\tif ( name === \"data\" && jQuery.isEmptyObject( obj[name] ) ) {\n\
\t\t\tcontinue;\n\
\t\t}\n\
\t\tif ( name !== \"toJSON\" ) {\n\
\t\t\treturn false;\n\
\t\t}\n\
\t}\n\
\n\
\treturn true;\n\
}\n\
jQuery.extend({\n\
\tqueue: function( elem, type, data ) {\n\
\t\tvar queue;\n\
\n\
\t\tif ( elem ) {\n\
\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\
\t\t\tqueue = jQuery._data( elem, type );\n\
\n\
\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\
\t\t\tif ( data ) {\n\
\t\t\t\tif ( !queue || jQuery.isArray(data) ) {\n\
\t\t\t\t\tqueue = jQuery._data( elem, type, jQuery.makeArray(data) );\n\
\t\t\t\t} else {\n\
\t\t\t\t\tqueue.push( data );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t\treturn queue || [];\n\
\t\t}\n\
\t},\n\
\n\
\tdequeue: function( elem, type ) {\n\
\t\ttype = type || \"fx\";\n\
\n\
\t\tvar queue = jQuery.queue( elem, type ),\n\
\t\t\tstartLength = queue.length,\n\
\t\t\tfn = queue.shift(),\n\
\t\t\thooks = jQuery._queueHooks( elem, type ),\n\
\t\t\tnext = function() {\n\
\t\t\t\tjQuery.dequeue( elem, type );\n\
\t\t\t};\n\
\n\
\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\
\t\tif ( fn === \"inprogress\" ) {\n\
\t\t\tfn = queue.shift();\n\
\t\t\tstartLength--;\n\
\t\t}\n\
\n\
\t\thooks.cur = fn;\n\
\t\tif ( fn ) {\n\
\n\
\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\
\t\t\t// automatically dequeued\n\
\t\t\tif ( type === \"fx\" ) {\n\
\t\t\t\tqueue.unshift( \"inprogress\" );\n\
\t\t\t}\n\
\n\
\t\t\t// clear up the last queue stop function\n\
\t\t\tdelete hooks.stop;\n\
\t\t\tfn.call( elem, next, hooks );\n\
\t\t}\n\
\n\
\t\tif ( !startLength && hooks ) {\n\
\t\t\thooks.empty.fire();\n\
\t\t}\n\
\t},\n\
\n\
\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\
\t_queueHooks: function( elem, type ) {\n\
\t\tvar key = type + \"queueHooks\";\n\
\t\treturn jQuery._data( elem, key ) || jQuery._data( elem, key, {\n\
\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\
\t\t\t\tjQuery._removeData( elem, type + \"queue\" );\n\
\t\t\t\tjQuery._removeData( elem, key );\n\
\t\t\t})\n\
\t\t});\n\
\t}\n\
});\n\
\n\
jQuery.fn.extend({\n\
\tqueue: function( type, data ) {\n\
\t\tvar setter = 2;\n\
\n\
\t\tif ( typeof type !== \"string\" ) {\n\
\t\t\tdata = type;\n\
\t\t\ttype = \"fx\";\n\
\t\t\tsetter--;\n\
\t\t}\n\
\n\
\t\tif ( arguments.length < setter ) {\n\
\t\t\treturn jQuery.queue( this[0], type );\n\
\t\t}\n\
\n\
\t\treturn data === undefined ?\n\
\t\t\tthis :\n\
\t\t\tthis.each(function() {\n\
\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\
\n\
\t\t\t\t// ensure a hooks for this queue\n\
\t\t\t\tjQuery._queueHooks( this, type );\n\
\n\
\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\
\t\t\t\t\tjQuery.dequeue( this, type );\n\
\t\t\t\t}\n\
\t\t\t});\n\
\t},\n\
\tdequeue: function( type ) {\n\
\t\treturn this.each(function() {\n\
\t\t\tjQuery.dequeue( this, type );\n\
\t\t});\n\
\t},\n\
\t// Based off of the plugin by Clint Helfers, with permission.\n\
\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\
\tdelay: function( time, type ) {\n\
\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\
\t\ttype = type || \"fx\";\n\
\n\
\t\treturn this.queue( type, function( next, hooks ) {\n\
\t\t\tvar timeout = setTimeout( next, time );\n\
\t\t\thooks.stop = function() {\n\
\t\t\t\tclearTimeout( timeout );\n\
\t\t\t};\n\
\t\t});\n\
\t},\n\
\tclearQueue: function( type ) {\n\
\t\treturn this.queue( type || \"fx\", [] );\n\
\t},\n\
\t// Get a promise resolved when queues of a certain type\n\
\t// are emptied (fx is the type by default)\n\
\tpromise: function( type, obj ) {\n\
\t\tvar tmp,\n\
\t\t\tcount = 1,\n\
\t\t\tdefer = jQuery.Deferred(),\n\
\t\t\telements = this,\n\
\t\t\ti = this.length,\n\
\t\t\tresolve = function() {\n\
\t\t\t\tif ( !( --count ) ) {\n\
\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\
\t\t\t\t}\n\
\t\t\t};\n\
\n\
\t\tif ( typeof type !== \"string\" ) {\n\
\t\t\tobj = type;\n\
\t\t\ttype = undefined;\n\
\t\t}\n\
\t\ttype = type || \"fx\";\n\
\n\
\t\twhile( i-- ) {\n\
\t\t\ttmp = jQuery._data( elements[ i ], type + \"queueHooks\" );\n\
\t\t\tif ( tmp && tmp.empty ) {\n\
\t\t\t\tcount++;\n\
\t\t\t\ttmp.empty.add( resolve );\n\
\t\t\t}\n\
\t\t}\n\
\t\tresolve();\n\
\t\treturn defer.promise( obj );\n\
\t}\n\
});\n\
var nodeHook, boolHook,\n\
\trclass = /[\\t\\r\\n\
]/g,\n\
\trreturn = /\\r/g,\n\
\trfocusable = /^(?:input|select|textarea|button|object)$/i,\n\
\trclickable = /^(?:a|area)$/i,\n\
\trboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,\n\
\truseDefault = /^(?:checked|selected)$/i,\n\
\tgetSetAttribute = jQuery.support.getSetAttribute,\n\
\tgetSetInput = jQuery.support.input;\n\
\n\
jQuery.fn.extend({\n\
\tattr: function( name, value ) {\n\
\t\treturn jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\n\
\t},\n\
\n\
\tremoveAttr: function( name ) {\n\
\t\treturn this.each(function() {\n\
\t\t\tjQuery.removeAttr( this, name );\n\
\t\t});\n\
\t},\n\
\n\
\tprop: function( name, value ) {\n\
\t\treturn jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\n\
\t},\n\
\n\
\tremoveProp: function( name ) {\n\
\t\tname = jQuery.propFix[ name ] || name;\n\
\t\treturn this.each(function() {\n\
\t\t\t// try/catch handles cases where IE balks (such as removing a property on window)\n\
\t\t\ttry {\n\
\t\t\t\tthis[ name ] = undefined;\n\
\t\t\t\tdelete this[ name ];\n\
\t\t\t} catch( e ) {}\n\
\t\t});\n\
\t},\n\
\n\
\taddClass: function( value ) {\n\
\t\tvar classes, elem, cur, clazz, j,\n\
\t\t\ti = 0,\n\
\t\t\tlen = this.length,\n\
\t\t\tproceed = typeof value === \"string\" && value;\n\
\n\
\t\tif ( jQuery.isFunction( value ) ) {\n\
\t\t\treturn this.each(function( j ) {\n\
\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\
\t\t\t});\n\
\t\t}\n\
\n\
\t\tif ( proceed ) {\n\
\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\
\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\
\n\
\t\t\tfor ( ; i < len; i++ ) {\n\
\t\t\t\telem = this[ i ];\n\
\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\
\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\
\t\t\t\t\t\" \"\n\
\t\t\t\t);\n\
\n\
\t\t\t\tif ( cur ) {\n\
\t\t\t\t\tj = 0;\n\
\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\
\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\
\t\t\t\t\t\t\tcur += clazz + \" \";\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t\telem.className = jQuery.trim( cur );\n\
\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\tremoveClass: function( value ) {\n\
\t\tvar classes, elem, cur, clazz, j,\n\
\t\t\ti = 0,\n\
\t\t\tlen = this.length,\n\
\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\n\
\n\
\t\tif ( jQuery.isFunction( value ) ) {\n\
\t\t\treturn this.each(function( j ) {\n\
\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\
\t\t\t});\n\
\t\t}\n\
\t\tif ( proceed ) {\n\
\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\
\n\
\t\t\tfor ( ; i < len; i++ ) {\n\
\t\t\t\telem = this[ i ];\n\
\t\t\t\t// This expression is here for better compressibility (see addClass)\n\
\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\
\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\
\t\t\t\t\t\"\"\n\
\t\t\t\t);\n\
\n\
\t\t\t\tif ( cur ) {\n\
\t\t\t\t\tj = 0;\n\
\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\
\t\t\t\t\t\t// Remove *all* instances\n\
\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\
\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t\telem.className = value ? jQuery.trim( cur ) : \"\";\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\ttoggleClass: function( value, stateVal ) {\n\
\t\tvar type = typeof value,\n\
\t\t\tisBool = typeof stateVal === \"boolean\";\n\
\n\
\t\tif ( jQuery.isFunction( value ) ) {\n\
\t\t\treturn this.each(function( i ) {\n\
\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\
\t\t\t});\n\
\t\t}\n\
\n\
\t\treturn this.each(function() {\n\
\t\t\tif ( type === \"string\" ) {\n\
\t\t\t\t// toggle individual class names\n\
\t\t\t\tvar className,\n\
\t\t\t\t\ti = 0,\n\
\t\t\t\t\tself = jQuery( this ),\n\
\t\t\t\t\tstate = stateVal,\n\
\t\t\t\t\tclassNames = value.match( core_rnotwhite ) || [];\n\
\n\
\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\
\t\t\t\t\t// check each className given, space separated list\n\
\t\t\t\t\tstate = isBool ? state : !self.hasClass( className );\n\
\t\t\t\t\tself[ state ? \"addClass\" : \"removeClass\" ]( className );\n\
\t\t\t\t}\n\
\n\
\t\t\t// Toggle whole class name\n\
\t\t\t} else if ( type === core_strundefined || type === \"boolean\" ) {\n\
\t\t\t\tif ( this.className ) {\n\
\t\t\t\t\t// store className if set\n\
\t\t\t\t\tjQuery._data( this, \"__className__\", this.className );\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\
\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\
\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\
\t\t\t\t// falling back to the empty string if nothing was stored.\n\
\t\t\t\tthis.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n\
\t\t\t}\n\
\t\t});\n\
\t},\n\
\n\
\thasClass: function( selector ) {\n\
\t\tvar className = \" \" + selector + \" \",\n\
\t\t\ti = 0,\n\
\t\t\tl = this.length;\n\
\t\tfor ( ; i < l; i++ ) {\n\
\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\
\t\t\t\treturn true;\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn false;\n\
\t},\n\
\n\
\tval: function( value ) {\n\
\t\tvar ret, hooks, isFunction,\n\
\t\t\telem = this[0];\n\
\n\
\t\tif ( !arguments.length ) {\n\
\t\t\tif ( elem ) {\n\
\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\
\n\
\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\
\t\t\t\t\treturn ret;\n\
\t\t\t\t}\n\
\n\
\t\t\t\tret = elem.value;\n\
\n\
\t\t\t\treturn typeof ret === \"string\" ?\n\
\t\t\t\t\t// handle most common string cases\n\
\t\t\t\t\tret.replace(rreturn, \"\") :\n\
\t\t\t\t\t// handle cases where value is null/undef or number\n\
\t\t\t\t\tret == null ? \"\" : ret;\n\
\t\t\t}\n\
\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\tisFunction = jQuery.isFunction( value );\n\
\n\
\t\treturn this.each(function( i ) {\n\
\t\t\tvar val,\n\
\t\t\t\tself = jQuery(this);\n\
\n\
\t\t\tif ( this.nodeType !== 1 ) {\n\
\t\t\t\treturn;\n\
\t\t\t}\n\
\n\
\t\t\tif ( isFunction ) {\n\
\t\t\t\tval = value.call( this, i, self.val() );\n\
\t\t\t} else {\n\
\t\t\t\tval = value;\n\
\t\t\t}\n\
\n\
\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\
\t\t\tif ( val == null ) {\n\
\t\t\t\tval = \"\";\n\
\t\t\t} else if ( typeof val === \"number\" ) {\n\
\t\t\t\tval += \"\";\n\
\t\t\t} else if ( jQuery.isArray( val ) ) {\n\
\t\t\t\tval = jQuery.map(val, function ( value ) {\n\
\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\
\t\t\t\t});\n\
\t\t\t}\n\
\n\
\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\
\n\
\t\t\t// If set returns undefined, fall back to normal setting\n\
\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\
\t\t\t\tthis.value = val;\n\
\t\t\t}\n\
\t\t});\n\
\t}\n\
});\n\
\n\
jQuery.extend({\n\
\tvalHooks: {\n\
\t\toption: {\n\
\t\t\tget: function( elem ) {\n\
\t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\n\
\t\t\t\t// uses .value. See #6932\n\
\t\t\t\tvar val = elem.attributes.value;\n\
\t\t\t\treturn !val || val.specified ? elem.value : elem.text;\n\
\t\t\t}\n\
\t\t},\n\
\t\tselect: {\n\
\t\t\tget: function( elem ) {\n\
\t\t\t\tvar value, option,\n\
\t\t\t\t\toptions = elem.options,\n\
\t\t\t\t\tindex = elem.selectedIndex,\n\
\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\
\t\t\t\t\tvalues = one ? null : [],\n\
\t\t\t\t\tmax = one ? index + 1 : options.length,\n\
\t\t\t\t\ti = index < 0 ?\n\
\t\t\t\t\t\tmax :\n\
\t\t\t\t\t\tone ? index : 0;\n\
\n\
\t\t\t\t// Loop through all the selected options\n\
\t\t\t\tfor ( ; i < max; i++ ) {\n\
\t\t\t\t\toption = options[ i ];\n\
\n\
\t\t\t\t\t// oldIE doesn't update selected after form reset (#2551)\n\
\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\
\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\
\t\t\t\t\t\t\t( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n\
\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\
\n\
\t\t\t\t\t\t// Get the specific value for the option\n\
\t\t\t\t\t\tvalue = jQuery( option ).val();\n\
\n\
\t\t\t\t\t\t// We don't need an array for one selects\n\
\t\t\t\t\t\tif ( one ) {\n\
\t\t\t\t\t\t\treturn value;\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t// Multi-Selects return an array\n\
\t\t\t\t\t\tvalues.push( value );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\n\
\t\t\t\treturn values;\n\
\t\t\t},\n\
\n\
\t\t\tset: function( elem, value ) {\n\
\t\t\t\tvar values = jQuery.makeArray( value );\n\
\n\
\t\t\t\tjQuery(elem).find(\"option\").each(function() {\n\
\t\t\t\t\tthis.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;\n\
\t\t\t\t});\n\
\n\
\t\t\t\tif ( !values.length ) {\n\
\t\t\t\t\telem.selectedIndex = -1;\n\
\t\t\t\t}\n\
\t\t\t\treturn values;\n\
\t\t\t}\n\
\t\t}\n\
\t},\n\
\n\
\tattr: function( elem, name, value ) {\n\
\t\tvar hooks, notxml, ret,\n\
\t\t\tnType = elem.nodeType;\n\
\n\
\t\t// don't get/set attributes on text, comment and attribute nodes\n\
\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\t// Fallback to prop when attributes are not supported\n\
\t\tif ( typeof elem.getAttribute === core_strundefined ) {\n\
\t\t\treturn jQuery.prop( elem, name, value );\n\
\t\t}\n\
\n\
\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\
\n\
\t\t// All attributes are lowercase\n\
\t\t// Grab necessary hook if one is defined\n\
\t\tif ( notxml ) {\n\
\t\t\tname = name.toLowerCase();\n\
\t\t\thooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );\n\
\t\t}\n\
\n\
\t\tif ( value !== undefined ) {\n\
\n\
\t\t\tif ( value === null ) {\n\
\t\t\t\tjQuery.removeAttr( elem, name );\n\
\n\
\t\t\t} else if ( hooks && notxml && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\
\t\t\t\treturn ret;\n\
\n\
\t\t\t} else {\n\
\t\t\t\telem.setAttribute( name, value + \"\" );\n\
\t\t\t\treturn value;\n\
\t\t\t}\n\
\n\
\t\t} else if ( hooks && notxml && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\
\t\t\treturn ret;\n\
\n\
\t\t} else {\n\
\n\
\t\t\t// In IE9+, Flash objects don't have .getAttribute (#12945)\n\
\t\t\t// Support: IE9+\n\
\t\t\tif ( typeof elem.getAttribute !== core_strundefined ) {\n\
\t\t\t\tret =  elem.getAttribute( name );\n\
\t\t\t}\n\
\n\
\t\t\t// Non-existent attributes return null, we normalize to undefined\n\
\t\t\treturn ret == null ?\n\
\t\t\t\tundefined :\n\
\t\t\t\tret;\n\
\t\t}\n\
\t},\n\
\n\
\tremoveAttr: function( elem, value ) {\n\
\t\tvar name, propName,\n\
\t\t\ti = 0,\n\
\t\t\tattrNames = value && value.match( core_rnotwhite );\n\
\n\
\t\tif ( attrNames && elem.nodeType === 1 ) {\n\
\t\t\twhile ( (name = attrNames[i++]) ) {\n\
\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\
\n\
\t\t\t\t// Boolean attributes get special treatment (#10870)\n\
\t\t\t\tif ( rboolean.test( name ) ) {\n\
\t\t\t\t\t// Set corresponding property to false for boolean attributes\n\
\t\t\t\t\t// Also clear defaultChecked/defaultSelected (if appropriate) for IE<8\n\
\t\t\t\t\tif ( !getSetAttribute && ruseDefault.test( name ) ) {\n\
\t\t\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] =\n\
\t\t\t\t\t\t\telem[ propName ] = false;\n\
\t\t\t\t\t} else {\n\
\t\t\t\t\t\telem[ propName ] = false;\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t// See #9699 for explanation of this approach (setting first, then removal)\n\
\t\t\t\t} else {\n\
\t\t\t\t\tjQuery.attr( elem, name, \"\" );\n\
\t\t\t\t}\n\
\n\
\t\t\t\telem.removeAttribute( getSetAttribute ? name : propName );\n\
\t\t\t}\n\
\t\t}\n\
\t},\n\
\n\
\tattrHooks: {\n\
\t\ttype: {\n\
\t\t\tset: function( elem, value ) {\n\
\t\t\t\tif ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\
\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\
\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\
\t\t\t\t\tvar val = elem.value;\n\
\t\t\t\t\telem.setAttribute( \"type\", value );\n\
\t\t\t\t\tif ( val ) {\n\
\t\t\t\t\t\telem.value = val;\n\
\t\t\t\t\t}\n\
\t\t\t\t\treturn value;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t},\n\
\n\
\tpropFix: {\n\
\t\ttabindex: \"tabIndex\",\n\
\t\treadonly: \"readOnly\",\n\
\t\t\"for\": \"htmlFor\",\n\
\t\t\"class\": \"className\",\n\
\t\tmaxlength: \"maxLength\",\n\
\t\tcellspacing: \"cellSpacing\",\n\
\t\tcellpadding: \"cellPadding\",\n\
\t\trowspan: \"rowSpan\",\n\
\t\tcolspan: \"colSpan\",\n\
\t\tusemap: \"useMap\",\n\
\t\tframeborder: \"frameBorder\",\n\
\t\tcontenteditable: \"contentEditable\"\n\
\t},\n\
\n\
\tprop: function( elem, name, value ) {\n\
\t\tvar ret, hooks, notxml,\n\
\t\t\tnType = elem.nodeType;\n\
\n\
\t\t// don't get/set properties on text, comment and attribute nodes\n\
\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\
\n\
\t\tif ( notxml ) {\n\
\t\t\t// Fix name and attach hooks\n\
\t\t\tname = jQuery.propFix[ name ] || name;\n\
\t\t\thooks = jQuery.propHooks[ name ];\n\
\t\t}\n\
\n\
\t\tif ( value !== undefined ) {\n\
\t\t\tif ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\
\t\t\t\treturn ret;\n\
\n\
\t\t\t} else {\n\
\t\t\t\treturn ( elem[ name ] = value );\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\
\t\t\t\treturn ret;\n\
\n\
\t\t\t} else {\n\
\t\t\t\treturn elem[ name ];\n\
\t\t\t}\n\
\t\t}\n\
\t},\n\
\n\
\tpropHooks: {\n\
\t\ttabIndex: {\n\
\t\t\tget: function( elem ) {\n\
\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\
\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\
\t\t\t\tvar attributeNode = elem.getAttributeNode(\"tabindex\");\n\
\n\
\t\t\t\treturn attributeNode && attributeNode.specified ?\n\
\t\t\t\t\tparseInt( attributeNode.value, 10 ) :\n\
\t\t\t\t\trfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n\
\t\t\t\t\t\t0 :\n\
\t\t\t\t\t\tundefined;\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
});\n\
\n\
// Hook for boolean attributes\n\
boolHook = {\n\
\tget: function( elem, name ) {\n\
\t\tvar\n\
\t\t\t// Use .prop to determine if this attribute is understood as boolean\n\
\t\t\tprop = jQuery.prop( elem, name ),\n\
\n\
\t\t\t// Fetch it accordingly\n\
\t\t\tattr = typeof prop === \"boolean\" && elem.getAttribute( name ),\n\
\t\t\tdetail = typeof prop === \"boolean\" ?\n\
\n\
\t\t\t\tgetSetInput && getSetAttribute ?\n\
\t\t\t\t\tattr != null :\n\
\t\t\t\t\t// oldIE fabricates an empty string for missing boolean attributes\n\
\t\t\t\t\t// and conflates checked/selected into attroperties\n\
\t\t\t\t\truseDefault.test( name ) ?\n\
\t\t\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] :\n\
\t\t\t\t\t\t!!attr :\n\
\n\
\t\t\t\t// fetch an attribute node for properties not recognized as boolean\n\
\t\t\t\telem.getAttributeNode( name );\n\
\n\
\t\treturn detail && detail.value !== false ?\n\
\t\t\tname.toLowerCase() :\n\
\t\t\tundefined;\n\
\t},\n\
\tset: function( elem, value, name ) {\n\
\t\tif ( value === false ) {\n\
\t\t\t// Remove boolean attributes when set to false\n\
\t\t\tjQuery.removeAttr( elem, name );\n\
\t\t} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\
\t\t\t// IE<8 needs the *property* name\n\
\t\t\telem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\
\n\
\t\t// Use defaultChecked and defaultSelected for oldIE\n\
\t\t} else {\n\
\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] = elem[ name ] = true;\n\
\t\t}\n\
\n\
\t\treturn name;\n\
\t}\n\
};\n\
\n\
// fix oldIE value attroperty\n\
if ( !getSetInput || !getSetAttribute ) {\n\
\tjQuery.attrHooks.value = {\n\
\t\tget: function( elem, name ) {\n\
\t\t\tvar ret = elem.getAttributeNode( name );\n\
\t\t\treturn jQuery.nodeName( elem, \"input\" ) ?\n\
\n\
\t\t\t\t// Ignore the value *property* by using defaultValue\n\
\t\t\t\telem.defaultValue :\n\
\n\
\t\t\t\tret && ret.specified ? ret.value : undefined;\n\
\t\t},\n\
\t\tset: function( elem, value, name ) {\n\
\t\t\tif ( jQuery.nodeName( elem, \"input\" ) ) {\n\
\t\t\t\t// Does not return so that setAttribute is also used\n\
\t\t\t\telem.defaultValue = value;\n\
\t\t\t} else {\n\
\t\t\t\t// Use nodeHook if defined (#1954); otherwise setAttribute is fine\n\
\t\t\t\treturn nodeHook && nodeHook.set( elem, value, name );\n\
\t\t\t}\n\
\t\t}\n\
\t};\n\
}\n\
\n\
// IE6/7 do not support getting/setting some attributes with get/setAttribute\n\
if ( !getSetAttribute ) {\n\
\n\
\t// Use this for any attribute in IE6/7\n\
\t// This fixes almost every IE6/7 issue\n\
\tnodeHook = jQuery.valHooks.button = {\n\
\t\tget: function( elem, name ) {\n\
\t\t\tvar ret = elem.getAttributeNode( name );\n\
\t\t\treturn ret && ( name === \"id\" || name === \"name\" || name === \"coords\" ? ret.value !== \"\" : ret.specified ) ?\n\
\t\t\t\tret.value :\n\
\t\t\t\tundefined;\n\
\t\t},\n\
\t\tset: function( elem, value, name ) {\n\
\t\t\t// Set the existing or create a new attribute node\n\
\t\t\tvar ret = elem.getAttributeNode( name );\n\
\t\t\tif ( !ret ) {\n\
\t\t\t\telem.setAttributeNode(\n\
\t\t\t\t\t(ret = elem.ownerDocument.createAttribute( name ))\n\
\t\t\t\t);\n\
\t\t\t}\n\
\n\
\t\t\tret.value = value += \"\";\n\
\n\
\t\t\t// Break association with cloned elements by also using setAttribute (#9646)\n\
\t\t\treturn name === \"value\" || value === elem.getAttribute( name ) ?\n\
\t\t\t\tvalue :\n\
\t\t\t\tundefined;\n\
\t\t}\n\
\t};\n\
\n\
\t// Set contenteditable to false on removals(#10429)\n\
\t// Setting to empty string throws an error as an invalid value\n\
\tjQuery.attrHooks.contenteditable = {\n\
\t\tget: nodeHook.get,\n\
\t\tset: function( elem, value, name ) {\n\
\t\t\tnodeHook.set( elem, value === \"\" ? false : value, name );\n\
\t\t}\n\
\t};\n\
\n\
\t// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n\
\t// This is for removals\n\
\tjQuery.each([ \"width\", \"height\" ], function( i, name ) {\n\
\t\tjQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n\
\t\t\tset: function( elem, value ) {\n\
\t\t\t\tif ( value === \"\" ) {\n\
\t\t\t\t\telem.setAttribute( name, \"auto\" );\n\
\t\t\t\t\treturn value;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t});\n\
\t});\n\
}\n\
\n\
\n\
// Some attributes require a special call on IE\n\
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\
if ( !jQuery.support.hrefNormalized ) {\n\
\tjQuery.each([ \"href\", \"src\", \"width\", \"height\" ], function( i, name ) {\n\
\t\tjQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n\
\t\t\tget: function( elem ) {\n\
\t\t\t\tvar ret = elem.getAttribute( name, 2 );\n\
\t\t\t\treturn ret == null ? undefined : ret;\n\
\t\t\t}\n\
\t\t});\n\
\t});\n\
\n\
\t// href/src property should get the full normalized URL (#10299/#12915)\n\
\tjQuery.each([ \"href\", \"src\" ], function( i, name ) {\n\
\t\tjQuery.propHooks[ name ] = {\n\
\t\t\tget: function( elem ) {\n\
\t\t\t\treturn elem.getAttribute( name, 4 );\n\
\t\t\t}\n\
\t\t};\n\
\t});\n\
}\n\
\n\
if ( !jQuery.support.style ) {\n\
\tjQuery.attrHooks.style = {\n\
\t\tget: function( elem ) {\n\
\t\t\t// Return undefined in the case of empty string\n\
\t\t\t// Note: IE uppercases css property names, but if we were to .toLowerCase()\n\
\t\t\t// .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n\
\t\t\treturn elem.style.cssText || undefined;\n\
\t\t},\n\
\t\tset: function( elem, value ) {\n\
\t\t\treturn ( elem.style.cssText = value + \"\" );\n\
\t\t}\n\
\t};\n\
}\n\
\n\
// Safari mis-reports the default selected property of an option\n\
// Accessing the parent's selectedIndex property fixes it\n\
if ( !jQuery.support.optSelected ) {\n\
\tjQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {\n\
\t\tget: function( elem ) {\n\
\t\t\tvar parent = elem.parentNode;\n\
\n\
\t\t\tif ( parent ) {\n\
\t\t\t\tparent.selectedIndex;\n\
\n\
\t\t\t\t// Make sure that it also works with optgroups, see #5701\n\
\t\t\t\tif ( parent.parentNode ) {\n\
\t\t\t\t\tparent.parentNode.selectedIndex;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t\treturn null;\n\
\t\t}\n\
\t});\n\
}\n\
\n\
// IE6/7 call enctype encoding\n\
if ( !jQuery.support.enctype ) {\n\
\tjQuery.propFix.enctype = \"encoding\";\n\
}\n\
\n\
// Radios and checkboxes getter/setter\n\
if ( !jQuery.support.checkOn ) {\n\
\tjQuery.each([ \"radio\", \"checkbox\" ], function() {\n\
\t\tjQuery.valHooks[ this ] = {\n\
\t\t\tget: function( elem ) {\n\
\t\t\t\t// Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified\n\
\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\
\t\t\t}\n\
\t\t};\n\
\t});\n\
}\n\
jQuery.each([ \"radio\", \"checkbox\" ], function() {\n\
\tjQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {\n\
\t\tset: function( elem, value ) {\n\
\t\t\tif ( jQuery.isArray( value ) ) {\n\
\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\
\t\t\t}\n\
\t\t}\n\
\t});\n\
});\n\
var rformElems = /^(?:input|select|textarea)$/i,\n\
\trkeyEvent = /^key/,\n\
\trmouseEvent = /^(?:mouse|contextmenu)|click/,\n\
\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\
\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\
\n\
function returnTrue() {\n\
\treturn true;\n\
}\n\
\n\
function returnFalse() {\n\
\treturn false;\n\
}\n\
\n\
/*\n\
 * Helper functions for managing events -- not part of the public interface.\n\
 * Props to Dean Edwards' addEvent library for many of the ideas.\n\
 */\n\
jQuery.event = {\n\
\n\
\tglobal: {},\n\
\n\
\tadd: function( elem, types, handler, data, selector ) {\n\
\t\tvar tmp, events, t, handleObjIn,\n\
\t\t\tspecial, eventHandle, handleObj,\n\
\t\t\thandlers, type, namespaces, origType,\n\
\t\t\telemData = jQuery._data( elem );\n\
\n\
\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\
\t\tif ( !elemData ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\t// Caller can pass in an object of custom data in lieu of the handler\n\
\t\tif ( handler.handler ) {\n\
\t\t\thandleObjIn = handler;\n\
\t\t\thandler = handleObjIn.handler;\n\
\t\t\tselector = handleObjIn.selector;\n\
\t\t}\n\
\n\
\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\
\t\tif ( !handler.guid ) {\n\
\t\t\thandler.guid = jQuery.guid++;\n\
\t\t}\n\
\n\
\t\t// Init the element's event structure and main handler, if this is the first\n\
\t\tif ( !(events = elemData.events) ) {\n\
\t\t\tevents = elemData.events = {};\n\
\t\t}\n\
\t\tif ( !(eventHandle = elemData.handle) ) {\n\
\t\t\teventHandle = elemData.handle = function( e ) {\n\
\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\
\t\t\t\t// when an event is called after a page has unloaded\n\
\t\t\t\treturn typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?\n\
\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\
\t\t\t\t\tundefined;\n\
\t\t\t};\n\
\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\
\t\t\teventHandle.elem = elem;\n\
\t\t}\n\
\n\
\t\t// Handle multiple events separated by a space\n\
\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\
\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\
\t\tt = types.length;\n\
\t\twhile ( t-- ) {\n\
\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\
\t\t\ttype = origType = tmp[1];\n\
\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\
\n\
\t\t\t// If event changes its type, use the special event handlers for the changed type\n\
\t\t\tspecial = jQuery.event.special[ type ] || {};\n\
\n\
\t\t\t// If selector defined, determine special event api type, otherwise given type\n\
\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\
\n\
\t\t\t// Update special based on newly reset type\n\
\t\t\tspecial = jQuery.event.special[ type ] || {};\n\
\n\
\t\t\t// handleObj is passed to all event handlers\n\
\t\t\thandleObj = jQuery.extend({\n\
\t\t\t\ttype: type,\n\
\t\t\t\torigType: origType,\n\
\t\t\t\tdata: data,\n\
\t\t\t\thandler: handler,\n\
\t\t\t\tguid: handler.guid,\n\
\t\t\t\tselector: selector,\n\
\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\
\t\t\t\tnamespace: namespaces.join(\".\")\n\
\t\t\t}, handleObjIn );\n\
\n\
\t\t\t// Init the event handler queue if we're the first\n\
\t\t\tif ( !(handlers = events[ type ]) ) {\n\
\t\t\t\thandlers = events[ type ] = [];\n\
\t\t\t\thandlers.delegateCount = 0;\n\
\n\
\t\t\t\t// Only use addEventListener/attachEvent if the special events handler returns false\n\
\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\
\t\t\t\t\t// Bind the global event handler to the element\n\
\t\t\t\t\tif ( elem.addEventListener ) {\n\
\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\
\n\
\t\t\t\t\t} else if ( elem.attachEvent ) {\n\
\t\t\t\t\t\telem.attachEvent( \"on\" + type, eventHandle );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\tif ( special.add ) {\n\
\t\t\t\tspecial.add.call( elem, handleObj );\n\
\n\
\t\t\t\tif ( !handleObj.handler.guid ) {\n\
\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\t// Add to the element's handler list, delegates in front\n\
\t\t\tif ( selector ) {\n\
\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\
\t\t\t} else {\n\
\t\t\t\thandlers.push( handleObj );\n\
\t\t\t}\n\
\n\
\t\t\t// Keep track of which events have ever been used, for event optimization\n\
\t\t\tjQuery.event.global[ type ] = true;\n\
\t\t}\n\
\n\
\t\t// Nullify elem to prevent memory leaks in IE\n\
\t\telem = null;\n\
\t},\n\
\n\
\t// Detach an event or set of events from an element\n\
\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\
\t\tvar j, handleObj, tmp,\n\
\t\t\torigCount, t, events,\n\
\t\t\tspecial, handlers, type,\n\
\t\t\tnamespaces, origType,\n\
\t\t\telemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\
\n\
\t\tif ( !elemData || !(events = elemData.events) ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\t// Once for each type.namespace in types; type may be omitted\n\
\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\
\t\tt = types.length;\n\
\t\twhile ( t-- ) {\n\
\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\
\t\t\ttype = origType = tmp[1];\n\
\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\
\n\
\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\
\t\t\tif ( !type ) {\n\
\t\t\t\tfor ( type in events ) {\n\
\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\
\t\t\t\t}\n\
\t\t\t\tcontinue;\n\
\t\t\t}\n\
\n\
\t\t\tspecial = jQuery.event.special[ type ] || {};\n\
\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\
\t\t\thandlers = events[ type ] || [];\n\
\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\
\n\
\t\t\t// Remove matching events\n\
\t\t\torigCount = j = handlers.length;\n\
\t\t\twhile ( j-- ) {\n\
\t\t\t\thandleObj = handlers[ j ];\n\
\n\
\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\
\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\
\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\
\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\
\t\t\t\t\thandlers.splice( j, 1 );\n\
\n\
\t\t\t\t\tif ( handleObj.selector ) {\n\
\t\t\t\t\t\thandlers.delegateCount--;\n\
\t\t\t\t\t}\n\
\t\t\t\t\tif ( special.remove ) {\n\
\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\
\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\
\t\t\tif ( origCount && !handlers.length ) {\n\
\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\
\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\
\t\t\t\t}\n\
\n\
\t\t\t\tdelete events[ type ];\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Remove the expando if it's no longer used\n\
\t\tif ( jQuery.isEmptyObject( events ) ) {\n\
\t\t\tdelete elemData.handle;\n\
\n\
\t\t\t// removeData also checks for emptiness and clears the expando if empty\n\
\t\t\t// so use it instead of delete\n\
\t\t\tjQuery._removeData( elem, \"events\" );\n\
\t\t}\n\
\t},\n\
\n\
\ttrigger: function( event, data, elem, onlyHandlers ) {\n\
\t\tvar handle, ontype, cur,\n\
\t\t\tbubbleType, special, tmp, i,\n\
\t\t\teventPath = [ elem || document ],\n\
\t\t\ttype = core_hasOwn.call( event, \"type\" ) ? event.type : event,\n\
\t\t\tnamespaces = core_hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\
\n\
\t\tcur = tmp = elem = elem || document;\n\
\n\
\t\t// Don't do events on text and comment nodes\n\
\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\
\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\tif ( type.indexOf(\".\") >= 0 ) {\n\
\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\
\t\t\tnamespaces = type.split(\".\");\n\
\t\t\ttype = namespaces.shift();\n\
\t\t\tnamespaces.sort();\n\
\t\t}\n\
\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\
\n\
\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\
\t\tevent = event[ jQuery.expando ] ?\n\
\t\t\tevent :\n\
\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\
\n\
\t\tevent.isTrigger = true;\n\
\t\tevent.namespace = namespaces.join(\".\");\n\
\t\tevent.namespace_re = event.namespace ?\n\
\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\
\t\t\tnull;\n\
\n\
\t\t// Clean up the event in case it is being reused\n\
\t\tevent.result = undefined;\n\
\t\tif ( !event.target ) {\n\
\t\t\tevent.target = elem;\n\
\t\t}\n\
\n\
\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\
\t\tdata = data == null ?\n\
\t\t\t[ event ] :\n\
\t\t\tjQuery.makeArray( data, [ event ] );\n\
\n\
\t\t// Allow special events to draw outside the lines\n\
\t\tspecial = jQuery.event.special[ type ] || {};\n\
\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\
\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\
\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\
\n\
\t\t\tbubbleType = special.delegateType || type;\n\
\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\
\t\t\t\tcur = cur.parentNode;\n\
\t\t\t}\n\
\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\
\t\t\t\teventPath.push( cur );\n\
\t\t\t\ttmp = cur;\n\
\t\t\t}\n\
\n\
\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\
\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\
\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Fire handlers on the event path\n\
\t\ti = 0;\n\
\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\
\n\
\t\t\tevent.type = i > 1 ?\n\
\t\t\t\tbubbleType :\n\
\t\t\t\tspecial.bindType || type;\n\
\n\
\t\t\t// jQuery handler\n\
\t\t\thandle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] && jQuery._data( cur, \"handle\" );\n\
\t\t\tif ( handle ) {\n\
\t\t\t\thandle.apply( cur, data );\n\
\t\t\t}\n\
\n\
\t\t\t// Native handler\n\
\t\t\thandle = ontype && cur[ ontype ];\n\
\t\t\tif ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {\n\
\t\t\t\tevent.preventDefault();\n\
\t\t\t}\n\
\t\t}\n\
\t\tevent.type = type;\n\
\n\
\t\t// If nobody prevented the default action, do it now\n\
\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\
\n\
\t\t\tif ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&\n\
\t\t\t\t!(type === \"click\" && jQuery.nodeName( elem, \"a\" )) && jQuery.acceptData( elem ) ) {\n\
\n\
\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\
\t\t\t\t// Can't use an .isFunction() check here because IE6/7 fails that test.\n\
\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\
\t\t\t\tif ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\
\n\
\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\
\t\t\t\t\ttmp = elem[ ontype ];\n\
\n\
\t\t\t\t\tif ( tmp ) {\n\
\t\t\t\t\t\telem[ ontype ] = null;\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\
\t\t\t\t\tjQuery.event.triggered = type;\n\
\t\t\t\t\ttry {\n\
\t\t\t\t\t\telem[ type ]();\n\
\t\t\t\t\t} catch ( e ) {\n\
\t\t\t\t\t\t// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n\
\t\t\t\t\t\t// only reproducible on winXP IE8 native, not IE9 in IE8 mode\n\
\t\t\t\t\t}\n\
\t\t\t\t\tjQuery.event.triggered = undefined;\n\
\n\
\t\t\t\t\tif ( tmp ) {\n\
\t\t\t\t\t\telem[ ontype ] = tmp;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn event.result;\n\
\t},\n\
\n\
\tdispatch: function( event ) {\n\
\n\
\t\t// Make a writable jQuery.Event from the native event object\n\
\t\tevent = jQuery.event.fix( event );\n\
\n\
\t\tvar i, ret, handleObj, matched, j,\n\
\t\t\thandlerQueue = [],\n\
\t\t\targs = core_slice.call( arguments ),\n\
\t\t\thandlers = ( jQuery._data( this, \"events\" ) || {} )[ event.type ] || [],\n\
\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\
\n\
\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\
\t\targs[0] = event;\n\
\t\tevent.delegateTarget = this;\n\
\n\
\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\
\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\t// Determine handlers\n\
\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\
\n\
\t\t// Run delegates first; they may want to stop propagation beneath us\n\
\t\ti = 0;\n\
\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\
\t\t\tevent.currentTarget = matched.elem;\n\
\n\
\t\t\tj = 0;\n\
\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\
\n\
\t\t\t\t// Triggered event must either 1) have no namespace, or\n\
\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\
\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\
\n\
\t\t\t\t\tevent.handleObj = handleObj;\n\
\t\t\t\t\tevent.data = handleObj.data;\n\
\n\
\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\
\t\t\t\t\t\t\t.apply( matched.elem, args );\n\
\n\
\t\t\t\t\tif ( ret !== undefined ) {\n\
\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\
\t\t\t\t\t\t\tevent.preventDefault();\n\
\t\t\t\t\t\t\tevent.stopPropagation();\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Call the postDispatch hook for the mapped type\n\
\t\tif ( special.postDispatch ) {\n\
\t\t\tspecial.postDispatch.call( this, event );\n\
\t\t}\n\
\n\
\t\treturn event.result;\n\
\t},\n\
\n\
\thandlers: function( event, handlers ) {\n\
\t\tvar sel, handleObj, matches, i,\n\
\t\t\thandlerQueue = [],\n\
\t\t\tdelegateCount = handlers.delegateCount,\n\
\t\t\tcur = event.target;\n\
\n\
\t\t// Find delegate handlers\n\
\t\t// Black-hole SVG <use> instance trees (#13180)\n\
\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\
\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\
\n\
\t\t\tfor ( ; cur != this; cur = cur.parentNode || this ) {\n\
\n\
\t\t\t\t// Don't check non-elements (#13208)\n\
\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\
\t\t\t\tif ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\") ) {\n\
\t\t\t\t\tmatches = [];\n\
\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\
\t\t\t\t\t\thandleObj = handlers[ i ];\n\
\n\
\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\
\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\
\n\
\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\
\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\
\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\
\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t\tif ( matches[ sel ] ) {\n\
\t\t\t\t\t\t\tmatches.push( handleObj );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t\tif ( matches.length ) {\n\
\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Add the remaining (directly-bound) handlers\n\
\t\tif ( delegateCount < handlers.length ) {\n\
\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\
\t\t}\n\
\n\
\t\treturn handlerQueue;\n\
\t},\n\
\n\
\tfix: function( event ) {\n\
\t\tif ( event[ jQuery.expando ] ) {\n\
\t\t\treturn event;\n\
\t\t}\n\
\n\
\t\t// Create a writable copy of the event object and normalize some properties\n\
\t\tvar i, prop, copy,\n\
\t\t\ttype = event.type,\n\
\t\t\toriginalEvent = event,\n\
\t\t\tfixHook = this.fixHooks[ type ];\n\
\n\
\t\tif ( !fixHook ) {\n\
\t\t\tthis.fixHooks[ type ] = fixHook =\n\
\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\
\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\
\t\t\t\t{};\n\
\t\t}\n\
\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\
\n\
\t\tevent = new jQuery.Event( originalEvent );\n\
\n\
\t\ti = copy.length;\n\
\t\twhile ( i-- ) {\n\
\t\t\tprop = copy[ i ];\n\
\t\t\tevent[ prop ] = originalEvent[ prop ];\n\
\t\t}\n\
\n\
\t\t// Support: IE<9\n\
\t\t// Fix target property (#1925)\n\
\t\tif ( !event.target ) {\n\
\t\t\tevent.target = originalEvent.srcElement || document;\n\
\t\t}\n\
\n\
\t\t// Support: Chrome 23+, Safari?\n\
\t\t// Target should not be a text node (#504, #13143)\n\
\t\tif ( event.target.nodeType === 3 ) {\n\
\t\t\tevent.target = event.target.parentNode;\n\
\t\t}\n\
\n\
\t\t// Support: IE<9\n\
\t\t// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\
\t\tevent.metaKey = !!event.metaKey;\n\
\n\
\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\
\t},\n\
\n\
\t// Includes some event props shared by KeyEvent and MouseEvent\n\
\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\
\n\
\tfixHooks: {},\n\
\n\
\tkeyHooks: {\n\
\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\
\t\tfilter: function( event, original ) {\n\
\n\
\t\t\t// Add which for key events\n\
\t\t\tif ( event.which == null ) {\n\
\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\
\t\t\t}\n\
\n\
\t\t\treturn event;\n\
\t\t}\n\
\t},\n\
\n\
\tmouseHooks: {\n\
\t\tprops: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\
\t\tfilter: function( event, original ) {\n\
\t\t\tvar body, eventDoc, doc,\n\
\t\t\t\tbutton = original.button,\n\
\t\t\t\tfromElement = original.fromElement;\n\
\n\
\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\
\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\
\t\t\t\teventDoc = event.target.ownerDocument || document;\n\
\t\t\t\tdoc = eventDoc.documentElement;\n\
\t\t\t\tbody = eventDoc.body;\n\
\n\
\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\
\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\
\t\t\t}\n\
\n\
\t\t\t// Add relatedTarget, if necessary\n\
\t\t\tif ( !event.relatedTarget && fromElement ) {\n\
\t\t\t\tevent.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n\
\t\t\t}\n\
\n\
\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\
\t\t\t// Note: button is not normalized, so don't use it\n\
\t\t\tif ( !event.which && button !== undefined ) {\n\
\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\
\t\t\t}\n\
\n\
\t\t\treturn event;\n\
\t\t}\n\
\t},\n\
\n\
\tspecial: {\n\
\t\tload: {\n\
\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\
\t\t\tnoBubble: true\n\
\t\t},\n\
\t\tclick: {\n\
\t\t\t// For checkbox, fire native event so checked state will be right\n\
\t\t\ttrigger: function() {\n\
\t\t\t\tif ( jQuery.nodeName( this, \"input\" ) && this.type === \"checkbox\" && this.click ) {\n\
\t\t\t\t\tthis.click();\n\
\t\t\t\t\treturn false;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t},\n\
\t\tfocus: {\n\
\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\
\t\t\ttrigger: function() {\n\
\t\t\t\tif ( this !== document.activeElement && this.focus ) {\n\
\t\t\t\t\ttry {\n\
\t\t\t\t\t\tthis.focus();\n\
\t\t\t\t\t\treturn false;\n\
\t\t\t\t\t} catch ( e ) {\n\
\t\t\t\t\t\t// Support: IE<9\n\
\t\t\t\t\t\t// If we error on focus to hidden element (#1486, #12518),\n\
\t\t\t\t\t\t// let .trigger() run the handlers\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t},\n\
\t\t\tdelegateType: \"focusin\"\n\
\t\t},\n\
\t\tblur: {\n\
\t\t\ttrigger: function() {\n\
\t\t\t\tif ( this === document.activeElement && this.blur ) {\n\
\t\t\t\t\tthis.blur();\n\
\t\t\t\t\treturn false;\n\
\t\t\t\t}\n\
\t\t\t},\n\
\t\t\tdelegateType: \"focusout\"\n\
\t\t},\n\
\n\
\t\tbeforeunload: {\n\
\t\t\tpostDispatch: function( event ) {\n\
\n\
\t\t\t\t// Even when returnValue equals to undefined Firefox will still show alert\n\
\t\t\t\tif ( event.result !== undefined ) {\n\
\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t},\n\
\n\
\tsimulate: function( type, elem, event, bubble ) {\n\
\t\t// Piggyback on a donor event to simulate a different one.\n\
\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\
\t\t// simulated event prevents default then we do the same on the donor.\n\
\t\tvar e = jQuery.extend(\n\
\t\t\tnew jQuery.Event(),\n\
\t\t\tevent,\n\
\t\t\t{ type: type,\n\
\t\t\t\tisSimulated: true,\n\
\t\t\t\toriginalEvent: {}\n\
\t\t\t}\n\
\t\t);\n\
\t\tif ( bubble ) {\n\
\t\t\tjQuery.event.trigger( e, null, elem );\n\
\t\t} else {\n\
\t\t\tjQuery.event.dispatch.call( elem, e );\n\
\t\t}\n\
\t\tif ( e.isDefaultPrevented() ) {\n\
\t\t\tevent.preventDefault();\n\
\t\t}\n\
\t}\n\
};\n\
\n\
jQuery.removeEvent = document.removeEventListener ?\n\
\tfunction( elem, type, handle ) {\n\
\t\tif ( elem.removeEventListener ) {\n\
\t\t\telem.removeEventListener( type, handle, false );\n\
\t\t}\n\
\t} :\n\
\tfunction( elem, type, handle ) {\n\
\t\tvar name = \"on\" + type;\n\
\n\
\t\tif ( elem.detachEvent ) {\n\
\n\
\t\t\t// #8545, #7054, preventing memory leaks for custom events in IE6-8\n\
\t\t\t// detachEvent needed property on element, by name of that event, to properly expose it to GC\n\
\t\t\tif ( typeof elem[ name ] === core_strundefined ) {\n\
\t\t\t\telem[ name ] = null;\n\
\t\t\t}\n\
\n\
\t\t\telem.detachEvent( name, handle );\n\
\t\t}\n\
\t};\n\
\n\
jQuery.Event = function( src, props ) {\n\
\t// Allow instantiation without the 'new' keyword\n\
\tif ( !(this instanceof jQuery.Event) ) {\n\
\t\treturn new jQuery.Event( src, props );\n\
\t}\n\
\n\
\t// Event object\n\
\tif ( src && src.type ) {\n\
\t\tthis.originalEvent = src;\n\
\t\tthis.type = src.type;\n\
\n\
\t\t// Events bubbling up the document may have been marked as prevented\n\
\t\t// by a handler lower down the tree; reflect the correct value.\n\
\t\tthis.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||\n\
\t\t\tsrc.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\n\
\n\
\t// Event type\n\
\t} else {\n\
\t\tthis.type = src;\n\
\t}\n\
\n\
\t// Put explicitly provided properties onto the event object\n\
\tif ( props ) {\n\
\t\tjQuery.extend( this, props );\n\
\t}\n\
\n\
\t// Create a timestamp if incoming event doesn't have one\n\
\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\
\n\
\t// Mark it as fixed\n\
\tthis[ jQuery.expando ] = true;\n\
};\n\
\n\
// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\
jQuery.Event.prototype = {\n\
\tisDefaultPrevented: returnFalse,\n\
\tisPropagationStopped: returnFalse,\n\
\tisImmediatePropagationStopped: returnFalse,\n\
\n\
\tpreventDefault: function() {\n\
\t\tvar e = this.originalEvent;\n\
\n\
\t\tthis.isDefaultPrevented = returnTrue;\n\
\t\tif ( !e ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\t// If preventDefault exists, run it on the original event\n\
\t\tif ( e.preventDefault ) {\n\
\t\t\te.preventDefault();\n\
\n\
\t\t// Support: IE\n\
\t\t// Otherwise set the returnValue property of the original event to false\n\
\t\t} else {\n\
\t\t\te.returnValue = false;\n\
\t\t}\n\
\t},\n\
\tstopPropagation: function() {\n\
\t\tvar e = this.originalEvent;\n\
\n\
\t\tthis.isPropagationStopped = returnTrue;\n\
\t\tif ( !e ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\t\t// If stopPropagation exists, run it on the original event\n\
\t\tif ( e.stopPropagation ) {\n\
\t\t\te.stopPropagation();\n\
\t\t}\n\
\n\
\t\t// Support: IE\n\
\t\t// Set the cancelBubble property of the original event to true\n\
\t\te.cancelBubble = true;\n\
\t},\n\
\tstopImmediatePropagation: function() {\n\
\t\tthis.isImmediatePropagationStopped = returnTrue;\n\
\t\tthis.stopPropagation();\n\
\t}\n\
};\n\
\n\
// Create mouseenter/leave events using mouseover/out and event-time checks\n\
jQuery.each({\n\
\tmouseenter: \"mouseover\",\n\
\tmouseleave: \"mouseout\"\n\
}, function( orig, fix ) {\n\
\tjQuery.event.special[ orig ] = {\n\
\t\tdelegateType: fix,\n\
\t\tbindType: fix,\n\
\n\
\t\thandle: function( event ) {\n\
\t\t\tvar ret,\n\
\t\t\t\ttarget = this,\n\
\t\t\t\trelated = event.relatedTarget,\n\
\t\t\t\thandleObj = event.handleObj;\n\
\n\
\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\
\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\
\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\
\t\t\t\tevent.type = handleObj.origType;\n\
\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\
\t\t\t\tevent.type = fix;\n\
\t\t\t}\n\
\t\t\treturn ret;\n\
\t\t}\n\
\t};\n\
});\n\
\n\
// IE submit delegation\n\
if ( !jQuery.support.submitBubbles ) {\n\
\n\
\tjQuery.event.special.submit = {\n\
\t\tsetup: function() {\n\
\t\t\t// Only need this for delegated form submit events\n\
\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\
\t\t\t\treturn false;\n\
\t\t\t}\n\
\n\
\t\t\t// Lazy-add a submit handler when a descendant form may potentially be submitted\n\
\t\t\tjQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n\
\t\t\t\t// Node name check avoids a VML-related crash in IE (#9807)\n\
\t\t\t\tvar elem = e.target,\n\
\t\t\t\t\tform = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.form : undefined;\n\
\t\t\t\tif ( form && !jQuery._data( form, \"submitBubbles\" ) ) {\n\
\t\t\t\t\tjQuery.event.add( form, \"submit._submit\", function( event ) {\n\
\t\t\t\t\t\tevent._submit_bubble = true;\n\
\t\t\t\t\t});\n\
\t\t\t\t\tjQuery._data( form, \"submitBubbles\", true );\n\
\t\t\t\t}\n\
\t\t\t});\n\
\t\t\t// return undefined since we don't need an event listener\n\
\t\t},\n\
\n\
\t\tpostDispatch: function( event ) {\n\
\t\t\t// If form was submitted by the user, bubble the event up the tree\n\
\t\t\tif ( event._submit_bubble ) {\n\
\t\t\t\tdelete event._submit_bubble;\n\
\t\t\t\tif ( this.parentNode && !event.isTrigger ) {\n\
\t\t\t\t\tjQuery.event.simulate( \"submit\", this.parentNode, event, true );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t},\n\
\n\
\t\tteardown: function() {\n\
\t\t\t// Only need this for delegated form submit events\n\
\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\
\t\t\t\treturn false;\n\
\t\t\t}\n\
\n\
\t\t\t// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\
\t\t\tjQuery.event.remove( this, \"._submit\" );\n\
\t\t}\n\
\t};\n\
}\n\
\n\
// IE change delegation and checkbox/radio fix\n\
if ( !jQuery.support.changeBubbles ) {\n\
\n\
\tjQuery.event.special.change = {\n\
\n\
\t\tsetup: function() {\n\
\n\
\t\t\tif ( rformElems.test( this.nodeName ) ) {\n\
\t\t\t\t// IE doesn't fire change on a check/radio until blur; trigger it on click\n\
\t\t\t\t// after a propertychange. Eat the blur-change in special.change.handle.\n\
\t\t\t\t// This still fires onchange a second time for check/radio after blur.\n\
\t\t\t\tif ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n\
\t\t\t\t\tjQuery.event.add( this, \"propertychange._change\", function( event ) {\n\
\t\t\t\t\t\tif ( event.originalEvent.propertyName === \"checked\" ) {\n\
\t\t\t\t\t\t\tthis._just_changed = true;\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t});\n\
\t\t\t\t\tjQuery.event.add( this, \"click._change\", function( event ) {\n\
\t\t\t\t\t\tif ( this._just_changed && !event.isTrigger ) {\n\
\t\t\t\t\t\t\tthis._just_changed = false;\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t\t// Allow triggered, simulated change events (#11500)\n\
\t\t\t\t\t\tjQuery.event.simulate( \"change\", this, event, true );\n\
\t\t\t\t\t});\n\
\t\t\t\t}\n\
\t\t\t\treturn false;\n\
\t\t\t}\n\
\t\t\t// Delegated event; lazy-add a change handler on descendant inputs\n\
\t\t\tjQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n\
\t\t\t\tvar elem = e.target;\n\
\n\
\t\t\t\tif ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, \"changeBubbles\" ) ) {\n\
\t\t\t\t\tjQuery.event.add( elem, \"change._change\", function( event ) {\n\
\t\t\t\t\t\tif ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n\
\t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this.parentNode, event, true );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t});\n\
\t\t\t\t\tjQuery._data( elem, \"changeBubbles\", true );\n\
\t\t\t\t}\n\
\t\t\t});\n\
\t\t},\n\
\n\
\t\thandle: function( event ) {\n\
\t\t\tvar elem = event.target;\n\
\n\
\t\t\t// Swallow native change events from checkbox/radio, we already triggered them above\n\
\t\t\tif ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== \"radio\" && elem.type !== \"checkbox\") ) {\n\
\t\t\t\treturn event.handleObj.handler.apply( this, arguments );\n\
\t\t\t}\n\
\t\t},\n\
\n\
\t\tteardown: function() {\n\
\t\t\tjQuery.event.remove( this, \"._change\" );\n\
\n\
\t\t\treturn !rformElems.test( this.nodeName );\n\
\t\t}\n\
\t};\n\
}\n\
\n\
// Create \"bubbling\" focus and blur events\n\
if ( !jQuery.support.focusinBubbles ) {\n\
\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\
\n\
\t\t// Attach a single capturing handler while someone wants focusin/focusout\n\
\t\tvar attaches = 0,\n\
\t\t\thandler = function( event ) {\n\
\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\
\t\t\t};\n\
\n\
\t\tjQuery.event.special[ fix ] = {\n\
\t\t\tsetup: function() {\n\
\t\t\t\tif ( attaches++ === 0 ) {\n\
\t\t\t\t\tdocument.addEventListener( orig, handler, true );\n\
\t\t\t\t}\n\
\t\t\t},\n\
\t\t\tteardown: function() {\n\
\t\t\t\tif ( --attaches === 0 ) {\n\
\t\t\t\t\tdocument.removeEventListener( orig, handler, true );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t};\n\
\t});\n\
}\n\
\n\
jQuery.fn.extend({\n\
\n\
\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\
\t\tvar type, origFn;\n\
\n\
\t\t// Types can be a map of types/handlers\n\
\t\tif ( typeof types === \"object\" ) {\n\
\t\t\t// ( types-Object, selector, data )\n\
\t\t\tif ( typeof selector !== \"string\" ) {\n\
\t\t\t\t// ( types-Object, data )\n\
\t\t\t\tdata = data || selector;\n\
\t\t\t\tselector = undefined;\n\
\t\t\t}\n\
\t\t\tfor ( type in types ) {\n\
\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\
\t\t\t}\n\
\t\t\treturn this;\n\
\t\t}\n\
\n\
\t\tif ( data == null && fn == null ) {\n\
\t\t\t// ( types, fn )\n\
\t\t\tfn = selector;\n\
\t\t\tdata = selector = undefined;\n\
\t\t} else if ( fn == null ) {\n\
\t\t\tif ( typeof selector === \"string\" ) {\n\
\t\t\t\t// ( types, selector, fn )\n\
\t\t\t\tfn = data;\n\
\t\t\t\tdata = undefined;\n\
\t\t\t} else {\n\
\t\t\t\t// ( types, data, fn )\n\
\t\t\t\tfn = data;\n\
\t\t\t\tdata = selector;\n\
\t\t\t\tselector = undefined;\n\
\t\t\t}\n\
\t\t}\n\
\t\tif ( fn === false ) {\n\
\t\t\tfn = returnFalse;\n\
\t\t} else if ( !fn ) {\n\
\t\t\treturn this;\n\
\t\t}\n\
\n\
\t\tif ( one === 1 ) {\n\
\t\t\torigFn = fn;\n\
\t\t\tfn = function( event ) {\n\
\t\t\t\t// Can use an empty set, since event contains the info\n\
\t\t\t\tjQuery().off( event );\n\
\t\t\t\treturn origFn.apply( this, arguments );\n\
\t\t\t};\n\
\t\t\t// Use same guid so caller can remove using origFn\n\
\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\
\t\t}\n\
\t\treturn this.each( function() {\n\
\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\
\t\t});\n\
\t},\n\
\tone: function( types, selector, data, fn ) {\n\
\t\treturn this.on( types, selector, data, fn, 1 );\n\
\t},\n\
\toff: function( types, selector, fn ) {\n\
\t\tvar handleObj, type;\n\
\t\tif ( types && types.preventDefault && types.handleObj ) {\n\
\t\t\t// ( event )  dispatched jQuery.Event\n\
\t\t\thandleObj = types.handleObj;\n\
\t\t\tjQuery( types.delegateTarget ).off(\n\
\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\
\t\t\t\thandleObj.selector,\n\
\t\t\t\thandleObj.handler\n\
\t\t\t);\n\
\t\t\treturn this;\n\
\t\t}\n\
\t\tif ( typeof types === \"object\" ) {\n\
\t\t\t// ( types-object [, selector] )\n\
\t\t\tfor ( type in types ) {\n\
\t\t\t\tthis.off( type, selector, types[ type ] );\n\
\t\t\t}\n\
\t\t\treturn this;\n\
\t\t}\n\
\t\tif ( selector === false || typeof selector === \"function\" ) {\n\
\t\t\t// ( types [, fn] )\n\
\t\t\tfn = selector;\n\
\t\t\tselector = undefined;\n\
\t\t}\n\
\t\tif ( fn === false ) {\n\
\t\t\tfn = returnFalse;\n\
\t\t}\n\
\t\treturn this.each(function() {\n\
\t\t\tjQuery.event.remove( this, types, fn, selector );\n\
\t\t});\n\
\t},\n\
\n\
\tbind: function( types, data, fn ) {\n\
\t\treturn this.on( types, null, data, fn );\n\
\t},\n\
\tunbind: function( types, fn ) {\n\
\t\treturn this.off( types, null, fn );\n\
\t},\n\
\n\
\tdelegate: function( selector, types, data, fn ) {\n\
\t\treturn this.on( types, selector, data, fn );\n\
\t},\n\
\tundelegate: function( selector, types, fn ) {\n\
\t\t// ( namespace ) or ( selector, types [, fn] )\n\
\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\
\t},\n\
\n\
\ttrigger: function( type, data ) {\n\
\t\treturn this.each(function() {\n\
\t\t\tjQuery.event.trigger( type, data, this );\n\
\t\t});\n\
\t},\n\
\ttriggerHandler: function( type, data ) {\n\
\t\tvar elem = this[0];\n\
\t\tif ( elem ) {\n\
\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\
\t\t}\n\
\t}\n\
});\n\
/*!\n\
 * Sizzle CSS Selector Engine\n\
 * Copyright 2012 jQuery Foundation and other contributors\n\
 * Released under the MIT license\n\
 * http://sizzlejs.com/\n\
 */\n\
(function( window, undefined ) {\n\
\n\
var i,\n\
\tcachedruns,\n\
\tExpr,\n\
\tgetText,\n\
\tisXML,\n\
\tcompile,\n\
\thasDuplicate,\n\
\toutermostContext,\n\
\n\
\t// Local document vars\n\
\tsetDocument,\n\
\tdocument,\n\
\tdocElem,\n\
\tdocumentIsXML,\n\
\trbuggyQSA,\n\
\trbuggyMatches,\n\
\tmatches,\n\
\tcontains,\n\
\tsortOrder,\n\
\n\
\t// Instance-specific data\n\
\texpando = \"sizzle\" + -(new Date()),\n\
\tpreferredDoc = window.document,\n\
\tsupport = {},\n\
\tdirruns = 0,\n\
\tdone = 0,\n\
\tclassCache = createCache(),\n\
\ttokenCache = createCache(),\n\
\tcompilerCache = createCache(),\n\
\n\
\t// General-purpose constants\n\
\tstrundefined = typeof undefined,\n\
\tMAX_NEGATIVE = 1 << 31,\n\
\n\
\t// Array methods\n\
\tarr = [],\n\
\tpop = arr.pop,\n\
\tpush = arr.push,\n\
\tslice = arr.slice,\n\
\t// Use a stripped-down indexOf if we can't use a native one\n\
\tindexOf = arr.indexOf || function( elem ) {\n\
\t\tvar i = 0,\n\
\t\t\tlen = this.length;\n\
\t\tfor ( ; i < len; i++ ) {\n\
\t\t\tif ( this[i] === elem ) {\n\
\t\t\t\treturn i;\n\
\t\t\t}\n\
\t\t}\n\
\t\treturn -1;\n\
\t},\n\
\n\
\n\
\t// Regular expressions\n\
\n\
\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\
\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\
\\\\f]\",\n\
\t// http://www.w3.org/TR/css3-syntax/#characters\n\
\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\
\n\
\t// Loosely modeled on CSS identifier characters\n\
\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\
\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\
\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\
\n\
\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n\
\toperators = \"([*^$|!~]?=)\",\n\
\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\n\
\t\t\"*(?:\" + operators + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n\
\n\
\t// Prefer arguments quoted,\n\
\t//   then not containing pseudos/brackets,\n\
\t//   then attribute selectors/non-parenthetical expressions,\n\
\t//   then anything else\n\
\t// These preferences are here to reduce the number of selectors\n\
\t//   needing tokenize in the PSEUDO preFilter\n\
\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\n\
\n\
\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\
\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\
\n\
\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\
\trcombinators = new RegExp( \"^\" + whitespace + \"*([\\\\x20\\\\t\\\\r\\\\n\
\\\\f>+~])\" + whitespace + \"*\" ),\n\
\trpseudo = new RegExp( pseudos ),\n\
\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\
\n\
\tmatchExpr = {\n\
\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\
\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\
\t\t\"NAME\": new RegExp( \"^\\\\[name=['\\\"]?(\" + characterEncoding + \")['\\\"]?\\\\]\" ),\n\
\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\
\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\
\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\
\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\
\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\
\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\
\t\t// For use in libraries implementing .is()\n\
\t\t// We use this for POS matching in `select`\n\
\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\
\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\
\t},\n\
\n\
\trsibling = /[\\x20\\t\\r\\n\
\\f]*[+~]/,\n\
\n\
\trnative = /^[^{]+\\{\\s*\\[native code/,\n\
\n\
\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\
\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\
\n\
\trinputs = /^(?:input|select|textarea|button)$/i,\n\
\trheader = /^h\\d$/i,\n\
\n\
\trescape = /'|\\\\/g,\n\
\trattributeQuotes = /\\=[\\x20\\t\\r\\n\
\\f]*([^'\"\\]]*)[\\x20\\t\\r\\n\
\\f]*\\]/g,\n\
\n\
\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\
\trunescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\
\\f]?|.)/g,\n\
\tfunescape = function( _, escaped ) {\n\
\t\tvar high = \"0x\" + escaped - 0x10000;\n\
\t\t// NaN means non-codepoint\n\
\t\treturn high !== high ?\n\
\t\t\tescaped :\n\
\t\t\t// BMP codepoint\n\
\t\t\thigh < 0 ?\n\
\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\
\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\
\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\
\t};\n\
\n\
// Use a stripped-down slice if we can't use a native one\n\
try {\n\
\tslice.call( preferredDoc.documentElement.childNodes, 0 )[0].nodeType;\n\
} catch ( e ) {\n\
\tslice = function( i ) {\n\
\t\tvar elem,\n\
\t\t\tresults = [];\n\
\t\twhile ( (elem = this[i++]) ) {\n\
\t\t\tresults.push( elem );\n\
\t\t}\n\
\t\treturn results;\n\
\t};\n\
}\n\
\n\
/**\n\
 * For feature detection\n\
 * @param {Function} fn The function to test for native support\n\
 */\n\
function isNative( fn ) {\n\
\treturn rnative.test( fn + \"\" );\n\
}\n\
\n\
/**\n\
 * Create key-value caches of limited size\n\
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n\
 *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n\
 *\tdeleting the oldest entry\n\
 */\n\
function createCache() {\n\
\tvar cache,\n\
\t\tkeys = [];\n\
\n\
\treturn (cache = function( key, value ) {\n\
\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\
\t\tif ( keys.push( key += \" \" ) > Expr.cacheLength ) {\n\
\t\t\t// Only keep the most recent entries\n\
\t\t\tdelete cache[ keys.shift() ];\n\
\t\t}\n\
\t\treturn (cache[ key ] = value);\n\
\t});\n\
}\n\
\n\
/**\n\
 * Mark a function for special use by Sizzle\n\
 * @param {Function} fn The function to mark\n\
 */\n\
function markFunction( fn ) {\n\
\tfn[ expando ] = true;\n\
\treturn fn;\n\
}\n\
\n\
/**\n\
 * Support testing using an element\n\
 * @param {Function} fn Passed the created div and expects a boolean result\n\
 */\n\
function assert( fn ) {\n\
\tvar div = document.createElement(\"div\");\n\
\n\
\ttry {\n\
\t\treturn fn( div );\n\
\t} catch (e) {\n\
\t\treturn false;\n\
\t} finally {\n\
\t\t// release memory in IE\n\
\t\tdiv = null;\n\
\t}\n\
}\n\
\n\
function Sizzle( selector, context, results, seed ) {\n\
\tvar match, elem, m, nodeType,\n\
\t\t// QSA vars\n\
\t\ti, groups, old, nid, newContext, newSelector;\n\
\n\
\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\
\t\tsetDocument( context );\n\
\t}\n\
\n\
\tcontext = context || document;\n\
\tresults = results || [];\n\
\n\
\tif ( !selector || typeof selector !== \"string\" ) {\n\
\t\treturn results;\n\
\t}\n\
\n\
\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n\
\t\treturn [];\n\
\t}\n\
\n\
\tif ( !documentIsXML && !seed ) {\n\
\n\
\t\t// Shortcuts\n\
\t\tif ( (match = rquickExpr.exec( selector )) ) {\n\
\t\t\t// Speed-up: Sizzle(\"#ID\")\n\
\t\t\tif ( (m = match[1]) ) {\n\
\t\t\t\tif ( nodeType === 9 ) {\n\
\t\t\t\t\telem = context.getElementById( m );\n\
\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\
\t\t\t\t\t// nodes that are no longer in the document #6963\n\
\t\t\t\t\tif ( elem && elem.parentNode ) {\n\
\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\
\t\t\t\t\t\t// by name instead of ID\n\
\t\t\t\t\t\tif ( elem.id === m ) {\n\
\t\t\t\t\t\t\tresults.push( elem );\n\
\t\t\t\t\t\t\treturn results;\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t} else {\n\
\t\t\t\t\t\treturn results;\n\
\t\t\t\t\t}\n\
\t\t\t\t} else {\n\
\t\t\t\t\t// Context is not a document\n\
\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\
\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\
\t\t\t\t\t\tresults.push( elem );\n\
\t\t\t\t\t\treturn results;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\n\
\t\t\t// Speed-up: Sizzle(\"TAG\")\n\
\t\t\t} else if ( match[2] ) {\n\
\t\t\t\tpush.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );\n\
\t\t\t\treturn results;\n\
\n\
\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\
\t\t\t} else if ( (m = match[3]) && support.getByClassName && context.getElementsByClassName ) {\n\
\t\t\t\tpush.apply( results, slice.call(context.getElementsByClassName( m ), 0) );\n\
\t\t\t\treturn results;\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// QSA path\n\
\t\tif ( support.qsa && !rbuggyQSA.test(selector) ) {\n\
\t\t\told = true;\n\
\t\t\tnid = expando;\n\
\t\t\tnewContext = context;\n\
\t\t\tnewSelector = nodeType === 9 && selector;\n\
\n\
\t\t\t// qSA works strangely on Element-rooted queries\n\
\t\t\t// We can work around this by specifying an extra ID on the root\n\
\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\
\t\t\t// IE 8 doesn't work on object elements\n\
\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\
\t\t\t\tgroups = tokenize( selector );\n\
\n\
\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\
\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\
\t\t\t\t} else {\n\
\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\
\t\t\t\t}\n\
\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\
\n\
\t\t\t\ti = groups.length;\n\
\t\t\t\twhile ( i-- ) {\n\
\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\
\t\t\t\t}\n\
\t\t\t\tnewContext = rsibling.test( selector ) && context.parentNode || context;\n\
\t\t\t\tnewSelector = groups.join(\",\");\n\
\t\t\t}\n\
\n\
\t\t\tif ( newSelector ) {\n\
\t\t\t\ttry {\n\
\t\t\t\t\tpush.apply( results, slice.call( newContext.querySelectorAll(\n\
\t\t\t\t\t\tnewSelector\n\
\t\t\t\t\t), 0 ) );\n\
\t\t\t\t\treturn results;\n\
\t\t\t\t} catch(qsaError) {\n\
\t\t\t\t} finally {\n\
\t\t\t\t\tif ( !old ) {\n\
\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\t// All others\n\
\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n\
}\n\
\n\
/**\n\
 * Detect xml\n\
 * @param {Element|Object} elem An element or a document\n\
 */\n\
isXML = Sizzle.isXML = function( elem ) {\n\
\t// documentElement is verified for cases where it doesn't yet exist\n\
\t// (such as loading iframes in IE - #4833)\n\
\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\
\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\
};\n\
\n\
/**\n\
 * Sets document-related variables once based on the current document\n\
 * @param {Element|Object} [doc] An element or document object to use to set the document\n\
 * @returns {Object} Returns the current document\n\
 */\n\
setDocument = Sizzle.setDocument = function( node ) {\n\
\tvar doc = node ? node.ownerDocument || node : preferredDoc;\n\
\n\
\t// If no document and documentElement is available, return\n\
\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\
\t\treturn document;\n\
\t}\n\
\n\
\t// Set our document\n\
\tdocument = doc;\n\
\tdocElem = doc.documentElement;\n\
\n\
\t// Support tests\n\
\tdocumentIsXML = isXML( doc );\n\
\n\
\t// Check if getElementsByTagName(\"*\") returns only elements\n\
\tsupport.tagNameNoComments = assert(function( div ) {\n\
\t\tdiv.appendChild( doc.createComment(\"\") );\n\
\t\treturn !div.getElementsByTagName(\"*\").length;\n\
\t});\n\
\n\
\t// Check if attributes should be retrieved by attribute nodes\n\
\tsupport.attributes = assert(function( div ) {\n\
\t\tdiv.innerHTML = \"<select></select>\";\n\
\t\tvar type = typeof div.lastChild.getAttribute(\"multiple\");\n\
\t\t// IE8 returns a string for some attributes even when not present\n\
\t\treturn type !== \"boolean\" && type !== \"string\";\n\
\t});\n\
\n\
\t// Check if getElementsByClassName can be trusted\n\
\tsupport.getByClassName = assert(function( div ) {\n\
\t\t// Opera can't find a second classname (in 9.6)\n\
\t\tdiv.innerHTML = \"<div class='hidden e'></div><div class='hidden'></div>\";\n\
\t\tif ( !div.getElementsByClassName || !div.getElementsByClassName(\"e\").length ) {\n\
\t\t\treturn false;\n\
\t\t}\n\
\n\
\t\t// Safari 3.2 caches class attributes and doesn't catch changes\n\
\t\tdiv.lastChild.className = \"e\";\n\
\t\treturn div.getElementsByClassName(\"e\").length === 2;\n\
\t});\n\
\n\
\t// Check if getElementById returns elements by name\n\
\t// Check if getElementsByName privileges form controls or returns elements by ID\n\
\tsupport.getByName = assert(function( div ) {\n\
\t\t// Inject content\n\
\t\tdiv.id = expando + 0;\n\
\t\tdiv.innerHTML = \"<a name='\" + expando + \"'></a><div name='\" + expando + \"'></div>\";\n\
\t\tdocElem.insertBefore( div, docElem.firstChild );\n\
\n\
\t\t// Test\n\
\t\tvar pass = doc.getElementsByName &&\n\
\t\t\t// buggy browsers will return fewer than the correct 2\n\
\t\t\tdoc.getElementsByName( expando ).length === 2 +\n\
\t\t\t// buggy browsers will return more than the correct 0\n\
\t\t\tdoc.getElementsByName( expando + 0 ).length;\n\
\t\tsupport.getIdNotName = !doc.getElementById( expando );\n\
\n\
\t\t// Cleanup\n\
\t\tdocElem.removeChild( div );\n\
\n\
\t\treturn pass;\n\
\t});\n\
\n\
\t// IE6/7 return modified attributes\n\
\tExpr.attrHandle = assert(function( div ) {\n\
\t\tdiv.innerHTML = \"<a href='#'></a>\";\n\
\t\treturn div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&\n\
\t\t\tdiv.firstChild.getAttribute(\"href\") === \"#\";\n\
\t}) ?\n\
\t\t{} :\n\
\t\t{\n\
\t\t\t\"href\": function( elem ) {\n\
\t\t\t\treturn elem.getAttribute( \"href\", 2 );\n\
\t\t\t},\n\
\t\t\t\"type\": function( elem ) {\n\
\t\t\t\treturn elem.getAttribute(\"type\");\n\
\t\t\t}\n\
\t\t};\n\
\n\
\t// ID find and filter\n\
\tif ( support.getIdNotName ) {\n\
\t\tExpr.find[\"ID\"] = function( id, context ) {\n\
\t\t\tif ( typeof context.getElementById !== strundefined && !documentIsXML ) {\n\
\t\t\t\tvar m = context.getElementById( id );\n\
\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\
\t\t\t\t// nodes that are no longer in the document #6963\n\
\t\t\t\treturn m && m.parentNode ? [m] : [];\n\
\t\t\t}\n\
\t\t};\n\
\t\tExpr.filter[\"ID\"] = function( id ) {\n\
\t\t\tvar attrId = id.replace( runescape, funescape );\n\
\t\t\treturn function( elem ) {\n\
\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\
\t\t\t};\n\
\t\t};\n\
\t} else {\n\
\t\tExpr.find[\"ID\"] = function( id, context ) {\n\
\t\t\tif ( typeof context.getElementById !== strundefined && !documentIsXML ) {\n\
\t\t\t\tvar m = context.getElementById( id );\n\
\n\
\t\t\t\treturn m ?\n\
\t\t\t\t\tm.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode(\"id\").value === id ?\n\
\t\t\t\t\t\t[m] :\n\
\t\t\t\t\t\tundefined :\n\
\t\t\t\t\t[];\n\
\t\t\t}\n\
\t\t};\n\
\t\tExpr.filter[\"ID\"] =  function( id ) {\n\
\t\t\tvar attrId = id.replace( runescape, funescape );\n\
\t\t\treturn function( elem ) {\n\
\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n\
\t\t\t\treturn node && node.value === attrId;\n\
\t\t\t};\n\
\t\t};\n\
\t}\n\
\n\
\t// Tag\n\
\tExpr.find[\"TAG\"] = support.tagNameNoComments ?\n\
\t\tfunction( tag, context ) {\n\
\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\n\
\t\t\t\treturn context.getElementsByTagName( tag );\n\
\t\t\t}\n\
\t\t} :\n\
\t\tfunction( tag, context ) {\n\
\t\t\tvar elem,\n\
\t\t\t\ttmp = [],\n\
\t\t\t\ti = 0,\n\
\t\t\t\tresults = context.getElementsByTagName( tag );\n\
\n\
\t\t\t// Filter out possible comments\n\
\t\t\tif ( tag === \"*\" ) {\n\
\t\t\t\twhile ( (elem = results[i++]) ) {\n\
\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\
\t\t\t\t\t\ttmp.push( elem );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\n\
\t\t\t\treturn tmp;\n\
\t\t\t}\n\
\t\t\treturn results;\n\
\t\t};\n\
\n\
\t// Name\n\
\tExpr.find[\"NAME\"] = support.getByName && function( tag, context ) {\n\
\t\tif ( typeof context.getElementsByName !== strundefined ) {\n\
\t\t\treturn context.getElementsByName( name );\n\
\t\t}\n\
\t};\n\
\n\
\t// Class\n\
\tExpr.find[\"CLASS\"] = support.getByClassName && function( className, context ) {\n\
\t\tif ( typeof context.getElementsByClassName !== strundefined && !documentIsXML ) {\n\
\t\t\treturn context.getElementsByClassName( className );\n\
\t\t}\n\
\t};\n\
\n\
\t// QSA and matchesSelector support\n\
\n\
\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\
\trbuggyMatches = [];\n\
\n\
\t// qSa(:focus) reports false when true (Chrome 21),\n\
\t// no need to also add to buggyMatches since matches checks buggyQSA\n\
\t// A support test would require too much code (would include document ready)\n\
\trbuggyQSA = [ \":focus\" ];\n\
\n\
\tif ( (support.qsa = isNative(doc.querySelectorAll)) ) {\n\
\t\t// Build QSA regex\n\
\t\t// Regex strategy adopted from Diego Perini\n\
\t\tassert(function( div ) {\n\
\t\t\t// Select is set to empty string on purpose\n\
\t\t\t// This is to test IE's treatment of not explictly\n\
\t\t\t// setting a boolean content attribute,\n\
\t\t\t// since its presence should be enough\n\
\t\t\t// http://bugs.jquery.com/ticket/12359\n\
\t\t\tdiv.innerHTML = \"<select><option selected=''></option></select>\";\n\
\n\
\t\t\t// IE8 - Some boolean attributes are not treated correctly\n\
\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\
\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:checked|disabled|ismap|multiple|readonly|selected|value)\" );\n\
\t\t\t}\n\
\n\
\t\t\t// Webkit/Opera - :checked should return selected option elements\n\
\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\
\t\t\t// IE8 throws error here and will not see later tests\n\
\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\
\t\t\t\trbuggyQSA.push(\":checked\");\n\
\t\t\t}\n\
\t\t});\n\
\n\
\t\tassert(function( div ) {\n\
\n\
\t\t\t// Opera 10-12/IE8 - ^= $= *= and empty values\n\
\t\t\t// Should not select anything\n\
\t\t\tdiv.innerHTML = \"<input type='hidden' i=''/>\";\n\
\t\t\tif ( div.querySelectorAll(\"[i^='']\").length ) {\n\
\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:\\\"\\\"|'')\" );\n\
\t\t\t}\n\
\n\
\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\
\t\t\t// IE8 throws error here and will not see later tests\n\
\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\
\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\
\t\t\t}\n\
\n\
\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\
\t\t\tdiv.querySelectorAll(\"*,:x\");\n\
\t\t\trbuggyQSA.push(\",.*:\");\n\
\t\t});\n\
\t}\n\
\n\
\tif ( (support.matchesSelector = isNative( (matches = docElem.matchesSelector ||\n\
\t\tdocElem.mozMatchesSelector ||\n\
\t\tdocElem.webkitMatchesSelector ||\n\
\t\tdocElem.oMatchesSelector ||\n\
\t\tdocElem.msMatchesSelector) )) ) {\n\
\n\
\t\tassert(function( div ) {\n\
\t\t\t// Check to see if it's possible to do matchesSelector\n\
\t\t\t// on a disconnected node (IE 9)\n\
\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\
\n\
\t\t\t// This should fail with an exception\n\
\t\t\t// Gecko does not error, returns false instead\n\
\t\t\tmatches.call( div, \"[s!='']:x\" );\n\
\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\
\t\t});\n\
\t}\n\
\n\
\trbuggyQSA = new RegExp( rbuggyQSA.join(\"|\") );\n\
\trbuggyMatches = new RegExp( rbuggyMatches.join(\"|\") );\n\
\n\
\t// Element contains another\n\
\t// Purposefully does not implement inclusive descendent\n\
\t// As in, an element does not contain itself\n\
\tcontains = isNative(docElem.contains) || docElem.compareDocumentPosition ?\n\
\t\tfunction( a, b ) {\n\
\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\
\t\t\t\tbup = b && b.parentNode;\n\
\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\
\t\t\t\tadown.contains ?\n\
\t\t\t\t\tadown.contains( bup ) :\n\
\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\
\t\t\t));\n\
\t\t} :\n\
\t\tfunction( a, b ) {\n\
\t\t\tif ( b ) {\n\
\t\t\t\twhile ( (b = b.parentNode) ) {\n\
\t\t\t\t\tif ( b === a ) {\n\
\t\t\t\t\t\treturn true;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t\treturn false;\n\
\t\t};\n\
\n\
\t// Document order sorting\n\
\tsortOrder = docElem.compareDocumentPosition ?\n\
\tfunction( a, b ) {\n\
\t\tvar compare;\n\
\n\
\t\tif ( a === b ) {\n\
\t\t\thasDuplicate = true;\n\
\t\t\treturn 0;\n\
\t\t}\n\
\n\
\t\tif ( (compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b )) ) {\n\
\t\t\tif ( compare & 1 || a.parentNode && a.parentNode.nodeType === 11 ) {\n\
\t\t\t\tif ( a === doc || contains( preferredDoc, a ) ) {\n\
\t\t\t\t\treturn -1;\n\
\t\t\t\t}\n\
\t\t\t\tif ( b === doc || contains( preferredDoc, b ) ) {\n\
\t\t\t\t\treturn 1;\n\
\t\t\t\t}\n\
\t\t\t\treturn 0;\n\
\t\t\t}\n\
\t\t\treturn compare & 4 ? -1 : 1;\n\
\t\t}\n\
\n\
\t\treturn a.compareDocumentPosition ? -1 : 1;\n\
\t} :\n\
\tfunction( a, b ) {\n\
\t\tvar cur,\n\
\t\t\ti = 0,\n\
\t\t\taup = a.parentNode,\n\
\t\t\tbup = b.parentNode,\n\
\t\t\tap = [ a ],\n\
\t\t\tbp = [ b ];\n\
\n\
\t\t// Exit early if the nodes are identical\n\
\t\tif ( a === b ) {\n\
\t\t\thasDuplicate = true;\n\
\t\t\treturn 0;\n\
\n\
\t\t// Parentless nodes are either documents or disconnected\n\
\t\t} else if ( !aup || !bup ) {\n\
\t\t\treturn a === doc ? -1 :\n\
\t\t\t\tb === doc ? 1 :\n\
\t\t\t\taup ? -1 :\n\
\t\t\t\tbup ? 1 :\n\
\t\t\t\t0;\n\
\n\
\t\t// If the nodes are siblings, we can do a quick check\n\
\t\t} else if ( aup === bup ) {\n\
\t\t\treturn siblingCheck( a, b );\n\
\t\t}\n\
\n\
\t\t// Otherwise we need full lists of their ancestors for comparison\n\
\t\tcur = a;\n\
\t\twhile ( (cur = cur.parentNode) ) {\n\
\t\t\tap.unshift( cur );\n\
\t\t}\n\
\t\tcur = b;\n\
\t\twhile ( (cur = cur.parentNode) ) {\n\
\t\t\tbp.unshift( cur );\n\
\t\t}\n\
\n\
\t\t// Walk down the tree looking for a discrepancy\n\
\t\twhile ( ap[i] === bp[i] ) {\n\
\t\t\ti++;\n\
\t\t}\n\
\n\
\t\treturn i ?\n\
\t\t\t// Do a sibling check if the nodes have a common ancestor\n\
\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\
\n\
\t\t\t// Otherwise nodes in our document sort first\n\
\t\t\tap[i] === preferredDoc ? -1 :\n\
\t\t\tbp[i] === preferredDoc ? 1 :\n\
\t\t\t0;\n\
\t};\n\
\n\
\t// Always assume the presence of duplicates if sort doesn't\n\
\t// pass them to our comparison function (as in Google Chrome).\n\
\thasDuplicate = false;\n\
\t[0, 0].sort( sortOrder );\n\
\tsupport.detectDuplicates = hasDuplicate;\n\
\n\
\treturn document;\n\
};\n\
\n\
Sizzle.matches = function( expr, elements ) {\n\
\treturn Sizzle( expr, null, null, elements );\n\
};\n\
\n\
Sizzle.matchesSelector = function( elem, expr ) {\n\
\t// Set document vars if needed\n\
\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\
\t\tsetDocument( elem );\n\
\t}\n\
\n\
\t// Make sure that attribute selectors are quoted\n\
\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\
\n\
\t// rbuggyQSA always contains :focus, so no need for an existence check\n\
\tif ( support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr) ) {\n\
\t\ttry {\n\
\t\t\tvar ret = matches.call( elem, expr );\n\
\n\
\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\
\t\t\tif ( ret || support.disconnectedMatch ||\n\
\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\
\t\t\t\t\t// fragment in IE 9\n\
\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\
\t\t\t\treturn ret;\n\
\t\t\t}\n\
\t\t} catch(e) {}\n\
\t}\n\
\n\
\treturn Sizzle( expr, document, null, [elem] ).length > 0;\n\
};\n\
\n\
Sizzle.contains = function( context, elem ) {\n\
\t// Set document vars if needed\n\
\tif ( ( context.ownerDocument || context ) !== document ) {\n\
\t\tsetDocument( context );\n\
\t}\n\
\treturn contains( context, elem );\n\
};\n\
\n\
Sizzle.attr = function( elem, name ) {\n\
\tvar val;\n\
\n\
\t// Set document vars if needed\n\
\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\
\t\tsetDocument( elem );\n\
\t}\n\
\n\
\tif ( !documentIsXML ) {\n\
\t\tname = name.toLowerCase();\n\
\t}\n\
\tif ( (val = Expr.attrHandle[ name ]) ) {\n\
\t\treturn val( elem );\n\
\t}\n\
\tif ( documentIsXML || support.attributes ) {\n\
\t\treturn elem.getAttribute( name );\n\
\t}\n\
\treturn ( (val = elem.getAttributeNode( name )) || elem.getAttribute( name ) ) && elem[ name ] === true ?\n\
\t\tname :\n\
\t\tval && val.specified ? val.value : null;\n\
};\n\
\n\
Sizzle.error = function( msg ) {\n\
\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n\
};\n\
\n\
// Document sorting and removing duplicates\n\
Sizzle.uniqueSort = function( results ) {\n\
\tvar elem,\n\
\t\tduplicates = [],\n\
\t\ti = 1,\n\
\t\tj = 0;\n\
\n\
\t// Unless we *know* we can detect duplicates, assume their presence\n\
\thasDuplicate = !support.detectDuplicates;\n\
\tresults.sort( sortOrder );\n\
\n\
\tif ( hasDuplicate ) {\n\
\t\tfor ( ; (elem = results[i]); i++ ) {\n\
\t\t\tif ( elem === results[ i - 1 ] ) {\n\
\t\t\t\tj = duplicates.push( i );\n\
\t\t\t}\n\
\t\t}\n\
\t\twhile ( j-- ) {\n\
\t\t\tresults.splice( duplicates[ j ], 1 );\n\
\t\t}\n\
\t}\n\
\n\
\treturn results;\n\
};\n\
\n\
function siblingCheck( a, b ) {\n\
\tvar cur = b && a,\n\
\t\tdiff = cur && ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE );\n\
\n\
\t// Use IE sourceIndex if available on both nodes\n\
\tif ( diff ) {\n\
\t\treturn diff;\n\
\t}\n\
\n\
\t// Check if b follows a\n\
\tif ( cur ) {\n\
\t\twhile ( (cur = cur.nextSibling) ) {\n\
\t\t\tif ( cur === b ) {\n\
\t\t\t\treturn -1;\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\treturn a ? 1 : -1;\n\
}\n\
\n\
// Returns a function to use in pseudos for input types\n\
function createInputPseudo( type ) {\n\
\treturn function( elem ) {\n\
\t\tvar name = elem.nodeName.toLowerCase();\n\
\t\treturn name === \"input\" && elem.type === type;\n\
\t};\n\
}\n\
\n\
// Returns a function to use in pseudos for buttons\n\
function createButtonPseudo( type ) {\n\
\treturn function( elem ) {\n\
\t\tvar name = elem.nodeName.toLowerCase();\n\
\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\
\t};\n\
}\n\
\n\
// Returns a function to use in pseudos for positionals\n\
function createPositionalPseudo( fn ) {\n\
\treturn markFunction(function( argument ) {\n\
\t\targument = +argument;\n\
\t\treturn markFunction(function( seed, matches ) {\n\
\t\t\tvar j,\n\
\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\
\t\t\t\ti = matchIndexes.length;\n\
\n\
\t\t\t// Match elements found at the specified indexes\n\
\t\t\twhile ( i-- ) {\n\
\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\
\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t});\n\
\t});\n\
}\n\
\n\
/**\n\
 * Utility function for retrieving the text value of an array of DOM nodes\n\
 * @param {Array|Element} elem\n\
 */\n\
getText = Sizzle.getText = function( elem ) {\n\
\tvar node,\n\
\t\tret = \"\",\n\
\t\ti = 0,\n\
\t\tnodeType = elem.nodeType;\n\
\n\
\tif ( !nodeType ) {\n\
\t\t// If no nodeType, this is expected to be an array\n\
\t\tfor ( ; (node = elem[i]); i++ ) {\n\
\t\t\t// Do not traverse comment nodes\n\
\t\t\tret += getText( node );\n\
\t\t}\n\
\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\
\t\t// Use textContent for elements\n\
\t\t// innerText usage removed for consistency of new lines (see #11153)\n\
\t\tif ( typeof elem.textContent === \"string\" ) {\n\
\t\t\treturn elem.textContent;\n\
\t\t} else {\n\
\t\t\t// Traverse its children\n\
\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\
\t\t\t\tret += getText( elem );\n\
\t\t\t}\n\
\t\t}\n\
\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\
\t\treturn elem.nodeValue;\n\
\t}\n\
\t// Do not include comment or processing instruction nodes\n\
\n\
\treturn ret;\n\
};\n\
\n\
Expr = Sizzle.selectors = {\n\
\n\
\t// Can be adjusted by the user\n\
\tcacheLength: 50,\n\
\n\
\tcreatePseudo: markFunction,\n\
\n\
\tmatch: matchExpr,\n\
\n\
\tfind: {},\n\
\n\
\trelative: {\n\
\t\t\">\": { dir: \"parentNode\", first: true },\n\
\t\t\" \": { dir: \"parentNode\" },\n\
\t\t\"+\": { dir: \"previousSibling\", first: true },\n\
\t\t\"~\": { dir: \"previousSibling\" }\n\
\t},\n\
\n\
\tpreFilter: {\n\
\t\t\"ATTR\": function( match ) {\n\
\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\
\n\
\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\
\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\
\n\
\t\t\tif ( match[2] === \"~=\" ) {\n\
\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\
\t\t\t}\n\
\n\
\t\t\treturn match.slice( 0, 4 );\n\
\t\t},\n\
\n\
\t\t\"CHILD\": function( match ) {\n\
\t\t\t/* matches from matchExpr[\"CHILD\"]\n\
\t\t\t\t1 type (only|nth|...)\n\
\t\t\t\t2 what (child|of-type)\n\
\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\
\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\
\t\t\t\t5 sign of xn-component\n\
\t\t\t\t6 x of xn-component\n\
\t\t\t\t7 sign of y-component\n\
\t\t\t\t8 y of y-component\n\
\t\t\t*/\n\
\t\t\tmatch[1] = match[1].toLowerCase();\n\
\n\
\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\
\t\t\t\t// nth-* requires argument\n\
\t\t\t\tif ( !match[3] ) {\n\
\t\t\t\t\tSizzle.error( match[0] );\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\
\t\t\t\t// remember that false/true cast respectively to 0/1\n\
\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\
\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\
\n\
\t\t\t// other types prohibit arguments\n\
\t\t\t} else if ( match[3] ) {\n\
\t\t\t\tSizzle.error( match[0] );\n\
\t\t\t}\n\
\n\
\t\t\treturn match;\n\
\t\t},\n\
\n\
\t\t\"PSEUDO\": function( match ) {\n\
\t\t\tvar excess,\n\
\t\t\t\tunquoted = !match[5] && match[2];\n\
\n\
\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\
\t\t\t\treturn null;\n\
\t\t\t}\n\
\n\
\t\t\t// Accept quoted arguments as-is\n\
\t\t\tif ( match[4] ) {\n\
\t\t\t\tmatch[2] = match[4];\n\
\n\
\t\t\t// Strip excess characters from unquoted arguments\n\
\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\
\t\t\t\t// Get excess from tokenize (recursively)\n\
\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\
\t\t\t\t// advance to the next closing parenthesis\n\
\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\
\n\
\t\t\t\t// excess is a negative index\n\
\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\
\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\
\t\t\t}\n\
\n\
\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\
\t\t\treturn match.slice( 0, 3 );\n\
\t\t}\n\
\t},\n\
\n\
\tfilter: {\n\
\n\
\t\t\"TAG\": function( nodeName ) {\n\
\t\t\tif ( nodeName === \"*\" ) {\n\
\t\t\t\treturn function() { return true; };\n\
\t\t\t}\n\
\n\
\t\t\tnodeName = nodeName.replace( runescape, funescape ).toLowerCase();\n\
\t\t\treturn function( elem ) {\n\
\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\
\t\t\t};\n\
\t\t},\n\
\n\
\t\t\"CLASS\": function( className ) {\n\
\t\t\tvar pattern = classCache[ className + \" \" ];\n\
\n\
\t\t\treturn pattern ||\n\
\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\
\t\t\t\tclassCache( className, function( elem ) {\n\
\t\t\t\t\treturn pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\")) || \"\" );\n\
\t\t\t\t});\n\
\t\t},\n\
\n\
\t\t\"ATTR\": function( name, operator, check ) {\n\
\t\t\treturn function( elem ) {\n\
\t\t\t\tvar result = Sizzle.attr( elem, name );\n\
\n\
\t\t\t\tif ( result == null ) {\n\
\t\t\t\t\treturn operator === \"!=\";\n\
\t\t\t\t}\n\
\t\t\t\tif ( !operator ) {\n\
\t\t\t\t\treturn true;\n\
\t\t\t\t}\n\
\n\
\t\t\t\tresult += \"\";\n\
\n\
\t\t\t\treturn operator === \"=\" ? result === check :\n\
\t\t\t\t\toperator === \"!=\" ? result !== check :\n\
\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\
\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\
\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\
\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n\
\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\
\t\t\t\t\tfalse;\n\
\t\t\t};\n\
\t\t},\n\
\n\
\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\
\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\
\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\
\t\t\t\tofType = what === \"of-type\";\n\
\n\
\t\t\treturn first === 1 && last === 0 ?\n\
\n\
\t\t\t\t// Shortcut for :nth-*(n)\n\
\t\t\t\tfunction( elem ) {\n\
\t\t\t\t\treturn !!elem.parentNode;\n\
\t\t\t\t} :\n\
\n\
\t\t\t\tfunction( elem, context, xml ) {\n\
\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\
\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\
\t\t\t\t\t\tparent = elem.parentNode,\n\
\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\
\t\t\t\t\t\tuseCache = !xml && !ofType;\n\
\n\
\t\t\t\t\tif ( parent ) {\n\
\n\
\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\
\t\t\t\t\t\tif ( simple ) {\n\
\t\t\t\t\t\t\twhile ( dir ) {\n\
\t\t\t\t\t\t\t\tnode = elem;\n\
\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\
\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\
\t\t\t\t\t\t\t\t\t\treturn false;\n\
\t\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\
\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\treturn true;\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\
\n\
\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\
\t\t\t\t\t\tif ( forward && useCache ) {\n\
\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\
\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\
\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\
\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\
\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\
\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\
\n\
\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\
\n\
\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\
\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\
\n\
\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\
\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\
\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\
\t\t\t\t\t\t\t\t\tbreak;\n\
\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t// Use previously-cached element index if available\n\
\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\
\t\t\t\t\t\t\tdiff = cache[1];\n\
\n\
\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\
\t\t\t\t\t\t} else {\n\
\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\
\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\
\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\
\n\
\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\
\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\
\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\
\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\
\t\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\
\t\t\t\t\t\t\t\t\t\tbreak;\n\
\t\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\
\t\t\t\t\t\tdiff -= last;\n\
\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\
\t\t\t\t\t}\n\
\t\t\t\t};\n\
\t\t},\n\
\n\
\t\t\"PSEUDO\": function( pseudo, argument ) {\n\
\t\t\t// pseudo-class names are case-insensitive\n\
\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\
\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\
\t\t\t// Remember that setFilters inherits from pseudos\n\
\t\t\tvar args,\n\
\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\
\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\
\n\
\t\t\t// The user may use createPseudo to indicate that\n\
\t\t\t// arguments are needed to create the filter function\n\
\t\t\t// just as Sizzle does\n\
\t\t\tif ( fn[ expando ] ) {\n\
\t\t\t\treturn fn( argument );\n\
\t\t\t}\n\
\n\
\t\t\t// But maintain support for old signatures\n\
\t\t\tif ( fn.length > 1 ) {\n\
\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\
\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\
\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\
\t\t\t\t\t\tvar idx,\n\
\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\
\t\t\t\t\t\t\ti = matched.length;\n\
\t\t\t\t\t\twhile ( i-- ) {\n\
\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\n\
\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}) :\n\
\t\t\t\t\tfunction( elem ) {\n\
\t\t\t\t\t\treturn fn( elem, 0, args );\n\
\t\t\t\t\t};\n\
\t\t\t}\n\
\n\
\t\t\treturn fn;\n\
\t\t}\n\
\t},\n\
\n\
\tpseudos: {\n\
\t\t// Potentially complex pseudos\n\
\t\t\"not\": markFunction(function( selector ) {\n\
\t\t\t// Trim the selector passed to compile\n\
\t\t\t// to avoid treating leading and trailing\n\
\t\t\t// spaces as combinators\n\
\t\t\tvar input = [],\n\
\t\t\t\tresults = [],\n\
\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\
\n\
\t\t\treturn matcher[ expando ] ?\n\
\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\
\t\t\t\t\tvar elem,\n\
\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\
\t\t\t\t\t\ti = seed.length;\n\
\n\
\t\t\t\t\t// Match elements unmatched by `matcher`\n\
\t\t\t\t\twhile ( i-- ) {\n\
\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\
\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t}) :\n\
\t\t\t\tfunction( elem, context, xml ) {\n\
\t\t\t\t\tinput[0] = elem;\n\
\t\t\t\t\tmatcher( input, null, xml, results );\n\
\t\t\t\t\treturn !results.pop();\n\
\t\t\t\t};\n\
\t\t}),\n\
\n\
\t\t\"has\": markFunction(function( selector ) {\n\
\t\t\treturn function( elem ) {\n\
\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\
\t\t\t};\n\
\t\t}),\n\
\n\
\t\t\"contains\": markFunction(function( text ) {\n\
\t\t\treturn function( elem ) {\n\
\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\
\t\t\t};\n\
\t\t}),\n\
\n\
\t\t// \"Whether an element is represented by a :lang() selector\n\
\t\t// is based solely on the element's language value\n\
\t\t// being equal to the identifier C,\n\
\t\t// or beginning with the identifier C immediately followed by \"-\".\n\
\t\t// The matching of C against the element's language value is performed case-insensitively.\n\
\t\t// The identifier C does not have to be a valid language name.\"\n\
\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\
\t\t\"lang\": markFunction( function( lang ) {\n\
\t\t\t// lang value must be a valid identifider\n\
\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\
\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\
\t\t\t}\n\
\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\
\t\t\treturn function( elem ) {\n\
\t\t\t\tvar elemLang;\n\
\t\t\t\tdo {\n\
\t\t\t\t\tif ( (elemLang = documentIsXML ?\n\
\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\") :\n\
\t\t\t\t\t\telem.lang) ) {\n\
\n\
\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\
\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\
\t\t\t\t\t}\n\
\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\
\t\t\t\treturn false;\n\
\t\t\t};\n\
\t\t}),\n\
\n\
\t\t// Miscellaneous\n\
\t\t\"target\": function( elem ) {\n\
\t\t\tvar hash = window.location && window.location.hash;\n\
\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\
\t\t},\n\
\n\
\t\t\"root\": function( elem ) {\n\
\t\t\treturn elem === docElem;\n\
\t\t},\n\
\n\
\t\t\"focus\": function( elem ) {\n\
\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\
\t\t},\n\
\n\
\t\t// Boolean properties\n\
\t\t\"enabled\": function( elem ) {\n\
\t\t\treturn elem.disabled === false;\n\
\t\t},\n\
\n\
\t\t\"disabled\": function( elem ) {\n\
\t\t\treturn elem.disabled === true;\n\
\t\t},\n\
\n\
\t\t\"checked\": function( elem ) {\n\
\t\t\t// In CSS3, :checked should return both checked and selected elements\n\
\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\
\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\
\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\
\t\t},\n\
\n\
\t\t\"selected\": function( elem ) {\n\
\t\t\t// Accessing this property makes selected-by-default\n\
\t\t\t// options in Safari work properly\n\
\t\t\tif ( elem.parentNode ) {\n\
\t\t\t\telem.parentNode.selectedIndex;\n\
\t\t\t}\n\
\n\
\t\t\treturn elem.selected === true;\n\
\t\t},\n\
\n\
\t\t// Contents\n\
\t\t\"empty\": function( elem ) {\n\
\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\
\t\t\t// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\n\
\t\t\t//   not comment, processing instructions, or others\n\
\t\t\t// Thanks to Diego Perini for the nodeName shortcut\n\
\t\t\t//   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\n\
\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\
\t\t\t\tif ( elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4 ) {\n\
\t\t\t\t\treturn false;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t\treturn true;\n\
\t\t},\n\
\n\
\t\t\"parent\": function( elem ) {\n\
\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\
\t\t},\n\
\n\
\t\t// Element/input types\n\
\t\t\"header\": function( elem ) {\n\
\t\t\treturn rheader.test( elem.nodeName );\n\
\t\t},\n\
\n\
\t\t\"input\": function( elem ) {\n\
\t\t\treturn rinputs.test( elem.nodeName );\n\
\t\t},\n\
\n\
\t\t\"button\": function( elem ) {\n\
\t\t\tvar name = elem.nodeName.toLowerCase();\n\
\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\
\t\t},\n\
\n\
\t\t\"text\": function( elem ) {\n\
\t\t\tvar attr;\n\
\t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n\
\t\t\t// use getAttribute instead to test this case\n\
\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\
\t\t\t\telem.type === \"text\" &&\n\
\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type );\n\
\t\t},\n\
\n\
\t\t// Position-in-collection\n\
\t\t\"first\": createPositionalPseudo(function() {\n\
\t\t\treturn [ 0 ];\n\
\t\t}),\n\
\n\
\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\
\t\t\treturn [ length - 1 ];\n\
\t\t}),\n\
\n\
\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\
\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\
\t\t}),\n\
\n\
\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\
\t\t\tvar i = 0;\n\
\t\t\tfor ( ; i < length; i += 2 ) {\n\
\t\t\t\tmatchIndexes.push( i );\n\
\t\t\t}\n\
\t\t\treturn matchIndexes;\n\
\t\t}),\n\
\n\
\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\
\t\t\tvar i = 1;\n\
\t\t\tfor ( ; i < length; i += 2 ) {\n\
\t\t\t\tmatchIndexes.push( i );\n\
\t\t\t}\n\
\t\t\treturn matchIndexes;\n\
\t\t}),\n\
\n\
\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\
\t\t\tvar i = argument < 0 ? argument + length : argument;\n\
\t\t\tfor ( ; --i >= 0; ) {\n\
\t\t\t\tmatchIndexes.push( i );\n\
\t\t\t}\n\
\t\t\treturn matchIndexes;\n\
\t\t}),\n\
\n\
\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\
\t\t\tvar i = argument < 0 ? argument + length : argument;\n\
\t\t\tfor ( ; ++i < length; ) {\n\
\t\t\t\tmatchIndexes.push( i );\n\
\t\t\t}\n\
\t\t\treturn matchIndexes;\n\
\t\t})\n\
\t}\n\
};\n\
\n\
// Add button/input type pseudos\n\
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\
\tExpr.pseudos[ i ] = createInputPseudo( i );\n\
}\n\
for ( i in { submit: true, reset: true } ) {\n\
\tExpr.pseudos[ i ] = createButtonPseudo( i );\n\
}\n\
\n\
function tokenize( selector, parseOnly ) {\n\
\tvar matched, match, tokens, type,\n\
\t\tsoFar, groups, preFilters,\n\
\t\tcached = tokenCache[ selector + \" \" ];\n\
\n\
\tif ( cached ) {\n\
\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\
\t}\n\
\n\
\tsoFar = selector;\n\
\tgroups = [];\n\
\tpreFilters = Expr.preFilter;\n\
\n\
\twhile ( soFar ) {\n\
\n\
\t\t// Comma and first run\n\
\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\
\t\t\tif ( match ) {\n\
\t\t\t\t// Don't consume trailing commas as valid\n\
\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\
\t\t\t}\n\
\t\t\tgroups.push( tokens = [] );\n\
\t\t}\n\
\n\
\t\tmatched = false;\n\
\n\
\t\t// Combinators\n\
\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\
\t\t\tmatched = match.shift();\n\
\t\t\ttokens.push( {\n\
\t\t\t\tvalue: matched,\n\
\t\t\t\t// Cast descendant combinators to space\n\
\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\
\t\t\t} );\n\
\t\t\tsoFar = soFar.slice( matched.length );\n\
\t\t}\n\
\n\
\t\t// Filters\n\
\t\tfor ( type in Expr.filter ) {\n\
\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\
\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\
\t\t\t\tmatched = match.shift();\n\
\t\t\t\ttokens.push( {\n\
\t\t\t\t\tvalue: matched,\n\
\t\t\t\t\ttype: type,\n\
\t\t\t\t\tmatches: match\n\
\t\t\t\t} );\n\
\t\t\t\tsoFar = soFar.slice( matched.length );\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\tif ( !matched ) {\n\
\t\t\tbreak;\n\
\t\t}\n\
\t}\n\
\n\
\t// Return the length of the invalid excess\n\
\t// if we're just parsing\n\
\t// Otherwise, throw an error or return tokens\n\
\treturn parseOnly ?\n\
\t\tsoFar.length :\n\
\t\tsoFar ?\n\
\t\t\tSizzle.error( selector ) :\n\
\t\t\t// Cache the tokens\n\
\t\t\ttokenCache( selector, groups ).slice( 0 );\n\
}\n\
\n\
function toSelector( tokens ) {\n\
\tvar i = 0,\n\
\t\tlen = tokens.length,\n\
\t\tselector = \"\";\n\
\tfor ( ; i < len; i++ ) {\n\
\t\tselector += tokens[i].value;\n\
\t}\n\
\treturn selector;\n\
}\n\
\n\
function addCombinator( matcher, combinator, base ) {\n\
\tvar dir = combinator.dir,\n\
\t\tcheckNonElements = base && dir === \"parentNode\",\n\
\t\tdoneName = done++;\n\
\n\
\treturn combinator.first ?\n\
\t\t// Check against closest ancestor/preceding element\n\
\t\tfunction( elem, context, xml ) {\n\
\t\t\twhile ( (elem = elem[ dir ]) ) {\n\
\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\
\t\t\t\t\treturn matcher( elem, context, xml );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t} :\n\
\n\
\t\t// Check against all ancestor/preceding elements\n\
\t\tfunction( elem, context, xml ) {\n\
\t\t\tvar data, cache, outerCache,\n\
\t\t\t\tdirkey = dirruns + \" \" + doneName;\n\
\n\
\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\
\t\t\tif ( xml ) {\n\
\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\
\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\
\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\
\t\t\t\t\t\t\treturn true;\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t} else {\n\
\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\
\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\
\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\
\t\t\t\t\t\tif ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {\n\
\t\t\t\t\t\t\tif ( (data = cache[1]) === true || data === cachedruns ) {\n\
\t\t\t\t\t\t\t\treturn data === true;\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t} else {\n\
\t\t\t\t\t\t\tcache = outerCache[ dir ] = [ dirkey ];\n\
\t\t\t\t\t\t\tcache[1] = matcher( elem, context, xml ) || cachedruns;\n\
\t\t\t\t\t\t\tif ( cache[1] === true ) {\n\
\t\t\t\t\t\t\t\treturn true;\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t};\n\
}\n\
\n\
function elementMatcher( matchers ) {\n\
\treturn matchers.length > 1 ?\n\
\t\tfunction( elem, context, xml ) {\n\
\t\t\tvar i = matchers.length;\n\
\t\t\twhile ( i-- ) {\n\
\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\
\t\t\t\t\treturn false;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t\treturn true;\n\
\t\t} :\n\
\t\tmatchers[0];\n\
}\n\
\n\
function condense( unmatched, map, filter, context, xml ) {\n\
\tvar elem,\n\
\t\tnewUnmatched = [],\n\
\t\ti = 0,\n\
\t\tlen = unmatched.length,\n\
\t\tmapped = map != null;\n\
\n\
\tfor ( ; i < len; i++ ) {\n\
\t\tif ( (elem = unmatched[i]) ) {\n\
\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\
\t\t\t\tnewUnmatched.push( elem );\n\
\t\t\t\tif ( mapped ) {\n\
\t\t\t\t\tmap.push( i );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\treturn newUnmatched;\n\
}\n\
\n\
function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\
\tif ( postFilter && !postFilter[ expando ] ) {\n\
\t\tpostFilter = setMatcher( postFilter );\n\
\t}\n\
\tif ( postFinder && !postFinder[ expando ] ) {\n\
\t\tpostFinder = setMatcher( postFinder, postSelector );\n\
\t}\n\
\treturn markFunction(function( seed, results, context, xml ) {\n\
\t\tvar temp, i, elem,\n\
\t\t\tpreMap = [],\n\
\t\t\tpostMap = [],\n\
\t\t\tpreexisting = results.length,\n\
\n\
\t\t\t// Get initial elements from seed or context\n\
\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\
\n\
\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\
\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\
\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\
\t\t\t\telems,\n\
\n\
\t\t\tmatcherOut = matcher ?\n\
\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\
\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\
\n\
\t\t\t\t\t// ...intermediate processing is necessary\n\
\t\t\t\t\t[] :\n\
\n\
\t\t\t\t\t// ...otherwise use results directly\n\
\t\t\t\t\tresults :\n\
\t\t\t\tmatcherIn;\n\
\n\
\t\t// Find primary matches\n\
\t\tif ( matcher ) {\n\
\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\
\t\t}\n\
\n\
\t\t// Apply postFilter\n\
\t\tif ( postFilter ) {\n\
\t\t\ttemp = condense( matcherOut, postMap );\n\
\t\t\tpostFilter( temp, [], context, xml );\n\
\n\
\t\t\t// Un-match failing elements by moving them back to matcherIn\n\
\t\t\ti = temp.length;\n\
\t\t\twhile ( i-- ) {\n\
\t\t\t\tif ( (elem = temp[i]) ) {\n\
\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\tif ( seed ) {\n\
\t\t\tif ( postFinder || preFilter ) {\n\
\t\t\t\tif ( postFinder ) {\n\
\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\
\t\t\t\t\ttemp = [];\n\
\t\t\t\t\ti = matcherOut.length;\n\
\t\t\t\t\twhile ( i-- ) {\n\
\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\
\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\
\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\
\t\t\t\ti = matcherOut.length;\n\
\t\t\t\twhile ( i-- ) {\n\
\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\
\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\
\n\
\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t// Add elements to results, through postFinder if defined\n\
\t\t} else {\n\
\t\t\tmatcherOut = condense(\n\
\t\t\t\tmatcherOut === results ?\n\
\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\
\t\t\t\t\tmatcherOut\n\
\t\t\t);\n\
\t\t\tif ( postFinder ) {\n\
\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\
\t\t\t} else {\n\
\t\t\t\tpush.apply( results, matcherOut );\n\
\t\t\t}\n\
\t\t}\n\
\t});\n\
}\n\
\n\
function matcherFromTokens( tokens ) {\n\
\tvar checkContext, matcher, j,\n\
\t\tlen = tokens.length,\n\
\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\
\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\
\t\ti = leadingRelative ? 1 : 0,\n\
\n\
\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\
\t\tmatchContext = addCombinator( function( elem ) {\n\
\t\t\treturn elem === checkContext;\n\
\t\t}, implicitRelative, true ),\n\
\t\tmatchAnyContext = addCombinator( function( elem ) {\n\
\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n\
\t\t}, implicitRelative, true ),\n\
\t\tmatchers = [ function( elem, context, xml ) {\n\
\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\
\t\t\t\t(checkContext = context).nodeType ?\n\
\t\t\t\t\tmatchContext( elem, context, xml ) :\n\
\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\
\t\t} ];\n\
\n\
\tfor ( ; i < len; i++ ) {\n\
\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\
\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\
\t\t} else {\n\
\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\
\n\
\t\t\t// Return special upon seeing a positional matcher\n\
\t\t\tif ( matcher[ expando ] ) {\n\
\t\t\t\t// Find the next relative operator (if any) for proper handling\n\
\t\t\t\tj = ++i;\n\
\t\t\t\tfor ( ; j < len; j++ ) {\n\
\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\
\t\t\t\t\t\tbreak;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t\treturn setMatcher(\n\
\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\
\t\t\t\t\ti > 1 && toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, \"$1\" ),\n\
\t\t\t\t\tmatcher,\n\
\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\
\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\
\t\t\t\t\tj < len && toSelector( tokens )\n\
\t\t\t\t);\n\
\t\t\t}\n\
\t\t\tmatchers.push( matcher );\n\
\t\t}\n\
\t}\n\
\n\
\treturn elementMatcher( matchers );\n\
}\n\
\n\
function matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\
\t// A counter to specify which element is currently being matched\n\
\tvar matcherCachedRuns = 0,\n\
\t\tbySet = setMatchers.length > 0,\n\
\t\tbyElement = elementMatchers.length > 0,\n\
\t\tsuperMatcher = function( seed, context, xml, results, expandContext ) {\n\
\t\t\tvar elem, j, matcher,\n\
\t\t\t\tsetMatched = [],\n\
\t\t\t\tmatchedCount = 0,\n\
\t\t\t\ti = \"0\",\n\
\t\t\t\tunmatched = seed && [],\n\
\t\t\t\toutermost = expandContext != null,\n\
\t\t\t\tcontextBackup = outermostContext,\n\
\t\t\t\t// We must always have either seed elements or context\n\
\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", expandContext && context.parentNode || context ),\n\
\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\
\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);\n\
\n\
\t\t\tif ( outermost ) {\n\
\t\t\t\toutermostContext = context !== document && context;\n\
\t\t\t\tcachedruns = matcherCachedRuns;\n\
\t\t\t}\n\
\n\
\t\t\t// Add elements passing elementMatchers directly to results\n\
\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\
\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\
\t\t\t\tif ( byElement && elem ) {\n\
\t\t\t\t\tj = 0;\n\
\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\
\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\
\t\t\t\t\t\t\tresults.push( elem );\n\
\t\t\t\t\t\t\tbreak;\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t\tif ( outermost ) {\n\
\t\t\t\t\t\tdirruns = dirrunsUnique;\n\
\t\t\t\t\t\tcachedruns = ++matcherCachedRuns;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// Track unmatched elements for set filters\n\
\t\t\t\tif ( bySet ) {\n\
\t\t\t\t\t// They will have gone through all possible matchers\n\
\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\
\t\t\t\t\t\tmatchedCount--;\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Lengthen the array for every element, matched or not\n\
\t\t\t\t\tif ( seed ) {\n\
\t\t\t\t\t\tunmatched.push( elem );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\t// Apply set filters to unmatched elements\n\
\t\t\tmatchedCount += i;\n\
\t\t\tif ( bySet && i !== matchedCount ) {\n\
\t\t\t\tj = 0;\n\
\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\
\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( seed ) {\n\
\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\
\t\t\t\t\tif ( matchedCount > 0 ) {\n\
\t\t\t\t\t\twhile ( i-- ) {\n\
\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\
\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\
\t\t\t\t\tsetMatched = condense( setMatched );\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// Add matches to results\n\
\t\t\t\tpush.apply( results, setMatched );\n\
\n\
\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\
\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\
\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\
\n\
\t\t\t\t\tSizzle.uniqueSort( results );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\t// Override manipulation of globals by nested matchers\n\
\t\t\tif ( outermost ) {\n\
\t\t\t\tdirruns = dirrunsUnique;\n\
\t\t\t\toutermostContext = contextBackup;\n\
\t\t\t}\n\
\n\
\t\t\treturn unmatched;\n\
\t\t};\n\
\n\
\treturn bySet ?\n\
\t\tmarkFunction( superMatcher ) :\n\
\t\tsuperMatcher;\n\
}\n\
\n\
compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\n\
\tvar i,\n\
\t\tsetMatchers = [],\n\
\t\telementMatchers = [],\n\
\t\tcached = compilerCache[ selector + \" \" ];\n\
\n\
\tif ( !cached ) {\n\
\t\t// Generate a function of recursive functions that can be used to check each element\n\
\t\tif ( !group ) {\n\
\t\t\tgroup = tokenize( selector );\n\
\t\t}\n\
\t\ti = group.length;\n\
\t\twhile ( i-- ) {\n\
\t\t\tcached = matcherFromTokens( group[i] );\n\
\t\t\tif ( cached[ expando ] ) {\n\
\t\t\t\tsetMatchers.push( cached );\n\
\t\t\t} else {\n\
\t\t\t\telementMatchers.push( cached );\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Cache the compiled function\n\
\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\
\t}\n\
\treturn cached;\n\
};\n\
\n\
function multipleContexts( selector, contexts, results ) {\n\
\tvar i = 0,\n\
\t\tlen = contexts.length;\n\
\tfor ( ; i < len; i++ ) {\n\
\t\tSizzle( selector, contexts[i], results );\n\
\t}\n\
\treturn results;\n\
}\n\
\n\
function select( selector, context, results, seed ) {\n\
\tvar i, tokens, token, type, find,\n\
\t\tmatch = tokenize( selector );\n\
\n\
\tif ( !seed ) {\n\
\t\t// Try to minimize operations if there is only one group\n\
\t\tif ( match.length === 1 ) {\n\
\n\
\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\
\t\t\ttokens = match[0] = match[0].slice( 0 );\n\
\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\
\t\t\t\t\tcontext.nodeType === 9 && !documentIsXML &&\n\
\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\
\n\
\t\t\t\tcontext = Expr.find[\"ID\"]( token.matches[0].replace( runescape, funescape ), context )[0];\n\
\t\t\t\tif ( !context ) {\n\
\t\t\t\t\treturn results;\n\
\t\t\t\t}\n\
\n\
\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\
\t\t\t}\n\
\n\
\t\t\t// Fetch a seed set for right-to-left matching\n\
\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\
\t\t\twhile ( i-- ) {\n\
\t\t\t\ttoken = tokens[i];\n\
\n\
\t\t\t\t// Abort if we hit a combinator\n\
\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\
\t\t\t\t\tbreak;\n\
\t\t\t\t}\n\
\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\
\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\
\t\t\t\t\tif ( (seed = find(\n\
\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\
\t\t\t\t\t\trsibling.test( tokens[0].type ) && context.parentNode || context\n\
\t\t\t\t\t)) ) {\n\
\n\
\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\
\t\t\t\t\t\ttokens.splice( i, 1 );\n\
\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\
\t\t\t\t\t\tif ( !selector ) {\n\
\t\t\t\t\t\t\tpush.apply( results, slice.call( seed, 0 ) );\n\
\t\t\t\t\t\t\treturn results;\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tbreak;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\t// Compile and execute a filtering function\n\
\t// Provide `match` to avoid retokenization if we modified the selector above\n\
\tcompile( selector, match )(\n\
\t\tseed,\n\
\t\tcontext,\n\
\t\tdocumentIsXML,\n\
\t\tresults,\n\
\t\trsibling.test( selector )\n\
\t);\n\
\treturn results;\n\
}\n\
\n\
// Deprecated\n\
Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\
\n\
// Easy API for creating new setFilters\n\
function setFilters() {}\n\
Expr.filters = setFilters.prototype = Expr.pseudos;\n\
Expr.setFilters = new setFilters();\n\
\n\
// Initialize with the default document\n\
setDocument();\n\
\n\
// Override sizzle attribute retrieval\n\
Sizzle.attr = jQuery.attr;\n\
jQuery.find = Sizzle;\n\
jQuery.expr = Sizzle.selectors;\n\
jQuery.expr[\":\"] = jQuery.expr.pseudos;\n\
jQuery.unique = Sizzle.uniqueSort;\n\
jQuery.text = Sizzle.getText;\n\
jQuery.isXMLDoc = Sizzle.isXML;\n\
jQuery.contains = Sizzle.contains;\n\
\n\
\n\
})( window );\n\
var runtil = /Until$/,\n\
\trparentsprev = /^(?:parents|prev(?:Until|All))/,\n\
\tisSimple = /^.[^:#\\[\\.,]*$/,\n\
\trneedsContext = jQuery.expr.match.needsContext,\n\
\t// methods guaranteed to produce a unique set when starting from a unique set\n\
\tguaranteedUnique = {\n\
\t\tchildren: true,\n\
\t\tcontents: true,\n\
\t\tnext: true,\n\
\t\tprev: true\n\
\t};\n\
\n\
jQuery.fn.extend({\n\
\tfind: function( selector ) {\n\
\t\tvar i, ret, self,\n\
\t\t\tlen = this.length;\n\
\n\
\t\tif ( typeof selector !== \"string\" ) {\n\
\t\t\tself = this;\n\
\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\
\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\
\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\
\t\t\t\t\t\treturn true;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}) );\n\
\t\t}\n\
\n\
\t\tret = [];\n\
\t\tfor ( i = 0; i < len; i++ ) {\n\
\t\t\tjQuery.find( selector, this[ i ], ret );\n\
\t\t}\n\
\n\
\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\
\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\
\t\tret.selector = ( this.selector ? this.selector + \" \" : \"\" ) + selector;\n\
\t\treturn ret;\n\
\t},\n\
\n\
\thas: function( target ) {\n\
\t\tvar i,\n\
\t\t\ttargets = jQuery( target, this ),\n\
\t\t\tlen = targets.length;\n\
\n\
\t\treturn this.filter(function() {\n\
\t\t\tfor ( i = 0; i < len; i++ ) {\n\
\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\
\t\t\t\t\treturn true;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t});\n\
\t},\n\
\n\
\tnot: function( selector ) {\n\
\t\treturn this.pushStack( winnow(this, selector, false) );\n\
\t},\n\
\n\
\tfilter: function( selector ) {\n\
\t\treturn this.pushStack( winnow(this, selector, true) );\n\
\t},\n\
\n\
\tis: function( selector ) {\n\
\t\treturn !!selector && (\n\
\t\t\ttypeof selector === \"string\" ?\n\
\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\
\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\
\t\t\t\trneedsContext.test( selector ) ?\n\
\t\t\t\t\tjQuery( selector, this.context ).index( this[0] ) >= 0 :\n\
\t\t\t\t\tjQuery.filter( selector, this ).length > 0 :\n\
\t\t\t\tthis.filter( selector ).length > 0 );\n\
\t},\n\
\n\
\tclosest: function( selectors, context ) {\n\
\t\tvar cur,\n\
\t\t\ti = 0,\n\
\t\t\tl = this.length,\n\
\t\t\tret = [],\n\
\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\
\t\t\t\tjQuery( selectors, context || this.context ) :\n\
\t\t\t\t0;\n\
\n\
\t\tfor ( ; i < l; i++ ) {\n\
\t\t\tcur = this[i];\n\
\n\
\t\t\twhile ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {\n\
\t\t\t\tif ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {\n\
\t\t\t\t\tret.push( cur );\n\
\t\t\t\t\tbreak;\n\
\t\t\t\t}\n\
\t\t\t\tcur = cur.parentNode;\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );\n\
\t},\n\
\n\
\t// Determine the position of an element within\n\
\t// the matched set of elements\n\
\tindex: function( elem ) {\n\
\n\
\t\t// No argument, return index in parent\n\
\t\tif ( !elem ) {\n\
\t\t\treturn ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;\n\
\t\t}\n\
\n\
\t\t// index in selector\n\
\t\tif ( typeof elem === \"string\" ) {\n\
\t\t\treturn jQuery.inArray( this[0], jQuery( elem ) );\n\
\t\t}\n\
\n\
\t\t// Locate the position of the desired element\n\
\t\treturn jQuery.inArray(\n\
\t\t\t// If it receives a jQuery object, the first element is used\n\
\t\t\telem.jquery ? elem[0] : elem, this );\n\
\t},\n\
\n\
\tadd: function( selector, context ) {\n\
\t\tvar set = typeof selector === \"string\" ?\n\
\t\t\t\tjQuery( selector, context ) :\n\
\t\t\t\tjQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\n\
\t\t\tall = jQuery.merge( this.get(), set );\n\
\n\
\t\treturn this.pushStack( jQuery.unique(all) );\n\
\t},\n\
\n\
\taddBack: function( selector ) {\n\
\t\treturn this.add( selector == null ?\n\
\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\
\t\t);\n\
\t}\n\
});\n\
\n\
jQuery.fn.andSelf = jQuery.fn.addBack;\n\
\n\
function sibling( cur, dir ) {\n\
\tdo {\n\
\t\tcur = cur[ dir ];\n\
\t} while ( cur && cur.nodeType !== 1 );\n\
\n\
\treturn cur;\n\
}\n\
\n\
jQuery.each({\n\
\tparent: function( elem ) {\n\
\t\tvar parent = elem.parentNode;\n\
\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\
\t},\n\
\tparents: function( elem ) {\n\
\t\treturn jQuery.dir( elem, \"parentNode\" );\n\
\t},\n\
\tparentsUntil: function( elem, i, until ) {\n\
\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\
\t},\n\
\tnext: function( elem ) {\n\
\t\treturn sibling( elem, \"nextSibling\" );\n\
\t},\n\
\tprev: function( elem ) {\n\
\t\treturn sibling( elem, \"previousSibling\" );\n\
\t},\n\
\tnextAll: function( elem ) {\n\
\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\
\t},\n\
\tprevAll: function( elem ) {\n\
\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\
\t},\n\
\tnextUntil: function( elem, i, until ) {\n\
\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\
\t},\n\
\tprevUntil: function( elem, i, until ) {\n\
\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\
\t},\n\
\tsiblings: function( elem ) {\n\
\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\
\t},\n\
\tchildren: function( elem ) {\n\
\t\treturn jQuery.sibling( elem.firstChild );\n\
\t},\n\
\tcontents: function( elem ) {\n\
\t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\n\
\t\t\telem.contentDocument || elem.contentWindow.document :\n\
\t\t\tjQuery.merge( [], elem.childNodes );\n\
\t}\n\
}, function( name, fn ) {\n\
\tjQuery.fn[ name ] = function( until, selector ) {\n\
\t\tvar ret = jQuery.map( this, fn, until );\n\
\n\
\t\tif ( !runtil.test( name ) ) {\n\
\t\t\tselector = until;\n\
\t\t}\n\
\n\
\t\tif ( selector && typeof selector === \"string\" ) {\n\
\t\t\tret = jQuery.filter( selector, ret );\n\
\t\t}\n\
\n\
\t\tret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;\n\
\n\
\t\tif ( this.length > 1 && rparentsprev.test( name ) ) {\n\
\t\t\tret = ret.reverse();\n\
\t\t}\n\
\n\
\t\treturn this.pushStack( ret );\n\
\t};\n\
});\n\
\n\
jQuery.extend({\n\
\tfilter: function( expr, elems, not ) {\n\
\t\tif ( not ) {\n\
\t\t\texpr = \":not(\" + expr + \")\";\n\
\t\t}\n\
\n\
\t\treturn elems.length === 1 ?\n\
\t\t\tjQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :\n\
\t\t\tjQuery.find.matches(expr, elems);\n\
\t},\n\
\n\
\tdir: function( elem, dir, until ) {\n\
\t\tvar matched = [],\n\
\t\t\tcur = elem[ dir ];\n\
\n\
\t\twhile ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n\
\t\t\tif ( cur.nodeType === 1 ) {\n\
\t\t\t\tmatched.push( cur );\n\
\t\t\t}\n\
\t\t\tcur = cur[dir];\n\
\t\t}\n\
\t\treturn matched;\n\
\t},\n\
\n\
\tsibling: function( n, elem ) {\n\
\t\tvar r = [];\n\
\n\
\t\tfor ( ; n; n = n.nextSibling ) {\n\
\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\
\t\t\t\tr.push( n );\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn r;\n\
\t}\n\
});\n\
\n\
// Implement the identical functionality for filter and not\n\
function winnow( elements, qualifier, keep ) {\n\
\n\
\t// Can't pass null or undefined to indexOf in Firefox 4\n\
\t// Set to 0 to skip string check\n\
\tqualifier = qualifier || 0;\n\
\n\
\tif ( jQuery.isFunction( qualifier ) ) {\n\
\t\treturn jQuery.grep(elements, function( elem, i ) {\n\
\t\t\tvar retVal = !!qualifier.call( elem, i, elem );\n\
\t\t\treturn retVal === keep;\n\
\t\t});\n\
\n\
\t} else if ( qualifier.nodeType ) {\n\
\t\treturn jQuery.grep(elements, function( elem ) {\n\
\t\t\treturn ( elem === qualifier ) === keep;\n\
\t\t});\n\
\n\
\t} else if ( typeof qualifier === \"string\" ) {\n\
\t\tvar filtered = jQuery.grep(elements, function( elem ) {\n\
\t\t\treturn elem.nodeType === 1;\n\
\t\t});\n\
\n\
\t\tif ( isSimple.test( qualifier ) ) {\n\
\t\t\treturn jQuery.filter(qualifier, filtered, !keep);\n\
\t\t} else {\n\
\t\t\tqualifier = jQuery.filter( qualifier, filtered );\n\
\t\t}\n\
\t}\n\
\n\
\treturn jQuery.grep(elements, function( elem ) {\n\
\t\treturn ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;\n\
\t});\n\
}\n\
function createSafeFragment( document ) {\n\
\tvar list = nodeNames.split( \"|\" ),\n\
\t\tsafeFrag = document.createDocumentFragment();\n\
\n\
\tif ( safeFrag.createElement ) {\n\
\t\twhile ( list.length ) {\n\
\t\t\tsafeFrag.createElement(\n\
\t\t\t\tlist.pop()\n\
\t\t\t);\n\
\t\t}\n\
\t}\n\
\treturn safeFrag;\n\
}\n\
\n\
var nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" +\n\
\t\t\"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n\
\trinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n\
\trnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n\
\trleadingWhitespace = /^\\s+/,\n\
\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\
\trtagName = /<([\\w:]+)/,\n\
\trtbody = /<tbody/i,\n\
\trhtml = /<|&#?\\w+;/,\n\
\trnoInnerhtml = /<(?:script|style|link)/i,\n\
\tmanipulation_rcheckableType = /^(?:checkbox|radio)$/i,\n\
\t// checked=\"checked\" or checked\n\
\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\
\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\
\trscriptTypeMasked = /^true\\/(.*)/,\n\
\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\
\n\
\t// We have to close these tags to support XHTML (#13200)\n\
\twrapMap = {\n\
\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\
\t\tlegend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n\
\t\tarea: [ 1, \"<map>\", \"</map>\" ],\n\
\t\tparam: [ 1, \"<object>\", \"</object>\" ],\n\
\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\
\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\
\t\tcol: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n\
\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\
\n\
\t\t// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n\
\t\t// unless wrapped in a div with non-breaking characters in front of it.\n\
\t\t_default: jQuery.support.htmlSerialize ? [ 0, \"\", \"\" ] : [ 1, \"X<div>\", \"</div>\"  ]\n\
\t},\n\
\tsafeFragment = createSafeFragment( document ),\n\
\tfragmentDiv = safeFragment.appendChild( document.createElement(\"div\") );\n\
\n\
wrapMap.optgroup = wrapMap.option;\n\
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\
wrapMap.th = wrapMap.td;\n\
\n\
jQuery.fn.extend({\n\
\ttext: function( value ) {\n\
\t\treturn jQuery.access( this, function( value ) {\n\
\t\t\treturn value === undefined ?\n\
\t\t\t\tjQuery.text( this ) :\n\
\t\t\t\tthis.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );\n\
\t\t}, null, value, arguments.length );\n\
\t},\n\
\n\
\twrapAll: function( html ) {\n\
\t\tif ( jQuery.isFunction( html ) ) {\n\
\t\t\treturn this.each(function(i) {\n\
\t\t\t\tjQuery(this).wrapAll( html.call(this, i) );\n\
\t\t\t});\n\
\t\t}\n\
\n\
\t\tif ( this[0] ) {\n\
\t\t\t// The elements to wrap the target around\n\
\t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\
\n\
\t\t\tif ( this[0].parentNode ) {\n\
\t\t\t\twrap.insertBefore( this[0] );\n\
\t\t\t}\n\
\n\
\t\t\twrap.map(function() {\n\
\t\t\t\tvar elem = this;\n\
\n\
\t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n\
\t\t\t\t\telem = elem.firstChild;\n\
\t\t\t\t}\n\
\n\
\t\t\t\treturn elem;\n\
\t\t\t}).append( this );\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\twrapInner: function( html ) {\n\
\t\tif ( jQuery.isFunction( html ) ) {\n\
\t\t\treturn this.each(function(i) {\n\
\t\t\t\tjQuery(this).wrapInner( html.call(this, i) );\n\
\t\t\t});\n\
\t\t}\n\
\n\
\t\treturn this.each(function() {\n\
\t\t\tvar self = jQuery( this ),\n\
\t\t\t\tcontents = self.contents();\n\
\n\
\t\t\tif ( contents.length ) {\n\
\t\t\t\tcontents.wrapAll( html );\n\
\n\
\t\t\t} else {\n\
\t\t\t\tself.append( html );\n\
\t\t\t}\n\
\t\t});\n\
\t},\n\
\n\
\twrap: function( html ) {\n\
\t\tvar isFunction = jQuery.isFunction( html );\n\
\n\
\t\treturn this.each(function(i) {\n\
\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\
\t\t});\n\
\t},\n\
\n\
\tunwrap: function() {\n\
\t\treturn this.parent().each(function() {\n\
\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\
\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\
\t\t\t}\n\
\t\t}).end();\n\
\t},\n\
\n\
\tappend: function() {\n\
\t\treturn this.domManip(arguments, true, function( elem ) {\n\
\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\
\t\t\t\tthis.appendChild( elem );\n\
\t\t\t}\n\
\t\t});\n\
\t},\n\
\n\
\tprepend: function() {\n\
\t\treturn this.domManip(arguments, true, function( elem ) {\n\
\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\
\t\t\t\tthis.insertBefore( elem, this.firstChild );\n\
\t\t\t}\n\
\t\t});\n\
\t},\n\
\n\
\tbefore: function() {\n\
\t\treturn this.domManip( arguments, false, function( elem ) {\n\
\t\t\tif ( this.parentNode ) {\n\
\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\
\t\t\t}\n\
\t\t});\n\
\t},\n\
\n\
\tafter: function() {\n\
\t\treturn this.domManip( arguments, false, function( elem ) {\n\
\t\t\tif ( this.parentNode ) {\n\
\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\
\t\t\t}\n\
\t\t});\n\
\t},\n\
\n\
\t// keepData is for internal use only--do not document\n\
\tremove: function( selector, keepData ) {\n\
\t\tvar elem,\n\
\t\t\ti = 0;\n\
\n\
\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\
\t\t\tif ( !selector || jQuery.filter( selector, [ elem ] ).length > 0 ) {\n\
\t\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\
\t\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( elem.parentNode ) {\n\
\t\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\
\t\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\
\t\t\t\t\t}\n\
\t\t\t\t\telem.parentNode.removeChild( elem );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\tempty: function() {\n\
\t\tvar elem,\n\
\t\t\ti = 0;\n\
\n\
\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\
\t\t\t// Remove element nodes and prevent memory leaks\n\
\t\t\tif ( elem.nodeType === 1 ) {\n\
\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\
\t\t\t}\n\
\n\
\t\t\t// Remove any remaining nodes\n\
\t\t\twhile ( elem.firstChild ) {\n\
\t\t\t\telem.removeChild( elem.firstChild );\n\
\t\t\t}\n\
\n\
\t\t\t// If this is a select, ensure that it displays empty (#12336)\n\
\t\t\t// Support: IE<9\n\
\t\t\tif ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n\
\t\t\t\telem.options.length = 0;\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\t},\n\
\n\
\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\
\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\
\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\
\n\
\t\treturn this.map( function () {\n\
\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\
\t\t});\n\
\t},\n\
\n\
\thtml: function( value ) {\n\
\t\treturn jQuery.access( this, function( value ) {\n\
\t\t\tvar elem = this[0] || {},\n\
\t\t\t\ti = 0,\n\
\t\t\t\tl = this.length;\n\
\n\
\t\t\tif ( value === undefined ) {\n\
\t\t\t\treturn elem.nodeType === 1 ?\n\
\t\t\t\t\telem.innerHTML.replace( rinlinejQuery, \"\" ) :\n\
\t\t\t\t\tundefined;\n\
\t\t\t}\n\
\n\
\t\t\t// See if we can take a shortcut and just use innerHTML\n\
\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\
\t\t\t\t( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n\
\t\t\t\t( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n\
\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [\"\", \"\"] )[1].toLowerCase() ] ) {\n\
\n\
\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\
\n\
\t\t\t\ttry {\n\
\t\t\t\t\tfor (; i < l; i++ ) {\n\
\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\
\t\t\t\t\t\telem = this[i] || {};\n\
\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\
\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\
\t\t\t\t\t\t\telem.innerHTML = value;\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\telem = 0;\n\
\n\
\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\
\t\t\t\t} catch(e) {}\n\
\t\t\t}\n\
\n\
\t\t\tif ( elem ) {\n\
\t\t\t\tthis.empty().append( value );\n\
\t\t\t}\n\
\t\t}, null, value, arguments.length );\n\
\t},\n\
\n\
\treplaceWith: function( value ) {\n\
\t\tvar isFunc = jQuery.isFunction( value );\n\
\n\
\t\t// Make sure that the elements are removed from the DOM before they are inserted\n\
\t\t// this can help fix replacing a parent with child elements\n\
\t\tif ( !isFunc && typeof value !== \"string\" ) {\n\
\t\t\tvalue = jQuery( value ).not( this ).detach();\n\
\t\t}\n\
\n\
\t\treturn this.domManip( [ value ], true, function( elem ) {\n\
\t\t\tvar next = this.nextSibling,\n\
\t\t\t\tparent = this.parentNode;\n\
\n\
\t\t\tif ( parent ) {\n\
\t\t\t\tjQuery( this ).remove();\n\
\t\t\t\tparent.insertBefore( elem, next );\n\
\t\t\t}\n\
\t\t});\n\
\t},\n\
\n\
\tdetach: function( selector ) {\n\
\t\treturn this.remove( selector, true );\n\
\t},\n\
\n\
\tdomManip: function( args, table, callback ) {\n\
\n\
\t\t// Flatten any nested arrays\n\
\t\targs = core_concat.apply( [], args );\n\
\n\
\t\tvar first, node, hasScripts,\n\
\t\t\tscripts, doc, fragment,\n\
\t\t\ti = 0,\n\
\t\t\tl = this.length,\n\
\t\t\tset = this,\n\
\t\t\tiNoClone = l - 1,\n\
\t\t\tvalue = args[0],\n\
\t\t\tisFunction = jQuery.isFunction( value );\n\
\n\
\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\
\t\tif ( isFunction || !( l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {\n\
\t\t\treturn this.each(function( index ) {\n\
\t\t\t\tvar self = set.eq( index );\n\
\t\t\t\tif ( isFunction ) {\n\
\t\t\t\t\targs[0] = value.call( this, index, table ? self.html() : undefined );\n\
\t\t\t\t}\n\
\t\t\t\tself.domManip( args, table, callback );\n\
\t\t\t});\n\
\t\t}\n\
\n\
\t\tif ( l ) {\n\
\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\
\t\t\tfirst = fragment.firstChild;\n\
\n\
\t\t\tif ( fragment.childNodes.length === 1 ) {\n\
\t\t\t\tfragment = first;\n\
\t\t\t}\n\
\n\
\t\t\tif ( first ) {\n\
\t\t\t\ttable = table && jQuery.nodeName( first, \"tr\" );\n\
\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\
\t\t\t\thasScripts = scripts.length;\n\
\n\
\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\
\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\
\t\t\t\tfor ( ; i < l; i++ ) {\n\
\t\t\t\t\tnode = fragment;\n\
\n\
\t\t\t\t\tif ( i !== iNoClone ) {\n\
\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\
\n\
\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\
\t\t\t\t\t\tif ( hasScripts ) {\n\
\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tcallback.call(\n\
\t\t\t\t\t\ttable && jQuery.nodeName( this[i], \"table\" ) ?\n\
\t\t\t\t\t\t\tfindOrAppend( this[i], \"tbody\" ) :\n\
\t\t\t\t\t\t\tthis[i],\n\
\t\t\t\t\t\tnode,\n\
\t\t\t\t\t\ti\n\
\t\t\t\t\t);\n\
\t\t\t\t}\n\
\n\
\t\t\t\tif ( hasScripts ) {\n\
\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\
\n\
\t\t\t\t\t// Reenable scripts\n\
\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\
\n\
\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\
\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\
\t\t\t\t\t\tnode = scripts[ i ];\n\
\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\
\t\t\t\t\t\t\t!jQuery._data( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\
\n\
\t\t\t\t\t\t\tif ( node.src ) {\n\
\t\t\t\t\t\t\t\t// Hope ajax is available...\n\
\t\t\t\t\t\t\t\tjQuery.ajax({\n\
\t\t\t\t\t\t\t\t\turl: node.src,\n\
\t\t\t\t\t\t\t\t\ttype: \"GET\",\n\
\t\t\t\t\t\t\t\t\tdataType: \"script\",\n\
\t\t\t\t\t\t\t\t\tasync: false,\n\
\t\t\t\t\t\t\t\t\tglobal: false,\n\
\t\t\t\t\t\t\t\t\t\"throws\": true\n\
\t\t\t\t\t\t\t\t});\n\
\t\t\t\t\t\t\t} else {\n\
\t\t\t\t\t\t\t\tjQuery.globalEval( ( node.text || node.textContent || node.innerHTML || \"\" ).replace( rcleanScript, \"\" ) );\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// Fix #11809: Avoid leaking memory\n\
\t\t\t\tfragment = first = null;\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn this;\n\
\t}\n\
});\n\
\n\
function findOrAppend( elem, tag ) {\n\
\treturn elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );\n\
}\n\
\n\
// Replace/restore the type attribute of script elements for safe DOM manipulation\n\
function disableScript( elem ) {\n\
\tvar attr = elem.getAttributeNode(\"type\");\n\
\telem.type = ( attr && attr.specified ) + \"/\" + elem.type;\n\
\treturn elem;\n\
}\n\
function restoreScript( elem ) {\n\
\tvar match = rscriptTypeMasked.exec( elem.type );\n\
\tif ( match ) {\n\
\t\telem.type = match[1];\n\
\t} else {\n\
\t\telem.removeAttribute(\"type\");\n\
\t}\n\
\treturn elem;\n\
}\n\
\n\
// Mark scripts as having already been evaluated\n\
function setGlobalEval( elems, refElements ) {\n\
\tvar elem,\n\
\t\ti = 0;\n\
\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\
\t\tjQuery._data( elem, \"globalEval\", !refElements || jQuery._data( refElements[i], \"globalEval\" ) );\n\
\t}\n\
}\n\
\n\
function cloneCopyEvent( src, dest ) {\n\
\n\
\tif ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n\
\t\treturn;\n\
\t}\n\
\n\
\tvar type, i, l,\n\
\t\toldData = jQuery._data( src ),\n\
\t\tcurData = jQuery._data( dest, oldData ),\n\
\t\tevents = oldData.events;\n\
\n\
\tif ( events ) {\n\
\t\tdelete curData.handle;\n\
\t\tcurData.events = {};\n\
\n\
\t\tfor ( type in events ) {\n\
\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\
\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\t// make the cloned public data object a copy from the original\n\
\tif ( curData.data ) {\n\
\t\tcurData.data = jQuery.extend( {}, curData.data );\n\
\t}\n\
}\n\
\n\
function fixCloneNodeIssues( src, dest ) {\n\
\tvar nodeName, e, data;\n\
\n\
\t// We do not need to do anything for non-Elements\n\
\tif ( dest.nodeType !== 1 ) {\n\
\t\treturn;\n\
\t}\n\
\n\
\tnodeName = dest.nodeName.toLowerCase();\n\
\n\
\t// IE6-8 copies events bound via attachEvent when using cloneNode.\n\
\tif ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {\n\
\t\tdata = jQuery._data( dest );\n\
\n\
\t\tfor ( e in data.events ) {\n\
\t\t\tjQuery.removeEvent( dest, e, data.handle );\n\
\t\t}\n\
\n\
\t\t// Event data gets referenced instead of copied if the expando gets copied too\n\
\t\tdest.removeAttribute( jQuery.expando );\n\
\t}\n\
\n\
\t// IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\
\tif ( nodeName === \"script\" && dest.text !== src.text ) {\n\
\t\tdisableScript( dest ).text = src.text;\n\
\t\trestoreScript( dest );\n\
\n\
\t// IE6-10 improperly clones children of object elements using classid.\n\
\t// IE10 throws NoModificationAllowedError if parent is null, #12132.\n\
\t} else if ( nodeName === \"object\" ) {\n\
\t\tif ( dest.parentNode ) {\n\
\t\t\tdest.outerHTML = src.outerHTML;\n\
\t\t}\n\
\n\
\t\t// This path appears unavoidable for IE9. When cloning an object\n\
\t\t// element in IE9, the outerHTML strategy above is not sufficient.\n\
\t\t// If the src has innerHTML and the destination does not,\n\
\t\t// copy the src.innerHTML into the dest.innerHTML. #10324\n\
\t\tif ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {\n\
\t\t\tdest.innerHTML = src.innerHTML;\n\
\t\t}\n\
\n\
\t} else if ( nodeName === \"input\" && manipulation_rcheckableType.test( src.type ) ) {\n\
\t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n\
\t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n\
\t\t// a checked appearance if the defaultChecked value isn't also set\n\
\n\
\t\tdest.defaultChecked = dest.checked = src.checked;\n\
\n\
\t\t// IE6-7 get confused and end up setting the value of a cloned\n\
\t\t// checkbox/radio button to an empty string instead of \"on\"\n\
\t\tif ( dest.value !== src.value ) {\n\
\t\t\tdest.value = src.value;\n\
\t\t}\n\
\n\
\t// IE6-8 fails to return the selected option to the default selected\n\
\t// state when cloning options\n\
\t} else if ( nodeName === \"option\" ) {\n\
\t\tdest.defaultSelected = dest.selected = src.defaultSelected;\n\
\n\
\t// IE6-8 fails to set the defaultValue to the correct value when\n\
\t// cloning other types of input fields\n\
\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\
\t\tdest.defaultValue = src.defaultValue;\n\
\t}\n\
}\n\
\n\
jQuery.each({\n\
\tappendTo: \"append\",\n\
\tprependTo: \"prepend\",\n\
\tinsertBefore: \"before\",\n\
\tinsertAfter: \"after\",\n\
\treplaceAll: \"replaceWith\"\n\
}, function( name, original ) {\n\
\tjQuery.fn[ name ] = function( selector ) {\n\
\t\tvar elems,\n\
\t\t\ti = 0,\n\
\t\t\tret = [],\n\
\t\t\tinsert = jQuery( selector ),\n\
\t\t\tlast = insert.length - 1;\n\
\n\
\t\tfor ( ; i <= last; i++ ) {\n\
\t\t\telems = i === last ? this : this.clone(true);\n\
\t\t\tjQuery( insert[i] )[ original ]( elems );\n\
\n\
\t\t\t// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\
\t\t\tcore_push.apply( ret, elems.get() );\n\
\t\t}\n\
\n\
\t\treturn this.pushStack( ret );\n\
\t};\n\
});\n\
\n\
function getAll( context, tag ) {\n\
\tvar elems, elem,\n\
\t\ti = 0,\n\
\t\tfound = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || \"*\" ) :\n\
\t\t\ttypeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || \"*\" ) :\n\
\t\t\tundefined;\n\
\n\
\tif ( !found ) {\n\
\t\tfor ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {\n\
\t\t\tif ( !tag || jQuery.nodeName( elem, tag ) ) {\n\
\t\t\t\tfound.push( elem );\n\
\t\t\t} else {\n\
\t\t\t\tjQuery.merge( found, getAll( elem, tag ) );\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\
\t\tjQuery.merge( [ context ], found ) :\n\
\t\tfound;\n\
}\n\
\n\
// Used in buildFragment, fixes the defaultChecked property\n\
function fixDefaultChecked( elem ) {\n\
\tif ( manipulation_rcheckableType.test( elem.type ) ) {\n\
\t\telem.defaultChecked = elem.checked;\n\
\t}\n\
}\n\
\n\
jQuery.extend({\n\
\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\
\t\tvar destElements, node, clone, i, srcElements,\n\
\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\
\n\
\t\tif ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( \"<\" + elem.nodeName + \">\" ) ) {\n\
\t\t\tclone = elem.cloneNode( true );\n\
\n\
\t\t// IE<=8 does not properly clone detached, unknown element nodes\n\
\t\t} else {\n\
\t\t\tfragmentDiv.innerHTML = elem.outerHTML;\n\
\t\t\tfragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n\
\t\t}\n\
\n\
\t\tif ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&\n\
\t\t\t\t(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\
\n\
\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\
\t\t\tdestElements = getAll( clone );\n\
\t\t\tsrcElements = getAll( elem );\n\
\n\
\t\t\t// Fix all IE cloning issues\n\
\t\t\tfor ( i = 0; (node = srcElements[i]) != null; ++i ) {\n\
\t\t\t\t// Ensure that the destination node is not null; Fixes #9587\n\
\t\t\t\tif ( destElements[i] ) {\n\
\t\t\t\t\tfixCloneNodeIssues( node, destElements[i] );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Copy the events from the original to the clone\n\
\t\tif ( dataAndEvents ) {\n\
\t\t\tif ( deepDataAndEvents ) {\n\
\t\t\t\tsrcElements = srcElements || getAll( elem );\n\
\t\t\t\tdestElements = destElements || getAll( clone );\n\
\n\
\t\t\t\tfor ( i = 0; (node = srcElements[i]) != null; i++ ) {\n\
\t\t\t\t\tcloneCopyEvent( node, destElements[i] );\n\
\t\t\t\t}\n\
\t\t\t} else {\n\
\t\t\t\tcloneCopyEvent( elem, clone );\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Preserve script evaluation history\n\
\t\tdestElements = getAll( clone, \"script\" );\n\
\t\tif ( destElements.length > 0 ) {\n\
\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\
\t\t}\n\
\n\
\t\tdestElements = srcElements = node = null;\n\
\n\
\t\t// Return the cloned set\n\
\t\treturn clone;\n\
\t},\n\
\n\
\tbuildFragment: function( elems, context, scripts, selection ) {\n\
\t\tvar j, elem, contains,\n\
\t\t\ttmp, tag, tbody, wrap,\n\
\t\t\tl = elems.length,\n\
\n\
\t\t\t// Ensure a safe fragment\n\
\t\t\tsafe = createSafeFragment( context ),\n\
\n\
\t\t\tnodes = [],\n\
\t\t\ti = 0;\n\
\n\
\t\tfor ( ; i < l; i++ ) {\n\
\t\t\telem = elems[ i ];\n\
\n\
\t\t\tif ( elem || elem === 0 ) {\n\
\n\
\t\t\t\t// Add nodes directly\n\
\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\
\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\
\n\
\t\t\t\t// Convert non-html into a text node\n\
\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\
\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\
\n\
\t\t\t\t// Convert html into DOM nodes\n\
\t\t\t\t} else {\n\
\t\t\t\t\ttmp = tmp || safe.appendChild( context.createElement(\"div\") );\n\
\n\
\t\t\t\t\t// Deserialize a standard representation\n\
\t\t\t\t\ttag = ( rtagName.exec( elem ) || [\"\", \"\"] )[1].toLowerCase();\n\
\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\
\n\
\t\t\t\t\ttmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[2];\n\
\n\
\t\t\t\t\t// Descend through wrappers to the right content\n\
\t\t\t\t\tj = wrap[0];\n\
\t\t\t\t\twhile ( j-- ) {\n\
\t\t\t\t\t\ttmp = tmp.lastChild;\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Manually add leading whitespace removed by IE\n\
\t\t\t\t\tif ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n\
\t\t\t\t\t\tnodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\
\t\t\t\t\tif ( !jQuery.support.tbody ) {\n\
\n\
\t\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\
\t\t\t\t\t\telem = tag === \"table\" && !rtbody.test( elem ) ?\n\
\t\t\t\t\t\t\ttmp.firstChild :\n\
\n\
\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\
\t\t\t\t\t\t\twrap[1] === \"<table>\" && !rtbody.test( elem ) ?\n\
\t\t\t\t\t\t\t\ttmp :\n\
\t\t\t\t\t\t\t\t0;\n\
\n\
\t\t\t\t\t\tj = elem && elem.childNodes.length;\n\
\t\t\t\t\t\twhile ( j-- ) {\n\
\t\t\t\t\t\t\tif ( jQuery.nodeName( (tbody = elem.childNodes[j]), \"tbody\" ) && !tbody.childNodes.length ) {\n\
\t\t\t\t\t\t\t\telem.removeChild( tbody );\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\
\n\
\t\t\t\t\t// Fix #12392 for WebKit and IE > 9\n\
\t\t\t\t\ttmp.textContent = \"\";\n\
\n\
\t\t\t\t\t// Fix #12392 for oldIE\n\
\t\t\t\t\twhile ( tmp.firstChild ) {\n\
\t\t\t\t\t\ttmp.removeChild( tmp.firstChild );\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Remember the top-level container for proper cleanup\n\
\t\t\t\t\ttmp = safe.lastChild;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Fix #11356: Clear elements from fragment\n\
\t\tif ( tmp ) {\n\
\t\t\tsafe.removeChild( tmp );\n\
\t\t}\n\
\n\
\t\t// Reset defaultChecked for any radios and checkboxes\n\
\t\t// about to be appended to the DOM in IE 6/7 (#8060)\n\
\t\tif ( !jQuery.support.appendChecked ) {\n\
\t\t\tjQuery.grep( getAll( nodes, \"input\" ), fixDefaultChecked );\n\
\t\t}\n\
\n\
\t\ti = 0;\n\
\t\twhile ( (elem = nodes[ i++ ]) ) {\n\
\n\
\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\
\t\t\t// that element, do not do anything\n\
\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\
\t\t\t\tcontinue;\n\
\t\t\t}\n\
\n\
\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\
\n\
\t\t\t// Append to fragment\n\
\t\t\ttmp = getAll( safe.appendChild( elem ), \"script\" );\n\
\n\
\t\t\t// Preserve script evaluation history\n\
\t\t\tif ( contains ) {\n\
\t\t\t\tsetGlobalEval( tmp );\n\
\t\t\t}\n\
\n\
\t\t\t// Capture executables\n\
\t\t\tif ( scripts ) {\n\
\t\t\t\tj = 0;\n\
\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\
\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\
\t\t\t\t\t\tscripts.push( elem );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\ttmp = null;\n\
\n\
\t\treturn safe;\n\
\t},\n\
\n\
\tcleanData: function( elems, /* internal */ acceptData ) {\n\
\t\tvar elem, type, id, data,\n\
\t\t\ti = 0,\n\
\t\t\tinternalKey = jQuery.expando,\n\
\t\t\tcache = jQuery.cache,\n\
\t\t\tdeleteExpando = jQuery.support.deleteExpando,\n\
\t\t\tspecial = jQuery.event.special;\n\
\n\
\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\
\n\
\t\t\tif ( acceptData || jQuery.acceptData( elem ) ) {\n\
\n\
\t\t\t\tid = elem[ internalKey ];\n\
\t\t\t\tdata = id && cache[ id ];\n\
\n\
\t\t\t\tif ( data ) {\n\
\t\t\t\t\tif ( data.events ) {\n\
\t\t\t\t\t\tfor ( type in data.events ) {\n\
\t\t\t\t\t\t\tif ( special[ type ] ) {\n\
\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\
\n\
\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\
\t\t\t\t\t\t\t} else {\n\
\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Remove cache only if it was not already removed by jQuery.event.remove\n\
\t\t\t\t\tif ( cache[ id ] ) {\n\
\n\
\t\t\t\t\t\tdelete cache[ id ];\n\
\n\
\t\t\t\t\t\t// IE does not allow us to delete expando properties from nodes,\n\
\t\t\t\t\t\t// nor does it have a removeAttribute function on Document nodes;\n\
\t\t\t\t\t\t// we must handle all of these cases\n\
\t\t\t\t\t\tif ( deleteExpando ) {\n\
\t\t\t\t\t\t\tdelete elem[ internalKey ];\n\
\n\
\t\t\t\t\t\t} else if ( typeof elem.removeAttribute !== core_strundefined ) {\n\
\t\t\t\t\t\t\telem.removeAttribute( internalKey );\n\
\n\
\t\t\t\t\t\t} else {\n\
\t\t\t\t\t\t\telem[ internalKey ] = null;\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\tcore_deletedIds.push( id );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
});\n\
var iframe, getStyles, curCSS,\n\
\tralpha = /alpha\\([^)]*\\)/i,\n\
\tropacity = /opacity\\s*=\\s*([^)]*)/,\n\
\trposition = /^(top|right|bottom|left)$/,\n\
\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\
\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\
\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\
\trmargin = /^margin/,\n\
\trnumsplit = new RegExp( \"^(\" + core_pnum + \")(.*)$\", \"i\" ),\n\
\trnumnonpx = new RegExp( \"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\" ),\n\
\trrelNum = new RegExp( \"^([+-])=(\" + core_pnum + \")\", \"i\" ),\n\
\telemdisplay = { BODY: \"block\" },\n\
\n\
\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\
\tcssNormalTransform = {\n\
\t\tletterSpacing: 0,\n\
\t\tfontWeight: 400\n\
\t},\n\
\n\
\tcssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\n\
\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\
\n\
// return a css property mapped to a potentially vendor prefixed property\n\
function vendorPropName( style, name ) {\n\
\n\
\t// shortcut for names that are not vendor prefixed\n\
\tif ( name in style ) {\n\
\t\treturn name;\n\
\t}\n\
\n\
\t// check for vendor prefixed names\n\
\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\
\t\torigName = name,\n\
\t\ti = cssPrefixes.length;\n\
\n\
\twhile ( i-- ) {\n\
\t\tname = cssPrefixes[ i ] + capName;\n\
\t\tif ( name in style ) {\n\
\t\t\treturn name;\n\
\t\t}\n\
\t}\n\
\n\
\treturn origName;\n\
}\n\
\n\
function isHidden( elem, el ) {\n\
\t// isHidden might be called from jQuery#filter function;\n\
\t// in that case, element will be second argument\n\
\telem = el || elem;\n\
\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\
}\n\
\n\
function showHide( elements, show ) {\n\
\tvar display, elem, hidden,\n\
\t\tvalues = [],\n\
\t\tindex = 0,\n\
\t\tlength = elements.length;\n\
\n\
\tfor ( ; index < length; index++ ) {\n\
\t\telem = elements[ index ];\n\
\t\tif ( !elem.style ) {\n\
\t\t\tcontinue;\n\
\t\t}\n\
\n\
\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\" );\n\
\t\tdisplay = elem.style.display;\n\
\t\tif ( show ) {\n\
\t\t\t// Reset the inline display of this element to learn if it is\n\
\t\t\t// being hidden by cascaded rules or not\n\
\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\
\t\t\t\telem.style.display = \"\";\n\
\t\t\t}\n\
\n\
\t\t\t// Set elements which have been overridden with display: none\n\
\t\t\t// in a stylesheet to whatever the default browser style is\n\
\t\t\t// for such an element\n\
\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\
\t\t\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\", css_defaultDisplay(elem.nodeName) );\n\
\t\t\t}\n\
\t\t} else {\n\
\n\
\t\t\tif ( !values[ index ] ) {\n\
\t\t\t\thidden = isHidden( elem );\n\
\n\
\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\
\t\t\t\t\tjQuery._data( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\t// Set the display of most of the elements in a second loop\n\
\t// to avoid the constant reflow\n\
\tfor ( index = 0; index < length; index++ ) {\n\
\t\telem = elements[ index ];\n\
\t\tif ( !elem.style ) {\n\
\t\t\tcontinue;\n\
\t\t}\n\
\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\
\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\
\t\t}\n\
\t}\n\
\n\
\treturn elements;\n\
}\n\
\n\
jQuery.fn.extend({\n\
\tcss: function( name, value ) {\n\
\t\treturn jQuery.access( this, function( elem, name, value ) {\n\
\t\t\tvar len, styles,\n\
\t\t\t\tmap = {},\n\
\t\t\t\ti = 0;\n\
\n\
\t\t\tif ( jQuery.isArray( name ) ) {\n\
\t\t\t\tstyles = getStyles( elem );\n\
\t\t\t\tlen = name.length;\n\
\n\
\t\t\t\tfor ( ; i < len; i++ ) {\n\
\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\
\t\t\t\t}\n\
\n\
\t\t\t\treturn map;\n\
\t\t\t}\n\
\n\
\t\t\treturn value !== undefined ?\n\
\t\t\t\tjQuery.style( elem, name, value ) :\n\
\t\t\t\tjQuery.css( elem, name );\n\
\t\t}, name, value, arguments.length > 1 );\n\
\t},\n\
\tshow: function() {\n\
\t\treturn showHide( this, true );\n\
\t},\n\
\thide: function() {\n\
\t\treturn showHide( this );\n\
\t},\n\
\ttoggle: function( state ) {\n\
\t\tvar bool = typeof state === \"boolean\";\n\
\n\
\t\treturn this.each(function() {\n\
\t\t\tif ( bool ? state : isHidden( this ) ) {\n\
\t\t\t\tjQuery( this ).show();\n\
\t\t\t} else {\n\
\t\t\t\tjQuery( this ).hide();\n\
\t\t\t}\n\
\t\t});\n\
\t}\n\
});\n\
\n\
jQuery.extend({\n\
\t// Add in style property hooks for overriding the default\n\
\t// behavior of getting and setting a style property\n\
\tcssHooks: {\n\
\t\topacity: {\n\
\t\t\tget: function( elem, computed ) {\n\
\t\t\t\tif ( computed ) {\n\
\t\t\t\t\t// We should always get a number back from opacity\n\
\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\
\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t},\n\
\n\
\t// Exclude the following css properties to add px\n\
\tcssNumber: {\n\
\t\t\"columnCount\": true,\n\
\t\t\"fillOpacity\": true,\n\
\t\t\"fontWeight\": true,\n\
\t\t\"lineHeight\": true,\n\
\t\t\"opacity\": true,\n\
\t\t\"orphans\": true,\n\
\t\t\"widows\": true,\n\
\t\t\"zIndex\": true,\n\
\t\t\"zoom\": true\n\
\t},\n\
\n\
\t// Add in properties whose names you wish to fix before\n\
\t// setting or getting the value\n\
\tcssProps: {\n\
\t\t// normalize float css property\n\
\t\t\"float\": jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n\
\t},\n\
\n\
\t// Get and set the style property on a DOM Node\n\
\tstyle: function( elem, name, value, extra ) {\n\
\t\t// Don't set styles on text and comment nodes\n\
\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\t// Make sure that we're working with the right name\n\
\t\tvar ret, type, hooks,\n\
\t\t\torigName = jQuery.camelCase( name ),\n\
\t\t\tstyle = elem.style;\n\
\n\
\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\
\n\
\t\t// gets hook for the prefixed version\n\
\t\t// followed by the unprefixed version\n\
\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\
\n\
\t\t// Check if we're setting a value\n\
\t\tif ( value !== undefined ) {\n\
\t\t\ttype = typeof value;\n\
\n\
\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\
\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\
\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\
\t\t\t\t// Fixes bug #9237\n\
\t\t\t\ttype = \"number\";\n\
\t\t\t}\n\
\n\
\t\t\t// Make sure that NaN and null values aren't set. See: #7116\n\
\t\t\tif ( value == null || type === \"number\" && isNaN( value ) ) {\n\
\t\t\t\treturn;\n\
\t\t\t}\n\
\n\
\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\
\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\
\t\t\t\tvalue += \"px\";\n\
\t\t\t}\n\
\n\
\t\t\t// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n\
\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\
\t\t\tif ( !jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n\
\t\t\t\tstyle[ name ] = \"inherit\";\n\
\t\t\t}\n\
\n\
\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\
\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\
\n\
\t\t\t\t// Wrapped to prevent IE from throwing errors when 'invalid' values are provided\n\
\t\t\t\t// Fixes bug #5509\n\
\t\t\t\ttry {\n\
\t\t\t\t\tstyle[ name ] = value;\n\
\t\t\t\t} catch(e) {}\n\
\t\t\t}\n\
\n\
\t\t} else {\n\
\t\t\t// If a hook was provided get the non-computed value from there\n\
\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\
\t\t\t\treturn ret;\n\
\t\t\t}\n\
\n\
\t\t\t// Otherwise just get the value from the style object\n\
\t\t\treturn style[ name ];\n\
\t\t}\n\
\t},\n\
\n\
\tcss: function( elem, name, extra, styles ) {\n\
\t\tvar num, val, hooks,\n\
\t\t\torigName = jQuery.camelCase( name );\n\
\n\
\t\t// Make sure that we're working with the right name\n\
\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\
\n\
\t\t// gets hook for the prefixed version\n\
\t\t// followed by the unprefixed version\n\
\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\
\n\
\t\t// If a hook was provided get the computed value from there\n\
\t\tif ( hooks && \"get\" in hooks ) {\n\
\t\t\tval = hooks.get( elem, true, extra );\n\
\t\t}\n\
\n\
\t\t// Otherwise, if a way to get the computed value exists, use that\n\
\t\tif ( val === undefined ) {\n\
\t\t\tval = curCSS( elem, name, styles );\n\
\t\t}\n\
\n\
\t\t//convert \"normal\" to computed value\n\
\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\
\t\t\tval = cssNormalTransform[ name ];\n\
\t\t}\n\
\n\
\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\
\t\tif ( extra === \"\" || extra ) {\n\
\t\t\tnum = parseFloat( val );\n\
\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\
\t\t}\n\
\t\treturn val;\n\
\t},\n\
\n\
\t// A method for quickly swapping in/out CSS properties to get correct calculations\n\
\tswap: function( elem, options, callback, args ) {\n\
\t\tvar ret, name,\n\
\t\t\told = {};\n\
\n\
\t\t// Remember the old values, and insert the new ones\n\
\t\tfor ( name in options ) {\n\
\t\t\told[ name ] = elem.style[ name ];\n\
\t\t\telem.style[ name ] = options[ name ];\n\
\t\t}\n\
\n\
\t\tret = callback.apply( elem, args || [] );\n\
\n\
\t\t// Revert the old values\n\
\t\tfor ( name in options ) {\n\
\t\t\telem.style[ name ] = old[ name ];\n\
\t\t}\n\
\n\
\t\treturn ret;\n\
\t}\n\
});\n\
\n\
// NOTE: we've included the \"window\" in window.getComputedStyle\n\
// because jsdom on node.js will break without it.\n\
if ( window.getComputedStyle ) {\n\
\tgetStyles = function( elem ) {\n\
\t\treturn window.getComputedStyle( elem, null );\n\
\t};\n\
\n\
\tcurCSS = function( elem, name, _computed ) {\n\
\t\tvar width, minWidth, maxWidth,\n\
\t\t\tcomputed = _computed || getStyles( elem ),\n\
\n\
\t\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\
\t\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,\n\
\t\t\tstyle = elem.style;\n\
\n\
\t\tif ( computed ) {\n\
\n\
\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\
\t\t\t\tret = jQuery.style( elem, name );\n\
\t\t\t}\n\
\n\
\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\
\t\t\t// Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n\
\t\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\
\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\
\t\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\
\n\
\t\t\t\t// Remember the original values\n\
\t\t\t\twidth = style.width;\n\
\t\t\t\tminWidth = style.minWidth;\n\
\t\t\t\tmaxWidth = style.maxWidth;\n\
\n\
\t\t\t\t// Put in the new values to get a computed value out\n\
\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\
\t\t\t\tret = computed.width;\n\
\n\
\t\t\t\t// Revert the changed values\n\
\t\t\t\tstyle.width = width;\n\
\t\t\t\tstyle.minWidth = minWidth;\n\
\t\t\t\tstyle.maxWidth = maxWidth;\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn ret;\n\
\t};\n\
} else if ( document.documentElement.currentStyle ) {\n\
\tgetStyles = function( elem ) {\n\
\t\treturn elem.currentStyle;\n\
\t};\n\
\n\
\tcurCSS = function( elem, name, _computed ) {\n\
\t\tvar left, rs, rsLeft,\n\
\t\t\tcomputed = _computed || getStyles( elem ),\n\
\t\t\tret = computed ? computed[ name ] : undefined,\n\
\t\t\tstyle = elem.style;\n\
\n\
\t\t// Avoid setting ret to empty string here\n\
\t\t// so we don't default to auto\n\
\t\tif ( ret == null && style && style[ name ] ) {\n\
\t\t\tret = style[ name ];\n\
\t\t}\n\
\n\
\t\t// From the awesome hack by Dean Edwards\n\
\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\
\n\
\t\t// If we're not dealing with a regular pixel number\n\
\t\t// but a number that has a weird ending, we need to convert it to pixels\n\
\t\t// but not position css attributes, as those are proportional to the parent element instead\n\
\t\t// and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n\
\t\tif ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\
\n\
\t\t\t// Remember the original values\n\
\t\t\tleft = style.left;\n\
\t\t\trs = elem.runtimeStyle;\n\
\t\t\trsLeft = rs && rs.left;\n\
\n\
\t\t\t// Put in the new values to get a computed value out\n\
\t\t\tif ( rsLeft ) {\n\
\t\t\t\trs.left = elem.currentStyle.left;\n\
\t\t\t}\n\
\t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : ret;\n\
\t\t\tret = style.pixelLeft + \"px\";\n\
\n\
\t\t\t// Revert the changed values\n\
\t\t\tstyle.left = left;\n\
\t\t\tif ( rsLeft ) {\n\
\t\t\t\trs.left = rsLeft;\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn ret === \"\" ? \"auto\" : ret;\n\
\t};\n\
}\n\
\n\
function setPositiveNumber( elem, value, subtract ) {\n\
\tvar matches = rnumsplit.exec( value );\n\
\treturn matches ?\n\
\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\
\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\
\t\tvalue;\n\
}\n\
\n\
function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\
\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\
\t\t// If we already have the right measurement, avoid augmentation\n\
\t\t4 :\n\
\t\t// Otherwise initialize for horizontal or vertical properties\n\
\t\tname === \"width\" ? 1 : 0,\n\
\n\
\t\tval = 0;\n\
\n\
\tfor ( ; i < 4; i += 2 ) {\n\
\t\t// both box models exclude margin, so add it if we want it\n\
\t\tif ( extra === \"margin\" ) {\n\
\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\
\t\t}\n\
\n\
\t\tif ( isBorderBox ) {\n\
\t\t\t// border-box includes padding, so remove it if we want content\n\
\t\t\tif ( extra === \"content\" ) {\n\
\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\
\t\t\t}\n\
\n\
\t\t\t// at this point, extra isn't border nor margin, so remove border\n\
\t\t\tif ( extra !== \"margin\" ) {\n\
\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\
\t\t\t}\n\
\t\t} else {\n\
\t\t\t// at this point, extra isn't content, so add padding\n\
\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\
\n\
\t\t\t// at this point, extra isn't content nor padding, so add border\n\
\t\t\tif ( extra !== \"padding\" ) {\n\
\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\treturn val;\n\
}\n\
\n\
function getWidthOrHeight( elem, name, extra ) {\n\
\n\
\t// Start with offset property, which is equivalent to the border-box value\n\
\tvar valueIsBorderBox = true,\n\
\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\
\t\tstyles = getStyles( elem ),\n\
\t\tisBorderBox = jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\
\n\
\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\
\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\
\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\
\tif ( val <= 0 || val == null ) {\n\
\t\t// Fall back to computed then uncomputed css if necessary\n\
\t\tval = curCSS( elem, name, styles );\n\
\t\tif ( val < 0 || val == null ) {\n\
\t\t\tval = elem.style[ name ];\n\
\t\t}\n\
\n\
\t\t// Computed unit is not pixels. Stop here and return.\n\
\t\tif ( rnumnonpx.test(val) ) {\n\
\t\t\treturn val;\n\
\t\t}\n\
\n\
\t\t// we need the check for style in case a browser which returns unreliable values\n\
\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\
\t\tvalueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\n\
\n\
\t\t// Normalize \"\", auto, and prepare for extra\n\
\t\tval = parseFloat( val ) || 0;\n\
\t}\n\
\n\
\t// use the active box-sizing model to add/subtract irrelevant styles\n\
\treturn ( val +\n\
\t\taugmentWidthOrHeight(\n\
\t\t\telem,\n\
\t\t\tname,\n\
\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\
\t\t\tvalueIsBorderBox,\n\
\t\t\tstyles\n\
\t\t)\n\
\t) + \"px\";\n\
}\n\
\n\
// Try to determine the default display value of an element\n\
function css_defaultDisplay( nodeName ) {\n\
\tvar doc = document,\n\
\t\tdisplay = elemdisplay[ nodeName ];\n\
\n\
\tif ( !display ) {\n\
\t\tdisplay = actualDisplay( nodeName, doc );\n\
\n\
\t\t// If the simple way fails, read from inside an iframe\n\
\t\tif ( display === \"none\" || !display ) {\n\
\t\t\t// Use the already-created iframe if possible\n\
\t\t\tiframe = ( iframe ||\n\
\t\t\t\tjQuery(\"<iframe frameborder='0' width='0' height='0'/>\")\n\
\t\t\t\t.css( \"cssText\", \"display:block !important\" )\n\
\t\t\t).appendTo( doc.documentElement );\n\
\n\
\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\
\t\t\tdoc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;\n\
\t\t\tdoc.write(\"<!doctype html><html><body>\");\n\
\t\t\tdoc.close();\n\
\n\
\t\t\tdisplay = actualDisplay( nodeName, doc );\n\
\t\t\tiframe.detach();\n\
\t\t}\n\
\n\
\t\t// Store the correct default display\n\
\t\telemdisplay[ nodeName ] = display;\n\
\t}\n\
\n\
\treturn display;\n\
}\n\
\n\
// Called ONLY from within css_defaultDisplay\n\
function actualDisplay( name, doc ) {\n\
\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\
\t\tdisplay = jQuery.css( elem[0], \"display\" );\n\
\telem.remove();\n\
\treturn display;\n\
}\n\
\n\
jQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\
\tjQuery.cssHooks[ name ] = {\n\
\t\tget: function( elem, computed, extra ) {\n\
\t\t\tif ( computed ) {\n\
\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\
\t\t\t\t// however, it must have a current display style that would benefit from this\n\
\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\n\
\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\
\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\
\t\t\t\t\t}) :\n\
\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\
\t\t\t}\n\
\t\t},\n\
\n\
\t\tset: function( elem, value, extra ) {\n\
\t\t\tvar styles = extra && getStyles( elem );\n\
\t\t\treturn setPositiveNumber( elem, value, extra ?\n\
\t\t\t\taugmentWidthOrHeight(\n\
\t\t\t\t\telem,\n\
\t\t\t\t\tname,\n\
\t\t\t\t\textra,\n\
\t\t\t\t\tjQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\
\t\t\t\t\tstyles\n\
\t\t\t\t) : 0\n\
\t\t\t);\n\
\t\t}\n\
\t};\n\
});\n\
\n\
if ( !jQuery.support.opacity ) {\n\
\tjQuery.cssHooks.opacity = {\n\
\t\tget: function( elem, computed ) {\n\
\t\t\t// IE uses filters for opacity\n\
\t\t\treturn ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n\
\t\t\t\t( 0.01 * parseFloat( RegExp.$1 ) ) + \"\" :\n\
\t\t\t\tcomputed ? \"1\" : \"\";\n\
\t\t},\n\
\n\
\t\tset: function( elem, value ) {\n\
\t\t\tvar style = elem.style,\n\
\t\t\t\tcurrentStyle = elem.currentStyle,\n\
\t\t\t\topacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n\
\t\t\t\tfilter = currentStyle && currentStyle.filter || style.filter || \"\";\n\
\n\
\t\t\t// IE has trouble with opacity if it does not have layout\n\
\t\t\t// Force it by setting the zoom level\n\
\t\t\tstyle.zoom = 1;\n\
\n\
\t\t\t// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n\
\t\t\t// if value === \"\", then remove inline opacity #12685\n\
\t\t\tif ( ( value >= 1 || value === \"\" ) &&\n\
\t\t\t\t\tjQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" &&\n\
\t\t\t\t\tstyle.removeAttribute ) {\n\
\n\
\t\t\t\t// Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n\
\t\t\t\t// if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n\
\t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\
\t\t\t\tstyle.removeAttribute( \"filter\" );\n\
\n\
\t\t\t\t// if there is no filter style applied in a css rule or unset inline opacity, we are done\n\
\t\t\t\tif ( value === \"\" || currentStyle && !currentStyle.filter ) {\n\
\t\t\t\t\treturn;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\t// otherwise, set new filter values\n\
\t\t\tstyle.filter = ralpha.test( filter ) ?\n\
\t\t\t\tfilter.replace( ralpha, opacity ) :\n\
\t\t\t\tfilter + \" \" + opacity;\n\
\t\t}\n\
\t};\n\
}\n\
\n\
// These hooks cannot be added until DOM ready because the support test\n\
// for it is not run until after DOM ready\n\
jQuery(function() {\n\
\tif ( !jQuery.support.reliableMarginRight ) {\n\
\t\tjQuery.cssHooks.marginRight = {\n\
\t\t\tget: function( elem, computed ) {\n\
\t\t\t\tif ( computed ) {\n\
\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\
\t\t\t\t\t// Work around by temporarily setting element display to inline-block\n\
\t\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\
\t\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t};\n\
\t}\n\
\n\
\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\
\t// getComputedStyle returns percent when specified for top/left/bottom/right\n\
\t// rather than make the css module depend on the offset module, we just check for it here\n\
\tif ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\n\
\t\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\
\t\t\tjQuery.cssHooks[ prop ] = {\n\
\t\t\t\tget: function( elem, computed ) {\n\
\t\t\t\t\tif ( computed ) {\n\
\t\t\t\t\t\tcomputed = curCSS( elem, prop );\n\
\t\t\t\t\t\t// if curCSS returns percentage, fallback to offset\n\
\t\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\
\t\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\
\t\t\t\t\t\t\tcomputed;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t};\n\
\t\t});\n\
\t}\n\
\n\
});\n\
\n\
if ( jQuery.expr && jQuery.expr.filters ) {\n\
\tjQuery.expr.filters.hidden = function( elem ) {\n\
\t\t// Support: Opera <= 12.12\n\
\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\
\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||\n\
\t\t\t(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, \"display\" )) === \"none\");\n\
\t};\n\
\n\
\tjQuery.expr.filters.visible = function( elem ) {\n\
\t\treturn !jQuery.expr.filters.hidden( elem );\n\
\t};\n\
}\n\
\n\
// These hooks are used by animate to expand properties\n\
jQuery.each({\n\
\tmargin: \"\",\n\
\tpadding: \"\",\n\
\tborder: \"Width\"\n\
}, function( prefix, suffix ) {\n\
\tjQuery.cssHooks[ prefix + suffix ] = {\n\
\t\texpand: function( value ) {\n\
\t\t\tvar i = 0,\n\
\t\t\t\texpanded = {},\n\
\n\
\t\t\t\t// assumes a single number if not a string\n\
\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\
\n\
\t\t\tfor ( ; i < 4; i++ ) {\n\
\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\
\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\
\t\t\t}\n\
\n\
\t\t\treturn expanded;\n\
\t\t}\n\
\t};\n\
\n\
\tif ( !rmargin.test( prefix ) ) {\n\
\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\
\t}\n\
});\n\
var r20 = /%20/g,\n\
\trbracket = /\\[\\]$/,\n\
\trCRLF = /\\r?\\n\
/g,\n\
\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\
\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\
\n\
jQuery.fn.extend({\n\
\tserialize: function() {\n\
\t\treturn jQuery.param( this.serializeArray() );\n\
\t},\n\
\tserializeArray: function() {\n\
\t\treturn this.map(function(){\n\
\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\
\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\
\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\
\t\t})\n\
\t\t.filter(function(){\n\
\t\t\tvar type = this.type;\n\
\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\
\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\
\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\
\t\t\t\t( this.checked || !manipulation_rcheckableType.test( type ) );\n\
\t\t})\n\
\t\t.map(function( i, elem ){\n\
\t\t\tvar val = jQuery( this ).val();\n\
\n\
\t\t\treturn val == null ?\n\
\t\t\t\tnull :\n\
\t\t\t\tjQuery.isArray( val ) ?\n\
\t\t\t\t\tjQuery.map( val, function( val ){\n\
\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\
\" ) };\n\
\t\t\t\t\t}) :\n\
\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\
\" ) };\n\
\t\t}).get();\n\
\t}\n\
});\n\
\n\
//Serialize an array of form elements or a set of\n\
//key/values into a query string\n\
jQuery.param = function( a, traditional ) {\n\
\tvar prefix,\n\
\t\ts = [],\n\
\t\tadd = function( key, value ) {\n\
\t\t\t// If value is a function, invoke it and return its value\n\
\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\
\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\
\t\t};\n\
\n\
\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\
\tif ( traditional === undefined ) {\n\
\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\
\t}\n\
\n\
\t// If an array was passed in, assume that it is an array of form elements.\n\
\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\
\t\t// Serialize the form elements\n\
\t\tjQuery.each( a, function() {\n\
\t\t\tadd( this.name, this.value );\n\
\t\t});\n\
\n\
\t} else {\n\
\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\
\t\t// did it), otherwise encode params recursively.\n\
\t\tfor ( prefix in a ) {\n\
\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\
\t\t}\n\
\t}\n\
\n\
\t// Return the resulting serialization\n\
\treturn s.join( \"&\" ).replace( r20, \"+\" );\n\
};\n\
\n\
function buildParams( prefix, obj, traditional, add ) {\n\
\tvar name;\n\
\n\
\tif ( jQuery.isArray( obj ) ) {\n\
\t\t// Serialize array item.\n\
\t\tjQuery.each( obj, function( i, v ) {\n\
\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\
\t\t\t\t// Treat each array item as a scalar.\n\
\t\t\t\tadd( prefix, v );\n\
\n\
\t\t\t} else {\n\
\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\
\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\
\t\t\t}\n\
\t\t});\n\
\n\
\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\
\t\t// Serialize object item.\n\
\t\tfor ( name in obj ) {\n\
\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\
\t\t}\n\
\n\
\t} else {\n\
\t\t// Serialize scalar item.\n\
\t\tadd( prefix, obj );\n\
\t}\n\
}\n\
jQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\
\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\
\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\
\n\
\t// Handle event binding\n\
\tjQuery.fn[ name ] = function( data, fn ) {\n\
\t\treturn arguments.length > 0 ?\n\
\t\t\tthis.on( name, null, data, fn ) :\n\
\t\t\tthis.trigger( name );\n\
\t};\n\
});\n\
\n\
jQuery.fn.hover = function( fnOver, fnOut ) {\n\
\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\
};\n\
var\n\
\t// Document location\n\
\tajaxLocParts,\n\
\tajaxLocation,\n\
\tajax_nonce = jQuery.now(),\n\
\n\
\tajax_rquery = /\\?/,\n\
\trhash = /#.*$/,\n\
\trts = /([?&])_=[^&]*/,\n\
\trheaders = /^(.*?):[ \\t]*([^\\r\\n\
]*)\\r?$/mg, // IE leaves an \\r character at EOL\n\
\t// #7653, #8125, #8152: local protocol detection\n\
\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\
\trnoContent = /^(?:GET|HEAD)$/,\n\
\trprotocol = /^\\/\\//,\n\
\trurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n\
\n\
\t// Keep a copy of the old load method\n\
\t_load = jQuery.fn.load,\n\
\n\
\t/* Prefilters\n\
\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\
\t * 2) These are called:\n\
\t *    - BEFORE asking for a transport\n\
\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\
\t * 3) key is the dataType\n\
\t * 4) the catchall symbol \"*\" can be used\n\
\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\
\t */\n\
\tprefilters = {},\n\
\n\
\t/* Transports bindings\n\
\t * 1) key is the dataType\n\
\t * 2) the catchall symbol \"*\" can be used\n\
\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\
\t */\n\
\ttransports = {},\n\
\n\
\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\
\tallTypes = \"*/\".concat(\"*\");\n\
\n\
// #8138, IE may throw an exception when accessing\n\
// a field from window.location if document.domain has been set\n\
try {\n\
\tajaxLocation = location.href;\n\
} catch( e ) {\n\
\t// Use the href attribute of an A element\n\
\t// since IE will modify it given document.location\n\
\tajaxLocation = document.createElement( \"a\" );\n\
\tajaxLocation.href = \"\";\n\
\tajaxLocation = ajaxLocation.href;\n\
}\n\
\n\
// Segment location into parts\n\
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\
\n\
// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\
function addToPrefiltersOrTransports( structure ) {\n\
\n\
\t// dataTypeExpression is optional and defaults to \"*\"\n\
\treturn function( dataTypeExpression, func ) {\n\
\n\
\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\
\t\t\tfunc = dataTypeExpression;\n\
\t\t\tdataTypeExpression = \"*\";\n\
\t\t}\n\
\n\
\t\tvar dataType,\n\
\t\t\ti = 0,\n\
\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];\n\
\n\
\t\tif ( jQuery.isFunction( func ) ) {\n\
\t\t\t// For each dataType in the dataTypeExpression\n\
\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\
\t\t\t\t// Prepend if requested\n\
\t\t\t\tif ( dataType[0] === \"+\" ) {\n\
\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\
\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\
\n\
\t\t\t\t// Otherwise append\n\
\t\t\t\t} else {\n\
\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t};\n\
}\n\
\n\
// Base inspection function for prefilters and transports\n\
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\
\n\
\tvar inspected = {},\n\
\t\tseekingTransport = ( structure === transports );\n\
\n\
\tfunction inspect( dataType ) {\n\
\t\tvar selected;\n\
\t\tinspected[ dataType ] = true;\n\
\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\
\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\
\t\t\tif( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\
\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\
\t\t\t\tinspect( dataTypeOrTransport );\n\
\t\t\t\treturn false;\n\
\t\t\t} else if ( seekingTransport ) {\n\
\t\t\t\treturn !( selected = dataTypeOrTransport );\n\
\t\t\t}\n\
\t\t});\n\
\t\treturn selected;\n\
\t}\n\
\n\
\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n\
}\n\
\n\
// A special extend for ajax options\n\
// that takes \"flat\" options (not to be deep extended)\n\
// Fixes #9887\n\
function ajaxExtend( target, src ) {\n\
\tvar deep, key,\n\
\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\
\n\
\tfor ( key in src ) {\n\
\t\tif ( src[ key ] !== undefined ) {\n\
\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\
\t\t}\n\
\t}\n\
\tif ( deep ) {\n\
\t\tjQuery.extend( true, target, deep );\n\
\t}\n\
\n\
\treturn target;\n\
}\n\
\n\
jQuery.fn.load = function( url, params, callback ) {\n\
\tif ( typeof url !== \"string\" && _load ) {\n\
\t\treturn _load.apply( this, arguments );\n\
\t}\n\
\n\
\tvar selector, response, type,\n\
\t\tself = this,\n\
\t\toff = url.indexOf(\" \");\n\
\n\
\tif ( off >= 0 ) {\n\
\t\tselector = url.slice( off, url.length );\n\
\t\turl = url.slice( 0, off );\n\
\t}\n\
\n\
\t// If it's a function\n\
\tif ( jQuery.isFunction( params ) ) {\n\
\n\
\t\t// We assume that it's the callback\n\
\t\tcallback = params;\n\
\t\tparams = undefined;\n\
\n\
\t// Otherwise, build a param string\n\
\t} else if ( params && typeof params === \"object\" ) {\n\
\t\ttype = \"POST\";\n\
\t}\n\
\n\
\t// If we have elements to modify, make the request\n\
\tif ( self.length > 0 ) {\n\
\t\tjQuery.ajax({\n\
\t\t\turl: url,\n\
\n\
\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\
\t\t\ttype: type,\n\
\t\t\tdataType: \"html\",\n\
\t\t\tdata: params\n\
\t\t}).done(function( responseText ) {\n\
\n\
\t\t\t// Save response for use in complete callback\n\
\t\t\tresponse = arguments;\n\
\n\
\t\t\tself.html( selector ?\n\
\n\
\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\
\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\
\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\
\n\
\t\t\t\t// Otherwise use the full result\n\
\t\t\t\tresponseText );\n\
\n\
\t\t}).complete( callback && function( jqXHR, status ) {\n\
\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\
\t\t});\n\
\t}\n\
\n\
\treturn this;\n\
};\n\
\n\
// Attach a bunch of functions for handling common AJAX events\n\
jQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ){\n\
\tjQuery.fn[ type ] = function( fn ){\n\
\t\treturn this.on( type, fn );\n\
\t};\n\
});\n\
\n\
jQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\
\tjQuery[ method ] = function( url, data, callback, type ) {\n\
\t\t// shift arguments if data argument was omitted\n\
\t\tif ( jQuery.isFunction( data ) ) {\n\
\t\t\ttype = type || callback;\n\
\t\t\tcallback = data;\n\
\t\t\tdata = undefined;\n\
\t\t}\n\
\n\
\t\treturn jQuery.ajax({\n\
\t\t\turl: url,\n\
\t\t\ttype: method,\n\
\t\t\tdataType: type,\n\
\t\t\tdata: data,\n\
\t\t\tsuccess: callback\n\
\t\t});\n\
\t};\n\
});\n\
\n\
jQuery.extend({\n\
\n\
\t// Counter for holding the number of active queries\n\
\tactive: 0,\n\
\n\
\t// Last-Modified header cache for next request\n\
\tlastModified: {},\n\
\tetag: {},\n\
\n\
\tajaxSettings: {\n\
\t\turl: ajaxLocation,\n\
\t\ttype: \"GET\",\n\
\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\
\t\tglobal: true,\n\
\t\tprocessData: true,\n\
\t\tasync: true,\n\
\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\
\t\t/*\n\
\t\ttimeout: 0,\n\
\t\tdata: null,\n\
\t\tdataType: null,\n\
\t\tusername: null,\n\
\t\tpassword: null,\n\
\t\tcache: null,\n\
\t\tthrows: false,\n\
\t\ttraditional: false,\n\
\t\theaders: {},\n\
\t\t*/\n\
\n\
\t\taccepts: {\n\
\t\t\t\"*\": allTypes,\n\
\t\t\ttext: \"text/plain\",\n\
\t\t\thtml: \"text/html\",\n\
\t\t\txml: \"application/xml, text/xml\",\n\
\t\t\tjson: \"application/json, text/javascript\"\n\
\t\t},\n\
\n\
\t\tcontents: {\n\
\t\t\txml: /xml/,\n\
\t\t\thtml: /html/,\n\
\t\t\tjson: /json/\n\
\t\t},\n\
\n\
\t\tresponseFields: {\n\
\t\t\txml: \"responseXML\",\n\
\t\t\ttext: \"responseText\"\n\
\t\t},\n\
\n\
\t\t// Data converters\n\
\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\
\t\tconverters: {\n\
\n\
\t\t\t// Convert anything to text\n\
\t\t\t\"* text\": window.String,\n\
\n\
\t\t\t// Text to html (true = no transformation)\n\
\t\t\t\"text html\": true,\n\
\n\
\t\t\t// Evaluate text as a json expression\n\
\t\t\t\"text json\": jQuery.parseJSON,\n\
\n\
\t\t\t// Parse text as xml\n\
\t\t\t\"text xml\": jQuery.parseXML\n\
\t\t},\n\
\n\
\t\t// For options that shouldn't be deep extended:\n\
\t\t// you can add your own custom options here if\n\
\t\t// and when you create one that shouldn't be\n\
\t\t// deep extended (see ajaxExtend)\n\
\t\tflatOptions: {\n\
\t\t\turl: true,\n\
\t\t\tcontext: true\n\
\t\t}\n\
\t},\n\
\n\
\t// Creates a full fledged settings object into target\n\
\t// with both ajaxSettings and settings fields.\n\
\t// If target is omitted, writes into ajaxSettings.\n\
\tajaxSetup: function( target, settings ) {\n\
\t\treturn settings ?\n\
\n\
\t\t\t// Building a settings object\n\
\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\
\n\
\t\t\t// Extending ajaxSettings\n\
\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\
\t},\n\
\n\
\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\
\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\
\n\
\t// Main method\n\
\tajax: function( url, options ) {\n\
\n\
\t\t// If url is an object, simulate pre-1.5 signature\n\
\t\tif ( typeof url === \"object\" ) {\n\
\t\t\toptions = url;\n\
\t\t\turl = undefined;\n\
\t\t}\n\
\n\
\t\t// Force options to be an object\n\
\t\toptions = options || {};\n\
\n\
\t\tvar // Cross-domain detection vars\n\
\t\t\tparts,\n\
\t\t\t// Loop variable\n\
\t\t\ti,\n\
\t\t\t// URL without anti-cache param\n\
\t\t\tcacheURL,\n\
\t\t\t// Response headers as string\n\
\t\t\tresponseHeadersString,\n\
\t\t\t// timeout handle\n\
\t\t\ttimeoutTimer,\n\
\n\
\t\t\t// To know if global events are to be dispatched\n\
\t\t\tfireGlobals,\n\
\n\
\t\t\ttransport,\n\
\t\t\t// Response headers\n\
\t\t\tresponseHeaders,\n\
\t\t\t// Create the final options object\n\
\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\
\t\t\t// Callbacks context\n\
\t\t\tcallbackContext = s.context || s,\n\
\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\
\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\
\t\t\t\tjQuery( callbackContext ) :\n\
\t\t\t\tjQuery.event,\n\
\t\t\t// Deferreds\n\
\t\t\tdeferred = jQuery.Deferred(),\n\
\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\
\t\t\t// Status-dependent callbacks\n\
\t\t\tstatusCode = s.statusCode || {},\n\
\t\t\t// Headers (they are sent all at once)\n\
\t\t\trequestHeaders = {},\n\
\t\t\trequestHeadersNames = {},\n\
\t\t\t// The jqXHR state\n\
\t\t\tstate = 0,\n\
\t\t\t// Default abort message\n\
\t\t\tstrAbort = \"canceled\",\n\
\t\t\t// Fake xhr\n\
\t\t\tjqXHR = {\n\
\t\t\t\treadyState: 0,\n\
\n\
\t\t\t\t// Builds headers hashtable if needed\n\
\t\t\t\tgetResponseHeader: function( key ) {\n\
\t\t\t\t\tvar match;\n\
\t\t\t\t\tif ( state === 2 ) {\n\
\t\t\t\t\t\tif ( !responseHeaders ) {\n\
\t\t\t\t\t\t\tresponseHeaders = {};\n\
\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\
\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\
\t\t\t\t\t}\n\
\t\t\t\t\treturn match == null ? null : match;\n\
\t\t\t\t},\n\
\n\
\t\t\t\t// Raw string\n\
\t\t\t\tgetAllResponseHeaders: function() {\n\
\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\
\t\t\t\t},\n\
\n\
\t\t\t\t// Caches the header\n\
\t\t\t\tsetRequestHeader: function( name, value ) {\n\
\t\t\t\t\tvar lname = name.toLowerCase();\n\
\t\t\t\t\tif ( !state ) {\n\
\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\
\t\t\t\t\t\trequestHeaders[ name ] = value;\n\
\t\t\t\t\t}\n\
\t\t\t\t\treturn this;\n\
\t\t\t\t},\n\
\n\
\t\t\t\t// Overrides response content-type header\n\
\t\t\t\toverrideMimeType: function( type ) {\n\
\t\t\t\t\tif ( !state ) {\n\
\t\t\t\t\t\ts.mimeType = type;\n\
\t\t\t\t\t}\n\
\t\t\t\t\treturn this;\n\
\t\t\t\t},\n\
\n\
\t\t\t\t// Status-dependent callbacks\n\
\t\t\t\tstatusCode: function( map ) {\n\
\t\t\t\t\tvar code;\n\
\t\t\t\t\tif ( map ) {\n\
\t\t\t\t\t\tif ( state < 2 ) {\n\
\t\t\t\t\t\t\tfor ( code in map ) {\n\
\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\
\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t} else {\n\
\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\
\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t\treturn this;\n\
\t\t\t\t},\n\
\n\
\t\t\t\t// Cancel the request\n\
\t\t\t\tabort: function( statusText ) {\n\
\t\t\t\t\tvar finalText = statusText || strAbort;\n\
\t\t\t\t\tif ( transport ) {\n\
\t\t\t\t\t\ttransport.abort( finalText );\n\
\t\t\t\t\t}\n\
\t\t\t\t\tdone( 0, finalText );\n\
\t\t\t\t\treturn this;\n\
\t\t\t\t}\n\
\t\t\t};\n\
\n\
\t\t// Attach deferreds\n\
\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\
\t\tjqXHR.success = jqXHR.done;\n\
\t\tjqXHR.error = jqXHR.fail;\n\
\n\
\t\t// Remove hash character (#7531: and string promotion)\n\
\t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n\
\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\
\t\t// We also use the url parameter if available\n\
\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\
\n\
\t\t// Alias method option to type as per ticket #12004\n\
\t\ts.type = options.method || options.type || s.method || s.type;\n\
\n\
\t\t// Extract dataTypes list\n\
\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( core_rnotwhite ) || [\"\"];\n\
\n\
\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\
\t\tif ( s.crossDomain == null ) {\n\
\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\
\t\t\ts.crossDomain = !!( parts &&\n\
\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\
\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? 80 : 443 ) ) !=\n\
\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? 80 : 443 ) ) )\n\
\t\t\t);\n\
\t\t}\n\
\n\
\t\t// Convert data if not already a string\n\
\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\
\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\
\t\t}\n\
\n\
\t\t// Apply prefilters\n\
\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\
\n\
\t\t// If request was aborted inside a prefilter, stop there\n\
\t\tif ( state === 2 ) {\n\
\t\t\treturn jqXHR;\n\
\t\t}\n\
\n\
\t\t// We can fire global events as of now if asked to\n\
\t\tfireGlobals = s.global;\n\
\n\
\t\t// Watch for a new set of requests\n\
\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\
\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\
\t\t}\n\
\n\
\t\t// Uppercase the type\n\
\t\ts.type = s.type.toUpperCase();\n\
\n\
\t\t// Determine if request has content\n\
\t\ts.hasContent = !rnoContent.test( s.type );\n\
\n\
\t\t// Save the URL in case we're toying with the If-Modified-Since\n\
\t\t// and/or If-None-Match header later on\n\
\t\tcacheURL = s.url;\n\
\n\
\t\t// More options handling for requests with no content\n\
\t\tif ( !s.hasContent ) {\n\
\n\
\t\t\t// If data is available, append data to url\n\
\t\t\tif ( s.data ) {\n\
\t\t\t\tcacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\
\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\
\t\t\t\tdelete s.data;\n\
\t\t\t}\n\
\n\
\t\t\t// Add anti-cache in url if needed\n\
\t\t\tif ( s.cache === false ) {\n\
\t\t\t\ts.url = rts.test( cacheURL ) ?\n\
\n\
\t\t\t\t\t// If there is already a '_' parameter, set its value\n\
\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + ajax_nonce++ ) :\n\
\n\
\t\t\t\t\t// Otherwise add one to the end\n\
\t\t\t\t\tcacheURL + ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ajax_nonce++;\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\
\t\tif ( s.ifModified ) {\n\
\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\
\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\
\t\t\t}\n\
\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\
\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Set the correct header, if data is being sent\n\
\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\
\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\
\t\t}\n\
\n\
\t\t// Set the Accepts header for the server, depending on the dataType\n\
\t\tjqXHR.setRequestHeader(\n\
\t\t\t\"Accept\",\n\
\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\
\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\
\t\t\t\ts.accepts[ \"*\" ]\n\
\t\t);\n\
\n\
\t\t// Check for headers option\n\
\t\tfor ( i in s.headers ) {\n\
\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\
\t\t}\n\
\n\
\t\t// Allow custom headers/mimetypes and early abort\n\
\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\
\t\t\t// Abort if not done already and return\n\
\t\t\treturn jqXHR.abort();\n\
\t\t}\n\
\n\
\t\t// aborting is no longer a cancellation\n\
\t\tstrAbort = \"abort\";\n\
\n\
\t\t// Install callbacks on deferreds\n\
\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\
\t\t\tjqXHR[ i ]( s[ i ] );\n\
\t\t}\n\
\n\
\t\t// Get transport\n\
\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\
\n\
\t\t// If no transport, we auto-abort\n\
\t\tif ( !transport ) {\n\
\t\t\tdone( -1, \"No Transport\" );\n\
\t\t} else {\n\
\t\t\tjqXHR.readyState = 1;\n\
\n\
\t\t\t// Send global event\n\
\t\t\tif ( fireGlobals ) {\n\
\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\
\t\t\t}\n\
\t\t\t// Timeout\n\
\t\t\tif ( s.async && s.timeout > 0 ) {\n\
\t\t\t\ttimeoutTimer = setTimeout(function() {\n\
\t\t\t\t\tjqXHR.abort(\"timeout\");\n\
\t\t\t\t}, s.timeout );\n\
\t\t\t}\n\
\n\
\t\t\ttry {\n\
\t\t\t\tstate = 1;\n\
\t\t\t\ttransport.send( requestHeaders, done );\n\
\t\t\t} catch ( e ) {\n\
\t\t\t\t// Propagate exception as error if not done\n\
\t\t\t\tif ( state < 2 ) {\n\
\t\t\t\t\tdone( -1, e );\n\
\t\t\t\t// Simply rethrow otherwise\n\
\t\t\t\t} else {\n\
\t\t\t\t\tthrow e;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\t// Callback for when everything is done\n\
\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\
\t\t\tvar isSuccess, success, error, response, modified,\n\
\t\t\t\tstatusText = nativeStatusText;\n\
\n\
\t\t\t// Called once\n\
\t\t\tif ( state === 2 ) {\n\
\t\t\t\treturn;\n\
\t\t\t}\n\
\n\
\t\t\t// State is \"done\" now\n\
\t\t\tstate = 2;\n\
\n\
\t\t\t// Clear timeout if it exists\n\
\t\t\tif ( timeoutTimer ) {\n\
\t\t\t\tclearTimeout( timeoutTimer );\n\
\t\t\t}\n\
\n\
\t\t\t// Dereference transport for early garbage collection\n\
\t\t\t// (no matter how long the jqXHR object will be used)\n\
\t\t\ttransport = undefined;\n\
\n\
\t\t\t// Cache response headers\n\
\t\t\tresponseHeadersString = headers || \"\";\n\
\n\
\t\t\t// Set readyState\n\
\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\
\n\
\t\t\t// Get response data\n\
\t\t\tif ( responses ) {\n\
\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\
\t\t\t}\n\
\n\
\t\t\t// If successful, handle type chaining\n\
\t\t\tif ( status >= 200 && status < 300 || status === 304 ) {\n\
\n\
\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\
\t\t\t\tif ( s.ifModified ) {\n\
\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\
\t\t\t\t\tif ( modified ) {\n\
\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\
\t\t\t\t\t}\n\
\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\
\t\t\t\t\tif ( modified ) {\n\
\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// if no content\n\
\t\t\t\tif ( status === 204 ) {\n\
\t\t\t\t\tisSuccess = true;\n\
\t\t\t\t\tstatusText = \"nocontent\";\n\
\n\
\t\t\t\t// if not modified\n\
\t\t\t\t} else if ( status === 304 ) {\n\
\t\t\t\t\tisSuccess = true;\n\
\t\t\t\t\tstatusText = \"notmodified\";\n\
\n\
\t\t\t\t// If we have data, let's convert it\n\
\t\t\t\t} else {\n\
\t\t\t\t\tisSuccess = ajaxConvert( s, response );\n\
\t\t\t\t\tstatusText = isSuccess.state;\n\
\t\t\t\t\tsuccess = isSuccess.data;\n\
\t\t\t\t\terror = isSuccess.error;\n\
\t\t\t\t\tisSuccess = !error;\n\
\t\t\t\t}\n\
\t\t\t} else {\n\
\t\t\t\t// We extract error from statusText\n\
\t\t\t\t// then normalize statusText and status for non-aborts\n\
\t\t\t\terror = statusText;\n\
\t\t\t\tif ( status || !statusText ) {\n\
\t\t\t\t\tstatusText = \"error\";\n\
\t\t\t\t\tif ( status < 0 ) {\n\
\t\t\t\t\t\tstatus = 0;\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\t// Set data for the fake xhr object\n\
\t\t\tjqXHR.status = status;\n\
\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\
\n\
\t\t\t// Success/Error\n\
\t\t\tif ( isSuccess ) {\n\
\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\
\t\t\t} else {\n\
\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\
\t\t\t}\n\
\n\
\t\t\t// Status-dependent callbacks\n\
\t\t\tjqXHR.statusCode( statusCode );\n\
\t\t\tstatusCode = undefined;\n\
\n\
\t\t\tif ( fireGlobals ) {\n\
\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\
\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\
\t\t\t}\n\
\n\
\t\t\t// Complete\n\
\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\
\n\
\t\t\tif ( fireGlobals ) {\n\
\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\
\t\t\t\t// Handle the global AJAX counter\n\
\t\t\t\tif ( !( --jQuery.active ) ) {\n\
\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\n\
\t\treturn jqXHR;\n\
\t},\n\
\n\
\tgetScript: function( url, callback ) {\n\
\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\
\t},\n\
\n\
\tgetJSON: function( url, data, callback ) {\n\
\t\treturn jQuery.get( url, data, callback, \"json\" );\n\
\t}\n\
});\n\
\n\
/* Handles responses to an ajax request:\n\
 * - sets all responseXXX fields accordingly\n\
 * - finds the right dataType (mediates between content-type and expected dataType)\n\
 * - returns the corresponding response\n\
 */\n\
function ajaxHandleResponses( s, jqXHR, responses ) {\n\
\tvar firstDataType, ct, finalDataType, type,\n\
\t\tcontents = s.contents,\n\
\t\tdataTypes = s.dataTypes,\n\
\t\tresponseFields = s.responseFields;\n\
\n\
\t// Fill responseXXX fields\n\
\tfor ( type in responseFields ) {\n\
\t\tif ( type in responses ) {\n\
\t\t\tjqXHR[ responseFields[type] ] = responses[ type ];\n\
\t\t}\n\
\t}\n\
\n\
\t// Remove auto dataType and get content-type in the process\n\
\twhile( dataTypes[ 0 ] === \"*\" ) {\n\
\t\tdataTypes.shift();\n\
\t\tif ( ct === undefined ) {\n\
\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\
\t\t}\n\
\t}\n\
\n\
\t// Check if we're dealing with a known content-type\n\
\tif ( ct ) {\n\
\t\tfor ( type in contents ) {\n\
\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\
\t\t\t\tdataTypes.unshift( type );\n\
\t\t\t\tbreak;\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\t// Check to see if we have a response for the expected dataType\n\
\tif ( dataTypes[ 0 ] in responses ) {\n\
\t\tfinalDataType = dataTypes[ 0 ];\n\
\t} else {\n\
\t\t// Try convertible dataTypes\n\
\t\tfor ( type in responses ) {\n\
\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\
\t\t\t\tfinalDataType = type;\n\
\t\t\t\tbreak;\n\
\t\t\t}\n\
\t\t\tif ( !firstDataType ) {\n\
\t\t\t\tfirstDataType = type;\n\
\t\t\t}\n\
\t\t}\n\
\t\t// Or just use first one\n\
\t\tfinalDataType = finalDataType || firstDataType;\n\
\t}\n\
\n\
\t// If we found a dataType\n\
\t// We add the dataType to the list if needed\n\
\t// and return the corresponding response\n\
\tif ( finalDataType ) {\n\
\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\
\t\t\tdataTypes.unshift( finalDataType );\n\
\t\t}\n\
\t\treturn responses[ finalDataType ];\n\
\t}\n\
}\n\
\n\
// Chain conversions given the request and the original response\n\
function ajaxConvert( s, response ) {\n\
\tvar conv2, current, conv, tmp,\n\
\t\tconverters = {},\n\
\t\ti = 0,\n\
\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\
\t\tdataTypes = s.dataTypes.slice(),\n\
\t\tprev = dataTypes[ 0 ];\n\
\n\
\t// Apply the dataFilter if provided\n\
\tif ( s.dataFilter ) {\n\
\t\tresponse = s.dataFilter( response, s.dataType );\n\
\t}\n\
\n\
\t// Create converters map with lowercased keys\n\
\tif ( dataTypes[ 1 ] ) {\n\
\t\tfor ( conv in s.converters ) {\n\
\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\
\t\t}\n\
\t}\n\
\n\
\t// Convert to each sequential dataType, tolerating list modification\n\
\tfor ( ; (current = dataTypes[++i]); ) {\n\
\n\
\t\t// There's only work to do if current dataType is non-auto\n\
\t\tif ( current !== \"*\" ) {\n\
\n\
\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\
\t\t\tif ( prev !== \"*\" && prev !== current ) {\n\
\n\
\t\t\t\t// Seek a direct converter\n\
\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\
\n\
\t\t\t\t// If none found, seek a pair\n\
\t\t\t\tif ( !conv ) {\n\
\t\t\t\t\tfor ( conv2 in converters ) {\n\
\n\
\t\t\t\t\t\t// If conv2 outputs current\n\
\t\t\t\t\t\ttmp = conv2.split(\" \");\n\
\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\
\n\
\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\
\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\
\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\
\t\t\t\t\t\t\tif ( conv ) {\n\
\t\t\t\t\t\t\t\t// Condense equivalence converters\n\
\t\t\t\t\t\t\t\tif ( conv === true ) {\n\
\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\
\n\
\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\
\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\
\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\
\t\t\t\t\t\t\t\t\tdataTypes.splice( i--, 0, current );\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\tbreak;\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// Apply converter (if not an equivalence)\n\
\t\t\t\tif ( conv !== true ) {\n\
\n\
\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\
\t\t\t\t\tif ( conv && s[\"throws\"] ) {\n\
\t\t\t\t\t\tresponse = conv( response );\n\
\t\t\t\t\t} else {\n\
\t\t\t\t\t\ttry {\n\
\t\t\t\t\t\t\tresponse = conv( response );\n\
\t\t\t\t\t\t} catch ( e ) {\n\
\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\t// Update prev for next iteration\n\
\t\t\tprev = current;\n\
\t\t}\n\
\t}\n\
\n\
\treturn { state: \"success\", data: response };\n\
}\n\
// Install script dataType\n\
jQuery.ajaxSetup({\n\
\taccepts: {\n\
\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\
\t},\n\
\tcontents: {\n\
\t\tscript: /(?:java|ecma)script/\n\
\t},\n\
\tconverters: {\n\
\t\t\"text script\": function( text ) {\n\
\t\t\tjQuery.globalEval( text );\n\
\t\t\treturn text;\n\
\t\t}\n\
\t}\n\
});\n\
\n\
// Handle cache's special case and global\n\
jQuery.ajaxPrefilter( \"script\", function( s ) {\n\
\tif ( s.cache === undefined ) {\n\
\t\ts.cache = false;\n\
\t}\n\
\tif ( s.crossDomain ) {\n\
\t\ts.type = \"GET\";\n\
\t\ts.global = false;\n\
\t}\n\
});\n\
\n\
// Bind script tag hack transport\n\
jQuery.ajaxTransport( \"script\", function(s) {\n\
\n\
\t// This transport only deals with cross domain requests\n\
\tif ( s.crossDomain ) {\n\
\n\
\t\tvar script,\n\
\t\t\thead = document.head || jQuery(\"head\")[0] || document.documentElement;\n\
\n\
\t\treturn {\n\
\n\
\t\t\tsend: function( _, callback ) {\n\
\n\
\t\t\t\tscript = document.createElement(\"script\");\n\
\n\
\t\t\t\tscript.async = true;\n\
\n\
\t\t\t\tif ( s.scriptCharset ) {\n\
\t\t\t\t\tscript.charset = s.scriptCharset;\n\
\t\t\t\t}\n\
\n\
\t\t\t\tscript.src = s.url;\n\
\n\
\t\t\t\t// Attach handlers for all browsers\n\
\t\t\t\tscript.onload = script.onreadystatechange = function( _, isAbort ) {\n\
\n\
\t\t\t\t\tif ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\
\n\
\t\t\t\t\t\t// Handle memory leak in IE\n\
\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\
\n\
\t\t\t\t\t\t// Remove the script\n\
\t\t\t\t\t\tif ( script.parentNode ) {\n\
\t\t\t\t\t\t\tscript.parentNode.removeChild( script );\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t// Dereference the script\n\
\t\t\t\t\t\tscript = null;\n\
\n\
\t\t\t\t\t\t// Callback if not abort\n\
\t\t\t\t\t\tif ( !isAbort ) {\n\
\t\t\t\t\t\t\tcallback( 200, \"success\" );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\t\t\t\t};\n\
\n\
\t\t\t\t// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n\
\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\
\t\t\t\thead.insertBefore( script, head.firstChild );\n\
\t\t\t},\n\
\n\
\t\t\tabort: function() {\n\
\t\t\t\tif ( script ) {\n\
\t\t\t\t\tscript.onload( undefined, true );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t};\n\
\t}\n\
});\n\
var oldCallbacks = [],\n\
\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\
\n\
// Default jsonp settings\n\
jQuery.ajaxSetup({\n\
\tjsonp: \"callback\",\n\
\tjsonpCallback: function() {\n\
\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( ajax_nonce++ ) );\n\
\t\tthis[ callback ] = true;\n\
\t\treturn callback;\n\
\t}\n\
});\n\
\n\
// Detect, normalize options and install callbacks for jsonp requests\n\
jQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\
\n\
\tvar callbackName, overwritten, responseContainer,\n\
\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\
\t\t\t\"url\" :\n\
\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\
\t\t);\n\
\n\
\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\
\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\
\n\
\t\t// Get callback name, remembering preexisting value associated with it\n\
\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\
\t\t\ts.jsonpCallback() :\n\
\t\t\ts.jsonpCallback;\n\
\n\
\t\t// Insert callback into url or form data\n\
\t\tif ( jsonProp ) {\n\
\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\
\t\t} else if ( s.jsonp !== false ) {\n\
\t\t\ts.url += ( ajax_rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\
\t\t}\n\
\n\
\t\t// Use data converter to retrieve json after script execution\n\
\t\ts.converters[\"script json\"] = function() {\n\
\t\t\tif ( !responseContainer ) {\n\
\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\
\t\t\t}\n\
\t\t\treturn responseContainer[ 0 ];\n\
\t\t};\n\
\n\
\t\t// force json dataType\n\
\t\ts.dataTypes[ 0 ] = \"json\";\n\
\n\
\t\t// Install callback\n\
\t\toverwritten = window[ callbackName ];\n\
\t\twindow[ callbackName ] = function() {\n\
\t\t\tresponseContainer = arguments;\n\
\t\t};\n\
\n\
\t\t// Clean-up function (fires after converters)\n\
\t\tjqXHR.always(function() {\n\
\t\t\t// Restore preexisting value\n\
\t\t\twindow[ callbackName ] = overwritten;\n\
\n\
\t\t\t// Save back as free\n\
\t\t\tif ( s[ callbackName ] ) {\n\
\t\t\t\t// make sure that re-using the options doesn't screw things around\n\
\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\
\n\
\t\t\t\t// save the callback name for future use\n\
\t\t\t\toldCallbacks.push( callbackName );\n\
\t\t\t}\n\
\n\
\t\t\t// Call if it was a function and we have a response\n\
\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\
\t\t\t\toverwritten( responseContainer[ 0 ] );\n\
\t\t\t}\n\
\n\
\t\t\tresponseContainer = overwritten = undefined;\n\
\t\t});\n\
\n\
\t\t// Delegate to script\n\
\t\treturn \"script\";\n\
\t}\n\
});\n\
var xhrCallbacks, xhrSupported,\n\
\txhrId = 0,\n\
\t// #5280: Internet Explorer will keep connections alive if we don't abort on unload\n\
\txhrOnUnloadAbort = window.ActiveXObject && function() {\n\
\t\t// Abort all pending requests\n\
\t\tvar key;\n\
\t\tfor ( key in xhrCallbacks ) {\n\
\t\t\txhrCallbacks[ key ]( undefined, true );\n\
\t\t}\n\
\t};\n\
\n\
// Functions to create xhrs\n\
function createStandardXHR() {\n\
\ttry {\n\
\t\treturn new window.XMLHttpRequest();\n\
\t} catch( e ) {}\n\
}\n\
\n\
function createActiveXHR() {\n\
\ttry {\n\
\t\treturn new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n\
\t} catch( e ) {}\n\
}\n\
\n\
// Create the request object\n\
// (This is still attached to ajaxSettings for backward compatibility)\n\
jQuery.ajaxSettings.xhr = window.ActiveXObject ?\n\
\t/* Microsoft failed to properly\n\
\t * implement the XMLHttpRequest in IE7 (can't request local files),\n\
\t * so we use the ActiveXObject when it is available\n\
\t * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n\
\t * we need a fallback.\n\
\t */\n\
\tfunction() {\n\
\t\treturn !this.isLocal && createStandardXHR() || createActiveXHR();\n\
\t} :\n\
\t// For all other browsers, use the standard XMLHttpRequest object\n\
\tcreateStandardXHR;\n\
\n\
// Determine support properties\n\
xhrSupported = jQuery.ajaxSettings.xhr();\n\
jQuery.support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\n\
xhrSupported = jQuery.support.ajax = !!xhrSupported;\n\
\n\
// Create transport if the browser can provide an xhr\n\
if ( xhrSupported ) {\n\
\n\
\tjQuery.ajaxTransport(function( s ) {\n\
\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\
\t\tif ( !s.crossDomain || jQuery.support.cors ) {\n\
\n\
\t\t\tvar callback;\n\
\n\
\t\t\treturn {\n\
\t\t\t\tsend: function( headers, complete ) {\n\
\n\
\t\t\t\t\t// Get a new xhr\n\
\t\t\t\t\tvar handle, i,\n\
\t\t\t\t\t\txhr = s.xhr();\n\
\n\
\t\t\t\t\t// Open the socket\n\
\t\t\t\t\t// Passing null username, generates a login popup on Opera (#2865)\n\
\t\t\t\t\tif ( s.username ) {\n\
\t\t\t\t\t\txhr.open( s.type, s.url, s.async, s.username, s.password );\n\
\t\t\t\t\t} else {\n\
\t\t\t\t\t\txhr.open( s.type, s.url, s.async );\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Apply custom fields if provided\n\
\t\t\t\t\tif ( s.xhrFields ) {\n\
\t\t\t\t\t\tfor ( i in s.xhrFields ) {\n\
\t\t\t\t\t\t\txhr[ i ] = s.xhrFields[ i ];\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Override mime type if needed\n\
\t\t\t\t\tif ( s.mimeType && xhr.overrideMimeType ) {\n\
\t\t\t\t\t\txhr.overrideMimeType( s.mimeType );\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// X-Requested-With header\n\
\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\
\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\
\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\
\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\
\t\t\t\t\tif ( !s.crossDomain && !headers[\"X-Requested-With\"] ) {\n\
\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\
\t\t\t\t\t}\n\
\n\
\t\t\t\t\t// Need an extra try/catch for cross domain requests in Firefox 3\n\
\t\t\t\t\ttry {\n\
\t\t\t\t\t\tfor ( i in headers ) {\n\
\t\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t} catch( err ) {}\n\
\n\
\t\t\t\t\t// Do send the request\n\
\t\t\t\t\t// This may raise an exception which is actually\n\
\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\
\t\t\t\t\txhr.send( ( s.hasContent && s.data ) || null );\n\
\n\
\t\t\t\t\t// Listener\n\
\t\t\t\t\tcallback = function( _, isAbort ) {\n\
\t\t\t\t\t\tvar status, responseHeaders, statusText, responses;\n\
\n\
\t\t\t\t\t\t// Firefox throws exceptions when accessing properties\n\
\t\t\t\t\t\t// of an xhr when a network error occurred\n\
\t\t\t\t\t\t// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n\
\t\t\t\t\t\ttry {\n\
\n\
\t\t\t\t\t\t\t// Was never called and is aborted or complete\n\
\t\t\t\t\t\t\tif ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\
\n\
\t\t\t\t\t\t\t\t// Only called once\n\
\t\t\t\t\t\t\t\tcallback = undefined;\n\
\n\
\t\t\t\t\t\t\t\t// Do not keep as active anymore\n\
\t\t\t\t\t\t\t\tif ( handle ) {\n\
\t\t\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n\
\t\t\t\t\t\t\t\t\tif ( xhrOnUnloadAbort ) {\n\
\t\t\t\t\t\t\t\t\t\tdelete xhrCallbacks[ handle ];\n\
\t\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\t// If it's an abort\n\
\t\t\t\t\t\t\t\tif ( isAbort ) {\n\
\t\t\t\t\t\t\t\t\t// Abort it manually if needed\n\
\t\t\t\t\t\t\t\t\tif ( xhr.readyState !== 4 ) {\n\
\t\t\t\t\t\t\t\t\t\txhr.abort();\n\
\t\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t\t} else {\n\
\t\t\t\t\t\t\t\t\tresponses = {};\n\
\t\t\t\t\t\t\t\t\tstatus = xhr.status;\n\
\t\t\t\t\t\t\t\t\tresponseHeaders = xhr.getAllResponseHeaders();\n\
\n\
\t\t\t\t\t\t\t\t\t// When requesting binary data, IE6-9 will throw an exception\n\
\t\t\t\t\t\t\t\t\t// on any attempt to access responseText (#11426)\n\
\t\t\t\t\t\t\t\t\tif ( typeof xhr.responseText === \"string\" ) {\n\
\t\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\
\t\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n\
\t\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n\
\t\t\t\t\t\t\t\t\ttry {\n\
\t\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n\
\t\t\t\t\t\t\t\t\t} catch( e ) {\n\
\t\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n\
\t\t\t\t\t\t\t\t\t\tstatusText = \"\";\n\
\t\t\t\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n\
\n\
\t\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n\
\t\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n\
\t\t\t\t\t\t\t\t\t// can do given current implementations)\n\
\t\t\t\t\t\t\t\t\tif ( !status && s.isLocal && !s.crossDomain ) {\n\
\t\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n\
\t\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n\
\t\t\t\t\t\t\t\t\t} else if ( status === 1223 ) {\n\
\t\t\t\t\t\t\t\t\t\tstatus = 204;\n\
\t\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t} catch( firefoxAccessException ) {\n\
\t\t\t\t\t\t\tif ( !isAbort ) {\n\
\t\t\t\t\t\t\t\tcomplete( -1, firefoxAccessException );\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t}\n\
\n\
\t\t\t\t\t\t// Call complete if needed\n\
\t\t\t\t\t\tif ( responses ) {\n\
\t\t\t\t\t\t\tcomplete( status, statusText, responses, responseHeaders );\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t};\n\
\n\
\t\t\t\t\tif ( !s.async ) {\n\
\t\t\t\t\t\t// if we're in sync mode we fire the callback\n\
\t\t\t\t\t\tcallback();\n\
\t\t\t\t\t} else if ( xhr.readyState === 4 ) {\n\
\t\t\t\t\t\t// (IE6 & IE7) if it's in cache and has been\n\
\t\t\t\t\t\t// retrieved directly we need to fire the callback\n\
\t\t\t\t\t\tsetTimeout( callback );\n\
\t\t\t\t\t} else {\n\
\t\t\t\t\t\thandle = ++xhrId;\n\
\t\t\t\t\t\tif ( xhrOnUnloadAbort ) {\n\
\t\t\t\t\t\t\t// Create the active xhrs callbacks list if needed\n\
\t\t\t\t\t\t\t// and attach the unload handler\n\
\t\t\t\t\t\t\tif ( !xhrCallbacks ) {\n\
\t\t\t\t\t\t\t\txhrCallbacks = {};\n\
\t\t\t\t\t\t\t\tjQuery( window ).unload( xhrOnUnloadAbort );\n\
\t\t\t\t\t\t\t}\n\
\t\t\t\t\t\t\t// Add to list of active xhrs callbacks\n\
\t\t\t\t\t\t\txhrCallbacks[ handle ] = callback;\n\
\t\t\t\t\t\t}\n\
\t\t\t\t\t\txhr.onreadystatechange = callback;\n\
\t\t\t\t\t}\n\
\t\t\t\t},\n\
\n\
\t\t\t\tabort: function() {\n\
\t\t\t\t\tif ( callback ) {\n\
\t\t\t\t\t\tcallback( undefined, true );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t};\n\
\t\t}\n\
\t});\n\
}\n\
var fxNow, timerId,\n\
\trfxtypes = /^(?:toggle|show|hide)$/,\n\
\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\" ),\n\
\trrun = /queueHooks$/,\n\
\tanimationPrefilters = [ defaultPrefilter ],\n\
\ttweeners = {\n\
\t\t\"*\": [function( prop, value ) {\n\
\t\t\tvar end, unit,\n\
\t\t\t\ttween = this.createTween( prop, value ),\n\
\t\t\t\tparts = rfxnum.exec( value ),\n\
\t\t\t\ttarget = tween.cur(),\n\
\t\t\t\tstart = +target || 0,\n\
\t\t\t\tscale = 1,\n\
\t\t\t\tmaxIterations = 20;\n\
\n\
\t\t\tif ( parts ) {\n\
\t\t\t\tend = +parts[2];\n\
\t\t\t\tunit = parts[3] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\
\n\
\t\t\t\t// We need to compute starting value\n\
\t\t\t\tif ( unit !== \"px\" && start ) {\n\
\t\t\t\t\t// Iteratively approximate from a nonzero starting point\n\
\t\t\t\t\t// Prefer the current property, because this process will be trivial if it uses the same units\n\
\t\t\t\t\t// Fallback to end or a simple constant\n\
\t\t\t\t\tstart = jQuery.css( tween.elem, prop, true ) || end || 1;\n\
\n\
\t\t\t\t\tdo {\n\
\t\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\
\t\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\
\t\t\t\t\t\tscale = scale || \".5\";\n\
\n\
\t\t\t\t\t\t// Adjust and apply\n\
\t\t\t\t\t\tstart = start / scale;\n\
\t\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\
\n\
\t\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\
\t\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\
\t\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\
\t\t\t\t}\n\
\n\
\t\t\t\ttween.unit = unit;\n\
\t\t\t\ttween.start = start;\n\
\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\
\t\t\t\ttween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;\n\
\t\t\t}\n\
\t\t\treturn tween;\n\
\t\t}]\n\
\t};\n\
\n\
// Animations created synchronously will run synchronously\n\
function createFxNow() {\n\
\tsetTimeout(function() {\n\
\t\tfxNow = undefined;\n\
\t});\n\
\treturn ( fxNow = jQuery.now() );\n\
}\n\
\n\
function createTweens( animation, props ) {\n\
\tjQuery.each( props, function( prop, value ) {\n\
\t\tvar collection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\
\t\t\tindex = 0,\n\
\t\t\tlength = collection.length;\n\
\t\tfor ( ; index < length; index++ ) {\n\
\t\t\tif ( collection[ index ].call( animation, prop, value ) ) {\n\
\n\
\t\t\t\t// we're done with this property\n\
\t\t\t\treturn;\n\
\t\t\t}\n\
\t\t}\n\
\t});\n\
}\n\
\n\
function Animation( elem, properties, options ) {\n\
\tvar result,\n\
\t\tstopped,\n\
\t\tindex = 0,\n\
\t\tlength = animationPrefilters.length,\n\
\t\tdeferred = jQuery.Deferred().always( function() {\n\
\t\t\t// don't match elem in the :animated selector\n\
\t\t\tdelete tick.elem;\n\
\t\t}),\n\
\t\ttick = function() {\n\
\t\t\tif ( stopped ) {\n\
\t\t\t\treturn false;\n\
\t\t\t}\n\
\t\t\tvar currentTime = fxNow || createFxNow(),\n\
\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\
\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\
\t\t\t\ttemp = remaining / animation.duration || 0,\n\
\t\t\t\tpercent = 1 - temp,\n\
\t\t\t\tindex = 0,\n\
\t\t\t\tlength = animation.tweens.length;\n\
\n\
\t\t\tfor ( ; index < length ; index++ ) {\n\
\t\t\t\tanimation.tweens[ index ].run( percent );\n\
\t\t\t}\n\
\n\
\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\
\n\
\t\t\tif ( percent < 1 && length ) {\n\
\t\t\t\treturn remaining;\n\
\t\t\t} else {\n\
\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\
\t\t\t\treturn false;\n\
\t\t\t}\n\
\t\t},\n\
\t\tanimation = deferred.promise({\n\
\t\t\telem: elem,\n\
\t\t\tprops: jQuery.extend( {}, properties ),\n\
\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\
\t\t\toriginalProperties: properties,\n\
\t\t\toriginalOptions: options,\n\
\t\t\tstartTime: fxNow || createFxNow(),\n\
\t\t\tduration: options.duration,\n\
\t\t\ttweens: [],\n\
\t\t\tcreateTween: function( prop, end ) {\n\
\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\
\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\
\t\t\t\tanimation.tweens.push( tween );\n\
\t\t\t\treturn tween;\n\
\t\t\t},\n\
\t\t\tstop: function( gotoEnd ) {\n\
\t\t\t\tvar index = 0,\n\
\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\
\t\t\t\t\t// otherwise we skip this part\n\
\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\
\t\t\t\tif ( stopped ) {\n\
\t\t\t\t\treturn this;\n\
\t\t\t\t}\n\
\t\t\t\tstopped = true;\n\
\t\t\t\tfor ( ; index < length ; index++ ) {\n\
\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// resolve when we played the last frame\n\
\t\t\t\t// otherwise, reject\n\
\t\t\t\tif ( gotoEnd ) {\n\
\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\
\t\t\t\t} else {\n\
\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\
\t\t\t\t}\n\
\t\t\t\treturn this;\n\
\t\t\t}\n\
\t\t}),\n\
\t\tprops = animation.props;\n\
\n\
\tpropFilter( props, animation.opts.specialEasing );\n\
\n\
\tfor ( ; index < length ; index++ ) {\n\
\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\
\t\tif ( result ) {\n\
\t\t\treturn result;\n\
\t\t}\n\
\t}\n\
\n\
\tcreateTweens( animation, props );\n\
\n\
\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\
\t\tanimation.opts.start.call( elem, animation );\n\
\t}\n\
\n\
\tjQuery.fx.timer(\n\
\t\tjQuery.extend( tick, {\n\
\t\t\telem: elem,\n\
\t\t\tanim: animation,\n\
\t\t\tqueue: animation.opts.queue\n\
\t\t})\n\
\t);\n\
\n\
\t// attach callbacks from options\n\
\treturn animation.progress( animation.opts.progress )\n\
\t\t.done( animation.opts.done, animation.opts.complete )\n\
\t\t.fail( animation.opts.fail )\n\
\t\t.always( animation.opts.always );\n\
}\n\
\n\
function propFilter( props, specialEasing ) {\n\
\tvar value, name, index, easing, hooks;\n\
\n\
\t// camelCase, specialEasing and expand cssHook pass\n\
\tfor ( index in props ) {\n\
\t\tname = jQuery.camelCase( index );\n\
\t\teasing = specialEasing[ name ];\n\
\t\tvalue = props[ index ];\n\
\t\tif ( jQuery.isArray( value ) ) {\n\
\t\t\teasing = value[ 1 ];\n\
\t\t\tvalue = props[ index ] = value[ 0 ];\n\
\t\t}\n\
\n\
\t\tif ( index !== name ) {\n\
\t\t\tprops[ name ] = value;\n\
\t\t\tdelete props[ index ];\n\
\t\t}\n\
\n\
\t\thooks = jQuery.cssHooks[ name ];\n\
\t\tif ( hooks && \"expand\" in hooks ) {\n\
\t\t\tvalue = hooks.expand( value );\n\
\t\t\tdelete props[ name ];\n\
\n\
\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\
\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\
\t\t\tfor ( index in value ) {\n\
\t\t\t\tif ( !( index in props ) ) {\n\
\t\t\t\t\tprops[ index ] = value[ index ];\n\
\t\t\t\t\tspecialEasing[ index ] = easing;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t} else {\n\
\t\t\tspecialEasing[ name ] = easing;\n\
\t\t}\n\
\t}\n\
}\n\
\n\
jQuery.Animation = jQuery.extend( Animation, {\n\
\n\
\ttweener: function( props, callback ) {\n\
\t\tif ( jQuery.isFunction( props ) ) {\n\
\t\t\tcallback = props;\n\
\t\t\tprops = [ \"*\" ];\n\
\t\t} else {\n\
\t\t\tprops = props.split(\" \");\n\
\t\t}\n\
\n\
\t\tvar prop,\n\
\t\t\tindex = 0,\n\
\t\t\tlength = props.length;\n\
\n\
\t\tfor ( ; index < length ; index++ ) {\n\
\t\t\tprop = props[ index ];\n\
\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\
\t\t\ttweeners[ prop ].unshift( callback );\n\
\t\t}\n\
\t},\n\
\n\
\tprefilter: function( callback, prepend ) {\n\
\t\tif ( prepend ) {\n\
\t\t\tanimationPrefilters.unshift( callback );\n\
\t\t} else {\n\
\t\t\tanimationPrefilters.push( callback );\n\
\t\t}\n\
\t}\n\
});\n\
\n\
function defaultPrefilter( elem, props, opts ) {\n\
\t/*jshint validthis:true */\n\
\tvar prop, index, length,\n\
\t\tvalue, dataShow, toggle,\n\
\t\ttween, hooks, oldfire,\n\
\t\tanim = this,\n\
\t\tstyle = elem.style,\n\
\t\torig = {},\n\
\t\thandled = [],\n\
\t\thidden = elem.nodeType && isHidden( elem );\n\
\n\
\t// handle queue: false promises\n\
\tif ( !opts.queue ) {\n\
\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\
\t\tif ( hooks.unqueued == null ) {\n\
\t\t\thooks.unqueued = 0;\n\
\t\t\toldfire = hooks.empty.fire;\n\
\t\t\thooks.empty.fire = function() {\n\
\t\t\t\tif ( !hooks.unqueued ) {\n\
\t\t\t\t\toldfire();\n\
\t\t\t\t}\n\
\t\t\t};\n\
\t\t}\n\
\t\thooks.unqueued++;\n\
\n\
\t\tanim.always(function() {\n\
\t\t\t// doing this makes sure that the complete handler will be called\n\
\t\t\t// before this completes\n\
\t\t\tanim.always(function() {\n\
\t\t\t\thooks.unqueued--;\n\
\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\
\t\t\t\t\thooks.empty.fire();\n\
\t\t\t\t}\n\
\t\t\t});\n\
\t\t});\n\
\t}\n\
\n\
\t// height/width overflow pass\n\
\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\
\t\t// Make sure that nothing sneaks out\n\
\t\t// Record all 3 overflow attributes because IE does not\n\
\t\t// change the overflow attribute when overflowX and\n\
\t\t// overflowY are set to the same value\n\
\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\
\n\
\t\t// Set display property to inline-block for height/width\n\
\t\t// animations on inline elements that are having width/height animated\n\
\t\tif ( jQuery.css( elem, \"display\" ) === \"inline\" &&\n\
\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\n\
\n\
\t\t\t// inline-level elements accept inline-block;\n\
\t\t\t// block-level elements need to be inline with layout\n\
\t\t\tif ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === \"inline\" ) {\n\
\t\t\t\tstyle.display = \"inline-block\";\n\
\n\
\t\t\t} else {\n\
\t\t\t\tstyle.zoom = 1;\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
\n\
\tif ( opts.overflow ) {\n\
\t\tstyle.overflow = \"hidden\";\n\
\t\tif ( !jQuery.support.shrinkWrapBlocks ) {\n\
\t\t\tanim.always(function() {\n\
\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\
\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\
\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\
\t\t\t});\n\
\t\t}\n\
\t}\n\
\n\
\n\
\t// show/hide pass\n\
\tfor ( index in props ) {\n\
\t\tvalue = props[ index ];\n\
\t\tif ( rfxtypes.exec( value ) ) {\n\
\t\t\tdelete props[ index ];\n\
\t\t\ttoggle = toggle || value === \"toggle\";\n\
\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\
\t\t\t\tcontinue;\n\
\t\t\t}\n\
\t\t\thandled.push( index );\n\
\t\t}\n\
\t}\n\
\n\
\tlength = handled.length;\n\
\tif ( length ) {\n\
\t\tdataShow = jQuery._data( elem, \"fxshow\" ) || jQuery._data( elem, \"fxshow\", {} );\n\
\t\tif ( \"hidden\" in dataShow ) {\n\
\t\t\thidden = dataShow.hidden;\n\
\t\t}\n\
\n\
\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\
\t\tif ( toggle ) {\n\
\t\t\tdataShow.hidden = !hidden;\n\
\t\t}\n\
\t\tif ( hidden ) {\n\
\t\t\tjQuery( elem ).show();\n\
\t\t} else {\n\
\t\t\tanim.done(function() {\n\
\t\t\t\tjQuery( elem ).hide();\n\
\t\t\t});\n\
\t\t}\n\
\t\tanim.done(function() {\n\
\t\t\tvar prop;\n\
\t\t\tjQuery._removeData( elem, \"fxshow\" );\n\
\t\t\tfor ( prop in orig ) {\n\
\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\
\t\t\t}\n\
\t\t});\n\
\t\tfor ( index = 0 ; index < length ; index++ ) {\n\
\t\t\tprop = handled[ index ];\n\
\t\t\ttween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );\n\
\t\t\torig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );\n\
\n\
\t\t\tif ( !( prop in dataShow ) ) {\n\
\t\t\t\tdataShow[ prop ] = tween.start;\n\
\t\t\t\tif ( hidden ) {\n\
\t\t\t\t\ttween.end = tween.start;\n\
\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\
\t\t\t\t}\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
}\n\
\n\
function Tween( elem, options, prop, end, easing ) {\n\
\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n\
}\n\
jQuery.Tween = Tween;\n\
\n\
Tween.prototype = {\n\
\tconstructor: Tween,\n\
\tinit: function( elem, options, prop, end, easing, unit ) {\n\
\t\tthis.elem = elem;\n\
\t\tthis.prop = prop;\n\
\t\tthis.easing = easing || \"swing\";\n\
\t\tthis.options = options;\n\
\t\tthis.start = this.now = this.cur();\n\
\t\tthis.end = end;\n\
\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\
\t},\n\
\tcur: function() {\n\
\t\tvar hooks = Tween.propHooks[ this.prop ];\n\
\n\
\t\treturn hooks && hooks.get ?\n\
\t\t\thooks.get( this ) :\n\
\t\t\tTween.propHooks._default.get( this );\n\
\t},\n\
\trun: function( percent ) {\n\
\t\tvar eased,\n\
\t\t\thooks = Tween.propHooks[ this.prop ];\n\
\n\
\t\tif ( this.options.duration ) {\n\
\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\
\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\
\t\t\t);\n\
\t\t} else {\n\
\t\t\tthis.pos = eased = percent;\n\
\t\t}\n\
\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\
\n\
\t\tif ( this.options.step ) {\n\
\t\t\tthis.options.step.call( this.elem, this.now, this );\n\
\t\t}\n\
\n\
\t\tif ( hooks && hooks.set ) {\n\
\t\t\thooks.set( this );\n\
\t\t} else {\n\
\t\t\tTween.propHooks._default.set( this );\n\
\t\t}\n\
\t\treturn this;\n\
\t}\n\
};\n\
\n\
Tween.prototype.init.prototype = Tween.prototype;\n\
\n\
Tween.propHooks = {\n\
\t_default: {\n\
\t\tget: function( tween ) {\n\
\t\t\tvar result;\n\
\n\
\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\
\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\
\t\t\t\treturn tween.elem[ tween.prop ];\n\
\t\t\t}\n\
\n\
\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\
\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\
\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\
\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\
\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\
\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\
\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\
\t\t},\n\
\t\tset: function( tween ) {\n\
\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\
\t\t\t// available and use plain properties where available\n\
\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\
\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\
\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\
\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\
\t\t\t} else {\n\
\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\
\t\t\t}\n\
\t\t}\n\
\t}\n\
};\n\
\n\
// Remove in 2.0 - this supports IE8's panic based approach\n\
// to setting things on disconnected nodes\n\
\n\
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\
\tset: function( tween ) {\n\
\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\
\t\t\ttween.elem[ tween.prop ] = tween.now;\n\
\t\t}\n\
\t}\n\
};\n\
\n\
jQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\
\tvar cssFn = jQuery.fn[ name ];\n\
\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\
\t\treturn speed == null || typeof speed === \"boolean\" ?\n\
\t\t\tcssFn.apply( this, arguments ) :\n\
\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\
\t};\n\
});\n\
\n\
jQuery.fn.extend({\n\
\tfadeTo: function( speed, to, easing, callback ) {\n\
\n\
\t\t// show any hidden elements after setting opacity to 0\n\
\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\
\n\
\t\t\t// animate to the value specified\n\
\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\
\t},\n\
\tanimate: function( prop, speed, easing, callback ) {\n\
\t\tvar empty = jQuery.isEmptyObject( prop ),\n\
\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\
\t\t\tdoAnimation = function() {\n\
\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\
\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\
\t\t\t\tdoAnimation.finish = function() {\n\
\t\t\t\t\tanim.stop( true );\n\
\t\t\t\t};\n\
\t\t\t\t// Empty animations, or finishing resolves immediately\n\
\t\t\t\tif ( empty || jQuery._data( this, \"finish\" ) ) {\n\
\t\t\t\t\tanim.stop( true );\n\
\t\t\t\t}\n\
\t\t\t};\n\
\t\t\tdoAnimation.finish = doAnimation;\n\
\n\
\t\treturn empty || optall.queue === false ?\n\
\t\t\tthis.each( doAnimation ) :\n\
\t\t\tthis.queue( optall.queue, doAnimation );\n\
\t},\n\
\tstop: function( type, clearQueue, gotoEnd ) {\n\
\t\tvar stopQueue = function( hooks ) {\n\
\t\t\tvar stop = hooks.stop;\n\
\t\t\tdelete hooks.stop;\n\
\t\t\tstop( gotoEnd );\n\
\t\t};\n\
\n\
\t\tif ( typeof type !== \"string\" ) {\n\
\t\t\tgotoEnd = clearQueue;\n\
\t\t\tclearQueue = type;\n\
\t\t\ttype = undefined;\n\
\t\t}\n\
\t\tif ( clearQueue && type !== false ) {\n\
\t\t\tthis.queue( type || \"fx\", [] );\n\
\t\t}\n\
\n\
\t\treturn this.each(function() {\n\
\t\t\tvar dequeue = true,\n\
\t\t\t\tindex = type != null && type + \"queueHooks\",\n\
\t\t\t\ttimers = jQuery.timers,\n\
\t\t\t\tdata = jQuery._data( this );\n\
\n\
\t\t\tif ( index ) {\n\
\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\
\t\t\t\t\tstopQueue( data[ index ] );\n\
\t\t\t\t}\n\
\t\t\t} else {\n\
\t\t\t\tfor ( index in data ) {\n\
\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\
\t\t\t\t\t\tstopQueue( data[ index ] );\n\
\t\t\t\t\t}\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\tfor ( index = timers.length; index--; ) {\n\
\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\
\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\
\t\t\t\t\tdequeue = false;\n\
\t\t\t\t\ttimers.splice( index, 1 );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\t// start the next in the queue if the last step wasn't forced\n\
\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\
\t\t\t// but only if they were gotoEnd\n\
\t\t\tif ( dequeue || !gotoEnd ) {\n\
\t\t\t\tjQuery.dequeue( this, type );\n\
\t\t\t}\n\
\t\t});\n\
\t},\n\
\tfinish: function( type ) {\n\
\t\tif ( type !== false ) {\n\
\t\t\ttype = type || \"fx\";\n\
\t\t}\n\
\t\treturn this.each(function() {\n\
\t\t\tvar index,\n\
\t\t\t\tdata = jQuery._data( this ),\n\
\t\t\t\tqueue = data[ type + \"queue\" ],\n\
\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\
\t\t\t\ttimers = jQuery.timers,\n\
\t\t\t\tlength = queue ? queue.length : 0;\n\
\n\
\t\t\t// enable finishing flag on private data\n\
\t\t\tdata.finish = true;\n\
\n\
\t\t\t// empty the queue first\n\
\t\t\tjQuery.queue( this, type, [] );\n\
\n\
\t\t\tif ( hooks && hooks.cur && hooks.cur.finish ) {\n\
\t\t\t\thooks.cur.finish.call( this );\n\
\t\t\t}\n\
\n\
\t\t\t// look for any active animations, and finish them\n\
\t\t\tfor ( index = timers.length; index--; ) {\n\
\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\
\t\t\t\t\ttimers[ index ].anim.stop( true );\n\
\t\t\t\t\ttimers.splice( index, 1 );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\t// look for any animations in the old queue and finish them\n\
\t\t\tfor ( index = 0; index < length; index++ ) {\n\
\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\
\t\t\t\t\tqueue[ index ].finish.call( this );\n\
\t\t\t\t}\n\
\t\t\t}\n\
\n\
\t\t\t// turn off finishing flag\n\
\t\t\tdelete data.finish;\n\
\t\t});\n\
\t}\n\
});\n\
\n\
// Generate parameters to create a standard animation\n\
function genFx( type, includeWidth ) {\n\
\tvar which,\n\
\t\tattrs = { height: type },\n\
\t\ti = 0;\n\
\n\
\t// if we include width, step value is 1 to do all cssExpand values,\n\
\t// if we don't include width, step value is 2 to skip over Left and Right\n\
\tincludeWidth = includeWidth? 1 : 0;\n\
\tfor( ; i < 4 ; i += 2 - includeWidth ) {\n\
\t\twhich = cssExpand[ i ];\n\
\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\
\t}\n\
\n\
\tif ( includeWidth ) {\n\
\t\tattrs.opacity = attrs.width = type;\n\
\t}\n\
\n\
\treturn attrs;\n\
}\n\
\n\
// Generate shortcuts for custom animations\n\
jQuery.each({\n\
\tslideDown: genFx(\"show\"),\n\
\tslideUp: genFx(\"hide\"),\n\
\tslideToggle: genFx(\"toggle\"),\n\
\tfadeIn: { opacity: \"show\" },\n\
\tfadeOut: { opacity: \"hide\" },\n\
\tfadeToggle: { opacity: \"toggle\" }\n\
}, function( name, props ) {\n\
\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\
\t\treturn this.animate( props, speed, easing, callback );\n\
\t};\n\
});\n\
\n\
jQuery.speed = function( speed, easing, fn ) {\n\
\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\
\t\tcomplete: fn || !fn && easing ||\n\
\t\t\tjQuery.isFunction( speed ) && speed,\n\
\t\tduration: speed,\n\
\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\
\t};\n\
\n\
\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\
\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\
\n\
\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\
\tif ( opt.queue == null || opt.queue === true ) {\n\
\t\topt.queue = \"fx\";\n\
\t}\n\
\n\
\t// Queueing\n\
\topt.old = opt.complete;\n\
\n\
\topt.complete = function() {\n\
\t\tif ( jQuery.isFunction( opt.old ) ) {\n\
\t\t\topt.old.call( this );\n\
\t\t}\n\
\n\
\t\tif ( opt.queue ) {\n\
\t\t\tjQuery.dequeue( this, opt.queue );\n\
\t\t}\n\
\t};\n\
\n\
\treturn opt;\n\
};\n\
\n\
jQuery.easing = {\n\
\tlinear: function( p ) {\n\
\t\treturn p;\n\
\t},\n\
\tswing: function( p ) {\n\
\t\treturn 0.5 - Math.cos( p*Math.PI ) / 2;\n\
\t}\n\
};\n\
\n\
jQuery.timers = [];\n\
jQuery.fx = Tween.prototype.init;\n\
jQuery.fx.tick = function() {\n\
\tvar timer,\n\
\t\ttimers = jQuery.timers,\n\
\t\ti = 0;\n\
\n\
\tfxNow = jQuery.now();\n\
\n\
\tfor ( ; i < timers.length; i++ ) {\n\
\t\ttimer = timers[ i ];\n\
\t\t// Checks the timer has not already been removed\n\
\t\tif ( !timer() && timers[ i ] === timer ) {\n\
\t\t\ttimers.splice( i--, 1 );\n\
\t\t}\n\
\t}\n\
\n\
\tif ( !timers.length ) {\n\
\t\tjQuery.fx.stop();\n\
\t}\n\
\tfxNow = undefined;\n\
};\n\
\n\
jQuery.fx.timer = function( timer ) {\n\
\tif ( timer() && jQuery.timers.push( timer ) ) {\n\
\t\tjQuery.fx.start();\n\
\t}\n\
};\n\
\n\
jQuery.fx.interval = 13;\n\
\n\
jQuery.fx.start = function() {\n\
\tif ( !timerId ) {\n\
\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\
\t}\n\
};\n\
\n\
jQuery.fx.stop = function() {\n\
\tclearInterval( timerId );\n\
\ttimerId = null;\n\
};\n\
\n\
jQuery.fx.speeds = {\n\
\tslow: 600,\n\
\tfast: 200,\n\
\t// Default speed\n\
\t_default: 400\n\
};\n\
\n\
// Back Compat <1.8 extension point\n\
jQuery.fx.step = {};\n\
\n\
if ( jQuery.expr && jQuery.expr.filters ) {\n\
\tjQuery.expr.filters.animated = function( elem ) {\n\
\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\
\t\t\treturn elem === fn.elem;\n\
\t\t}).length;\n\
\t};\n\
}\n\
jQuery.fn.offset = function( options ) {\n\
\tif ( arguments.length ) {\n\
\t\treturn options === undefined ?\n\
\t\t\tthis :\n\
\t\t\tthis.each(function( i ) {\n\
\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\
\t\t\t});\n\
\t}\n\
\n\
\tvar docElem, win,\n\
\t\tbox = { top: 0, left: 0 },\n\
\t\telem = this[ 0 ],\n\
\t\tdoc = elem && elem.ownerDocument;\n\
\n\
\tif ( !doc ) {\n\
\t\treturn;\n\
\t}\n\
\n\
\tdocElem = doc.documentElement;\n\
\n\
\t// Make sure it's not a disconnected DOM node\n\
\tif ( !jQuery.contains( docElem, elem ) ) {\n\
\t\treturn box;\n\
\t}\n\
\n\
\t// If we don't have gBCR, just use 0,0 rather than error\n\
\t// BlackBerry 5, iOS 3 (original iPhone)\n\
\tif ( typeof elem.getBoundingClientRect !== core_strundefined ) {\n\
\t\tbox = elem.getBoundingClientRect();\n\
\t}\n\
\twin = getWindow( doc );\n\
\treturn {\n\
\t\ttop: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n\
\t\tleft: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n\
\t};\n\
};\n\
\n\
jQuery.offset = {\n\
\n\
\tsetOffset: function( elem, options, i ) {\n\
\t\tvar position = jQuery.css( elem, \"position\" );\n\
\n\
\t\t// set position first, in-case top/left are set even on static elem\n\
\t\tif ( position === \"static\" ) {\n\
\t\t\telem.style.position = \"relative\";\n\
\t\t}\n\
\n\
\t\tvar curElem = jQuery( elem ),\n\
\t\t\tcurOffset = curElem.offset(),\n\
\t\t\tcurCSSTop = jQuery.css( elem, \"top\" ),\n\
\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" ),\n\
\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1,\n\
\t\t\tprops = {}, curPosition = {}, curTop, curLeft;\n\
\n\
\t\t// need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\
\t\tif ( calculatePosition ) {\n\
\t\t\tcurPosition = curElem.position();\n\
\t\t\tcurTop = curPosition.top;\n\
\t\t\tcurLeft = curPosition.left;\n\
\t\t} else {\n\
\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\
\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\
\t\t}\n\
\n\
\t\tif ( jQuery.isFunction( options ) ) {\n\
\t\t\toptions = options.call( elem, i, curOffset );\n\
\t\t}\n\
\n\
\t\tif ( options.top != null ) {\n\
\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\
\t\t}\n\
\t\tif ( options.left != null ) {\n\
\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\
\t\t}\n\
\n\
\t\tif ( \"using\" in options ) {\n\
\t\t\toptions.using.call( elem, props );\n\
\t\t} else {\n\
\t\t\tcurElem.css( props );\n\
\t\t}\n\
\t}\n\
};\n\
\n\
\n\
jQuery.fn.extend({\n\
\n\
\tposition: function() {\n\
\t\tif ( !this[ 0 ] ) {\n\
\t\t\treturn;\n\
\t\t}\n\
\n\
\t\tvar offsetParent, offset,\n\
\t\t\tparentOffset = { top: 0, left: 0 },\n\
\t\t\telem = this[ 0 ];\n\
\n\
\t\t// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n\
\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\
\t\t\t// we assume that getBoundingClientRect is available when computed position is fixed\n\
\t\t\toffset = elem.getBoundingClientRect();\n\
\t\t} else {\n\
\t\t\t// Get *real* offsetParent\n\
\t\t\toffsetParent = this.offsetParent();\n\
\n\
\t\t\t// Get correct offsets\n\
\t\t\toffset = this.offset();\n\
\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\
\t\t\t\tparentOffset = offsetParent.offset();\n\
\t\t\t}\n\
\n\
\t\t\t// Add offsetParent borders\n\
\t\t\tparentOffset.top  += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\
\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\
\t\t}\n\
\n\
\t\t// Subtract parent offsets and element margins\n\
\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\
\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\
\t\treturn {\n\
\t\t\ttop:  offset.top  - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\
\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true)\n\
\t\t};\n\
\t},\n\
\n\
\toffsetParent: function() {\n\
\t\treturn this.map(function() {\n\
\t\t\tvar offsetParent = this.offsetParent || document.documentElement;\n\
\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\") === \"static\" ) ) {\n\
\t\t\t\toffsetParent = offsetParent.offsetParent;\n\
\t\t\t}\n\
\t\t\treturn offsetParent || document.documentElement;\n\
\t\t});\n\
\t}\n\
});\n\
\n\
\n\
// Create scrollLeft and scrollTop methods\n\
jQuery.each( {scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function( method, prop ) {\n\
\tvar top = /Y/.test( prop );\n\
\n\
\tjQuery.fn[ method ] = function( val ) {\n\
\t\treturn jQuery.access( this, function( elem, method, val ) {\n\
\t\t\tvar win = getWindow( elem );\n\
\n\
\t\t\tif ( val === undefined ) {\n\
\t\t\t\treturn win ? (prop in win) ? win[ prop ] :\n\
\t\t\t\t\twin.document.documentElement[ method ] :\n\
\t\t\t\t\telem[ method ];\n\
\t\t\t}\n\
\n\
\t\t\tif ( win ) {\n\
\t\t\t\twin.scrollTo(\n\
\t\t\t\t\t!top ? val : jQuery( win ).scrollLeft(),\n\
\t\t\t\t\ttop ? val : jQuery( win ).scrollTop()\n\
\t\t\t\t);\n\
\n\
\t\t\t} else {\n\
\t\t\t\telem[ method ] = val;\n\
\t\t\t}\n\
\t\t}, method, val, arguments.length, null );\n\
\t};\n\
});\n\
\n\
function getWindow( elem ) {\n\
\treturn jQuery.isWindow( elem ) ?\n\
\t\telem :\n\
\t\telem.nodeType === 9 ?\n\
\t\t\telem.defaultView || elem.parentWindow :\n\
\t\t\tfalse;\n\
}\n\
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\
jQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\
\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\
\t\t// margin is only for outerHeight, outerWidth\n\
\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\
\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\
\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\
\n\
\t\t\treturn jQuery.access( this, function( elem, type, value ) {\n\
\t\t\t\tvar doc;\n\
\n\
\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\
\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\
\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\
\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\
\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\
\t\t\t\t}\n\
\n\
\t\t\t\t// Get document width or height\n\
\t\t\t\tif ( elem.nodeType === 9 ) {\n\
\t\t\t\t\tdoc = elem.documentElement;\n\
\n\
\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n\
\t\t\t\t\t// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n\
\t\t\t\t\treturn Math.max(\n\
\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\
\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\
\t\t\t\t\t\tdoc[ \"client\" + name ]\n\
\t\t\t\t\t);\n\
\t\t\t\t}\n\
\n\
\t\t\t\treturn value === undefined ?\n\
\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\
\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\
\n\
\t\t\t\t\t// Set width or height on the element\n\
\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\
\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\
\t\t};\n\
\t});\n\
});\n\
// Limit scope pollution from any deprecated API\n\
// (function() {\n\
\n\
// })();\n\
\n\
// Expose for component\n\
module.exports = jQuery;\n\
\n\
// Expose jQuery to the global object\n\
//window.jQuery = window.$ = jQuery;\n\
\n\
// Expose jQuery as an AMD module, but only for AMD loaders that\n\
// understand the issues with loading multiple versions of jQuery\n\
// in a page that all might call define(). The loader will indicate\n\
// they have special allowances for multiple jQuery versions by\n\
// specifying define.amd.jQuery = true. Register as a named module,\n\
// since jQuery can be concatenated with other files that may use define,\n\
// but not use a proper concatenation script that understands anonymous\n\
// AMD modules. A named AMD is safest and most robust way to register.\n\
// Lowercase jquery is used because AMD module names are derived from\n\
// file names, and jQuery is normally delivered in a lowercase file name.\n\
// Do this after creating the global so that if an AMD module wants to call\n\
// noConflict to hide this version of jQuery, it will work.\n\
if ( typeof define === \"function\" && define.amd && define.amd.jQuery ) {\n\
\tdefine( \"jquery\", [], function () { return jQuery; } );\n\
}\n\
\n\
})( window );\n\
//@ sourceURL=component-jquery/index.js"
));









require.alias("cvdlab-plasm-fun/index.js", "undefined/deps/plasm-fun/index.js");
require.alias("cvdlab-plasm-fun/index.js", "plasm-fun/index.js");
require.alias("cvdlab-f/index.js", "cvdlab-plasm-fun/deps/f/index.js");

require.alias("cvdlab-plasm/index.js", "cvdlab-plasm-fun/deps/plasm/index.js");
require.alias("cvdlab-simplexn/index.js", "cvdlab-plasm/deps/simplexn/index.js");

require.alias("cvdlab-three/index.js", "cvdlab-plasm/deps/three/index.js");

require.alias("cvdlab-three-detector/index.js", "cvdlab-plasm/deps/three-detector/index.js");

require.alias("cvdlab-three-stats/index.js", "cvdlab-plasm/deps/three-stats/index.js");

require.alias("cvdlab-three-trackball/index.js", "cvdlab-plasm/deps/three-trackball/index.js");
require.alias("cvdlab-three/index.js", "cvdlab-three-trackball/deps/three/index.js");


require.alias("enricomarino-globalize/index.js", "cvdlab-plasm-fun/deps/globalize/index.js");

require.alias("component-jquery/index.js", "undefined/deps/jquery/index.js");
require.alias("component-jquery/index.js", "jquery/index.js");
